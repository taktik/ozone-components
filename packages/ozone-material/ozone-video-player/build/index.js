/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 28);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {



(function () {
  'use strict';

  const userPolymer = window.Polymer;

  /**
   * @namespace Polymer
   * @summary Polymer is a lightweight library built on top of the web
   *   standards-based Web Components API's, and makes it easy to build your
   *   own custom HTML elements.
   * @param {!PolymerInit} info Prototype for the custom element. It must contain
   *   an `is` property to specify the element name. Other properties populate
   *   the element prototype. The `properties`, `observers`, `hostAttributes`,
   *   and `listeners` properties are processed to create element features.
   * @return {!Object} Returns a custom element class for the given provided
   *   prototype `info` object. The name of the element if given by `info.is`.
   */
  window.Polymer = function (info) {
    return window.Polymer._polymerFn(info);
  };

  // support user settings on the Polymer object
  if (userPolymer) {
    Object.assign(Polymer, userPolymer);
  }

  // To be plugged by legacy implementation if loaded
  /* eslint-disable valid-jsdoc */
  /**
   * @param {!PolymerInit} info Prototype for the custom element. It must contain
   *   an `is` property to specify the element name. Other properties populate
   *   the element prototype. The `properties`, `observers`, `hostAttributes`,
   *   and `listeners` properties are processed to create element features.
   * @return {!Object} Returns a custom element class for the given provided
   *   prototype `info` object. The name of the element if given by `info.is`.
   */
  window.Polymer._polymerFn = function (info) {
    // eslint-disable-line no-unused-vars
    throw new Error('Load polymer.html to use the Polymer() function.');
  };
  /* eslint-enable */

  window.Polymer.version = '2.5.0';

  /* eslint-disable no-unused-vars */
  /*
  When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]
  We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.
  */
  window.JSCompiler_renameProperty = function (prop, obj) {
    return prop;
  };
  /* eslint-enable */
})();

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

(function () {

  'use strict';

  // unique global id for deduping mixins.

  let dedupeId = 0;

  /**
   * @constructor
   * @extends {Function}
   */
  function MixinFunction() {}
  /** @type {(WeakMap | undefined)} */
  MixinFunction.prototype.__mixinApplications;
  /** @type {(Object | undefined)} */
  MixinFunction.prototype.__mixinSet;

  /* eslint-disable valid-jsdoc */
  /**
   * Wraps an ES6 class expression mixin such that the mixin is only applied
   * if it has not already been applied its base argument. Also memoizes mixin
   * applications.
   *
   * @memberof Polymer
   * @template T
   * @param {T} mixin ES6 class expression mixin to wrap
   * @return {T}
   * @suppress {invalidCasts}
   */
  Polymer.dedupingMixin = function (mixin) {
    let mixinApplications = /** @type {!MixinFunction} */mixin.__mixinApplications;
    if (!mixinApplications) {
      mixinApplications = new WeakMap();
      /** @type {!MixinFunction} */mixin.__mixinApplications = mixinApplications;
    }
    // maintain a unique id for each mixin
    let mixinDedupeId = dedupeId++;
    function dedupingMixin(base) {
      let baseSet = /** @type {!MixinFunction} */base.__mixinSet;
      if (baseSet && baseSet[mixinDedupeId]) {
        return base;
      }
      let map = mixinApplications;
      let extended = map.get(base);
      if (!extended) {
        extended = /** @type {!Function} */mixin(base);
        map.set(base, extended);
      }
      // copy inherited mixin set from the extended class, or the base class
      // NOTE: we avoid use of Set here because some browser (IE11)
      // cannot extend a base Set via the constructor.
      let mixinSet = Object.create( /** @type {!MixinFunction} */extended.__mixinSet || baseSet || null);
      mixinSet[mixinDedupeId] = true;
      /** @type {!MixinFunction} */extended.__mixinSet = mixinSet;
      return extended;
    }

    return (/** @type {T} */dedupingMixin
    );
  };
  /* eslint-enable valid-jsdoc */
})();

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(55), __webpack_require__(58), __webpack_require__(59), __webpack_require__(60), __webpack_require__(61), __webpack_require__(62)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", { value: true });
    function customElement(tagname) {
        return clazz => {
            clazz.is = tagname;
            window[clazz.name] = clazz; // Register class in windows se that is can be use without IMD module loading.
            // Useful for import in pure JS project.
            window.customElements.define(tagname, clazz);
        };
    }
    exports.customElement = customElement;
    /**
     * A TypeScript class decorator that declare a global class
     * `tagname` and the decorated class.
     */
    function jsElement() {
        return clazz => {
            window[clazz.name] = clazz; // Register class in windows se that is can be use without IMD module loading.
            // Useful for import in pure JS project.
        };
    }
    exports.jsElement = jsElement;
    function createProperty(proto, name, options) {
        const notify = options && options.notify || false;
        const reflectToAttribute = options && options.reflectToAttribute || false;
        const readOnly = options && options.readOnly || false;
        const computed = options && options.computed || "";
        const observer = options && options.observer || "";
        let type;
        if (options && options.hasOwnProperty("type")) {
            type = options.type;
        } else if (window.Reflect && Reflect.hasMetadata && Reflect.getMetadata && Reflect.hasMetadata("design:type", proto, name)) {
            type = Reflect.getMetadata("design:type", proto, name);
        } else {
            console.error(`A type could not be found for ${name}. ` + "Set a type or configure Metadata Reflection API support.");
        }
        if (!proto.constructor.hasOwnProperty("properties")) {
            Object.defineProperty(proto.constructor, "properties", { value: {} });
        }
        const finalOpts = { type, notify, reflectToAttribute, readOnly, computed, observer };
        proto.constructor.properties[name] = finalOpts;
    }
    /**
     * A TypeScript property decorator factory that defines this as a Polymer
     * property.
     *
     * This function must be invoked to return a decorator.
     */
    function property(options) {
        return (proto, propName) => {
            createProperty(proto, propName, options);
        };
    }
    exports.property = property;
    function domElement() {
        return (proto, propName) => {};
    }
    exports.domElement = domElement;
    /**
     * A TypeScript property decorator factory that causes the decorated method to
     * be called when a property changes. `targets` is either a single property
     * name, or a list of property names.
     *
     * This function must be invoked to return a decorator.
     */
    function observe(...targets) {
        return (proto, propName) => {
            if (!proto.constructor.hasOwnProperty("observers")) {
                proto.constructor.observers = [];
            }
            proto.constructor.observers.push(`${propName}(${targets.join(",")})`);
        };
    }
    exports.observe = observe;
    function _ensureConfig(proto) {
        const ctor = proto.constructor;
        if (ctor.hasOwnProperty("__polymer_ts_config")) {
            return ctor.__polymer_ts_config;
        }
        Object.defineProperty(ctor, "config", {
            get() {
                return ctor.__polymer_ts_config;
            }
        });
        const config = ctor.__polymer_ts_config = ctor.__polymer_ts_config || {};
        config.properties = config.properties || {};
        config.observers = config.observers || [];
        return config;
    }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OzoneConfig; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ozone_api_request__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_taktik_polymer_typescript__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_taktik_polymer_typescript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_taktik_polymer_typescript__);
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


const configUrl = './conf.ozone.json';
const ozoneAPIRequest = new __WEBPACK_IMPORTED_MODULE_0_ozone_api_request__["a" /* OzoneAPIRequest */]();
ozoneAPIRequest.url = configUrl;
ozoneAPIRequest.method = 'GET';
let OzoneConfig = OzoneConfig_1 = class OzoneConfig {
    static get() {
        if (!OzoneConfig_1.configPromise) {
            OzoneConfig_1.configPromise = ozoneAPIRequest.sendRequest().then(res => {
                return res.response.ozoneApi;
            }).catch(failRequest => {
                console.error('Unable to find config at ', configUrl);
                throw new Error('Unable to find config');
            });
        }
        return OzoneConfig_1.configPromise;
    }
};
OzoneConfig.configPromise = null;
OzoneConfig = OzoneConfig_1 = __decorate([Object(__WEBPACK_IMPORTED_MODULE_1_taktik_polymer_typescript__["jsElement"])()], OzoneConfig);

var OzoneConfig_1;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root,factory){if(true)module.exports=factory();else if(typeof define==='function'&&define.amd)define([],factory);else if(typeof exports==='object')exports["Clappr"]=factory();else root["Clappr"]=factory();})(this,function(){return(/******/function(modules){// webpackBootstrap
/******/// The module cache
/******/var installedModules={};/******//******/// The require function
/******/function __webpack_require__(moduleId){/******//******/// Check if module is in cache
/******/if(installedModules[moduleId]){/******/return installedModules[moduleId].exports;/******/}/******/// Create a new module (and put it into the cache)
/******/var module=installedModules[moduleId]={/******/i:moduleId,/******/l:false,/******/exports:{}/******/};/******//******/// Execute the module function
/******/modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);/******//******/// Flag the module as loaded
/******/module.l=true;/******//******/// Return the exports of the module
/******/return module.exports;/******/}/******//******//******/// expose the modules object (__webpack_modules__)
/******/__webpack_require__.m=modules;/******//******/// expose the module cache
/******/__webpack_require__.c=installedModules;/******//******/// define getter function for harmony exports
/******/__webpack_require__.d=function(exports,name,getter){/******/if(!__webpack_require__.o(exports,name)){/******/Object.defineProperty(exports,name,{/******/configurable:false,/******/enumerable:true,/******/get:getter/******/});/******/}/******/};/******//******/// getDefaultExport function for compatibility with non-harmony modules
/******/__webpack_require__.n=function(module){/******/var getter=module&&module.__esModule?/******/function getDefault(){return module['default'];}:/******/function getModuleExports(){return module;};/******/__webpack_require__.d(getter,'a',getter);/******/return getter;/******/};/******//******/// Object.prototype.hasOwnProperty.call
/******/__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};/******//******/// __webpack_public_path__
/******/__webpack_require__.p="<%=baseUrl%>/";/******//******/// Load entry module and return exports
/******/return __webpack_require__(__webpack_require__.s=87);/******/}(/************************************************************************//******/[/* 0 *//***/function(module,exports,__webpack_require__){"use strict";exports.__esModule=true;exports.default=function(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}};/***/},/* 1 *//***/function(module,exports,__webpack_require__){"use strict";exports.__esModule=true;var _typeof2=__webpack_require__(33);var _typeof3=_interopRequireDefault(_typeof2);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=function(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&((typeof call==="undefined"?"undefined":(0,_typeof3.default)(call))==="object"||typeof call==="function")?call:self;};/***/},/* 2 *//***/function(module,exports,__webpack_require__){"use strict";exports.__esModule=true;var _setPrototypeOf=__webpack_require__(119);var _setPrototypeOf2=_interopRequireDefault(_setPrototypeOf);var _create=__webpack_require__(71);var _create2=_interopRequireDefault(_create);var _typeof2=__webpack_require__(33);var _typeof3=_interopRequireDefault(_typeof2);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=function(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+(typeof superClass==="undefined"?"undefined":(0,_typeof3.default)(superClass)));}subClass.prototype=(0,_create2.default)(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)_setPrototypeOf2.default?(0,_setPrototypeOf2.default)(subClass,superClass):subClass.__proto__=superClass;};/***/},/* 3 *//***/function(module,exports,__webpack_require__){"use strict";exports.__esModule=true;var _defineProperty=__webpack_require__(70);var _defineProperty2=_interopRequireDefault(_defineProperty);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;(0,_defineProperty2.default)(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/***/},/* 4 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _keys=__webpack_require__(31);var _keys2=_interopRequireDefault(_keys);var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _typeof2=__webpack_require__(33);var _typeof3=_interopRequireDefault(_typeof2);var _log=__webpack_require__(55);var _log2=_interopRequireDefault(_log);var _utils=__webpack_require__(5);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var slice=Array.prototype.slice;var eventSplitter=/\s+/;var eventsApi=function eventsApi(obj,action,name,rest){if(!name){return true;}// Handle event maps.
if((typeof name==='undefined'?'undefined':(0,_typeof3.default)(name))==='object'){for(var key in name){obj[action].apply(obj,[key,name[key]].concat(rest));}return false;}// Handle space separated event names.
if(eventSplitter.test(name)){var names=name.split(eventSplitter);for(var i=0,l=names.length;i<l;i++){obj[action].apply(obj,[names[i]].concat(rest));}return false;}return true;};var triggerEvents=function triggerEvents(events,args,klass,name){var ev=void 0,i=-1;var l=events.length,a1=args[0],a2=args[1],a3=args[2];run();function run(){try{switch(args.length){case 0:while(++i<l){(ev=events[i]).callback.call(ev.ctx);}return;case 1:while(++i<l){(ev=events[i]).callback.call(ev.ctx,a1);}return;case 2:while(++i<l){(ev=events[i]).callback.call(ev.ctx,a1,a2);}return;case 3:while(++i<l){(ev=events[i]).callback.call(ev.ctx,a1,a2,a3);}return;default:while(++i<l){(ev=events[i]).callback.apply(ev.ctx,args);}return;}}catch(exception){_log2.default.error.apply(_log2.default,[klass,'error on event',name,'trigger','-',exception]);run();}}};/**
 * @class Events
 * @constructor
 * @module base
 */var Events=function(){function Events(){(0,_classCallCheck3.default)(this,Events);}/**
   * listen to an event indefinitely, if you want to stop you need to call `off`
   * @method on
   * @param {String} name
   * @param {Function} callback
   * @param {Object} context
   */Events.prototype.on=function on(name,callback,context){if(!eventsApi(this,'on',name,[callback,context])||!callback){return this;}this._events||(this._events={});var events=this._events[name]||(this._events[name]=[]);events.push({callback:callback,context:context,ctx:context||this});return this;};/**
   * listen to an event only once
   * @method once
   * @param {String} name
   * @param {Function} callback
   * @param {Object} context
   */Events.prototype.once=function once(name,callback,context){var _this=this;if(!eventsApi(this,'once',name,[callback,context])||!callback){return this;}var off=function off(){return _this.off(name,once);};var once=function once(){off(name,once);callback.apply(this,arguments);};return this.on(name,once,context);};/**
   * stop listening to an event
   * @method off
   * @param {String} name
   * @param {Function} callback
   * @param {Object} context
   */Events.prototype.off=function off(name,callback,context){var retain=void 0,ev=void 0,events=void 0,names=void 0,i=void 0,l=void 0,j=void 0,k=void 0;if(!this._events||!eventsApi(this,'off',name,[callback,context])){return this;}if(!name&&!callback&&!context){this._events=void 0;return this;}names=name?[name]:(0,_keys2.default)(this._events);// jshint maxdepth:5
for(i=0,l=names.length;i<l;i++){name=names[i];events=this._events[name];if(events){this._events[name]=retain=[];if(callback||context){for(j=0,k=events.length;j<k;j++){ev=events[j];if(callback&&callback!==ev.callback&&callback!==ev.callback._callback||context&&context!==ev.context){retain.push(ev);}}}if(!retain.length){delete this._events[name];}}}return this;};/**
   * triggers an event given its `name`
   * @method trigger
   * @param {String} name
   */Events.prototype.trigger=function trigger(name){var klass=this.name||this.constructor.name;_log2.default.debug.apply(_log2.default,[klass].concat(Array.prototype.slice.call(arguments)));if(!this._events){return this;}var args=slice.call(arguments,1);if(!eventsApi(this,'trigger',name,args)){return this;}var events=this._events[name];var allEvents=this._events.all;if(events){triggerEvents(events,args,klass,name);}if(allEvents){triggerEvents(allEvents,arguments,klass,name);}return this;};/**
   * stop listening an event for a given object
   * @method stopListening
   * @param {Object} obj
   * @param {String} name
   * @param {Function} callback
   */Events.prototype.stopListening=function stopListening(obj,name,callback){var listeningTo=this._listeningTo;if(!listeningTo){return this;}var remove=!name&&!callback;if(!callback&&(typeof name==='undefined'?'undefined':(0,_typeof3.default)(name))==='object'){callback=this;}if(obj){(listeningTo={})[obj._listenId]=obj;}for(var id in listeningTo){obj=listeningTo[id];obj.off(name,callback,this);if(remove||(0,_keys2.default)(obj._events).length===0){delete this._listeningTo[id];}}return this;};Events.register=function register(eventName){Events.Custom||(Events.Custom={});var property=typeof eventName==='string'&&eventName.toUpperCase().trim();if(property&&!Events.Custom[property]){Events.Custom[property]=property.toLowerCase().split('_').map(function(value,index){return index==0?value:value=value[0].toUpperCase()+value.slice(1);}).join('');}else{_log2.default.error('Events','Error when register event: '+eventName);}};Events.listAvailableCustomEvents=function listAvailableCustomEvents(){Events.Custom||(Events.Custom={});return(0,_keys2.default)(Events.Custom).filter(function(property){return typeof Events.Custom[property]==='string';});};return Events;}();/**
 * listen to an event indefinitely for a given `obj`
 * @method listenTo
 * @param {Object} obj
 * @param {String} name
 * @param {Function} callback
 * @param {Object} context
 * @example
 * ```javascript
 * this.listenTo(this.core.playback, Events.PLAYBACK_PAUSE, this.callback)
 * ```
 *//**
 * listen to an event once for a given `obj`
 * @method listenToOnce
 * @param {Object} obj
 * @param {String} name
 * @param {Function} callback
 * @param {Object} context
 * @example
 * ```javascript
 * this.listenToOnce(this.core.playback, Events.PLAYBACK_PAUSE, this.callback)
 * ```
 */exports.default=Events;var listenMethods={listenTo:'on',listenToOnce:'once'};(0,_keys2.default)(listenMethods).forEach(function(method){Events.prototype[method]=function(obj,name,callback){var listeningTo=this._listeningTo||(this._listeningTo={});var id=obj._listenId||(obj._listenId=(0,_utils.uniqueId)('l'));listeningTo[id]=obj;if(!callback&&(typeof name==='undefined'?'undefined':(0,_typeof3.default)(name))==='object'){callback=this;}obj[listenMethods[method]](name,callback,this);return this;};});// PLAYER EVENTS
/**
 * Fired when the player is ready on startup
 *
 * @event PLAYER_READY
 */Events.PLAYER_READY='ready';/**
 * Fired when player resizes
 *
 * @event PLAYER_RESIZE
 * @param {Object} currentSize an object with the current size
 */Events.PLAYER_RESIZE='resize';/**
 * Fired when player changes its fullscreen state
 *
 * @event PLAYER_FULLSCREEN
 * @param {Boolean} whether or not the player is on fullscreen mode
 */Events.PLAYER_FULLSCREEN='fullscreen';/**
 * Fired when player starts to play
 *
 * @event PLAYER_PLAY
 */Events.PLAYER_PLAY='play';/**
 * Fired when player pauses
 *
 * @event PLAYER_PAUSE
 */Events.PLAYER_PAUSE='pause';/**
 * Fired when player stops
 *
 * @event PLAYER_STOP
 */Events.PLAYER_STOP='stop';/**
 * Fired when player ends the video
 *
 * @event PLAYER_ENDED
 */Events.PLAYER_ENDED='ended';/**
 * Fired when player seeks the video
 *
 * @event PLAYER_SEEK
 * @param {Number} time the current time in seconds
 */Events.PLAYER_SEEK='seek';/**
 * Fired when player receives an error
 *
 * @event PLAYER_ERROR
 * @param {Object} error the error
 */Events.PLAYER_ERROR='error';/**
 * Fired when the time is updated on player
 *
 * @event PLAYER_TIMEUPDATE
 * @param {Object} progress Data
 * progress object
 * @param {Number} [progress.current]
 * current time
 * @param {Number} [progress.total]
 * total time
 */Events.PLAYER_TIMEUPDATE='timeupdate';/**
 * Fired when player updates its volume
 *
 * @event PLAYER_VOLUMEUPDATE
 * @param {Number} volume the current volume
 */Events.PLAYER_VOLUMEUPDATE='volumeupdate';/**
 * Fired when subtitle is available
 *
 * @event PLAYER_SUBTITLE_AVAILABLE
 */Events.PLAYER_SUBTITLE_AVAILABLE='subtitleavailable';// Playback Events
/**
 * Fired when the playback is downloading the media
 *
 * @event PLAYBACK_PROGRESS
 * @param progress {Object}
 * Data progress object
 * @param [progress.start] {Number}
 * start position of buffered content at current position
 * @param [progress.current] {Number}
 * end position of buffered content at current position
 * @param [progress.total] {Number}
 * total content to be downloaded
 * @param buffered {Array}
 * array of buffered segments ({start, end}). [Only for supported playbacks]
 */Events.PLAYBACK_PROGRESS='playback:progress';/**
 * Fired when the time is updated on playback
 *
 * @event PLAYBACK_TIMEUPDATE
 * @param {Object} progress Data
 * progress object
 * @param {Number} [progress.current]
 * current time
 * @param {Number} [progress.total]
 * total time
 */Events.PLAYBACK_TIMEUPDATE='playback:timeupdate';/**
 * Fired when playback is ready
 *
 * @event PLAYBACK_READY
 */Events.PLAYBACK_READY='playback:ready';/**
 * Fired when the playback starts having to buffer because
 * playback can currently not be smooth.
 *
 * This corresponds to the playback `buffering` property being
 * `true`.
 *
 * @event PLAYBACK_BUFFERING
 */Events.PLAYBACK_BUFFERING='playback:buffering';/**
 * Fired when the playback has enough in the buffer to be
 * able to play smoothly, after previously being unable to
 * do this.
 *
 * This corresponds to the playback `buffering` property being
 * `false`.
 *
 * @event PLAYBACK_BUFFERFULL
 */Events.PLAYBACK_BUFFERFULL='playback:bufferfull';/**
 * Fired when playback changes any settings (volume, seek and etc)
 *
 * @event PLAYBACK_SETTINGSUPDATE
 */Events.PLAYBACK_SETTINGSUPDATE='playback:settingsupdate';/**
 * Fired when playback loaded its metadata
 *
 * @event PLAYBACK_LOADEDMETADATA
 * @param {Object} metadata Data
 * settings object
 * @param {Number} [metadata.duration]
 * the playback duration
 * @param {Object} [metadata.data]
 * extra meta data
 */Events.PLAYBACK_LOADEDMETADATA='playback:loadedmetadata';/**
 * Fired when playback updates its video quality
 *
 * @event PLAYBACK_HIGHDEFINITIONUPDATE
 * @param {Boolean} isHD
 * true when is on HD, false otherwise
 */Events.PLAYBACK_HIGHDEFINITIONUPDATE='playback:highdefinitionupdate';/**
 * Fired when playback updates its bitrate
 *
 * @event PLAYBACK_BITRATE
 * @param {Object} bitrate Data
 * bitrate object
 * @param {Number} [bitrate.bandwidth]
 * bitrate bandwidth when it's available
 * @param {Number} [bitrate.width]
 * playback width (ex: 720, 640, 1080)
 * @param {Number} [bitrate.height]
 * playback height (ex: 240, 480, 720)
 * @param {Number} [bitrate.level]
 * playback level when it's available, it could be just a map for width (0 => 240, 1 => 480, 2 => 720)
 */Events.PLAYBACK_BITRATE='playback:bitrate';/**
 * Fired when the playback has its levels
 *
 * @event PLAYBACK_LEVELS_AVAILABLE
 * @param {Array} levels
 * the ordered levels, each one with the following format `{id: 1, label: '500kbps'}` ps: id should be a number >= 0
 * @param {Number} initial
 * the initial level otherwise -1 (AUTO)
 */Events.PLAYBACK_LEVELS_AVAILABLE='playback:levels:available';/**
 * Fired when the playback starts to switch level
 *
 * @event PLAYBACK_LEVEL_SWITCH_START
 *
 */Events.PLAYBACK_LEVEL_SWITCH_START='playback:levels:switch:start';/**
 * Fired when the playback ends the level switch
 *
 * @event PLAYBACK_LEVEL_SWITCH_END
 *
 */Events.PLAYBACK_LEVEL_SWITCH_END='playback:levels:switch:end';/**
 * Fired when playback internal state changes
 *
 * @event PLAYBACK_PLAYBACKSTATE
 * @param {Object} state Data
 * state object
 * @param {String} [state.type]
 * the playback type
 */Events.PLAYBACK_PLAYBACKSTATE='playback:playbackstate';/**
 * Fired when DVR becomes enabled/disabled.
 *
 * @event PLAYBACK_DVR
 * @param {boolean} state true if dvr enabled
 */Events.PLAYBACK_DVR='playback:dvr';// TODO doc
Events.PLAYBACK_MEDIACONTROL_DISABLE='playback:mediacontrol:disable';// TODO doc
Events.PLAYBACK_MEDIACONTROL_ENABLE='playback:mediacontrol:enable';/**
 * Fired when the media for a playback ends.
 *
 * @event PLAYBACK_ENDED
 * @param {String} name the name of the playback
 */Events.PLAYBACK_ENDED='playback:ended';/**
 * Fired when user requests `play()`
 *
 * @event PLAYBACK_PLAY_INTENT
 */Events.PLAYBACK_PLAY_INTENT='playback:play:intent';/**
 * Fired when the media for a playback starts playing.
 * This is not necessarily when the user requests `play()`
 * The media may have to buffer first.
 * I.e. `isPlaying()` might return `true` before this event is fired,
 * because `isPlaying()` represents the intended state.
 *
 * @event PLAYBACK_PLAY
 */Events.PLAYBACK_PLAY='playback:play';/**
 * Fired when the media for a playback pauses.
 *
 * @event PLAYBACK_PAUSE
 */Events.PLAYBACK_PAUSE='playback:pause';/**
 * Fired when the media for a playback is stopped.
 *
 * @event PLAYBACK_STOP
 */Events.PLAYBACK_STOP='playback:stop';/**
 * Fired if an error occurs in the playback.
 *
 * @event PLAYBACK_ERROR
 * @param {Object} error An object containing the error details
 * @param {String} name Playback name
 */Events.PLAYBACK_ERROR='playback:error';// TODO doc
Events.PLAYBACK_STATS_ADD='playback:stats:add';// TODO doc
Events.PLAYBACK_FRAGMENT_LOADED='playback:fragment:loaded';// TODO doc
Events.PLAYBACK_LEVEL_SWITCH='playback:level:switch';/**
 * Fired when subtitle is available on playback for display
 *
 * @event PLAYBACK_SUBTITLE_AVAILABLE
 */Events.PLAYBACK_SUBTITLE_AVAILABLE='playback:subtitle:available';/**
 * Fired when playback subtitle track has changed
 *
 * @event CONTAINER_SUBTITLE_CHANGED
 * @param {Object} track Data
 * track object
 * @param {Number} [track.id]
 * selected track id
 */Events.PLAYBACK_SUBTITLE_CHANGED='playback:subtitle:changed';// Core Events
/**
 * Fired when the containers are created
 *
 * @event CORE_CONTAINERS_CREATED
 */Events.CORE_CONTAINERS_CREATED='core:containers:created';/**
 * Fired when the options were changed for the core
 *
 * @event CORE_OPTIONS_CHANGE
 */Events.CORE_OPTIONS_CHANGE='core:options:change';/**
 * Fired after creating containers, when the core is ready
 *
 * @event CORE_READY
 */Events.CORE_READY='core:ready';/**
 * Fired when the fullscreen state change
 *
 * @event CORE_FULLSCREEN
 * @param {Boolean} whether or not the player is on fullscreen mode
 */Events.CORE_FULLSCREEN='core:fullscreen';/**
 * Fired when the screen orientation has changed.
 * This event is trigger only for mobile devices.
 *
 * @event CORE_SCREEN_ORIENTATION_CHANGED
 * @param {Object} screen An object with screen orientation
 * screen object
 * @param {Object} [screen.event]
 * window resize event object
 * @param {String} [screen.orientation]
 * screen orientation (ie: 'landscape' or 'portrait')
 */Events.CORE_SCREEN_ORIENTATION_CHANGED='core:screen:orientation:changed';// Container Events
/**
 * Fired when the container internal state changes
 *
 * @event CONTAINER_PLAYBACKSTATE
 * @param {Object} state Data
 * state object
 * @param {String} [state.type]
 * the playback type
 */Events.CONTAINER_PLAYBACKSTATE='container:playbackstate';Events.CONTAINER_PLAYBACKDVRSTATECHANGED='container:dvr';/**
 * Fired when the container updates its bitrate
 *
 * @event CONTAINER_BITRATE
 * @param {Object} bitrate Data
 * bitrate object
 * @param {Number} [bitrate.bandwidth]
 * bitrate bandwidth when it's available
 * @param {Number} [bitrate.width]
 * playback width (ex: 720, 640, 1080)
 * @param {Number} [bitrate.height]
 * playback height (ex: 240, 480, 720)
 * @param {Number} [bitrate.level]
 * playback level when it's available, it could be just a map for width (0 => 240, 1 => 480, 2 => 720)
 */Events.CONTAINER_BITRATE='container:bitrate';Events.CONTAINER_STATS_REPORT='container:stats:report';Events.CONTAINER_DESTROYED='container:destroyed';/**
 * Fired when the container is ready
 *
 * @event CONTAINER_READY
 */Events.CONTAINER_READY='container:ready';Events.CONTAINER_ERROR='container:error';/**
 * Fired when the container loaded its metadata
 *
 * @event CONTAINER_LOADEDMETADATA
 * @param {Object} metadata Data
 * settings object
 * @param {Number} [metadata.duration]
 * the playback duration
 * @param {Object} [metadata.data]
 * extra meta data
 */Events.CONTAINER_LOADEDMETADATA='container:loadedmetadata';/**
 * Fired when subtitle is available on container for display
 *
 * @event CONTAINER_SUBTITLE_AVAILABLE
 */Events.CONTAINER_SUBTITLE_AVAILABLE='container:subtitle:available';/**
 * Fired when subtitle track has changed
 *
 * @event CONTAINER_SUBTITLE_CHANGED
 * @param {Object} track Data
 * track object
 * @param {Number} [track.id]
 * selected track id
 */Events.CONTAINER_SUBTITLE_CHANGED='container:subtitle:changed';/**
 * Fired when the time is updated on container
 *
 * @event CONTAINER_TIMEUPDATE
 * @param {Object} progress Data
 * progress object
 * @param {Number} [progress.current]
 * current time
 * @param {Number} [progress.total]
 * total time
 */Events.CONTAINER_TIMEUPDATE='container:timeupdate';/**
 * Fired when the container is downloading the media
 *
 * @event CONTAINER_PROGRESS
 * @param {Object} progress Data
 * progress object
 * @param {Number} [progress.start]
 * initial downloaded content
 * @param {Number} [progress.current]
 * current dowloaded content
 * @param {Number} [progress.total]
 * total content to be downloaded
 */Events.CONTAINER_PROGRESS='container:progress';Events.CONTAINER_PLAY='container:play';Events.CONTAINER_STOP='container:stop';Events.CONTAINER_PAUSE='container:pause';Events.CONTAINER_ENDED='container:ended';Events.CONTAINER_CLICK='container:click';Events.CONTAINER_DBLCLICK='container:dblclick';Events.CONTAINER_CONTEXTMENU='container:contextmenu';Events.CONTAINER_MOUSE_ENTER='container:mouseenter';Events.CONTAINER_MOUSE_LEAVE='container:mouseleave';/**
 * Fired when the container seeks the video
 *
 * @event CONTAINER_SEEK
 * @param {Number} time the current time in seconds
 */Events.CONTAINER_SEEK='container:seek';Events.CONTAINER_VOLUME='container:volume';Events.CONTAINER_FULLSCREEN='container:fullscreen';/**
 * Fired when container is buffering
 *
 * @event CONTAINER_STATE_BUFFERING
 */Events.CONTAINER_STATE_BUFFERING='container:state:buffering';/**
 * Fired when the container filled the buffer
 *
 * @event CONTAINER_STATE_BUFFERFULL
 */Events.CONTAINER_STATE_BUFFERFULL='container:state:bufferfull';/**
 * Fired when the container changes any settings (volume, seek and etc)
 *
 * @event CONTAINER_SETTINGSUPDATE
 */Events.CONTAINER_SETTINGSUPDATE='container:settingsupdate';/**
 * Fired when container updates its video quality
 *
 * @event CONTAINER_HIGHDEFINITIONUPDATE
 * @param {Boolean} isHD
 * true when is on HD, false otherwise
 */Events.CONTAINER_HIGHDEFINITIONUPDATE='container:highdefinitionupdate';/**
 * Fired when the media control shows
 *
 * @event CONTAINER_MEDIACONTROL_SHOW
 */Events.CONTAINER_MEDIACONTROL_SHOW='container:mediacontrol:show';/**
 * Fired when the media control hides
 *
 * @event CONTAINER_MEDIACONTROL_HIDE
 */Events.CONTAINER_MEDIACONTROL_HIDE='container:mediacontrol:hide';Events.CONTAINER_MEDIACONTROL_DISABLE='container:mediacontrol:disable';Events.CONTAINER_MEDIACONTROL_ENABLE='container:mediacontrol:enable';Events.CONTAINER_STATS_ADD='container:stats:add';/**
 * Fired when the options were changed for the container
 *
 * @event CONTAINER_OPTIONS_CHANGE
 */Events.CONTAINER_OPTIONS_CHANGE='container:options:change';// MediaControl Events
Events.MEDIACONTROL_RENDERED='mediacontrol:rendered';/**
 * Fired when the player enters/exit on fullscreen
 *
 * @event MEDIACONTROL_FULLSCREEN
 */Events.MEDIACONTROL_FULLSCREEN='mediacontrol:fullscreen';/**
 * Fired when the media control shows
 *
 * @event MEDIACONTROL_SHOW
 */Events.MEDIACONTROL_SHOW='mediacontrol:show';/**
 * Fired when the media control hides
 *
 * @event MEDIACONTROL_HIDE
 */Events.MEDIACONTROL_HIDE='mediacontrol:hide';/**
 * Fired when mouse enters on the seekbar
 *
 * @event MEDIACONTROL_MOUSEMOVE_SEEKBAR
 * @param {Object} event
 * the javascript event
 */Events.MEDIACONTROL_MOUSEMOVE_SEEKBAR='mediacontrol:mousemove:seekbar';/**
 * Fired when mouse leaves the seekbar
 *
 * @event MEDIACONTROL_MOUSELEAVE_SEEKBAR
 * @param {Object} event
 * the javascript event
 */Events.MEDIACONTROL_MOUSELEAVE_SEEKBAR='mediacontrol:mouseleave:seekbar';/**
 * Fired when the media is being played
 *
 * @event MEDIACONTROL_PLAYING
 */Events.MEDIACONTROL_PLAYING='mediacontrol:playing';/**
 * Fired when the media is not being played
 *
 * @event MEDIACONTROL_NOTPLAYING
 */Events.MEDIACONTROL_NOTPLAYING='mediacontrol:notplaying';/**
 * Fired when the container was changed
 *
 * @event MEDIACONTROL_CONTAINERCHANGED
 */Events.MEDIACONTROL_CONTAINERCHANGED='mediacontrol:containerchanged';module.exports=exports['default'];/***/},/* 5 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.DomRecycler=exports.cancelAnimationFrame=exports.requestAnimationFrame=exports.QueryString=exports.Config=exports.Fullscreen=undefined;var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _defineProperty=__webpack_require__(70);var _defineProperty2=_interopRequireDefault(_defineProperty);var _getOwnPropertyDescriptor=__webpack_require__(125);var _getOwnPropertyDescriptor2=_interopRequireDefault(_getOwnPropertyDescriptor);exports.extend=extend;exports.formatTime=formatTime;exports.seekStringToSeconds=seekStringToSeconds;exports.uniqueId=uniqueId;exports.isNumber=isNumber;exports.currentScriptUrl=currentScriptUrl;exports.getBrowserLanguage=getBrowserLanguage;exports.now=now;exports.removeArrayItem=removeArrayItem;__webpack_require__(128);var _browser=__webpack_require__(13);var _browser2=_interopRequireDefault(_browser);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function assign(obj,source){if(source){for(var prop in source){var propDescriptor=(0,_getOwnPropertyDescriptor2.default)(source,prop);propDescriptor?(0,_defineProperty2.default)(obj,prop,propDescriptor):obj[prop]=source[prop];}}return obj;}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
/*jshint -W079 */function extend(parent,properties){var Surrogate=function(_parent){(0,_inherits3.default)(Surrogate,_parent);function Surrogate(){(0,_classCallCheck3.default)(this,Surrogate);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var _this=(0,_possibleConstructorReturn3.default)(this,_parent.call.apply(_parent,[this].concat(args)));if(properties.initialize){properties.initialize.apply(_this,args);}return _this;}return Surrogate;}(parent);assign(Surrogate.prototype,properties);return Surrogate;}function formatTime(time,paddedHours){if(!isFinite(time)){return'--:--';}time=time*1000;time=parseInt(time/1000);var seconds=time%60;time=parseInt(time/60);var minutes=time%60;time=parseInt(time/60);var hours=time%24;var days=parseInt(time/24);var out='';if(days&&days>0){out+=days+':';if(hours<1){out+='00:';}}if(hours&&hours>0||paddedHours){out+=('0'+hours).slice(-2)+':';}out+=('0'+minutes).slice(-2)+':';out+=('0'+seconds).slice(-2);return out.trim();}var Fullscreen=exports.Fullscreen={isFullscreen:function isFullscreen(){return!!(document.webkitFullscreenElement||document.webkitIsFullScreen||document.mozFullScreen||document.msFullscreenElement);},requestFullscreen:function requestFullscreen(el){if(el.requestFullscreen){el.requestFullscreen();}else if(el.webkitRequestFullscreen){el.webkitRequestFullscreen();}else if(el.mozRequestFullScreen){el.mozRequestFullScreen();}else if(el.msRequestFullscreen){el.msRequestFullscreen();}else if(el.querySelector&&el.querySelector('video')&&el.querySelector('video').webkitEnterFullScreen){el.querySelector('video').webkitEnterFullScreen();}else if(el.webkitEnterFullScreen){el.webkitEnterFullScreen();}},cancelFullscreen:function cancelFullscreen(){var el=arguments.length>0&&arguments[0]!==undefined?arguments[0]:document;if(el.exitFullscreen){el.exitFullscreen();}else if(el.webkitCancelFullScreen){el.webkitCancelFullScreen();}else if(el.webkitExitFullscreen){el.webkitExitFullscreen();}else if(el.mozCancelFullScreen){el.mozCancelFullScreen();}else if(el.msExitFullscreen){el.msExitFullscreen();}},fullscreenEnabled:function fullscreenEnabled(){return!!(document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullScreenEnabled||document.msFullscreenEnabled);}};var Config=exports.Config=function(){function Config(){(0,_classCallCheck3.default)(this,Config);}Config._defaultConfig=function _defaultConfig(){return{volume:{value:100,parse:parseInt}};};Config._defaultValueFor=function _defaultValueFor(key){try{return this._defaultConfig()[key].parse(this._defaultConfig()[key].value);}catch(e){return undefined;}};Config._createKeyspace=function _createKeyspace(key){return'clappr.'+document.domain+'.'+key;};Config.restore=function restore(key){if(_browser2.default.hasLocalstorage&&localStorage[this._createKeyspace(key)]){return this._defaultConfig()[key].parse(localStorage[this._createKeyspace(key)]);}return this._defaultValueFor(key);};Config.persist=function persist(key,value){if(_browser2.default.hasLocalstorage){try{localStorage[this._createKeyspace(key)]=value;return true;}catch(e){return false;}}};return Config;}();var QueryString=exports.QueryString=function(){function QueryString(){(0,_classCallCheck3.default)(this,QueryString);}QueryString.parse=function parse(paramsString){var match=void 0;var pl=/\+/g,// Regex for replacing addition symbol with a space
search=/([^&=]+)=?([^&]*)/g,decode=function decode(s){return decodeURIComponent(s.replace(pl,' '));},params={};while(match=search.exec(paramsString)){// eslint-disable-line no-cond-assign
params[decode(match[1]).toLowerCase()]=decode(match[2]);}return params;};(0,_createClass3.default)(QueryString,null,[{key:'params',get:function get(){var query=window.location.search.substring(1);if(query!==this.query){this._urlParams=this.parse(query);this.query=query;}return this._urlParams;}},{key:'hashParams',get:function get(){var hash=window.location.hash.substring(1);if(hash!==this.hash){this._hashParams=this.parse(hash);this.hash=hash;}return this._hashParams;}}]);return QueryString;}();function seekStringToSeconds(){var paramName=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'t';var seconds=0;var seekString=QueryString.params[paramName]||QueryString.hashParams[paramName]||'';var parts=seekString.match(/[0-9]+[hms]+/g)||[];if(parts.length>0){(function(){var factor={'h':3600,'m':60,'s':1};parts.forEach(function(el){if(el){var suffix=el[el.length-1];var time=parseInt(el.slice(0,el.length-1),10);seconds+=time*factor[suffix];}});})();}else if(seekString){seconds=parseInt(seekString,10);}return seconds;}var idsCounter={};function uniqueId(prefix){idsCounter[prefix]||(idsCounter[prefix]=0);var id=++idsCounter[prefix];return prefix+id;}function isNumber(value){return value-parseFloat(value)+1>=0;}function currentScriptUrl(){var scripts=document.getElementsByTagName('script');return scripts.length?scripts[scripts.length-1].src:'';}var requestAnimationFrame=exports.requestAnimationFrame=(window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||function(fn){window.setTimeout(fn,1000/60);}).bind(window);var cancelAnimationFrame=exports.cancelAnimationFrame=(window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.clearTimeout).bind(window);function getBrowserLanguage(){return window.navigator&&window.navigator.language;}function now(){if(window.performance&&window.performance.now){return performance.now();}return Date.now();}// remove the item from the array if it exists in the array
function removeArrayItem(arr,item){var i=arr.indexOf(item);if(i>=0){arr.splice(i,1);}}// Simple Zepto element factory with video recycle feature.
var videoStack=[];var DomRecycler=exports.DomRecycler=function(){function DomRecycler(){(0,_classCallCheck3.default)(this,DomRecycler);}DomRecycler.configure=function configure(options){this.options=_clapprZepto2.default.extend(this.options,options);};DomRecycler.create=function create(name){if(this.options.recycleVideo&&name==='video'&&videoStack.length>0){return videoStack.shift();}return(0,_clapprZepto2.default)('<'+name+'>');};DomRecycler.garbage=function garbage($el){// Expect Zepto collection with single element (does not iterate!)
if(!this.options.recycleVideo||$el[0].tagName.toUpperCase()!=='VIDEO')return;$el.children().remove();videoStack.push($el);};return DomRecycler;}();DomRecycler.options={recycleVideo:false};exports.default={Config:Config,Fullscreen:Fullscreen,QueryString:QueryString,DomRecycler:DomRecycler,extend:extend,formatTime:formatTime,seekStringToSeconds:seekStringToSeconds,uniqueId:uniqueId,currentScriptUrl:currentScriptUrl,isNumber:isNumber,requestAnimationFrame:requestAnimationFrame,cancelAnimationFrame:cancelAnimationFrame,getBrowserLanguage:getBrowserLanguage,now:now,removeArrayItem:removeArrayItem};/***/},/* 6 *//***/function(module,exports){/* Zepto v1.2.0 - zepto ajax callbacks deferred event ie selector - zeptojs.com/license */var Zepto=function(){var undefined,key,$,classList,emptyArray=[],concat=emptyArray.concat,filter=emptyArray.filter,slice=emptyArray.slice,document=window.document,elementDisplay={},classCache={},cssNumber={'column-count':1,'columns':1,'font-weight':1,'line-height':1,'opacity':1,'z-index':1,'zoom':1},fragmentRE=/^\s*<(\w+|!)[^>]*>/,singleTagRE=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,tagExpanderRE=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,rootNodeRE=/^(?:body|html)$/i,capitalRE=/([A-Z])/g,// special attributes that should be get/set via method calls
methodAttributes=['val','css','html','text','data','width','height','offset'],adjacencyOperators=['after','prepend','before','append'],table=document.createElement('table'),tableRow=document.createElement('tr'),containers={'tr':document.createElement('tbody'),'tbody':table,'thead':table,'tfoot':table,'td':tableRow,'th':tableRow,'*':document.createElement('div')},readyRE=/complete|loaded|interactive/,simpleSelectorRE=/^[\w-]*$/,class2type={},toString=class2type.toString,zepto={},camelize,uniq,tempParent=document.createElement('div'),propMap={'tabindex':'tabIndex','readonly':'readOnly','for':'htmlFor','class':'className','maxlength':'maxLength','cellspacing':'cellSpacing','cellpadding':'cellPadding','rowspan':'rowSpan','colspan':'colSpan','usemap':'useMap','frameborder':'frameBorder','contenteditable':'contentEditable'},isArray=Array.isArray||function(object){return object instanceof Array;};zepto.matches=function(element,selector){if(!selector||!element||element.nodeType!==1)return false;var matchesSelector=element.matches||element.webkitMatchesSelector||element.mozMatchesSelector||element.oMatchesSelector||element.matchesSelector;if(matchesSelector)return matchesSelector.call(element,selector);// fall back to performing a selector:
var match,parent=element.parentNode,temp=!parent;if(temp)(parent=tempParent).appendChild(element);match=~zepto.qsa(parent,selector).indexOf(element);temp&&tempParent.removeChild(element);return match;};function type(obj){return obj==null?String(obj):class2type[toString.call(obj)]||"object";}function isFunction(value){return type(value)=="function";}function isWindow(obj){return obj!=null&&obj==obj.window;}function isDocument(obj){return obj!=null&&obj.nodeType==obj.DOCUMENT_NODE;}function isObject(obj){return type(obj)=="object";}function isPlainObject(obj){return isObject(obj)&&!isWindow(obj)&&Object.getPrototypeOf(obj)==Object.prototype;}function likeArray(obj){var length=!!obj&&'length'in obj&&obj.length,type=$.type(obj);return'function'!=type&&!isWindow(obj)&&('array'==type||length===0||typeof length=='number'&&length>0&&length-1 in obj);}function compact(array){return filter.call(array,function(item){return item!=null;});}function flatten(array){return array.length>0?$.fn.concat.apply([],array):array;}camelize=function(str){return str.replace(/-+(.)?/g,function(match,chr){return chr?chr.toUpperCase():'';});};function dasherize(str){return str.replace(/::/g,'/').replace(/([A-Z]+)([A-Z][a-z])/g,'$1_$2').replace(/([a-z\d])([A-Z])/g,'$1_$2').replace(/_/g,'-').toLowerCase();}uniq=function(array){return filter.call(array,function(item,idx){return array.indexOf(item)==idx;});};function classRE(name){return name in classCache?classCache[name]:classCache[name]=new RegExp('(^|\\s)'+name+'(\\s|$)');}function maybeAddPx(name,value){return typeof value=="number"&&!cssNumber[dasherize(name)]?value+"px":value;}function defaultDisplay(nodeName){var element,display;if(!elementDisplay[nodeName]){element=document.createElement(nodeName);document.body.appendChild(element);display=getComputedStyle(element,'').getPropertyValue("display");element.parentNode.removeChild(element);display=="none"&&(display="block");elementDisplay[nodeName]=display;}return elementDisplay[nodeName];}function children(element){return'children'in element?slice.call(element.children):$.map(element.childNodes,function(node){if(node.nodeType==1)return node;});}function Z(dom,selector){var i,len=dom?dom.length:0;for(i=0;i<len;i++)this[i]=dom[i];this.length=len;this.selector=selector||'';}// `$.zepto.fragment` takes a html string and an optional tag name
// to generate DOM nodes from the given html string.
// The generated DOM nodes are returned as an array.
// This function can be overridden in plugins for example to make
// it compatible with browsers that don't support the DOM fully.
zepto.fragment=function(html,name,properties){var dom,nodes,container;// A special case optimization for a single tag
if(singleTagRE.test(html))dom=$(document.createElement(RegExp.$1));if(!dom){if(html.replace)html=html.replace(tagExpanderRE,"<$1></$2>");if(name===undefined)name=fragmentRE.test(html)&&RegExp.$1;if(!(name in containers))name='*';container=containers[name];container.innerHTML=''+html;dom=$.each(slice.call(container.childNodes),function(){container.removeChild(this);});}if(isPlainObject(properties)){nodes=$(dom);$.each(properties,function(key,value){if(methodAttributes.indexOf(key)>-1)nodes[key](value);else nodes.attr(key,value);});}return dom;};// `$.zepto.Z` swaps out the prototype of the given `dom` array
// of nodes with `$.fn` and thus supplying all the Zepto functions
// to the array. This method can be overridden in plugins.
zepto.Z=function(dom,selector){return new Z(dom,selector);};// `$.zepto.isZ` should return `true` if the given object is a Zepto
// collection. This method can be overridden in plugins.
zepto.isZ=function(object){return object instanceof zepto.Z;};// `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and
// takes a CSS selector and an optional context (and handles various
// special cases).
// This method can be overridden in plugins.
zepto.init=function(selector,context){var dom;// If nothing given, return an empty Zepto collection
if(!selector)return zepto.Z();// Optimize for string selectors
else if(typeof selector=='string'){selector=selector.trim();// If it's a html fragment, create nodes from it
// Note: In both Chrome 21 and Firefox 15, DOM error 12
// is thrown if the fragment doesn't begin with <
if(selector[0]=='<'&&fragmentRE.test(selector))dom=zepto.fragment(selector,RegExp.$1,context),selector=null;// If there's a context, create a collection on that context first, and select
// nodes from there
else if(context!==undefined)return $(context).find(selector);// If it's a CSS selector, use it to select nodes.
else dom=zepto.qsa(document,selector);}// If a function is given, call it when the DOM is ready
else if(isFunction(selector))return $(document).ready(selector);// If a Zepto collection is given, just return it
else if(zepto.isZ(selector))return selector;else{// normalize array if an array of nodes is given
if(isArray(selector))dom=compact(selector);// Wrap DOM nodes.
else if(isObject(selector))dom=[selector],selector=null;// If it's a html fragment, create nodes from it
else if(fragmentRE.test(selector))dom=zepto.fragment(selector.trim(),RegExp.$1,context),selector=null;// If there's a context, create a collection on that context first, and select
// nodes from there
else if(context!==undefined)return $(context).find(selector);// And last but no least, if it's a CSS selector, use it to select nodes.
else dom=zepto.qsa(document,selector);}// create a new Zepto collection from the nodes found
return zepto.Z(dom,selector);};// `$` will be the base `Zepto` object. When calling this
// function just call `$.zepto.init, which makes the implementation
// details of selecting nodes and creating Zepto collections
// patchable in plugins.
$=function(selector,context){return zepto.init(selector,context);};function extend(target,source,deep){for(key in source)if(deep&&(isPlainObject(source[key])||isArray(source[key]))){if(isPlainObject(source[key])&&!isPlainObject(target[key]))target[key]={};if(isArray(source[key])&&!isArray(target[key]))target[key]=[];extend(target[key],source[key],deep);}else if(source[key]!==undefined)target[key]=source[key];}// Copy all but undefined properties from one or more
// objects to the `target` object.
$.extend=function(target){var deep,args=slice.call(arguments,1);if(typeof target=='boolean'){deep=target;target=args.shift();}args.forEach(function(arg){extend(target,arg,deep);});return target;};// `$.zepto.qsa` is Zepto's CSS selector implementation which
// uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
// This method can be overridden in plugins.
zepto.qsa=function(element,selector){var found,maybeID=selector[0]=='#',maybeClass=!maybeID&&selector[0]=='.',nameOnly=maybeID||maybeClass?selector.slice(1):selector,// Ensure that a 1 char tag name still gets checked
isSimple=simpleSelectorRE.test(nameOnly);return element.getElementById&&isSimple&&maybeID?// Safari DocumentFragment doesn't have getElementById
(found=element.getElementById(nameOnly))?[found]:[]:element.nodeType!==1&&element.nodeType!==9&&element.nodeType!==11?[]:slice.call(isSimple&&!maybeID&&element.getElementsByClassName?// DocumentFragment doesn't have getElementsByClassName/TagName
maybeClass?element.getElementsByClassName(nameOnly):// If it's simple, it could be a class
element.getElementsByTagName(selector):// Or a tag
element.querySelectorAll(selector)// Or it's not simple, and we need to query all
);};function filtered(nodes,selector){return selector==null?$(nodes):$(nodes).filter(selector);}$.contains=document.documentElement.contains?function(parent,node){return parent!==node&&parent.contains(node);}:function(parent,node){while(node&&(node=node.parentNode))if(node===parent)return true;return false;};function funcArg(context,arg,idx,payload){return isFunction(arg)?arg.call(context,idx,payload):arg;}function setAttribute(node,name,value){value==null?node.removeAttribute(name):node.setAttribute(name,value);}// access className property while respecting SVGAnimatedString
function className(node,value){var klass=node.className||'',svg=klass&&klass.baseVal!==undefined;if(value===undefined)return svg?klass.baseVal:klass;svg?klass.baseVal=value:node.className=value;}// "true"  => true
// "false" => false
// "null"  => null
// "42"    => 42
// "42.5"  => 42.5
// "08"    => "08"
// JSON    => parse if valid
// String  => self
function deserializeValue(value){try{return value?value=="true"||(value=="false"?false:value=="null"?null:+value+""==value?+value:/^[\[\{]/.test(value)?$.parseJSON(value):value):value;}catch(e){return value;}}$.type=type;$.isFunction=isFunction;$.isWindow=isWindow;$.isArray=isArray;$.isPlainObject=isPlainObject;$.isEmptyObject=function(obj){var name;for(name in obj)return false;return true;};$.isNumeric=function(val){var num=Number(val),type=typeof val;return val!=null&&type!='boolean'&&(type!='string'||val.length)&&!isNaN(num)&&isFinite(num)||false;};$.inArray=function(elem,array,i){return emptyArray.indexOf.call(array,elem,i);};$.camelCase=camelize;$.trim=function(str){return str==null?"":String.prototype.trim.call(str);};// plugin compatibility
$.uuid=0;$.support={};$.expr={};$.noop=function(){};$.map=function(elements,callback){var value,values=[],i,key;if(likeArray(elements))for(i=0;i<elements.length;i++){value=callback(elements[i],i);if(value!=null)values.push(value);}else for(key in elements){value=callback(elements[key],key);if(value!=null)values.push(value);}return flatten(values);};$.each=function(elements,callback){var i,key;if(likeArray(elements)){for(i=0;i<elements.length;i++)if(callback.call(elements[i],i,elements[i])===false)return elements;}else{for(key in elements)if(callback.call(elements[key],key,elements[key])===false)return elements;}return elements;};$.grep=function(elements,callback){return filter.call(elements,callback);};if(window.JSON)$.parseJSON=JSON.parse;// Populate the class2type map
$.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(i,name){class2type["[object "+name+"]"]=name.toLowerCase();});// Define methods that will be available on all
// Zepto collections
$.fn={constructor:zepto.Z,length:0,// Because a collection acts like an array
// copy over these useful array functions.
forEach:emptyArray.forEach,reduce:emptyArray.reduce,push:emptyArray.push,sort:emptyArray.sort,splice:emptyArray.splice,indexOf:emptyArray.indexOf,concat:function(){var i,value,args=[];for(i=0;i<arguments.length;i++){value=arguments[i];args[i]=zepto.isZ(value)?value.toArray():value;}return concat.apply(zepto.isZ(this)?this.toArray():this,args);},// `map` and `slice` in the jQuery API work differently
// from their array counterparts
map:function(fn){return $($.map(this,function(el,i){return fn.call(el,i,el);}));},slice:function(){return $(slice.apply(this,arguments));},ready:function(callback){// need to check if document.body exists for IE as that browser reports
// document ready when it hasn't yet created the body element
if(readyRE.test(document.readyState)&&document.body)callback($);else document.addEventListener('DOMContentLoaded',function(){callback($);},false);return this;},get:function(idx){return idx===undefined?slice.call(this):this[idx>=0?idx:idx+this.length];},toArray:function(){return this.get();},size:function(){return this.length;},remove:function(){return this.each(function(){if(this.parentNode!=null)this.parentNode.removeChild(this);});},each:function(callback){emptyArray.every.call(this,function(el,idx){return callback.call(el,idx,el)!==false;});return this;},filter:function(selector){if(isFunction(selector))return this.not(this.not(selector));return $(filter.call(this,function(element){return zepto.matches(element,selector);}));},add:function(selector,context){return $(uniq(this.concat($(selector,context))));},is:function(selector){return this.length>0&&zepto.matches(this[0],selector);},not:function(selector){var nodes=[];if(isFunction(selector)&&selector.call!==undefined)this.each(function(idx){if(!selector.call(this,idx))nodes.push(this);});else{var excludes=typeof selector=='string'?this.filter(selector):likeArray(selector)&&isFunction(selector.item)?slice.call(selector):$(selector);this.forEach(function(el){if(excludes.indexOf(el)<0)nodes.push(el);});}return $(nodes);},has:function(selector){return this.filter(function(){return isObject(selector)?$.contains(this,selector):$(this).find(selector).size();});},eq:function(idx){return idx===-1?this.slice(idx):this.slice(idx,+idx+1);},first:function(){var el=this[0];return el&&!isObject(el)?el:$(el);},last:function(){var el=this[this.length-1];return el&&!isObject(el)?el:$(el);},find:function(selector){var result,$this=this;if(!selector)result=$();else if(typeof selector=='object')result=$(selector).filter(function(){var node=this;return emptyArray.some.call($this,function(parent){return $.contains(parent,node);});});else if(this.length==1)result=$(zepto.qsa(this[0],selector));else result=this.map(function(){return zepto.qsa(this,selector);});return result;},closest:function(selector,context){var nodes=[],collection=typeof selector=='object'&&$(selector);this.each(function(_,node){while(node&&!(collection?collection.indexOf(node)>=0:zepto.matches(node,selector)))node=node!==context&&!isDocument(node)&&node.parentNode;if(node&&nodes.indexOf(node)<0)nodes.push(node);});return $(nodes);},parents:function(selector){var ancestors=[],nodes=this;while(nodes.length>0)nodes=$.map(nodes,function(node){if((node=node.parentNode)&&!isDocument(node)&&ancestors.indexOf(node)<0){ancestors.push(node);return node;}});return filtered(ancestors,selector);},parent:function(selector){return filtered(uniq(this.pluck('parentNode')),selector);},children:function(selector){return filtered(this.map(function(){return children(this);}),selector);},contents:function(){return this.map(function(){return this.contentDocument||slice.call(this.childNodes);});},siblings:function(selector){return filtered(this.map(function(i,el){return filter.call(children(el.parentNode),function(child){return child!==el;});}),selector);},empty:function(){return this.each(function(){this.innerHTML='';});},// `pluck` is borrowed from Prototype.js
pluck:function(property){return $.map(this,function(el){return el[property];});},show:function(){return this.each(function(){this.style.display=="none"&&(this.style.display='');if(getComputedStyle(this,'').getPropertyValue("display")=="none")this.style.display=defaultDisplay(this.nodeName);});},replaceWith:function(newContent){return this.before(newContent).remove();},wrap:function(structure){var func=isFunction(structure);if(this[0]&&!func)var dom=$(structure).get(0),clone=dom.parentNode||this.length>1;return this.each(function(index){$(this).wrapAll(func?structure.call(this,index):clone?dom.cloneNode(true):dom);});},wrapAll:function(structure){if(this[0]){$(this[0]).before(structure=$(structure));var children;// drill down to the inmost element
while((children=structure.children()).length)structure=children.first();$(structure).append(this);}return this;},wrapInner:function(structure){var func=isFunction(structure);return this.each(function(index){var self=$(this),contents=self.contents(),dom=func?structure.call(this,index):structure;contents.length?contents.wrapAll(dom):self.append(dom);});},unwrap:function(){this.parent().each(function(){$(this).replaceWith($(this).children());});return this;},clone:function(){return this.map(function(){return this.cloneNode(true);});},hide:function(){return this.css("display","none");},toggle:function(setting){return this.each(function(){var el=$(this);(setting===undefined?el.css("display")=="none":setting)?el.show():el.hide();});},prev:function(selector){return $(this.pluck('previousElementSibling')).filter(selector||'*');},next:function(selector){return $(this.pluck('nextElementSibling')).filter(selector||'*');},html:function(html){return 0 in arguments?this.each(function(idx){var originHtml=this.innerHTML;$(this).empty().append(funcArg(this,html,idx,originHtml));}):0 in this?this[0].innerHTML:null;},text:function(text){return 0 in arguments?this.each(function(idx){var newText=funcArg(this,text,idx,this.textContent);this.textContent=newText==null?'':''+newText;}):0 in this?this.pluck('textContent').join(""):null;},attr:function(name,value){var result;return typeof name=='string'&&!(1 in arguments)?0 in this&&this[0].nodeType==1&&(result=this[0].getAttribute(name))!=null?result:undefined:this.each(function(idx){if(this.nodeType!==1)return;if(isObject(name))for(key in name)setAttribute(this,key,name[key]);else setAttribute(this,name,funcArg(this,value,idx,this.getAttribute(name)));});},removeAttr:function(name){return this.each(function(){this.nodeType===1&&name.split(' ').forEach(function(attribute){setAttribute(this,attribute);},this);});},prop:function(name,value){name=propMap[name]||name;return 1 in arguments?this.each(function(idx){this[name]=funcArg(this,value,idx,this[name]);}):this[0]&&this[0][name];},removeProp:function(name){name=propMap[name]||name;return this.each(function(){delete this[name];});},data:function(name,value){var attrName='data-'+name.replace(capitalRE,'-$1').toLowerCase();var data=1 in arguments?this.attr(attrName,value):this.attr(attrName);return data!==null?deserializeValue(data):undefined;},val:function(value){if(0 in arguments){if(value==null)value="";return this.each(function(idx){this.value=funcArg(this,value,idx,this.value);});}else{return this[0]&&(this[0].multiple?$(this[0]).find('option').filter(function(){return this.selected;}).pluck('value'):this[0].value);}},offset:function(coordinates){if(coordinates)return this.each(function(index){var $this=$(this),coords=funcArg(this,coordinates,index,$this.offset()),parentOffset=$this.offsetParent().offset(),props={top:coords.top-parentOffset.top,left:coords.left-parentOffset.left};if($this.css('position')=='static')props['position']='relative';$this.css(props);});if(!this.length)return null;if(document.documentElement!==this[0]&&!$.contains(document.documentElement,this[0]))return{top:0,left:0};var obj=this[0].getBoundingClientRect();return{left:obj.left+window.pageXOffset,top:obj.top+window.pageYOffset,width:Math.round(obj.width),height:Math.round(obj.height)};},css:function(property,value){if(arguments.length<2){var element=this[0];if(typeof property=='string'){if(!element)return;return element.style[camelize(property)]||getComputedStyle(element,'').getPropertyValue(property);}else if(isArray(property)){if(!element)return;var props={};var computedStyle=getComputedStyle(element,'');$.each(property,function(_,prop){props[prop]=element.style[camelize(prop)]||computedStyle.getPropertyValue(prop);});return props;}}var css='';if(type(property)=='string'){if(!value&&value!==0)this.each(function(){this.style.removeProperty(dasherize(property));});else css=dasherize(property)+":"+maybeAddPx(property,value);}else{for(key in property)if(!property[key]&&property[key]!==0)this.each(function(){this.style.removeProperty(dasherize(key));});else css+=dasherize(key)+':'+maybeAddPx(key,property[key])+';';}return this.each(function(){this.style.cssText+=';'+css;});},index:function(element){return element?this.indexOf($(element)[0]):this.parent().children().indexOf(this[0]);},hasClass:function(name){if(!name)return false;return emptyArray.some.call(this,function(el){return this.test(className(el));},classRE(name));},addClass:function(name){if(!name)return this;return this.each(function(idx){if(!('className'in this))return;classList=[];var cls=className(this),newName=funcArg(this,name,idx,cls);newName.split(/\s+/g).forEach(function(klass){if(!$(this).hasClass(klass))classList.push(klass);},this);classList.length&&className(this,cls+(cls?" ":"")+classList.join(" "));});},removeClass:function(name){return this.each(function(idx){if(!('className'in this))return;if(name===undefined)return className(this,'');classList=className(this);funcArg(this,name,idx,classList).split(/\s+/g).forEach(function(klass){classList=classList.replace(classRE(klass)," ");});className(this,classList.trim());});},toggleClass:function(name,when){if(!name)return this;return this.each(function(idx){var $this=$(this),names=funcArg(this,name,idx,className(this));names.split(/\s+/g).forEach(function(klass){(when===undefined?!$this.hasClass(klass):when)?$this.addClass(klass):$this.removeClass(klass);});});},scrollTop:function(value){if(!this.length)return;var hasScrollTop='scrollTop'in this[0];if(value===undefined)return hasScrollTop?this[0].scrollTop:this[0].pageYOffset;return this.each(hasScrollTop?function(){this.scrollTop=value;}:function(){this.scrollTo(this.scrollX,value);});},scrollLeft:function(value){if(!this.length)return;var hasScrollLeft='scrollLeft'in this[0];if(value===undefined)return hasScrollLeft?this[0].scrollLeft:this[0].pageXOffset;return this.each(hasScrollLeft?function(){this.scrollLeft=value;}:function(){this.scrollTo(value,this.scrollY);});},position:function(){if(!this.length)return;var elem=this[0],// Get *real* offsetParent
offsetParent=this.offsetParent(),// Get correct offsets
offset=this.offset(),parentOffset=rootNodeRE.test(offsetParent[0].nodeName)?{top:0,left:0}:offsetParent.offset();// Subtract element margins
// note: when an element has margin: auto the offsetLeft and marginLeft
// are the same in Safari causing offset.left to incorrectly be 0
offset.top-=parseFloat($(elem).css('margin-top'))||0;offset.left-=parseFloat($(elem).css('margin-left'))||0;// Add offsetParent borders
parentOffset.top+=parseFloat($(offsetParent[0]).css('border-top-width'))||0;parentOffset.left+=parseFloat($(offsetParent[0]).css('border-left-width'))||0;// Subtract the two offsets
return{top:offset.top-parentOffset.top,left:offset.left-parentOffset.left};},offsetParent:function(){return this.map(function(){var parent=this.offsetParent||document.body;while(parent&&!rootNodeRE.test(parent.nodeName)&&$(parent).css("position")=="static")parent=parent.offsetParent;return parent;});}// for now
};$.fn.detach=$.fn.remove// Generate the `width` and `height` functions
;['width','height'].forEach(function(dimension){var dimensionProperty=dimension.replace(/./,function(m){return m[0].toUpperCase();});$.fn[dimension]=function(value){var offset,el=this[0];if(value===undefined)return isWindow(el)?el['inner'+dimensionProperty]:isDocument(el)?el.documentElement['scroll'+dimensionProperty]:(offset=this.offset())&&offset[dimension];else return this.each(function(idx){el=$(this);el.css(dimension,funcArg(this,value,idx,el[dimension]()));});};});function traverseNode(node,fun){fun(node);for(var i=0,len=node.childNodes.length;i<len;i++)traverseNode(node.childNodes[i],fun);}// Generate the `after`, `prepend`, `before`, `append`,
// `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
adjacencyOperators.forEach(function(operator,operatorIndex){var inside=operatorIndex%2;//=> prepend, append
$.fn[operator]=function(){// arguments can be nodes, arrays of nodes, Zepto objects and HTML strings
var argType,nodes=$.map(arguments,function(arg){var arr=[];argType=type(arg);if(argType=="array"){arg.forEach(function(el){if(el.nodeType!==undefined)return arr.push(el);else if($.zepto.isZ(el))return arr=arr.concat(el.get());arr=arr.concat(zepto.fragment(el));});return arr;}return argType=="object"||arg==null?arg:zepto.fragment(arg);}),parent,copyByClone=this.length>1;if(nodes.length<1)return this;return this.each(function(_,target){parent=inside?target:target.parentNode;// convert all methods to a "before" operation
target=operatorIndex==0?target.nextSibling:operatorIndex==1?target.firstChild:operatorIndex==2?target:null;var parentInDocument=$.contains(document.documentElement,parent);nodes.forEach(function(node){if(copyByClone)node=node.cloneNode(true);else if(!parent)return $(node).remove();parent.insertBefore(node,target);if(parentInDocument)traverseNode(node,function(el){if(el.nodeName!=null&&el.nodeName.toUpperCase()==='SCRIPT'&&(!el.type||el.type==='text/javascript')&&!el.src){var target=el.ownerDocument?el.ownerDocument.defaultView:window;target['eval'].call(target,el.innerHTML);}});});});};// after    => insertAfter
// prepend  => prependTo
// before   => insertBefore
// append   => appendTo
$.fn[inside?operator+'To':'insert'+(operatorIndex?'Before':'After')]=function(html){$(html)[operator](this);return this;};});zepto.Z.prototype=Z.prototype=$.fn;// Export internal API functions in the `$.zepto` namespace
zepto.uniq=uniq;zepto.deserializeValue=deserializeValue;$.zepto=zepto;return $;}();window.Zepto=Zepto;window.$===undefined&&(window.$=Zepto);(function($){var jsonpID=+new Date(),document=window.document,key,name,rscript=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,scriptTypeRE=/^(?:text|application)\/javascript/i,xmlTypeRE=/^(?:text|application)\/xml/i,jsonType='application/json',htmlType='text/html',blankRE=/^\s*$/,originAnchor=document.createElement('a');originAnchor.href=window.location.href;// trigger a custom event and return false if it was cancelled
function triggerAndReturn(context,eventName,data){var event=$.Event(eventName);$(context).trigger(event,data);return!event.isDefaultPrevented();}// trigger an Ajax "global" event
function triggerGlobal(settings,context,eventName,data){if(settings.global)return triggerAndReturn(context||document,eventName,data);}// Number of active Ajax requests
$.active=0;function ajaxStart(settings){if(settings.global&&$.active++===0)triggerGlobal(settings,null,'ajaxStart');}function ajaxStop(settings){if(settings.global&&! --$.active)triggerGlobal(settings,null,'ajaxStop');}// triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
function ajaxBeforeSend(xhr,settings){var context=settings.context;if(settings.beforeSend.call(context,xhr,settings)===false||triggerGlobal(settings,context,'ajaxBeforeSend',[xhr,settings])===false)return false;triggerGlobal(settings,context,'ajaxSend',[xhr,settings]);}function ajaxSuccess(data,xhr,settings,deferred){var context=settings.context,status='success';settings.success.call(context,data,status,xhr);if(deferred)deferred.resolveWith(context,[data,status,xhr]);triggerGlobal(settings,context,'ajaxSuccess',[xhr,settings,data]);ajaxComplete(status,xhr,settings);}// type: "timeout", "error", "abort", "parsererror"
function ajaxError(error,type,xhr,settings,deferred){var context=settings.context;settings.error.call(context,xhr,type,error);if(deferred)deferred.rejectWith(context,[xhr,type,error]);triggerGlobal(settings,context,'ajaxError',[xhr,settings,error||type]);ajaxComplete(type,xhr,settings);}// status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
function ajaxComplete(status,xhr,settings){var context=settings.context;settings.complete.call(context,xhr,status);triggerGlobal(settings,context,'ajaxComplete',[xhr,settings]);ajaxStop(settings);}function ajaxDataFilter(data,type,settings){if(settings.dataFilter==empty)return data;var context=settings.context;return settings.dataFilter.call(context,data,type);}// Empty function, used as default callback
function empty(){}$.ajaxJSONP=function(options,deferred){if(!('type'in options))return $.ajax(options);var _callbackName=options.jsonpCallback,callbackName=($.isFunction(_callbackName)?_callbackName():_callbackName)||'Zepto'+jsonpID++,script=document.createElement('script'),originalCallback=window[callbackName],responseData,abort=function(errorType){$(script).triggerHandler('error',errorType||'abort');},xhr={abort:abort},abortTimeout;if(deferred)deferred.promise(xhr);$(script).on('load error',function(e,errorType){clearTimeout(abortTimeout);$(script).off().remove();if(e.type=='error'||!responseData){ajaxError(null,errorType||'error',xhr,options,deferred);}else{ajaxSuccess(responseData[0],xhr,options,deferred);}window[callbackName]=originalCallback;if(responseData&&$.isFunction(originalCallback))originalCallback(responseData[0]);originalCallback=responseData=undefined;});if(ajaxBeforeSend(xhr,options)===false){abort('abort');return xhr;}window[callbackName]=function(){responseData=arguments;};script.src=options.url.replace(/\?(.+)=\?/,'?$1='+callbackName);document.head.appendChild(script);if(options.timeout>0)abortTimeout=setTimeout(function(){abort('timeout');},options.timeout);return xhr;};$.ajaxSettings={// Default type of request
type:'GET',// Callback that is executed before request
beforeSend:empty,// Callback that is executed if the request succeeds
success:empty,// Callback that is executed the the server drops error
error:empty,// Callback that is executed on request complete (both: error and success)
complete:empty,// The context for the callbacks
context:null,// Whether to trigger "global" Ajax events
global:true,// Transport
xhr:function(){return new window.XMLHttpRequest();},// MIME types mapping
// IIS returns Javascript as "application/x-javascript"
accepts:{script:'text/javascript, application/javascript, application/x-javascript',json:jsonType,xml:'application/xml, text/xml',html:htmlType,text:'text/plain'},// Whether the request is to another domain
crossDomain:false,// Default timeout
timeout:0,// Whether data should be serialized to string
processData:true,// Whether the browser should be allowed to cache GET responses
cache:true,//Used to handle the raw response data of XMLHttpRequest.
//This is a pre-filtering function to sanitize the response.
//The sanitized response should be returned
dataFilter:empty};function mimeToDataType(mime){if(mime)mime=mime.split(';',2)[0];return mime&&(mime==htmlType?'html':mime==jsonType?'json':scriptTypeRE.test(mime)?'script':xmlTypeRE.test(mime)&&'xml')||'text';}function appendQuery(url,query){if(query=='')return url;return(url+'&'+query).replace(/[&?]{1,2}/,'?');}// serialize payload and append it to the URL for GET requests
function serializeData(options){if(options.processData&&options.data&&$.type(options.data)!="string")options.data=$.param(options.data,options.traditional);if(options.data&&(!options.type||options.type.toUpperCase()=='GET'||'jsonp'==options.dataType))options.url=appendQuery(options.url,options.data),options.data=undefined;}$.ajax=function(options){var settings=$.extend({},options||{}),deferred=$.Deferred&&$.Deferred(),urlAnchor,hashIndex;for(key in $.ajaxSettings)if(settings[key]===undefined)settings[key]=$.ajaxSettings[key];ajaxStart(settings);if(!settings.crossDomain){urlAnchor=document.createElement('a');urlAnchor.href=settings.url;// cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049
urlAnchor.href=urlAnchor.href;settings.crossDomain=originAnchor.protocol+'//'+originAnchor.host!==urlAnchor.protocol+'//'+urlAnchor.host;}if(!settings.url)settings.url=window.location.toString();if((hashIndex=settings.url.indexOf('#'))>-1)settings.url=settings.url.slice(0,hashIndex);serializeData(settings);var dataType=settings.dataType,hasPlaceholder=/\?.+=\?/.test(settings.url);if(hasPlaceholder)dataType='jsonp';if(settings.cache===false||(!options||options.cache!==true)&&('script'==dataType||'jsonp'==dataType))settings.url=appendQuery(settings.url,'_='+Date.now());if('jsonp'==dataType){if(!hasPlaceholder)settings.url=appendQuery(settings.url,settings.jsonp?settings.jsonp+'=?':settings.jsonp===false?'':'callback=?');return $.ajaxJSONP(settings,deferred);}var mime=settings.accepts[dataType],headers={},setHeader=function(name,value){headers[name.toLowerCase()]=[name,value];},protocol=/^([\w-]+:)\/\//.test(settings.url)?RegExp.$1:window.location.protocol,xhr=settings.xhr(),nativeSetHeader=xhr.setRequestHeader,abortTimeout;if(deferred)deferred.promise(xhr);if(!settings.crossDomain)setHeader('X-Requested-With','XMLHttpRequest');setHeader('Accept',mime||'*/*');if(mime=settings.mimeType||mime){if(mime.indexOf(',')>-1)mime=mime.split(',',2)[0];xhr.overrideMimeType&&xhr.overrideMimeType(mime);}if(settings.contentType||settings.contentType!==false&&settings.data&&settings.type.toUpperCase()!='GET')setHeader('Content-Type',settings.contentType||'application/x-www-form-urlencoded');if(settings.headers)for(name in settings.headers)setHeader(name,settings.headers[name]);xhr.setRequestHeader=setHeader;xhr.onreadystatechange=function(){if(xhr.readyState==4){xhr.onreadystatechange=empty;clearTimeout(abortTimeout);var result,error=false;if(xhr.status>=200&&xhr.status<300||xhr.status==304||xhr.status==0&&protocol=='file:'){dataType=dataType||mimeToDataType(settings.mimeType||xhr.getResponseHeader('content-type'));if(xhr.responseType=='arraybuffer'||xhr.responseType=='blob')result=xhr.response;else{result=xhr.responseText;try{// http://perfectionkills.com/global-eval-what-are-the-options/
// sanitize response accordingly if data filter callback provided
result=ajaxDataFilter(result,dataType,settings);if(dataType=='script')(1,eval)(result);else if(dataType=='xml')result=xhr.responseXML;else if(dataType=='json')result=blankRE.test(result)?null:$.parseJSON(result);}catch(e){error=e;}if(error)return ajaxError(error,'parsererror',xhr,settings,deferred);}ajaxSuccess(result,xhr,settings,deferred);}else{ajaxError(xhr.statusText||null,xhr.status?'error':'abort',xhr,settings,deferred);}}};if(ajaxBeforeSend(xhr,settings)===false){xhr.abort();ajaxError(null,'abort',xhr,settings,deferred);return xhr;}var async='async'in settings?settings.async:true;xhr.open(settings.type,settings.url,async,settings.username,settings.password);if(settings.xhrFields)for(name in settings.xhrFields)xhr[name]=settings.xhrFields[name];for(name in headers)nativeSetHeader.apply(xhr,headers[name]);if(settings.timeout>0)abortTimeout=setTimeout(function(){xhr.onreadystatechange=empty;xhr.abort();ajaxError(null,'timeout',xhr,settings,deferred);},settings.timeout);// avoid sending empty string (#319)
xhr.send(settings.data?settings.data:null);return xhr;};// handle optional data/success arguments
function parseArguments(url,data,success,dataType){if($.isFunction(data))dataType=success,success=data,data=undefined;if(!$.isFunction(success))dataType=success,success=undefined;return{url:url,data:data,success:success,dataType:dataType};}$.get=function()/* url, data, success, dataType */{return $.ajax(parseArguments.apply(null,arguments));};$.post=function()/* url, data, success, dataType */{var options=parseArguments.apply(null,arguments);options.type='POST';return $.ajax(options);};$.getJSON=function()/* url, data, success */{var options=parseArguments.apply(null,arguments);options.dataType='json';return $.ajax(options);};$.fn.load=function(url,data,success){if(!this.length)return this;var self=this,parts=url.split(/\s/),selector,options=parseArguments(url,data,success),callback=options.success;if(parts.length>1)options.url=parts[0],selector=parts[1];options.success=function(response){self.html(selector?$('<div>').html(response.replace(rscript,"")).find(selector):response);callback&&callback.apply(self,arguments);};$.ajax(options);return this;};var escape=encodeURIComponent;function serialize(params,obj,traditional,scope){var type,array=$.isArray(obj),hash=$.isPlainObject(obj);$.each(obj,function(key,value){type=$.type(value);if(scope)key=traditional?scope:scope+'['+(hash||type=='object'||type=='array'?key:'')+']';// handle data in serializeArray() format
if(!scope&&array)params.add(value.name,value.value);// recurse into nested objects
else if(type=="array"||!traditional&&type=="object")serialize(params,value,traditional,key);else params.add(key,value);});}$.param=function(obj,traditional){var params=[];params.add=function(key,value){if($.isFunction(value))value=value();if(value==null)value="";this.push(escape(key)+'='+escape(value));};serialize(params,obj,traditional);return params.join('&').replace(/%20/g,'+');};})(Zepto);(function($){// Create a collection of callbacks to be fired in a sequence, with configurable behaviour
// Option flags:
//   - once: Callbacks fired at most one time.
//   - memory: Remember the most recent context and arguments
//   - stopOnFalse: Cease iterating over callback list
//   - unique: Permit adding at most one instance of the same callback
$.Callbacks=function(options){options=$.extend({},options);var memory,// Last fire value (for non-forgettable lists)
fired,// Flag to know if list was already fired
firing,// Flag to know if list is currently firing
firingStart,// First callback to fire (used internally by add and fireWith)
firingLength,// End of the loop when firing
firingIndex,// Index of currently firing callback (modified by remove if needed)
list=[],// Actual callback list
stack=!options.once&&[],// Stack of fire calls for repeatable lists
fire=function(data){memory=options.memory&&data;fired=true;firingIndex=firingStart||0;firingStart=0;firingLength=list.length;firing=true;for(;list&&firingIndex<firingLength;++firingIndex){if(list[firingIndex].apply(data[0],data[1])===false&&options.stopOnFalse){memory=false;break;}}firing=false;if(list){if(stack)stack.length&&fire(stack.shift());else if(memory)list.length=0;else Callbacks.disable();}},Callbacks={add:function(){if(list){var start=list.length,add=function(args){$.each(args,function(_,arg){if(typeof arg==="function"){if(!options.unique||!Callbacks.has(arg))list.push(arg);}else if(arg&&arg.length&&typeof arg!=='string')add(arg);});};add(arguments);if(firing)firingLength=list.length;else if(memory){firingStart=start;fire(memory);}}return this;},remove:function(){if(list){$.each(arguments,function(_,arg){var index;while((index=$.inArray(arg,list,index))>-1){list.splice(index,1);// Handle firing indexes
if(firing){if(index<=firingLength)--firingLength;if(index<=firingIndex)--firingIndex;}}});}return this;},has:function(fn){return!!(list&&(fn?$.inArray(fn,list)>-1:list.length));},empty:function(){firingLength=list.length=0;return this;},disable:function(){list=stack=memory=undefined;return this;},disabled:function(){return!list;},lock:function(){stack=undefined;if(!memory)Callbacks.disable();return this;},locked:function(){return!stack;},fireWith:function(context,args){if(list&&(!fired||stack)){args=args||[];args=[context,args.slice?args.slice():args];if(firing)stack.push(args);else fire(args);}return this;},fire:function(){return Callbacks.fireWith(this,arguments);},fired:function(){return!!fired;}};return Callbacks;};})(Zepto);(function($){var slice=Array.prototype.slice;function Deferred(func){var tuples=[// action, add listener, listener list, final state
["resolve","done",$.Callbacks({once:1,memory:1}),"resolved"],["reject","fail",$.Callbacks({once:1,memory:1}),"rejected"],["notify","progress",$.Callbacks({memory:1})]],state="pending",promise={state:function(){return state;},always:function(){deferred.done(arguments).fail(arguments);return this;},then:function()/* fnDone [, fnFailed [, fnProgress]] */{var fns=arguments;return Deferred(function(defer){$.each(tuples,function(i,tuple){var fn=$.isFunction(fns[i])&&fns[i];deferred[tuple[1]](function(){var returned=fn&&fn.apply(this,arguments);if(returned&&$.isFunction(returned.promise)){returned.promise().done(defer.resolve).fail(defer.reject).progress(defer.notify);}else{var context=this===promise?defer.promise():this,values=fn?[returned]:arguments;defer[tuple[0]+"With"](context,values);}});});fns=null;}).promise();},promise:function(obj){return obj!=null?$.extend(obj,promise):promise;}},deferred={};$.each(tuples,function(i,tuple){var list=tuple[2],stateString=tuple[3];promise[tuple[1]]=list.add;if(stateString){list.add(function(){state=stateString;},tuples[i^1][2].disable,tuples[2][2].lock);}deferred[tuple[0]]=function(){deferred[tuple[0]+"With"](this===deferred?promise:this,arguments);return this;};deferred[tuple[0]+"With"]=list.fireWith;});promise.promise(deferred);if(func)func.call(deferred,deferred);return deferred;}$.when=function(sub){var resolveValues=slice.call(arguments),len=resolveValues.length,i=0,remain=len!==1||sub&&$.isFunction(sub.promise)?len:0,deferred=remain===1?sub:Deferred(),progressValues,progressContexts,resolveContexts,updateFn=function(i,ctx,val){return function(value){ctx[i]=this;val[i]=arguments.length>1?slice.call(arguments):value;if(val===progressValues){deferred.notifyWith(ctx,val);}else if(! --remain){deferred.resolveWith(ctx,val);}};};if(len>1){progressValues=new Array(len);progressContexts=new Array(len);resolveContexts=new Array(len);for(;i<len;++i){if(resolveValues[i]&&$.isFunction(resolveValues[i].promise)){resolveValues[i].promise().done(updateFn(i,resolveContexts,resolveValues)).fail(deferred.reject).progress(updateFn(i,progressContexts,progressValues));}else{--remain;}}}if(!remain)deferred.resolveWith(resolveContexts,resolveValues);return deferred.promise();};$.Deferred=Deferred;})(Zepto);(function($){var _zid=1,undefined,slice=Array.prototype.slice,isFunction=$.isFunction,isString=function(obj){return typeof obj=='string';},handlers={},specialEvents={},focusinSupported='onfocusin'in window,focus={focus:'focusin',blur:'focusout'},hover={mouseenter:'mouseover',mouseleave:'mouseout'};specialEvents.click=specialEvents.mousedown=specialEvents.mouseup=specialEvents.mousemove='MouseEvents';function zid(element){return element._zid||(element._zid=_zid++);}function findHandlers(element,event,fn,selector){event=parse(event);if(event.ns)var matcher=matcherFor(event.ns);return(handlers[zid(element)]||[]).filter(function(handler){return handler&&(!event.e||handler.e==event.e)&&(!event.ns||matcher.test(handler.ns))&&(!fn||zid(handler.fn)===zid(fn))&&(!selector||handler.sel==selector);});}function parse(event){var parts=(''+event).split('.');return{e:parts[0],ns:parts.slice(1).sort().join(' ')};}function matcherFor(ns){return new RegExp('(?:^| )'+ns.replace(' ',' .* ?')+'(?: |$)');}function eventCapture(handler,captureSetting){return handler.del&&!focusinSupported&&handler.e in focus||!!captureSetting;}function realEvent(type){return hover[type]||focusinSupported&&focus[type]||type;}function add(element,events,fn,data,selector,delegator,capture){var id=zid(element),set=handlers[id]||(handlers[id]=[]);events.split(/\s/).forEach(function(event){if(event=='ready')return $(document).ready(fn);var handler=parse(event);handler.fn=fn;handler.sel=selector;// emulate mouseenter, mouseleave
if(handler.e in hover)fn=function(e){var related=e.relatedTarget;if(!related||related!==this&&!$.contains(this,related))return handler.fn.apply(this,arguments);};handler.del=delegator;var callback=delegator||fn;handler.proxy=function(e){e=compatible(e);if(e.isImmediatePropagationStopped())return;e.data=data;var result=callback.apply(element,e._args==undefined?[e]:[e].concat(e._args));if(result===false)e.preventDefault(),e.stopPropagation();return result;};handler.i=set.length;set.push(handler);if('addEventListener'in element)element.addEventListener(realEvent(handler.e),handler.proxy,eventCapture(handler,capture));});}function remove(element,events,fn,selector,capture){var id=zid(element);(events||'').split(/\s/).forEach(function(event){findHandlers(element,event,fn,selector).forEach(function(handler){delete handlers[id][handler.i];if('removeEventListener'in element)element.removeEventListener(realEvent(handler.e),handler.proxy,eventCapture(handler,capture));});});}$.event={add:add,remove:remove};$.proxy=function(fn,context){var args=2 in arguments&&slice.call(arguments,2);if(isFunction(fn)){var proxyFn=function(){return fn.apply(context,args?args.concat(slice.call(arguments)):arguments);};proxyFn._zid=zid(fn);return proxyFn;}else if(isString(context)){if(args){args.unshift(fn[context],fn);return $.proxy.apply(null,args);}else{return $.proxy(fn[context],fn);}}else{throw new TypeError("expected function");}};$.fn.bind=function(event,data,callback){return this.on(event,data,callback);};$.fn.unbind=function(event,callback){return this.off(event,callback);};$.fn.one=function(event,selector,data,callback){return this.on(event,selector,data,callback,1);};var returnTrue=function(){return true;},returnFalse=function(){return false;},ignoreProperties=/^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,eventMethods={preventDefault:'isDefaultPrevented',stopImmediatePropagation:'isImmediatePropagationStopped',stopPropagation:'isPropagationStopped'};function compatible(event,source){if(source||!event.isDefaultPrevented){source||(source=event);$.each(eventMethods,function(name,predicate){var sourceMethod=source[name];event[name]=function(){this[predicate]=returnTrue;return sourceMethod&&sourceMethod.apply(source,arguments);};event[predicate]=returnFalse;});event.timeStamp||(event.timeStamp=Date.now());if(source.defaultPrevented!==undefined?source.defaultPrevented:'returnValue'in source?source.returnValue===false:source.getPreventDefault&&source.getPreventDefault())event.isDefaultPrevented=returnTrue;}return event;}function createProxy(event){var key,proxy={originalEvent:event};for(key in event)if(!ignoreProperties.test(key)&&event[key]!==undefined)proxy[key]=event[key];return compatible(proxy,event);}$.fn.delegate=function(selector,event,callback){return this.on(event,selector,callback);};$.fn.undelegate=function(selector,event,callback){return this.off(event,selector,callback);};$.fn.live=function(event,callback){$(document.body).delegate(this.selector,event,callback);return this;};$.fn.die=function(event,callback){$(document.body).undelegate(this.selector,event,callback);return this;};$.fn.on=function(event,selector,data,callback,one){var autoRemove,delegator,$this=this;if(event&&!isString(event)){$.each(event,function(type,fn){$this.on(type,selector,data,fn,one);});return $this;}if(!isString(selector)&&!isFunction(callback)&&callback!==false)callback=data,data=selector,selector=undefined;if(callback===undefined||data===false)callback=data,data=undefined;if(callback===false)callback=returnFalse;return $this.each(function(_,element){if(one)autoRemove=function(e){remove(element,e.type,callback);return callback.apply(this,arguments);};if(selector)delegator=function(e){var evt,match=$(e.target).closest(selector,element).get(0);if(match&&match!==element){evt=$.extend(createProxy(e),{currentTarget:match,liveFired:element});return(autoRemove||callback).apply(match,[evt].concat(slice.call(arguments,1)));}};add(element,event,callback,data,selector,delegator||autoRemove);});};$.fn.off=function(event,selector,callback){var $this=this;if(event&&!isString(event)){$.each(event,function(type,fn){$this.off(type,selector,fn);});return $this;}if(!isString(selector)&&!isFunction(callback)&&callback!==false)callback=selector,selector=undefined;if(callback===false)callback=returnFalse;return $this.each(function(){remove(this,event,callback,selector);});};$.fn.trigger=function(event,args){event=isString(event)||$.isPlainObject(event)?$.Event(event):compatible(event);event._args=args;return this.each(function(){// handle focus(), blur() by calling them directly
if(event.type in focus&&typeof this[event.type]=="function")this[event.type]();// items in the collection might not be DOM elements
else if('dispatchEvent'in this)this.dispatchEvent(event);else $(this).triggerHandler(event,args);});};// triggers event handlers on current element just as if an event occurred,
// doesn't trigger an actual event, doesn't bubble
$.fn.triggerHandler=function(event,args){var e,result;this.each(function(i,element){e=createProxy(isString(event)?$.Event(event):event);e._args=args;e.target=element;$.each(findHandlers(element,event.type||event),function(i,handler){result=handler.proxy(e);if(e.isImmediatePropagationStopped())return false;});});return result;}// shortcut methods for `.bind(event, fn)` for each event type
;('focusin focusout focus blur load resize scroll unload click dblclick '+'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+'change select keydown keypress keyup error').split(' ').forEach(function(event){$.fn[event]=function(callback){return 0 in arguments?this.bind(event,callback):this.trigger(event);};});$.Event=function(type,props){if(!isString(type))props=type,type=props.type;var event=document.createEvent(specialEvents[type]||'Events'),bubbles=true;if(props)for(var name in props)name=='bubbles'?bubbles=!!props[name]:event[name]=props[name];event.initEvent(type,bubbles,true);return compatible(event);};})(Zepto);(function(){// getComputedStyle shouldn't freak out when called
// without a valid element as argument
try{getComputedStyle(undefined);}catch(e){var nativeGetComputedStyle=getComputedStyle;window.getComputedStyle=function(element,pseudoElement){try{return nativeGetComputedStyle(element,pseudoElement);}catch(e){return null;}};}})();(function($){var zepto=$.zepto,oldQsa=zepto.qsa,oldMatches=zepto.matches;function visible(elem){elem=$(elem);return!!(elem.width()||elem.height())&&elem.css("display")!=="none";}// Implements a subset from:
// http://api.jquery.com/category/selectors/jquery-selector-extensions/
//
// Each filter function receives the current index, all nodes in the
// considered set, and a value if there were parentheses. The value
// of `this` is the node currently being considered. The function returns the
// resulting node(s), null, or undefined.
//
// Complex selectors are not supported:
//   li:has(label:contains("foo")) + li:has(label:contains("bar"))
//   ul.inner:first > li
var filters=$.expr[':']={visible:function(){if(visible(this))return this;},hidden:function(){if(!visible(this))return this;},selected:function(){if(this.selected)return this;},checked:function(){if(this.checked)return this;},parent:function(){return this.parentNode;},first:function(idx){if(idx===0)return this;},last:function(idx,nodes){if(idx===nodes.length-1)return this;},eq:function(idx,_,value){if(idx===value)return this;},contains:function(idx,_,text){if($(this).text().indexOf(text)>-1)return this;},has:function(idx,_,sel){if(zepto.qsa(this,sel).length)return this;}};var filterRe=new RegExp('(.*):(\\w+)(?:\\(([^)]+)\\))?$\\s*'),childRe=/^\s*>/,classTag='Zepto'+ +new Date();function process(sel,fn){// quote the hash in `a[href^=#]` expression
sel=sel.replace(/=#\]/g,'="#"]');var filter,arg,match=filterRe.exec(sel);if(match&&match[2]in filters){filter=filters[match[2]],arg=match[3];sel=match[1];if(arg){var num=Number(arg);if(isNaN(num))arg=arg.replace(/^["']|["']$/g,'');else arg=num;}}return fn(sel,filter,arg);}zepto.qsa=function(node,selector){return process(selector,function(sel,filter,arg){try{var taggedParent;if(!sel&&filter)sel='*';else if(childRe.test(sel))// support "> *" child queries by tagging the parent node with a
// unique class and prepending that classname onto the selector
taggedParent=$(node).addClass(classTag),sel='.'+classTag+' '+sel;var nodes=oldQsa(node,sel);}catch(e){console.error('error performing selector: %o',selector);throw e;}finally{if(taggedParent)taggedParent.removeClass(classTag);}return!filter?nodes:zepto.uniq($.map(nodes,function(n,i){return filter.call(n,i,nodes,arg);}));});};zepto.matches=function(node,selector){return process(selector,function(sel,filter,arg){return(!sel||oldMatches(node,sel))&&(!filter||filter.call(node,null,arg)===node);});};})(Zepto);module.exports=Zepto;/***/},/* 7 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var Styler={getStyleFor:function getStyleFor(style){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{baseUrl:''};return(0,_clapprZepto2.default)('<style class="clappr-style"></style>').html((0,_template2.default)(style.toString())(options));}};exports.default=Styler;module.exports=exports['default'];/***/},/* 8 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});/* eslint-disable no-var */// Simple JavaScript Templating
// Paul Miller (http://paulmillr.com)
// http://underscorejs.org
// (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
// By default, Underscore uses ERB-style template delimiters, change the
// following template settings to use alternative delimiters.
var settings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};// When customizing `templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch=/(.)^/;// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes={'\'':'\'','\\':'\\','\r':'r','\n':'n','\t':'t','\u2028':'u2028','\u2029':'u2029'};var escaper=/\\|'|\r|\n|\t|\u2028|\u2029/g;// List of HTML entities for escaping.
var htmlEntities={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#x27;'};var entityRe=new RegExp('[&<>"\']','g');var escapeExpr=function escapeExpr(string){if(string===null){return'';}return(''+string).replace(entityRe,function(match){return htmlEntities[match];});};var counter=0;// JavaScript micro-templating, similar to John Resig's implementation.
// Underscore templating handles arbitrary delimiters, preserves whitespace,
// and correctly escapes quotes within interpolated code.
var tmpl=function tmpl(text,data){var render;// Combine delimiters into one regular expression via alternation.
var matcher=new RegExp([(settings.escape||noMatch).source,(settings.interpolate||noMatch).source,(settings.evaluate||noMatch).source].join('|')+'|$','g');// Compile the template source, escaping string literals appropriately.
var index=0;var source='__p+=\'';text.replace(matcher,function(match,escape,interpolate,evaluate,offset){source+=text.slice(index,offset).replace(escaper,function(match){return'\\'+escapes[match];});if(escape){source+='\'+\n((__t=('+escape+'))==null?\'\':escapeExpr(__t))+\n\'';}if(interpolate){source+='\'+\n((__t=('+interpolate+'))==null?\'\':__t)+\n\'';}if(evaluate){source+='\';\n'+evaluate+'\n__p+=\'';}index=offset+match.length;return match;});source+='\';\n';// If a variable is not specified, place data values in local scope.
if(!settings.variable){source='with(obj||{}){\n'+source+'}\n';}source='var __t,__p=\'\',__j=Array.prototype.join,'+'print=function(){__p+=__j.call(arguments,\'\');};\n'+source+'return __p;\n//# sourceURL=/microtemplates/source['+counter++ +']';try{/*jshint -W054 */// TODO: find a way to avoid eval
render=new Function(settings.variable||'obj','escapeExpr',source);}catch(e){e.source=source;throw e;}if(data){return render(data,escapeExpr);}var template=function template(data){return render.call(this,data,escapeExpr);};// Provide the compiled function source as a convenience for precompilation.
template.source='function('+(settings.variable||'obj')+'){\n'+source+'}';return template;};tmpl.settings=settings;exports.default=tmpl;module.exports=exports['default'];/***/},/* 9 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _utils=__webpack_require__(5);var _ui_object=__webpack_require__(21);var _ui_object2=_interopRequireDefault(_ui_object);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * An abstraction to represent a generic playback, it's like an interface to be implemented by subclasses.
 * @class Playback
 * @constructor
 * @extends UIObject
 * @module base
 */var Playback=function(_UIObject){(0,_inherits3.default)(Playback,_UIObject);(0,_createClass3.default)(Playback,[{key:'isAudioOnly',/**
    * Determine if the playback does not contain video/has video but video should be ignored.
    * @property isAudioOnly
    * @type Boolean
    */get:function get(){return false;}/**
     * Determine if the playback has ended.
     * @property ended
     * @type Boolean
     */},{key:'ended',get:function get(){return false;}/**
     * The internationalization plugin.
     * @property i18n
     * @type {Strings}
     */},{key:'i18n',get:function get(){return this._i18n;}/**
     * Determine if the playback is having to buffer in order for
     * playback to be smooth.
     * (i.e if a live stream is playing smoothly, this will be false)
     * @property buffering
     * @type Boolean
     */},{key:'buffering',get:function get(){return false;}/**
     * @method constructor
     * @param {Object} options the options object
     * @param {Strings} i18n the internationalization component
     */}]);function Playback(options,i18n){(0,_classCallCheck3.default)(this,Playback);var _this=(0,_possibleConstructorReturn3.default)(this,_UIObject.call(this,options));_this.settings={};_this._i18n=i18n;return _this;}/**
   * Gives user consent to playback (mobile devices).
   * @method consent
   */Playback.prototype.consent=function consent(){};/**
   * plays the playback.
   * @method play
   */Playback.prototype.play=function play(){};/**
   * pauses the playback.
   * @method pause
   */Playback.prototype.pause=function pause(){};/**
   * stops the playback.
   * @method stop
   */Playback.prototype.stop=function stop(){};/**
   * seeks the playback to a given `time` in seconds
   * @method seek
   * @param {Number} time should be a number between 0 and the video duration
   */Playback.prototype.seek=function seek(time){};// eslint-disable-line no-unused-vars
/**
   * seeks the playback to a given `percentage` in percentage
   * @method seekPercentage
   * @param {Number} time should be a number between 0 and 100
   */Playback.prototype.seekPercentage=function seekPercentage(percentage){};// eslint-disable-line no-unused-vars
/**
   * The time that "0" now represents relative to when playback started.
   * For a stream with a sliding window this will increase as content is
   * removed from the beginning.
   * @method getStartTimeOffset
   * @return {Number} time (in seconds) that time "0" represents.
   */Playback.prototype.getStartTimeOffset=function getStartTimeOffset(){return 0;};/**
   * gets the duration in seconds
   * @method getDuration
   * @return {Number} duration (in seconds) of the current source
   */Playback.prototype.getDuration=function getDuration(){return 0;};/**
   * checks if the playback is playing.
   * @method isPlaying
   * @return {Boolean} `true` if the current playback is playing, otherwise `false`
   */Playback.prototype.isPlaying=function isPlaying(){return false;};/**
   * checks if the playback is ready.
   * @property isReady
   * @type {Boolean} `true` if the current playback is ready, otherwise `false`
   */// eslint-disable-line no-unused-vars
/**
   * gets the playback type (`'vod', 'live', 'aod'`)
   * @method getPlaybackType
   * @return {String} you should write the playback type otherwise it'll assume `'no_op'`
   * @example
   * ```javascript
   * html5VideoPlayback.getPlaybackType() //vod
   * html5AudioPlayback.getPlaybackType() //aod
   * html5VideoPlayback.getPlaybackType() //live
   * flashHlsPlayback.getPlaybackType() //live
   * ```
   */Playback.prototype.getPlaybackType=function getPlaybackType(){return Playback.NO_OP;};/**
   * checks if the playback is in HD.
   * @method isHighDefinitionInUse
   * @return {Boolean} `true` if the playback is playing in HD, otherwise `false`
   */Playback.prototype.isHighDefinitionInUse=function isHighDefinitionInUse(){return false;};/**
   * sets the volume for the playback
   * @method volume
   * @param {Number} value a number between 0 (`muted`) to 100 (`max`)
   */Playback.prototype.volume=function volume(value){};// eslint-disable-line no-unused-vars
/**
   * destroys the playback, removing it from DOM
   * @method destroy
   */Playback.prototype.destroy=function destroy(){this.$el.remove();};(0,_createClass3.default)(Playback,[{key:'isReady',get:function get(){return false;}/**
     * checks if the playback has closed caption tracks.
     * @property hasClosedCaptionsTracks
     * @type {Boolean}
     */},{key:'hasClosedCaptionsTracks',get:function get(){return this.closedCaptionsTracks.length>0;}/**
     * gets the playback available closed caption tracks.
     * @property closedCaptionsTracks
     * @type {Array} an array of objects with at least 'id' and 'name' properties
     */},{key:'closedCaptionsTracks',get:function get(){return[];}/**
     * gets the selected closed caption track index. (-1 is disabled)
     * @property closedCaptionsTrackId
     * @type {Number}
     */},{key:'closedCaptionsTrackId',get:function get(){return-1;}/**
     * sets the selected closed caption track index. (-1 is disabled)
     * @property closedCaptionsTrackId
     * @type {Number}
     */,set:function set(trackId){}}]);return Playback;}(_ui_object2.default);exports.default=Playback;Playback.extend=function(properties){return(0,_utils.extend)(Playback,properties);};/**
 * checks if the playback can play a given `source`
 * If a mimeType is provided then this will be used instead of inferring the mimetype
 * from the source extension.
 * @method canPlay
 * @static
 * @param {String} source the given source ex: `http://example.com/play.mp4`
 * @param {String} [mimeType] the given mime type, ex: `'application/vnd.apple.mpegurl'`
 * @return {Boolean} `true` if the playback is playable, otherwise `false`
 */Playback.canPlay=function(source,mimeType){// eslint-disable-line no-unused-vars
return false;};/**
 * a playback type for video on demand
 *
 * @property VOD
 * @static
 * @type String
 */Playback.VOD='vod';/**
 * a playback type for audio on demand
 *
 * @property AOD
 * @static
 * @type String
 */Playback.AOD='aod';/**
 * a playback type for live video
 *
 * @property LIVE
 * @static
 * @type String
 */Playback.LIVE='live';/**
 * a default playback type
 *
 * @property NO_OP
 * @static
 * @type String
 */Playback.NO_OP='no_op';/**
 * the plugin type
 *
 * @property type
 * @static
 * @type String
 */Playback.type='playback';module.exports=exports['default'];/***/},/* 10 *//***/function(module,exports){/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/// css base code, injected by the css-loader
module.exports=function(useSourceMap){var list=[];// return the list of modules as css string
list.toString=function toString(){return this.map(function(item){var content=cssWithMappingToString(item,useSourceMap);if(item[2]){return"@media "+item[2]+"{"+content+"}";}else{return content;}}).join("");};// import a list of modules into the list
list.i=function(modules,mediaQuery){if(typeof modules==="string")modules=[[null,modules,""]];var alreadyImportedModules={};for(var i=0;i<this.length;i++){var id=this[i][0];if(typeof id==="number")alreadyImportedModules[id]=true;}for(i=0;i<modules.length;i++){var item=modules[i];// skip already imported module
// this implementation is not 100% perfect for weird media query combinations
//  when a module is imported multiple times with different media queries.
//  I hope this will never occur (Hey this way we have smaller bundles)
if(typeof item[0]!=="number"||!alreadyImportedModules[item[0]]){if(mediaQuery&&!item[2]){item[2]=mediaQuery;}else if(mediaQuery){item[2]="("+item[2]+") and ("+mediaQuery+")";}list.push(item);}}};return list;};function cssWithMappingToString(item,useSourceMap){var content=item[1]||'';var cssMapping=item[3];if(!cssMapping){return content;}if(useSourceMap&&typeof btoa==='function'){var sourceMapping=toComment(cssMapping);var sourceURLs=cssMapping.sources.map(function(source){return'/*# sourceURL='+cssMapping.sourceRoot+source+' */';});return[content].concat(sourceURLs).concat([sourceMapping]).join('\n');}return[content].join('\n');}// Adapted from convert-source-map (MIT)
function toComment(sourceMap){// eslint-disable-next-line no-undef
var base64=btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));var data='sourceMappingURL=data:application/json;charset=utf-8;base64,'+base64;return'/*# '+data+' */';}/***/},/* 11 *//***/function(module,exports){var core=module.exports={version:'2.4.0'};if(typeof __e=='number')__e=core;// eslint-disable-line no-undef
/***/},/* 12 *//***/function(module,exports,__webpack_require__){var store=__webpack_require__(44)('wks'),uid=__webpack_require__(32),Symbol=__webpack_require__(15).Symbol,USE_SYMBOL=typeof Symbol=='function';var $exports=module.exports=function(name){return store[name]||(store[name]=USE_SYMBOL&&Symbol[name]||(USE_SYMBOL?Symbol:uid)('Symbol.'+name));};$exports.store=store;/***/},/* 13 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var Browser={};var hasLocalstorage=function hasLocalstorage(){try{localStorage.setItem('clappr','clappr');localStorage.removeItem('clappr');return true;}catch(e){return false;}};var hasFlash=function hasFlash(){try{var fo=new ActiveXObject('ShockwaveFlash.ShockwaveFlash');return!!fo;}catch(e){return!!(navigator.mimeTypes&&navigator.mimeTypes['application/x-shockwave-flash']!==undefined&&navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin);}};var getBrowserInfo=function getBrowserInfo(){var ua=navigator.userAgent;var parts=ua.match(/\b(playstation 4|nx|opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i)||[],extra=void 0;if(/trident/i.test(parts[1])){extra=/\brv[ :]+(\d+)/g.exec(ua)||[];return{name:'IE',version:parseInt(extra[1]||'')};}else if(parts[1]==='Chrome'){extra=ua.match(/\bOPR\/(\d+)/);if(extra!=null){return{name:'Opera',version:parseInt(extra[1])};}extra=ua.match(/\bEdge\/(\d+)/);if(extra!=null){return{name:'Edge',version:parseInt(extra[1])};}}parts=parts[2]?[parts[1],parts[2]]:[navigator.appName,navigator.appVersion,'-?'];if(extra=ua.match(/version\/(\d+)/i)){parts.splice(1,1,extra[1]);}return{name:parts[0],version:parseInt(parts[1])};};var browserInfo=getBrowserInfo();Browser.isEdge=/edge/i.test(navigator.userAgent);Browser.isChrome=/chrome|CriOS/i.test(navigator.userAgent)&&!Browser.isEdge;Browser.isSafari=/safari/i.test(navigator.userAgent)&&!Browser.isChrome&&!Browser.isEdge;Browser.isFirefox=/firefox/i.test(navigator.userAgent);Browser.isLegacyIE=!!window.ActiveXObject;Browser.isIE=Browser.isLegacyIE||/trident.*rv:1\d/i.test(navigator.userAgent);Browser.isIE11=/trident.*rv:11/i.test(navigator.userAgent);Browser.isChromecast=Browser.isChrome&&/CrKey/i.test(navigator.userAgent);Browser.isMobile=/Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone|IEMobile|Mobile Safari|Opera Mini/i.test(navigator.userAgent);Browser.isiOS=/iPad|iPhone|iPod/i.test(navigator.userAgent);Browser.isAndroid=/Android/i.test(navigator.userAgent);Browser.isWindowsPhone=/Windows Phone/i.test(navigator.userAgent);Browser.isWin8App=/MSAppHost/i.test(navigator.userAgent);Browser.isWiiU=/WiiU/i.test(navigator.userAgent);Browser.isPS4=/PlayStation 4/i.test(navigator.userAgent);Browser.hasLocalstorage=hasLocalstorage();Browser.hasFlash=hasFlash();Browser.name=browserInfo.name;Browser.version=browserInfo.version;exports.default=Browser;module.exports=exports['default'];/***/},/* 14 *//***/function(module,exports,__webpack_require__){// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject=__webpack_require__(91),defined=__webpack_require__(40);module.exports=function(it){return IObject(defined(it));};/***/},/* 15 *//***/function(module,exports){// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global=module.exports=typeof window!='undefined'&&window.Math==Math?window:typeof self!='undefined'&&self.Math==Math?self:Function('return this')();if(typeof __g=='number')__g=global;// eslint-disable-line no-undef
/***/},/* 16 *//***/function(module,exports,__webpack_require__){var anObject=__webpack_require__(23),IE8_DOM_DEFINE=__webpack_require__(63),toPrimitive=__webpack_require__(47),dP=Object.defineProperty;exports.f=__webpack_require__(20)?Object.defineProperty:function defineProperty(O,P,Attributes){anObject(O);P=toPrimitive(P,true);anObject(Attributes);if(IE8_DOM_DEFINE)try{return dP(O,P,Attributes);}catch(e){/* empty */}if('get'in Attributes||'set'in Attributes)throw TypeError('Accessors not supported!');if('value'in Attributes)O[P]=Attributes.value;return O;};/***/},/* 17 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _utils=__webpack_require__(5);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * @class BaseObject
 * @constructor
 * @extends Events
 * @module base
 */// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var BaseObject=function(_Events){(0,_inherits3.default)(BaseObject,_Events);(0,_createClass3.default)(BaseObject,[{key:'options',/**
     * returns the object options
     * @property options
     * @type Object
     */get:function get(){return this._options;}/**
     * @method constructor
     * @param {Object} options
     */}]);function BaseObject(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};(0,_classCallCheck3.default)(this,BaseObject);var _this=(0,_possibleConstructorReturn3.default)(this,_Events.call(this,options));_this._options=options;_this.uniqueId=(0,_utils.uniqueId)('o');return _this;}/**
  * a unique id prefixed with `'o'`, `o1, o232`
  *
  * @property uniqueId
  * @type String
  */return BaseObject;}(_events2.default);exports.default=BaseObject;module.exports=exports['default'];/***/},/* 18 *//***/function(module,exports){var hasOwnProperty={}.hasOwnProperty;module.exports=function(it,key){return hasOwnProperty.call(it,key);};/***/},/* 19 *//***/function(module,exports,__webpack_require__){var global=__webpack_require__(15),core=__webpack_require__(11),ctx=__webpack_require__(46),hide=__webpack_require__(22),PROTOTYPE='prototype';var $export=function(type,name,source){var IS_FORCED=type&$export.F,IS_GLOBAL=type&$export.G,IS_STATIC=type&$export.S,IS_PROTO=type&$export.P,IS_BIND=type&$export.B,IS_WRAP=type&$export.W,exports=IS_GLOBAL?core:core[name]||(core[name]={}),expProto=exports[PROTOTYPE],target=IS_GLOBAL?global:IS_STATIC?global[name]:(global[name]||{})[PROTOTYPE],key,own,out;if(IS_GLOBAL)source=name;for(key in source){// contains in native
own=!IS_FORCED&&target&&target[key]!==undefined;if(own&&key in exports)continue;// export native or passed
out=own?target[key]:source[key];// prevent global pollution for namespaces
exports[key]=IS_GLOBAL&&typeof target[key]!='function'?source[key]// bind timers to global for call from export context
:IS_BIND&&own?ctx(out,global)// wrap global constructors for prevent change them in library
:IS_WRAP&&target[key]==out?function(C){var F=function(a,b,c){if(this instanceof C){switch(arguments.length){case 0:return new C();case 1:return new C(a);case 2:return new C(a,b);}return new C(a,b,c);}return C.apply(this,arguments);};F[PROTOTYPE]=C[PROTOTYPE];return F;// make static versions for prototype methods
}(out):IS_PROTO&&typeof out=='function'?ctx(Function.call,out):out;// export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
if(IS_PROTO){(exports.virtual||(exports.virtual={}))[key]=out;// export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
if(type&$export.R&&expProto&&!expProto[key])hide(expProto,key,out);}}};// type bitmap
$export.F=1;// forced
$export.G=2;// global
$export.S=4;// static
$export.P=8;// proto
$export.B=16;// bind
$export.W=32;// wrap
$export.U=64;// safe
$export.R=128;// real proto method for `library` 
module.exports=$export;/***/},/* 20 *//***/function(module,exports,__webpack_require__){// Thank's IE8 for his funny defineProperty
module.exports=!__webpack_require__(27)(function(){return Object.defineProperty({},'a',{get:function(){return 7;}}).a!=7;});/***/},/* 21 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);var _utils=__webpack_require__(5);var _base_object=__webpack_require__(17);var _base_object2=_interopRequireDefault(_base_object);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var delegateEventSplitter=/^(\S+)\s*(.*)$/;/**
 * A base class to create ui object.
 * @class UIObject
 * @constructor
 * @extends BaseObject
 * @module base
 */// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var UIObject=function(_BaseObject){(0,_inherits3.default)(UIObject,_BaseObject);(0,_createClass3.default)(UIObject,[{key:'tagName',/**
     * a unique id prefixed with `'c'`, `c1, c232`
     *
     * @property cid
     * @type String
     *//**
     * the dom element itself
     *
     * @property el
     * @type HTMLElement
     *//**
     * the dom element wrapped by `$`
     *
     * @property $el
     * @type HTMLElement
     *//**
     * gets the tag name for the ui component
     * @method tagName
     * @default div
     * @return {String} tag's name
     */get:function get(){return'div';}/**
     * a literal object mapping element's events to methods
     * @property events
     * @type Object
     * @example
     *
     *```javascript
     *
     * class MyButton extends UIObject {
     *   constructor(options) {
     *     super(options)
     *     this.myId = 0
     *   }
     *   get events() { return { 'click': 'myClick' } }
     *   myClick(){ this.myId = 42 }
     * }
     *
     * // when you click on MyButton the method `myClick` will be called
     *```
     */},{key:'events',get:function get(){return{};}/**
     * a literal object mapping attributes and values to the element
     * element's attribute name and the value the attribute value
     * @property attributes
     * @type Object
     * @example
     *
     *```javascript
     *
     * class MyButton extends UIObject {
     *    constructor(options) { super(options) }
     *    get attributes() { return { class: 'my-button'} }
     * }
     *
     * // MyButton.el.className will be 'my-button'
     * ```
     */},{key:'attributes',get:function get(){return{};}/**
     * it builds an ui component by:
     *  * creating an id for the component `cid`
     *  * making sure the element is created `$el`
     *  * delegating all `events` to the element
     * @method constructor
     * @param {Object} options the options object
     */}]);function UIObject(options){(0,_classCallCheck3.default)(this,UIObject);var _this=(0,_possibleConstructorReturn3.default)(this,_BaseObject.call(this,options));_this.cid=(0,_utils.uniqueId)('c');_this._ensureElement();_this.delegateEvents();return _this;}/**
   * selects within the component.
   * @method $
   * @param {String} selector a selector to find within the component.
   * @return {HTMLElement} an element, if it exists.
   * @example
   * ```javascript
   * fullScreenBarUIComponent.$('.button-full') //will return only `.button-full` within the component
   * ```
   */UIObject.prototype.$=function $(selector){return this.$el.find(selector);};/**
   * render the component, usually attach it to a real existent `element`
   * @method render
   * @return {UIObject} itself
   */UIObject.prototype.render=function render(){return this;};/**
   * removes the ui component from DOM
   * @method remove
   * @return {UIObject} itself
   */UIObject.prototype.remove=function remove(){this.$el.remove();this.stopListening();this.undelegateEvents();return this;};/**
   * set element to `el` and `$el`
   * @method setElement
   * @param {HTMLElement} element
   * @param {Boolean} delegate whether is delegate or not
   * @return {UIObject} itself
   */UIObject.prototype.setElement=function setElement(element,delegate){if(this.$el){this.undelegateEvents();}this.$el=element instanceof _clapprZepto2.default?element:(0,_clapprZepto2.default)(element);this.el=this.$el[0];if(delegate!==false){this.delegateEvents();}return this;};/**
   * delegates all the original `events` on `element` to its callbacks
   * @method delegateEvents
   * @param {Object} events
   * @return {UIObject} itself
   */UIObject.prototype.delegateEvents=function delegateEvents(events){if(!(events||(events=this.events))){return this;}this.undelegateEvents();for(var key in events){var method=events[key];if(method&&method.constructor!==Function){method=this[events[key]];}if(!method){continue;}var match=key.match(delegateEventSplitter);var eventName=match[1],selector=match[2];eventName+='.delegateEvents'+this.cid;if(selector===''){this.$el.on(eventName,method.bind(this));}else{this.$el.on(eventName,selector,method.bind(this));}}return this;};/**
   * undelegats all the `events`
   * @method undelegateEvents
   * @return {UIObject} itself
   */UIObject.prototype.undelegateEvents=function undelegateEvents(){this.$el.off('.delegateEvents'+this.cid);return this;};/**
   * ensures the creation of this ui component
   * @method _ensureElement
   * @private
   */UIObject.prototype._ensureElement=function _ensureElement(){if(!this.el){var attrs=_clapprZepto2.default.extend({},this.attributes);if(this.id){attrs.id=this.id;}if(this.className){attrs['class']=this.className;}var $el=_utils.DomRecycler.create(this.tagName).attr(attrs);this.setElement($el,false);}else{this.setElement(this.el,false);}};return UIObject;}(_base_object2.default);exports.default=UIObject;module.exports=exports['default'];/***/},/* 22 *//***/function(module,exports,__webpack_require__){var dP=__webpack_require__(16),createDesc=__webpack_require__(28);module.exports=__webpack_require__(20)?function(object,key,value){return dP.f(object,key,createDesc(1,value));}:function(object,key,value){object[key]=value;return object;};/***/},/* 23 *//***/function(module,exports,__webpack_require__){var isObject=__webpack_require__(26);module.exports=function(it){if(!isObject(it))throw TypeError(it+' is not an object!');return it;};/***/},/* 24 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var events=new _events2.default();// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
/**
 * The mediator is a singleton for handling global events.
 */var Mediator=function Mediator(){(0,_classCallCheck3.default)(this,Mediator);};exports.default=Mediator;Mediator.on=function(name,callback,context){events.on(name,callback,context);return;};Mediator.once=function(name,callback,context){events.once(name,callback,context);return;};Mediator.off=function(name,callback,context){events.off(name,callback,context);return;};Mediator.trigger=function(name){for(var _len=arguments.length,opts=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){opts[_key-1]=arguments[_key];}events.trigger.apply(events,[name].concat(opts));return;};Mediator.stopListening=function(obj,name,callback){events.stopListening(obj,name,callback);return;};module.exports=exports['default'];/***/},/* 25 *//***/function(module,exports,__webpack_require__){// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys=__webpack_require__(60),enumBugKeys=__webpack_require__(45);module.exports=Object.keys||function keys(O){return $keys(O,enumBugKeys);};/***/},/* 26 *//***/function(module,exports){module.exports=function(it){return typeof it==='object'?it!==null:typeof it==='function';};/***/},/* 27 *//***/function(module,exports){module.exports=function(exec){try{return!!exec();}catch(e){return true;}};/***/},/* 28 *//***/function(module,exports){module.exports=function(bitmap,value){return{enumerable:!(bitmap&1),configurable:!(bitmap&2),writable:!(bitmap&4),value:value};};/***/},/* 29 *//***/function(module,exports){module.exports={};/***/},/* 30 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _utils=__webpack_require__(5);var _base_object=__webpack_require__(17);var _base_object2=_interopRequireDefault(_base_object);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var CorePlugin=function(_BaseObject){(0,_inherits3.default)(CorePlugin,_BaseObject);function CorePlugin(core){(0,_classCallCheck3.default)(this,CorePlugin);var _this=(0,_possibleConstructorReturn3.default)(this,_BaseObject.call(this,core.options));_this.core=core;_this.enabled=true;_this.bindEvents();return _this;}CorePlugin.prototype.bindEvents=function bindEvents(){};CorePlugin.prototype.enable=function enable(){if(!this.enabled){this.bindEvents();this.enabled=true;}};CorePlugin.prototype.disable=function disable(){if(this.enabled){this.stopListening();this.enabled=false;}};CorePlugin.prototype.getExternalInterface=function getExternalInterface(){return{};};CorePlugin.prototype.destroy=function destroy(){this.stopListening();};return CorePlugin;}(_base_object2.default);exports.default=CorePlugin;CorePlugin.extend=function(properties){return(0,_utils.extend)(CorePlugin,properties);};CorePlugin.type='core';module.exports=exports['default'];/***/},/* 31 *//***/function(module,exports,__webpack_require__){module.exports={"default":__webpack_require__(89),__esModule:true};/***/},/* 32 *//***/function(module,exports){var id=0,px=Math.random();module.exports=function(key){return'Symbol('.concat(key===undefined?'':key,')_',(++id+px).toString(36));};/***/},/* 33 *//***/function(module,exports,__webpack_require__){"use strict";exports.__esModule=true;var _iterator=__webpack_require__(95);var _iterator2=_interopRequireDefault(_iterator);var _symbol=__webpack_require__(106);var _symbol2=_interopRequireDefault(_symbol);var _typeof=typeof _symbol2.default==="function"&&typeof _iterator2.default==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof _symbol2.default==="function"&&obj.constructor===_symbol2.default&&obj!==_symbol2.default.prototype?"symbol":typeof obj;};function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=typeof _symbol2.default==="function"&&_typeof(_iterator2.default)==="symbol"?function(obj){return typeof obj==="undefined"?"undefined":_typeof(obj);}:function(obj){return obj&&typeof _symbol2.default==="function"&&obj.constructor===_symbol2.default&&obj!==_symbol2.default.prototype?"symbol":typeof obj==="undefined"?"undefined":_typeof(obj);};/***/},/* 34 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var PlayerInfo=function PlayerInfo(){(0,_classCallCheck3.default)(this,PlayerInfo);this.options={};this.playbackPlugins=[];this.currentSize={width:0,height:0};};PlayerInfo._players={};PlayerInfo.getInstance=function(playerId){return PlayerInfo._players[playerId]||(PlayerInfo._players[playerId]=new PlayerInfo());};exports.default=PlayerInfo;module.exports=exports["default"];/***/},/* 35 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _html5_video=__webpack_require__(152);var _html5_video2=_interopRequireDefault(_html5_video);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_html5_video2.default;module.exports=exports['default'];/***/},/* 36 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _utils=__webpack_require__(5);var _ui_object=__webpack_require__(21);var _ui_object2=_interopRequireDefault(_ui_object);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * The base class for an ui container plugin
 * @class UIContainerPlugin
 * @constructor
 * @extends UIObject
 * @module base
 */// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var UIContainerPlugin=function(_UIObject){(0,_inherits3.default)(UIContainerPlugin,_UIObject);function UIContainerPlugin(container){(0,_classCallCheck3.default)(this,UIContainerPlugin);var _this=(0,_possibleConstructorReturn3.default)(this,_UIObject.call(this,container.options));_this.container=container;_this.enabled=true;_this.bindEvents();return _this;}UIContainerPlugin.prototype.enable=function enable(){if(!this.enabled){this.bindEvents();this.$el.show();this.enabled=true;}};UIContainerPlugin.prototype.disable=function disable(){this.stopListening();this.$el.hide();this.enabled=false;};UIContainerPlugin.prototype.bindEvents=function bindEvents(){};UIContainerPlugin.prototype.destroy=function destroy(){this.remove();};return UIContainerPlugin;}(_ui_object2.default);exports.default=UIContainerPlugin;UIContainerPlugin.extend=function(properties){return(0,_utils.extend)(UIContainerPlugin,properties);};UIContainerPlugin.type='container';module.exports=exports['default'];/***/},/* 37 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _base_object=__webpack_require__(17);var _base_object2=_interopRequireDefault(_base_object);var _utils=__webpack_require__(5);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * The base class for a container plugin
 * @class ContainerPlugin
 * @constructor
 * @extends UIObject
 * @module base
 */var ContainerPlugin=function(_BaseObject){(0,_inherits3.default)(ContainerPlugin,_BaseObject);function ContainerPlugin(container){(0,_classCallCheck3.default)(this,ContainerPlugin);var _this=(0,_possibleConstructorReturn3.default)(this,_BaseObject.call(this,container.options));_this.container=container;_this.enabled=true;_this.bindEvents();return _this;}ContainerPlugin.prototype.enable=function enable(){if(!this.enabled){this.bindEvents();this.enabled=true;}};ContainerPlugin.prototype.disable=function disable(){if(this.enabled){this.stopListening();this.enabled=false;}};ContainerPlugin.prototype.bindEvents=function bindEvents(){};ContainerPlugin.prototype.destroy=function destroy(){this.stopListening();};return ContainerPlugin;}(_base_object2.default);exports.default=ContainerPlugin;ContainerPlugin.extend=function(properties){return(0,_utils.extend)(ContainerPlugin,properties);};ContainerPlugin.type='container';module.exports=exports['default'];/***/},/* 38 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _utils=__webpack_require__(5);var _ui_object=__webpack_require__(21);var _ui_object2=_interopRequireDefault(_ui_object);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var UICorePlugin=function(_UIObject){(0,_inherits3.default)(UICorePlugin,_UIObject);function UICorePlugin(core){(0,_classCallCheck3.default)(this,UICorePlugin);var _this=(0,_possibleConstructorReturn3.default)(this,_UIObject.call(this,core.options));_this.core=core;_this.enabled=true;_this.bindEvents();_this.render();return _this;}UICorePlugin.prototype.bindEvents=function bindEvents(){};UICorePlugin.prototype.getExternalInterface=function getExternalInterface(){return{};};UICorePlugin.prototype.enable=function enable(){if(!this.enabled){this.bindEvents();this.$el.show();this.enabled=true;}};UICorePlugin.prototype.disable=function disable(){this.stopListening();this.$el.hide();this.enabled=false;};UICorePlugin.prototype.destroy=function destroy(){this.remove();};UICorePlugin.prototype.render=function render(){return this;};return UICorePlugin;}(_ui_object2.default);exports.default=UICorePlugin;UICorePlugin.extend=function(properties){return(0,_utils.extend)(UICorePlugin,properties);};UICorePlugin.type='core';module.exports=exports['default'];/***/},/* 39 *//***/function(module,exports,__webpack_require__){// 7.1.13 ToObject(argument)
var defined=__webpack_require__(40);module.exports=function(it){return Object(defined(it));};/***/},/* 40 *//***/function(module,exports){// 7.2.1 RequireObjectCoercible(argument)
module.exports=function(it){if(it==undefined)throw TypeError("Can't call method on  "+it);return it;};/***/},/* 41 *//***/function(module,exports){var toString={}.toString;module.exports=function(it){return toString.call(it).slice(8,-1);};/***/},/* 42 *//***/function(module,exports){// 7.1.4 ToInteger
var ceil=Math.ceil,floor=Math.floor;module.exports=function(it){return isNaN(it=+it)?0:(it>0?floor:ceil)(it);};/***/},/* 43 *//***/function(module,exports,__webpack_require__){var shared=__webpack_require__(44)('keys'),uid=__webpack_require__(32);module.exports=function(key){return shared[key]||(shared[key]=uid(key));};/***/},/* 44 *//***/function(module,exports,__webpack_require__){var global=__webpack_require__(15),SHARED='__core-js_shared__',store=global[SHARED]||(global[SHARED]={});module.exports=function(key){return store[key]||(store[key]={});};/***/},/* 45 *//***/function(module,exports){// IE 8- don't enum bug keys
module.exports='constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');/***/},/* 46 *//***/function(module,exports,__webpack_require__){// optional / simple context binding
var aFunction=__webpack_require__(94);module.exports=function(fn,that,length){aFunction(fn);if(that===undefined)return fn;switch(length){case 1:return function(a){return fn.call(that,a);};case 2:return function(a,b){return fn.call(that,a,b);};case 3:return function(a,b,c){return fn.call(that,a,b,c);};}return function()/* ...args */{return fn.apply(that,arguments);};};/***/},/* 47 *//***/function(module,exports,__webpack_require__){// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject=__webpack_require__(26);// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports=function(it,S){if(!isObject(it))return it;var fn,val;if(S&&typeof(fn=it.toString)=='function'&&!isObject(val=fn.call(it)))return val;if(typeof(fn=it.valueOf)=='function'&&!isObject(val=fn.call(it)))return val;if(!S&&typeof(fn=it.toString)=='function'&&!isObject(val=fn.call(it)))return val;throw TypeError("Can't convert object to primitive value");};/***/},/* 48 *//***/function(module,exports){module.exports=true;/***/},/* 49 *//***/function(module,exports,__webpack_require__){// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject=__webpack_require__(23),dPs=__webpack_require__(99),enumBugKeys=__webpack_require__(45),IE_PROTO=__webpack_require__(43)('IE_PROTO'),Empty=function(){/* empty */},PROTOTYPE='prototype';// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict=function(){// Thrash, waste and sodomy: IE GC bug
var iframe=__webpack_require__(64)('iframe'),i=enumBugKeys.length,lt='<',gt='>',iframeDocument;iframe.style.display='none';__webpack_require__(100).appendChild(iframe);iframe.src='javascript:';// eslint-disable-line no-script-url
// createDict = iframe.contentWindow.Object;
// html.removeChild(iframe);
iframeDocument=iframe.contentWindow.document;iframeDocument.open();iframeDocument.write(lt+'script'+gt+'document.F=Object'+lt+'/script'+gt);iframeDocument.close();createDict=iframeDocument.F;while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];return createDict();};module.exports=Object.create||function create(O,Properties){var result;if(O!==null){Empty[PROTOTYPE]=anObject(O);result=new Empty();Empty[PROTOTYPE]=null;// add "__proto__" for Object.getPrototypeOf polyfill
result[IE_PROTO]=O;}else result=createDict();return Properties===undefined?result:dPs(result,Properties);};/***/},/* 50 *//***/function(module,exports,__webpack_require__){var def=__webpack_require__(16).f,has=__webpack_require__(18),TAG=__webpack_require__(12)('toStringTag');module.exports=function(it,tag,stat){if(it&&!has(it=stat?it:it.prototype,TAG))def(it,TAG,{configurable:true,value:tag});};/***/},/* 51 *//***/function(module,exports,__webpack_require__){exports.f=__webpack_require__(12);/***/},/* 52 *//***/function(module,exports,__webpack_require__){var global=__webpack_require__(15),core=__webpack_require__(11),LIBRARY=__webpack_require__(48),wksExt=__webpack_require__(51),defineProperty=__webpack_require__(16).f;module.exports=function(name){var $Symbol=core.Symbol||(core.Symbol=LIBRARY?{}:global.Symbol||{});if(name.charAt(0)!='_'&&!(name in $Symbol))defineProperty($Symbol,name,{value:wksExt.f(name)});};/***/},/* 53 *//***/function(module,exports){exports.f={}.propertyIsEnumerable;/***/},/* 54 *//***/function(module,exports,__webpack_require__){var pIE=__webpack_require__(53),createDesc=__webpack_require__(28),toIObject=__webpack_require__(14),toPrimitive=__webpack_require__(47),has=__webpack_require__(18),IE8_DOM_DEFINE=__webpack_require__(63),gOPD=Object.getOwnPropertyDescriptor;exports.f=__webpack_require__(20)?gOPD:function getOwnPropertyDescriptor(O,P){O=toIObject(O);P=toPrimitive(P,true);if(IE8_DOM_DEFINE)try{return gOPD(O,P);}catch(e){/* empty */}if(has(O,P))return createDesc(!pIE.f.call(O,P),O[P]);};/***/},/* 55 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _log=__webpack_require__(129);var _log2=_interopRequireDefault(_log);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_log2.default;module.exports=exports['default'];/***/},/* 56 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _kibo=__webpack_require__(130);var _kibo2=_interopRequireDefault(_kibo);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default={Kibo:_kibo2.default};module.exports=exports['default'];/***/},/* 57 *//***/function(module,exports){// shim for using process in browser
var process=module.exports={};// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;var cachedClearTimeout;function defaultSetTimout(){throw new Error('setTimeout has not been defined');}function defaultClearTimeout(){throw new Error('clearTimeout has not been defined');}(function(){try{if(typeof setTimeout==='function'){cachedSetTimeout=setTimeout;}else{cachedSetTimeout=defaultSetTimout;}}catch(e){cachedSetTimeout=defaultSetTimout;}try{if(typeof clearTimeout==='function'){cachedClearTimeout=clearTimeout;}else{cachedClearTimeout=defaultClearTimeout;}}catch(e){cachedClearTimeout=defaultClearTimeout;}})();function runTimeout(fun){if(cachedSetTimeout===setTimeout){//normal enviroments in sane situations
return setTimeout(fun,0);}// if setTimeout wasn't available but was latter defined
if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout){cachedSetTimeout=setTimeout;return setTimeout(fun,0);}try{// when when somebody has screwed with setTimeout but no I.E. maddness
return cachedSetTimeout(fun,0);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
return cachedSetTimeout.call(null,fun,0);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
return cachedSetTimeout.call(this,fun,0);}}}function runClearTimeout(marker){if(cachedClearTimeout===clearTimeout){//normal enviroments in sane situations
return clearTimeout(marker);}// if clearTimeout wasn't available but was latter defined
if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout){cachedClearTimeout=clearTimeout;return clearTimeout(marker);}try{// when when somebody has screwed with setTimeout but no I.E. maddness
return cachedClearTimeout(marker);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
return cachedClearTimeout.call(null,marker);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
// Some versions of I.E. have different rules for clearTimeout vs setTimeout
return cachedClearTimeout.call(this,marker);}}}var queue=[];var draining=false;var currentQueue;var queueIndex=-1;function cleanUpNextTick(){if(!draining||!currentQueue){return;}draining=false;if(currentQueue.length){queue=currentQueue.concat(queue);}else{queueIndex=-1;}if(queue.length){drainQueue();}}function drainQueue(){if(draining){return;}var timeout=runTimeout(cleanUpNextTick);draining=true;var len=queue.length;while(len){currentQueue=queue;queue=[];while(++queueIndex<len){if(currentQueue){currentQueue[queueIndex].run();}}queueIndex=-1;len=queue.length;}currentQueue=null;draining=false;runClearTimeout(timeout);}process.nextTick=function(fun){var args=new Array(arguments.length-1);if(arguments.length>1){for(var i=1;i<arguments.length;i++){args[i-1]=arguments[i];}}queue.push(new Item(fun,args));if(queue.length===1&&!draining){runTimeout(drainQueue);}};// v8 likes predictible objects
function Item(fun,array){this.fun=fun;this.array=array;}Item.prototype.run=function(){this.fun.apply(null,this.array);};process.title='browser';process.browser=true;process.env={};process.argv=[];process.version='';// empty string to avoid regexp issues
process.versions={};function noop(){}process.on=noop;process.addListener=noop;process.once=noop;process.off=noop;process.removeListener=noop;process.removeAllListeners=noop;process.emit=noop;process.binding=function(name){throw new Error('process.binding is not supported');};process.cwd=function(){return'/';};process.chdir=function(dir){throw new Error('process.chdir is not supported');};process.umask=function(){return 0;};/***/},/* 58 *//***/function(module,exports){module.exports="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill=\"#010101\" d=\"M1.425.35L14.575 8l-13.15 7.65V.35z\"></path></svg>";/***/},/* 59 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.default=__webpack_require__(164);module.exports=exports['default'];/***/},/* 60 *//***/function(module,exports,__webpack_require__){var has=__webpack_require__(18),toIObject=__webpack_require__(14),arrayIndexOf=__webpack_require__(92)(false),IE_PROTO=__webpack_require__(43)('IE_PROTO');module.exports=function(object,names){var O=toIObject(object),i=0,result=[],key;for(key in O)if(key!=IE_PROTO)has(O,key)&&result.push(key);// Don't enum bug & hidden keys
while(names.length>i)if(has(O,key=names[i++])){~arrayIndexOf(result,key)||result.push(key);}return result;};/***/},/* 61 *//***/function(module,exports,__webpack_require__){// 7.1.15 ToLength
var toInteger=__webpack_require__(42),min=Math.min;module.exports=function(it){return it>0?min(toInteger(it),0x1fffffffffffff):0;// pow(2, 53) - 1 == 9007199254740991
};/***/},/* 62 *//***/function(module,exports,__webpack_require__){// most Object methods by ES6 should accept primitives
var $export=__webpack_require__(19),core=__webpack_require__(11),fails=__webpack_require__(27);module.exports=function(KEY,exec){var fn=(core.Object||{})[KEY]||Object[KEY],exp={};exp[KEY]=exec(fn);$export($export.S+$export.F*fails(function(){fn(1);}),'Object',exp);};/***/},/* 63 *//***/function(module,exports,__webpack_require__){module.exports=!__webpack_require__(20)&&!__webpack_require__(27)(function(){return Object.defineProperty(__webpack_require__(64)('div'),'a',{get:function(){return 7;}}).a!=7;});/***/},/* 64 *//***/function(module,exports,__webpack_require__){var isObject=__webpack_require__(26),document=__webpack_require__(15).document// in old IE typeof document.createElement is 'object'
,is=isObject(document)&&isObject(document.createElement);module.exports=function(it){return is?document.createElement(it):{};};/***/},/* 65 *//***/function(module,exports,__webpack_require__){"use strict";var $at=__webpack_require__(97)(true);// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(66)(String,'String',function(iterated){this._t=String(iterated);// target
this._i=0;// next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
},function(){var O=this._t,index=this._i,point;if(index>=O.length)return{value:undefined,done:true};point=$at(O,index);this._i+=point.length;return{value:point,done:false};});/***/},/* 66 *//***/function(module,exports,__webpack_require__){"use strict";var LIBRARY=__webpack_require__(48),$export=__webpack_require__(19),redefine=__webpack_require__(67),hide=__webpack_require__(22),has=__webpack_require__(18),Iterators=__webpack_require__(29),$iterCreate=__webpack_require__(98),setToStringTag=__webpack_require__(50),getPrototypeOf=__webpack_require__(101),ITERATOR=__webpack_require__(12)('iterator'),BUGGY=!([].keys&&'next'in[].keys())// Safari has buggy iterators w/o `next`
,FF_ITERATOR='@@iterator',KEYS='keys',VALUES='values';var returnThis=function(){return this;};module.exports=function(Base,NAME,Constructor,next,DEFAULT,IS_SET,FORCED){$iterCreate(Constructor,NAME,next);var getMethod=function(kind){if(!BUGGY&&kind in proto)return proto[kind];switch(kind){case KEYS:return function keys(){return new Constructor(this,kind);};case VALUES:return function values(){return new Constructor(this,kind);};}return function entries(){return new Constructor(this,kind);};};var TAG=NAME+' Iterator',DEF_VALUES=DEFAULT==VALUES,VALUES_BUG=false,proto=Base.prototype,$native=proto[ITERATOR]||proto[FF_ITERATOR]||DEFAULT&&proto[DEFAULT],$default=$native||getMethod(DEFAULT),$entries=DEFAULT?!DEF_VALUES?$default:getMethod('entries'):undefined,$anyNative=NAME=='Array'?proto.entries||$native:$native,methods,key,IteratorPrototype;// Fix native
if($anyNative){IteratorPrototype=getPrototypeOf($anyNative.call(new Base()));if(IteratorPrototype!==Object.prototype){// Set @@toStringTag to native iterators
setToStringTag(IteratorPrototype,TAG,true);// fix for some old engines
if(!LIBRARY&&!has(IteratorPrototype,ITERATOR))hide(IteratorPrototype,ITERATOR,returnThis);}}// fix Array#{values, @@iterator}.name in V8 / FF
if(DEF_VALUES&&$native&&$native.name!==VALUES){VALUES_BUG=true;$default=function values(){return $native.call(this);};}// Define iterator
if((!LIBRARY||FORCED)&&(BUGGY||VALUES_BUG||!proto[ITERATOR])){hide(proto,ITERATOR,$default);}// Plug for library
Iterators[NAME]=$default;Iterators[TAG]=returnThis;if(DEFAULT){methods={values:DEF_VALUES?$default:getMethod(VALUES),keys:IS_SET?$default:getMethod(KEYS),entries:$entries};if(FORCED)for(key in methods){if(!(key in proto))redefine(proto,key,methods[key]);}else $export($export.P+$export.F*(BUGGY||VALUES_BUG),NAME,methods);}return methods;};/***/},/* 67 *//***/function(module,exports,__webpack_require__){module.exports=__webpack_require__(22);/***/},/* 68 *//***/function(module,exports){exports.f=Object.getOwnPropertySymbols;/***/},/* 69 *//***/function(module,exports,__webpack_require__){// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys=__webpack_require__(60),hiddenKeys=__webpack_require__(45).concat('length','prototype');exports.f=Object.getOwnPropertyNames||function getOwnPropertyNames(O){return $keys(O,hiddenKeys);};/***/},/* 70 *//***/function(module,exports,__webpack_require__){module.exports={"default":__webpack_require__(117),__esModule:true};/***/},/* 71 *//***/function(module,exports,__webpack_require__){module.exports={"default":__webpack_require__(123),__esModule:true};/***/},/* 72 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _core=__webpack_require__(133);var _core2=_interopRequireDefault(_core);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_core2.default;module.exports=exports['default'];/***/},/* 73 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _container=__webpack_require__(136);var _container2=_interopRequireDefault(_container);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_container2.default;module.exports=exports['default'];/***/},/* 74 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _media_control=__webpack_require__(138);var _media_control2=_interopRequireDefault(_media_control);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_media_control2.default;module.exports=exports['default'];/***/},/* 75 *//***/function(module,exports,__webpack_require__){module.exports=__webpack_require__.p+"a8c874b93b3d848f39a71260c57e3863.cur";/***/},/* 76 *//***/function(module,exports){module.exports="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"#010101\" d=\"M1.712 14.76H6.43V1.24H1.71v13.52zm7.86-13.52v13.52h4.716V1.24H9.573z\"></path></svg>";/***/},/* 77 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _loader=__webpack_require__(151);var _loader2=_interopRequireDefault(_loader);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_loader2.default;module.exports=exports['default'];/***/},/* 78 *//***/function(module,exports,__webpack_require__){module.exports={"default":__webpack_require__(153),__esModule:true};/***/},/* 79 *//***/function(module,exports,__webpack_require__){"use strict";exports.__esModule=true;var _from=__webpack_require__(78);var _from2=_interopRequireDefault(_from);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=function(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return(0,_from2.default)(arr);}};/***/},/* 80 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _flash=__webpack_require__(163);var _flash2=_interopRequireDefault(_flash);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_flash2.default;module.exports=exports['default'];/***/},/* 81 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _html5_audio=__webpack_require__(168);var _html5_audio2=_interopRequireDefault(_html5_audio);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_html5_audio2.default;module.exports=exports['default'];/***/},/* 82 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _flashls=__webpack_require__(169);var _flashls2=_interopRequireDefault(_flashls);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_flashls2.default;module.exports=exports['default'];/***/},/* 83 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _hls=__webpack_require__(172);var _hls2=_interopRequireDefault(_hls);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_hls2.default;module.exports=exports['default'];/***/},/* 84 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _html_img=__webpack_require__(174);var _html_img2=_interopRequireDefault(_html_img);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_html_img2.default;module.exports=exports['default'];/***/},/* 85 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _no_op=__webpack_require__(176);var _no_op2=_interopRequireDefault(_no_op);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_no_op2.default;module.exports=exports['default'];/***/},/* 86 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _poster=__webpack_require__(189);var _poster2=_interopRequireDefault(_poster);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_poster2.default;module.exports=exports['default'];/***/},/* 87 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _player=__webpack_require__(88);var _player2=_interopRequireDefault(_player);var _utils=__webpack_require__(5);var _utils2=_interopRequireDefault(_utils);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _container_plugin=__webpack_require__(37);var _container_plugin2=_interopRequireDefault(_container_plugin);var _core_plugin=__webpack_require__(30);var _core_plugin2=_interopRequireDefault(_core_plugin);var _ui_core_plugin=__webpack_require__(38);var _ui_core_plugin2=_interopRequireDefault(_ui_core_plugin);var _ui_container_plugin=__webpack_require__(36);var _ui_container_plugin2=_interopRequireDefault(_ui_container_plugin);var _base_object=__webpack_require__(17);var _base_object2=_interopRequireDefault(_base_object);var _ui_object=__webpack_require__(21);var _ui_object2=_interopRequireDefault(_ui_object);var _browser=__webpack_require__(13);var _browser2=_interopRequireDefault(_browser);var _container=__webpack_require__(73);var _container2=_interopRequireDefault(_container);var _core=__webpack_require__(72);var _core2=_interopRequireDefault(_core);var _loader=__webpack_require__(77);var _loader2=_interopRequireDefault(_loader);var _mediator=__webpack_require__(24);var _mediator2=_interopRequireDefault(_mediator);var _media_control=__webpack_require__(74);var _media_control2=_interopRequireDefault(_media_control);var _player_info=__webpack_require__(34);var _player_info2=_interopRequireDefault(_player_info);var _base_flash_playback=__webpack_require__(59);var _base_flash_playback2=_interopRequireDefault(_base_flash_playback);var _flash=__webpack_require__(80);var _flash2=_interopRequireDefault(_flash);var _flashls=__webpack_require__(82);var _flashls2=_interopRequireDefault(_flashls);var _hls=__webpack_require__(83);var _hls2=_interopRequireDefault(_hls);var _html5_audio=__webpack_require__(81);var _html5_audio2=_interopRequireDefault(_html5_audio);var _html5_video=__webpack_require__(35);var _html5_video2=_interopRequireDefault(_html5_video);var _html_img=__webpack_require__(84);var _html_img2=_interopRequireDefault(_html_img);var _no_op=__webpack_require__(85);var _no_op2=_interopRequireDefault(_no_op);var _poster=__webpack_require__(86);var _poster2=_interopRequireDefault(_poster);var _log=__webpack_require__(55);var _log2=_interopRequireDefault(_log);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _vendor=__webpack_require__(56);var _vendor2=_interopRequireDefault(_vendor);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var version="0.2.71";// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
exports.default={Player:_player2.default,Mediator:_mediator2.default,Events:_events2.default,Browser:_browser2.default,PlayerInfo:_player_info2.default,MediaControl:_media_control2.default,ContainerPlugin:_container_plugin2.default,UIContainerPlugin:_ui_container_plugin2.default,CorePlugin:_core_plugin2.default,UICorePlugin:_ui_core_plugin2.default,Playback:_playback2.default,Container:_container2.default,Core:_core2.default,Loader:_loader2.default,BaseObject:_base_object2.default,UIObject:_ui_object2.default,Utils:_utils2.default,BaseFlashPlayback:_base_flash_playback2.default,Flash:_flash2.default,FlasHLS:_flashls2.default,HLS:_hls2.default,HTML5Audio:_html5_audio2.default,HTML5Video:_html5_video2.default,HTMLImg:_html_img2.default,NoOp:_no_op2.default,Poster:_poster2.default,Log:_log2.default,Styler:_styler2.default,Vendor:_vendor2.default,version:version,template:_template2.default,$:_clapprZepto2.default};module.exports=exports['default'];/***/},/* 88 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _keys=__webpack_require__(31);var _keys2=_interopRequireDefault(_keys);var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _utils=__webpack_require__(5);var _base_object=__webpack_require__(17);var _base_object2=_interopRequireDefault(_base_object);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _browser=__webpack_require__(13);var _browser2=_interopRequireDefault(_browser);var _core_factory=__webpack_require__(131);var _core_factory2=_interopRequireDefault(_core_factory);var _loader=__webpack_require__(77);var _loader2=_interopRequireDefault(_loader);var _player_info=__webpack_require__(34);var _player_info2=_interopRequireDefault(_player_info);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var baseUrl=(0,_utils.currentScriptUrl)().replace(/\/[^/]+$/,'');/**
 * @class Player
 * @constructor
 * @extends BaseObject
 * @module components
 * @example
 * ### Using the Player
 *
 * Add the following script on your HTML:
 * ```html
 * <head>
 *   <script type="text/javascript" src="http://cdn.clappr.io/latest/clappr.min.js"></script>
 * </head>
 * ```
 * Now, create the player:
 * ```html
 * <body>
 *   <div id="player"></div>
 *   <script>
 *     var player = new Clappr.Player({source: "http://your.video/here.mp4", parentId: "#player"});
 *   </script>
 * </body>
 * ```
 */var Player=function(_BaseObject){(0,_inherits3.default)(Player,_BaseObject);(0,_createClass3.default)(Player,[{key:'loader',set:function set(loader){this._loader=loader;},get:function get(){if(!this._loader){this._loader=new _loader2.default(this.options.plugins||{},this.options.playerId);}return this._loader;}/**
     * Determine if the playback has ended.
     * @property ended
     * @type Boolean
     */},{key:'ended',get:function get(){return this.core.mediaControl.container.ended;}/**
     * Determine if the playback is having to buffer in order for
     * playback to be smooth.
     * (i.e if a live stream is playing smoothly, this will be false)
     * @property buffering
     * @type Boolean
     */},{key:'buffering',get:function get(){return this.core.mediaControl.container.buffering;}/*
     * determine if the player is ready.
     * @property isReady
     * @type {Boolean} `true` if the player is ready. ie PLAYER_READY event has fired
     */},{key:'isReady',get:function get(){return!!this._ready;}/**
     * An events map that allows the user to add custom callbacks in player's options.
     * @property eventsMapping
     * @type {Object}
     */},{key:'eventsMapping',get:function get(){return{onReady:_events2.default.PLAYER_READY,onResize:_events2.default.PLAYER_RESIZE,onPlay:_events2.default.PLAYER_PLAY,onPause:_events2.default.PLAYER_PAUSE,onStop:_events2.default.PLAYER_STOP,onEnded:_events2.default.PLAYER_ENDED,onSeek:_events2.default.PLAYER_SEEK,onError:_events2.default.PLAYER_ERROR,onTimeUpdate:_events2.default.PLAYER_TIMEUPDATE,onVolumeUpdate:_events2.default.PLAYER_VOLUMEUPDATE,onSubtitleAvailable:_events2.default.PLAYER_SUBTITLE_AVAILABLE};}/**
     * ## Player's constructor
     *
     * You might pass the options object to build the player.
     * ```javascript
     * var options = {source: "http://example.com/video.mp4", param1: "val1"};
     * var player = new Clappr.Player(options);
     * ```
     *
     * @method constructor
     * @param {Object} options Data
     * options to build a player instance
     * @param {Number} [options.width]
     * player's width **default**: `640`
     * @param {Number} [options.height]
     * player's height **default**: `360`
     * @param {String} [options.parentId]
     * the id of the element on the page that the player should be inserted into
     * @param {Object} [options.parent]
     * a reference to a dom element that the player should be inserted into
     * @param {String} [options.source]
     * The media source URL, or {source: <<source URL>>, mimeType: <<source mime type>>}
     * @param {Object} [options.sources]
     * An array of media source URL's, or an array of {source: <<source URL>>, mimeType: <<source mime type>>}
     * @param {Boolean} [options.autoPlay]
     * automatically play after page load **default**: `false`
     * @param {Boolean} [options.loop]
     * automatically replay after it ends **default**: `false`
     * @param {Boolean} [options.chromeless]
     * player acts in chromeless mode **default**: `false`
     * @param {Boolean} [options.allowUserInteraction]
     * whether or not the player should handle click events when in chromeless mode **default**: `false` on desktops browsers, `true` on mobile.
     * @param {Boolean} [options.disableKeyboardShortcuts]
     * disable keyboard shortcuts. **default**: `false`. `true` if `allowUserInteraction` is `false`.
     * @param {Boolean} [options.muted]
     * start the video muted **default**: `false`
     * @param {String} [options.mimeType]
     * add `mimeType: "application/vnd.apple.mpegurl"` if you need to use a url without extension.
     * @param {String} [options.actualLiveTime]
     * show duration and seek time relative to actual time.
     * @param {String} [options.actualLiveServerTime]
     * specify server time as a string, format: "2015/11/26 06:01:03". This option is meant to be used with actualLiveTime.
     * @param {Boolean} [options.persistConfig]
     * persist player's settings (volume) through the same domain **default**: `true`
     * @param {String} [options.preload]
     * video will be preloaded according to `preload` attribute options **default**: `'metadata'`
     * @param {Number} [options.maxBufferLength]
     * the default behavior for the **HLS playback** is to keep buffering indefinitely, even on VoD.
     * This replicates the behavior for progressive download, which continues buffering when pausing the video, thus making the video available for playback even on slow networks.
     * To change this behavior use `maxBufferLength` where **value is in seconds**.
     * @param {String} [options.gaAccount]
     * enable Google Analytics events dispatch **(play/pause/stop/buffering/etc)** by adding your `gaAccount`
     * @param {String} [options.gaTrackerName]
     * besides `gaAccount` you can optionally, pass your favorite trackerName as `gaTrackerName`
     * @param {Object} [options.mediacontrol]
     * customize control bar colors, example: `mediacontrol: {seekbar: "#E113D3", buttons: "#66B2FF"}`
     * @param {Boolean} [options.hideMediaControl]
     * control media control auto hide **default**: `true`
     * @param {Boolean} [options.hideVolumeBar]
     * when embedded with width less than 320, volume bar will hide. You can force this behavior for all sizes by adding `true` **default**: `false`
     * @param {String} [options.watermark]
     * put `watermark: 'http://url/img.png'` on your embed parameters to automatically add watermark on your video.
     * You can customize corner position by defining position parameter. Positions can be `bottom-left`, `bottom-right`, `top-left` and `top-right`.
     * @param {String} [options.watermarkLink]
     * `watermarkLink: 'http://example.net/'` - define URL to open when the watermark is clicked. If not provided watermark will not be clickable.
     * @param {Boolean} [options.disableVideoTagContextMenu]
     * disables the context menu (right click) on the video element if a HTML5Video playback is used.
     * @param {Boolean} [options.autoSeekFromUrl]
     * Automatically seek to the seconds provided in the url (e.g example.com?t=100) **default**: `true`
     * @param {Boolean} [options.exitFullscreenOnEnd]
     * Automatically exit full screen when the media finishes. **default**: `true`
     * @param {String} [options.poster]
     * define a poster by adding its address `poster: 'http://url/img.png'`. It will appear after video embed, disappear on play and go back when user stops the video.
     * @param {String} [options.playbackNotSupportedMessage]
     * define a custom message to be displayed when a playback is not supported.
     * @param {Object} [options.events]
     * Specify listeners which will be registered with their corresponding player events.
     * E.g. onReady -> "PLAYER_READY", onTimeUpdate -> "PLAYER_TIMEUPDATE"
     */}]);function Player(options){(0,_classCallCheck3.default)(this,Player);var _this=(0,_possibleConstructorReturn3.default)(this,_BaseObject.call(this,options));var defaultOptions={playerId:(0,_utils.uniqueId)(''),persistConfig:true,width:640,height:360,baseUrl:baseUrl,allowUserInteraction:_browser2.default.isMobile};_this._options=_clapprZepto2.default.extend(defaultOptions,options);_this.options.sources=_this._normalizeSources(options);if(!_this.options.chromeless){// "allowUserInteraction" cannot be false if not in chromeless mode.
_this.options.allowUserInteraction=true;}if(!_this.options.allowUserInteraction){// if user iteraction is not allowed ensure keyboard shortcuts are disabled
_this.options.disableKeyboardShortcuts=true;}_this._registerOptionEventListeners();_this._coreFactory=new _core_factory2.default(_this);_this.playerInfo=_player_info2.default.getInstance(_this.options.playerId);_this.playerInfo.currentSize={width:options.width,height:options.height};_this.playerInfo.options=_this.options;if(_this.options.parentId){_this.setParentId(_this.options.parentId);}else if(_this.options.parent){_this.attachTo(_this.options.parent);}return _this;}/**
   * Specify a `parentId` to the player.
   * @method setParentId
   * @param {String} parentId the element parent id.
   * @return {Player} itself
   */Player.prototype.setParentId=function setParentId(parentId){var el=document.querySelector(parentId);if(el){this.attachTo(el);}return this;};/**
   * You can use this method to attach the player to a given element. You don't need to do this when you specify it during the player instantiation passing the `parentId` param.
   * @method attachTo
   * @param {Object} element a given element.
   * @return {Player} itself
   */Player.prototype.attachTo=function attachTo(element){this.options.parentElement=element;this.core=this._coreFactory.create();this._addEventListeners();return this;};Player.prototype._addEventListeners=function _addEventListeners(){if(!this.core.isReady){this.listenToOnce(this.core,_events2.default.CORE_READY,this._onReady);}else{this._onReady();}this.listenTo(this.core.mediaControl,_events2.default.MEDIACONTROL_CONTAINERCHANGED,this._containerChanged);this.listenTo(this.core,_events2.default.CORE_FULLSCREEN,this._onFullscreenChange);return this;};Player.prototype._addContainerEventListeners=function _addContainerEventListeners(){var container=this.core.mediaControl.container;if(container){this.listenTo(container,_events2.default.CONTAINER_PLAY,this._onPlay);this.listenTo(container,_events2.default.CONTAINER_PAUSE,this._onPause);this.listenTo(container,_events2.default.CONTAINER_STOP,this._onStop);this.listenTo(container,_events2.default.CONTAINER_ENDED,this._onEnded);this.listenTo(container,_events2.default.CONTAINER_SEEK,this._onSeek);this.listenTo(container,_events2.default.CONTAINER_ERROR,this._onError);this.listenTo(container,_events2.default.CONTAINER_TIMEUPDATE,this._onTimeUpdate);this.listenTo(container,_events2.default.CONTAINER_VOLUME,this._onVolumeUpdate);this.listenTo(container,_events2.default.CONTAINER_SUBTITLE_AVAILABLE,this._onSubtitleAvailable);}return this;};Player.prototype._registerOptionEventListeners=function _registerOptionEventListeners(){var _this2=this;var userEvents=this.options.events||{};(0,_keys2.default)(userEvents).forEach(function(userEvent){var eventType=_this2.eventsMapping[userEvent];if(eventType){var eventFunction=userEvents[userEvent];eventFunction=typeof eventFunction==='function'&&eventFunction;eventFunction&&_this2.on(eventType,eventFunction);}});return this;};Player.prototype._containerChanged=function _containerChanged(){this.stopListening();this._addEventListeners();};Player.prototype._onReady=function _onReady(){this._ready=true;this._addContainerEventListeners();this.trigger(_events2.default.PLAYER_READY);};Player.prototype._onFullscreenChange=function _onFullscreenChange(fullscreen){this.trigger(_events2.default.PLAYER_FULLSCREEN,fullscreen);};Player.prototype._onVolumeUpdate=function _onVolumeUpdate(volume){this.trigger(_events2.default.PLAYER_VOLUMEUPDATE,volume);};Player.prototype._onSubtitleAvailable=function _onSubtitleAvailable(){this.trigger(_events2.default.PLAYER_SUBTITLE_AVAILABLE);};Player.prototype._onPlay=function _onPlay(){this.trigger(_events2.default.PLAYER_PLAY);};Player.prototype._onPause=function _onPause(){this.trigger(_events2.default.PLAYER_PAUSE);};Player.prototype._onStop=function _onStop(){this.trigger(_events2.default.PLAYER_STOP,this.getCurrentTime());};Player.prototype._onEnded=function _onEnded(){this.trigger(_events2.default.PLAYER_ENDED);};Player.prototype._onSeek=function _onSeek(time){this.trigger(_events2.default.PLAYER_SEEK,time);};Player.prototype._onTimeUpdate=function _onTimeUpdate(timeProgress){this.trigger(_events2.default.PLAYER_TIMEUPDATE,timeProgress);};Player.prototype._onError=function _onError(error){this.trigger(_events2.default.PLAYER_ERROR,error);};Player.prototype._normalizeSources=function _normalizeSources(options){var sources=options.sources||(options.source!==undefined?[options.source]:[]);return sources.length===0?[{source:'',mimeType:''}]:sources;};/**
   * resizes the current player canvas.
   * @method resize
   * @param {Object} size should be a literal object with `height` and `width`.
   * @return {Player} itself
   * @example
   * ```javascript
   * player.resize({height: 360, width: 640})
   * ```
   */Player.prototype.resize=function resize(size){this.core.resize(size);return this;};/**
   * loads a new source.
   * @method load
   * @param {Array|String} sources source or sources of video.
   * An array item can be a string or {source: <<source URL>>, mimeType: <<source mime type>>}
   * @param {String} mimeType a mime type, example: `'application/vnd.apple.mpegurl'`
   * @param {Boolean} [autoPlay=false] whether playing should be started immediately
   * @return {Player} itself
   */Player.prototype.load=function load(sources,mimeType,autoPlay){if(autoPlay!==undefined){this.configure({autoPlay:!!autoPlay});}this.core.load(sources,mimeType);return this;};/**
   * destroys the current player and removes it from the DOM.
   * @method destroy
   * @return {Player} itself
   */Player.prototype.destroy=function destroy(){this.core.destroy();return this;};/**
   * Gives user consent to playback. Required by mobile device after a click event before Player.load().
   * @method consent
   * @return {Player} itself
   */Player.prototype.consent=function consent(){this.core.getCurrentPlayback().consent();return this;};/**
   * plays the current video (`source`).
   * @method play
   * @return {Player} itself
   */Player.prototype.play=function play(){this.core.mediaControl.container.play();return this;};/**
   * pauses the current video (`source`).
   * @method pause
   * @return {Player} itself
   */Player.prototype.pause=function pause(){this.core.mediaControl.container.pause();return this;};/**
   * stops the current video (`source`).
   * @method stop
   * @return {Player} itself
   */Player.prototype.stop=function stop(){this.core.mediaControl.container.stop();return this;};/**
   * seeks the current video (`source`). For example, `player.seek(120)` will seek to second 120 (2minutes) of the current video.
   * @method seek
   * @param {Number} time should be a number between 0 and the video duration.
   * @return {Player} itself
   */Player.prototype.seek=function seek(time){this.core.mediaControl.container.seek(time);return this;};/**
   * seeks the current video (`source`). For example, `player.seek(50)` will seek to the middle of the current video.
   * @method seekPercentage
   * @param {Number} time should be a number between 0 and 100.
   * @return {Player} itself
   */Player.prototype.seekPercentage=function seekPercentage(percentage){this.core.mediaControl.container.seekPercentage(percentage);return this;};/**
   * Set the volume for the current video (`source`).
   * @method setVolume
   * @param {Number} volume should be a number between 0 and 100, 0 being mute and 100 the max volume.
   * @return {Player} itself
   */Player.prototype.setVolume=function setVolume(volume){if(this.core&&this.core.mediaControl){this.core.mediaControl.setVolume(volume);}return this;};/**
   * Get the volume for the current video
   * @method getVolume
   * @return {Number} volume should be a number between 0 and 100, 0 being mute and 100 the max volume.
   */Player.prototype.getVolume=function getVolume(){return this.core&&this.core.mediaControl?this.core.mediaControl.volume:0;};/**
   * mutes the current video (`source`).
   * @method mute
   * @return {Player} itself
   */Player.prototype.mute=function mute(){this._mutedVolume=this.getVolume();this.setVolume(0);return this;};/**
   * unmutes the current video (`source`).
   * @method unmute
   * @return {Player} itself
   */Player.prototype.unmute=function unmute(){this.setVolume(typeof this._mutedVolume==='number'?this._mutedVolume:100);this._mutedVolume=null;return this;};/**
   * checks if the player is playing.
   * @method isPlaying
   * @return {Boolean} `true` if the current source is playing, otherwise `false`
   */Player.prototype.isPlaying=function isPlaying(){return this.core.mediaControl.container.isPlaying();};/**
   * returns `true` if DVR is enable otherwise `false`.
   * @method isDvrEnabled
   * @return {Boolean}
   */Player.prototype.isDvrEnabled=function isDvrEnabled(){return this.core.mediaControl.container.isDvrEnabled();};/**
   * returns `true` if DVR is in use otherwise `false`.
   * @method isDvrInUse
   * @return {Boolean}
   */Player.prototype.isDvrInUse=function isDvrInUse(){return this.core.mediaControl.container.isDvrInUse();};/**
   * enables to configure a player after its creation
   * @method configure
   * @param {Object} options all the options to change in form of a javascript object
   * @return {Player} itself
   */Player.prototype.configure=function configure(options){this.core.configure(options);return this;};/**
   * get a plugin by its name.
   * @method getPlugin
   * @param {String} name of the plugin.
   * @return {Object} the plugin instance
   * @example
   * ```javascript
   * var poster = player.getPlugin('poster');
   * poster.hidePlayButton();
   * ```
   */Player.prototype.getPlugin=function getPlugin(name){var plugins=this.core.plugins.concat(this.core.mediaControl.container.plugins);return plugins.filter(function(plugin){return plugin.name===name;})[0];};/**
   * the current time in seconds.
   * @method getCurrentTime
   * @return {Number} current time (in seconds) of the current source
   */Player.prototype.getCurrentTime=function getCurrentTime(){return this.core.mediaControl.container.getCurrentTime();};/**
   * The time that "0" now represents relative to when playback started.
   * For a stream with a sliding window this will increase as content is
   * removed from the beginning.
   * @method getStartTimeOffset
   * @return {Number} time (in seconds) that time "0" represents.
   */Player.prototype.getStartTimeOffset=function getStartTimeOffset(){return this.core.mediaControl.container.getStartTimeOffset();};/**
   * the duration time in seconds.
   * @method getDuration
   * @return {Number} duration time (in seconds) of the current source
   */Player.prototype.getDuration=function getDuration(){return this.core.mediaControl.container.getDuration();};return Player;}(_base_object2.default);exports.default=Player;module.exports=exports['default'];/***/},/* 89 *//***/function(module,exports,__webpack_require__){__webpack_require__(90);module.exports=__webpack_require__(11).Object.keys;/***/},/* 90 *//***/function(module,exports,__webpack_require__){// 19.1.2.14 Object.keys(O)
var toObject=__webpack_require__(39),$keys=__webpack_require__(25);__webpack_require__(62)('keys',function(){return function keys(it){return $keys(toObject(it));};});/***/},/* 91 *//***/function(module,exports,__webpack_require__){// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof=__webpack_require__(41);module.exports=Object('z').propertyIsEnumerable(0)?Object:function(it){return cof(it)=='String'?it.split(''):Object(it);};/***/},/* 92 *//***/function(module,exports,__webpack_require__){// false -> Array#indexOf
// true  -> Array#includes
var toIObject=__webpack_require__(14),toLength=__webpack_require__(61),toIndex=__webpack_require__(93);module.exports=function(IS_INCLUDES){return function($this,el,fromIndex){var O=toIObject($this),length=toLength(O.length),index=toIndex(fromIndex,length),value;// Array#includes uses SameValueZero equality algorithm
if(IS_INCLUDES&&el!=el)while(length>index){value=O[index++];if(value!=value)return true;// Array#toIndex ignores holes, Array#includes - not
}else for(;length>index;index++)if(IS_INCLUDES||index in O){if(O[index]===el)return IS_INCLUDES||index||0;}return!IS_INCLUDES&&-1;};};/***/},/* 93 *//***/function(module,exports,__webpack_require__){var toInteger=__webpack_require__(42),max=Math.max,min=Math.min;module.exports=function(index,length){index=toInteger(index);return index<0?max(index+length,0):min(index,length);};/***/},/* 94 *//***/function(module,exports){module.exports=function(it){if(typeof it!='function')throw TypeError(it+' is not a function!');return it;};/***/},/* 95 *//***/function(module,exports,__webpack_require__){module.exports={"default":__webpack_require__(96),__esModule:true};/***/},/* 96 *//***/function(module,exports,__webpack_require__){__webpack_require__(65);__webpack_require__(102);module.exports=__webpack_require__(51).f('iterator');/***/},/* 97 *//***/function(module,exports,__webpack_require__){var toInteger=__webpack_require__(42),defined=__webpack_require__(40);// true  -> String#at
// false -> String#codePointAt
module.exports=function(TO_STRING){return function(that,pos){var s=String(defined(that)),i=toInteger(pos),l=s.length,a,b;if(i<0||i>=l)return TO_STRING?'':undefined;a=s.charCodeAt(i);return a<0xd800||a>0xdbff||i+1===l||(b=s.charCodeAt(i+1))<0xdc00||b>0xdfff?TO_STRING?s.charAt(i):a:TO_STRING?s.slice(i,i+2):(a-0xd800<<10)+(b-0xdc00)+0x10000;};};/***/},/* 98 *//***/function(module,exports,__webpack_require__){"use strict";var create=__webpack_require__(49),descriptor=__webpack_require__(28),setToStringTag=__webpack_require__(50),IteratorPrototype={};// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(22)(IteratorPrototype,__webpack_require__(12)('iterator'),function(){return this;});module.exports=function(Constructor,NAME,next){Constructor.prototype=create(IteratorPrototype,{next:descriptor(1,next)});setToStringTag(Constructor,NAME+' Iterator');};/***/},/* 99 *//***/function(module,exports,__webpack_require__){var dP=__webpack_require__(16),anObject=__webpack_require__(23),getKeys=__webpack_require__(25);module.exports=__webpack_require__(20)?Object.defineProperties:function defineProperties(O,Properties){anObject(O);var keys=getKeys(Properties),length=keys.length,i=0,P;while(length>i)dP.f(O,P=keys[i++],Properties[P]);return O;};/***/},/* 100 *//***/function(module,exports,__webpack_require__){module.exports=__webpack_require__(15).document&&document.documentElement;/***/},/* 101 *//***/function(module,exports,__webpack_require__){// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has=__webpack_require__(18),toObject=__webpack_require__(39),IE_PROTO=__webpack_require__(43)('IE_PROTO'),ObjectProto=Object.prototype;module.exports=Object.getPrototypeOf||function(O){O=toObject(O);if(has(O,IE_PROTO))return O[IE_PROTO];if(typeof O.constructor=='function'&&O instanceof O.constructor){return O.constructor.prototype;}return O instanceof Object?ObjectProto:null;};/***/},/* 102 *//***/function(module,exports,__webpack_require__){__webpack_require__(103);var global=__webpack_require__(15),hide=__webpack_require__(22),Iterators=__webpack_require__(29),TO_STRING_TAG=__webpack_require__(12)('toStringTag');for(var collections=['NodeList','DOMTokenList','MediaList','StyleSheetList','CSSRuleList'],i=0;i<5;i++){var NAME=collections[i],Collection=global[NAME],proto=Collection&&Collection.prototype;if(proto&&!proto[TO_STRING_TAG])hide(proto,TO_STRING_TAG,NAME);Iterators[NAME]=Iterators.Array;}/***/},/* 103 *//***/function(module,exports,__webpack_require__){"use strict";var addToUnscopables=__webpack_require__(104),step=__webpack_require__(105),Iterators=__webpack_require__(29),toIObject=__webpack_require__(14);// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports=__webpack_require__(66)(Array,'Array',function(iterated,kind){this._t=toIObject(iterated);// target
this._i=0;// next index
this._k=kind;// kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
},function(){var O=this._t,kind=this._k,index=this._i++;if(!O||index>=O.length){this._t=undefined;return step(1);}if(kind=='keys')return step(0,index);if(kind=='values')return step(0,O[index]);return step(0,[index,O[index]]);},'values');// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments=Iterators.Array;addToUnscopables('keys');addToUnscopables('values');addToUnscopables('entries');/***/},/* 104 *//***/function(module,exports){module.exports=function(){/* empty */};/***/},/* 105 *//***/function(module,exports){module.exports=function(done,value){return{value:value,done:!!done};};/***/},/* 106 *//***/function(module,exports,__webpack_require__){module.exports={"default":__webpack_require__(107),__esModule:true};/***/},/* 107 *//***/function(module,exports,__webpack_require__){__webpack_require__(108);__webpack_require__(114);__webpack_require__(115);__webpack_require__(116);module.exports=__webpack_require__(11).Symbol;/***/},/* 108 *//***/function(module,exports,__webpack_require__){"use strict";// ECMAScript 6 symbols shim
var global=__webpack_require__(15),has=__webpack_require__(18),DESCRIPTORS=__webpack_require__(20),$export=__webpack_require__(19),redefine=__webpack_require__(67),META=__webpack_require__(109).KEY,$fails=__webpack_require__(27),shared=__webpack_require__(44),setToStringTag=__webpack_require__(50),uid=__webpack_require__(32),wks=__webpack_require__(12),wksExt=__webpack_require__(51),wksDefine=__webpack_require__(52),keyOf=__webpack_require__(110),enumKeys=__webpack_require__(111),isArray=__webpack_require__(112),anObject=__webpack_require__(23),toIObject=__webpack_require__(14),toPrimitive=__webpack_require__(47),createDesc=__webpack_require__(28),_create=__webpack_require__(49),gOPNExt=__webpack_require__(113),$GOPD=__webpack_require__(54),$DP=__webpack_require__(16),$keys=__webpack_require__(25),gOPD=$GOPD.f,dP=$DP.f,gOPN=gOPNExt.f,$Symbol=global.Symbol,$JSON=global.JSON,_stringify=$JSON&&$JSON.stringify,PROTOTYPE='prototype',HIDDEN=wks('_hidden'),TO_PRIMITIVE=wks('toPrimitive'),isEnum={}.propertyIsEnumerable,SymbolRegistry=shared('symbol-registry'),AllSymbols=shared('symbols'),OPSymbols=shared('op-symbols'),ObjectProto=Object[PROTOTYPE],USE_NATIVE=typeof $Symbol=='function',QObject=global.QObject;// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter=!QObject||!QObject[PROTOTYPE]||!QObject[PROTOTYPE].findChild;// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc=DESCRIPTORS&&$fails(function(){return _create(dP({},'a',{get:function(){return dP(this,'a',{value:7}).a;}})).a!=7;})?function(it,key,D){var protoDesc=gOPD(ObjectProto,key);if(protoDesc)delete ObjectProto[key];dP(it,key,D);if(protoDesc&&it!==ObjectProto)dP(ObjectProto,key,protoDesc);}:dP;var wrap=function(tag){var sym=AllSymbols[tag]=_create($Symbol[PROTOTYPE]);sym._k=tag;return sym;};var isSymbol=USE_NATIVE&&typeof $Symbol.iterator=='symbol'?function(it){return typeof it=='symbol';}:function(it){return it instanceof $Symbol;};var $defineProperty=function defineProperty(it,key,D){if(it===ObjectProto)$defineProperty(OPSymbols,key,D);anObject(it);key=toPrimitive(key,true);anObject(D);if(has(AllSymbols,key)){if(!D.enumerable){if(!has(it,HIDDEN))dP(it,HIDDEN,createDesc(1,{}));it[HIDDEN][key]=true;}else{if(has(it,HIDDEN)&&it[HIDDEN][key])it[HIDDEN][key]=false;D=_create(D,{enumerable:createDesc(0,false)});}return setSymbolDesc(it,key,D);}return dP(it,key,D);};var $defineProperties=function defineProperties(it,P){anObject(it);var keys=enumKeys(P=toIObject(P)),i=0,l=keys.length,key;while(l>i)$defineProperty(it,key=keys[i++],P[key]);return it;};var $create=function create(it,P){return P===undefined?_create(it):$defineProperties(_create(it),P);};var $propertyIsEnumerable=function propertyIsEnumerable(key){var E=isEnum.call(this,key=toPrimitive(key,true));if(this===ObjectProto&&has(AllSymbols,key)&&!has(OPSymbols,key))return false;return E||!has(this,key)||!has(AllSymbols,key)||has(this,HIDDEN)&&this[HIDDEN][key]?E:true;};var $getOwnPropertyDescriptor=function getOwnPropertyDescriptor(it,key){it=toIObject(it);key=toPrimitive(key,true);if(it===ObjectProto&&has(AllSymbols,key)&&!has(OPSymbols,key))return;var D=gOPD(it,key);if(D&&has(AllSymbols,key)&&!(has(it,HIDDEN)&&it[HIDDEN][key]))D.enumerable=true;return D;};var $getOwnPropertyNames=function getOwnPropertyNames(it){var names=gOPN(toIObject(it)),result=[],i=0,key;while(names.length>i){if(!has(AllSymbols,key=names[i++])&&key!=HIDDEN&&key!=META)result.push(key);}return result;};var $getOwnPropertySymbols=function getOwnPropertySymbols(it){var IS_OP=it===ObjectProto,names=gOPN(IS_OP?OPSymbols:toIObject(it)),result=[],i=0,key;while(names.length>i){if(has(AllSymbols,key=names[i++])&&(IS_OP?has(ObjectProto,key):true))result.push(AllSymbols[key]);}return result;};// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){$Symbol=function Symbol(){if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');var tag=uid(arguments.length>0?arguments[0]:undefined);var $set=function(value){if(this===ObjectProto)$set.call(OPSymbols,value);if(has(this,HIDDEN)&&has(this[HIDDEN],tag))this[HIDDEN][tag]=false;setSymbolDesc(this,tag,createDesc(1,value));};if(DESCRIPTORS&&setter)setSymbolDesc(ObjectProto,tag,{configurable:true,set:$set});return wrap(tag);};redefine($Symbol[PROTOTYPE],'toString',function toString(){return this._k;});$GOPD.f=$getOwnPropertyDescriptor;$DP.f=$defineProperty;__webpack_require__(69).f=gOPNExt.f=$getOwnPropertyNames;__webpack_require__(53).f=$propertyIsEnumerable;__webpack_require__(68).f=$getOwnPropertySymbols;if(DESCRIPTORS&&!__webpack_require__(48)){redefine(ObjectProto,'propertyIsEnumerable',$propertyIsEnumerable,true);}wksExt.f=function(name){return wrap(wks(name));};}$export($export.G+$export.W+$export.F*!USE_NATIVE,{Symbol:$Symbol});for(var symbols=// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','),i=0;symbols.length>i;)wks(symbols[i++]);for(var symbols=$keys(wks.store),i=0;symbols.length>i;)wksDefine(symbols[i++]);$export($export.S+$export.F*!USE_NATIVE,'Symbol',{// 19.4.2.1 Symbol.for(key)
'for':function(key){return has(SymbolRegistry,key+='')?SymbolRegistry[key]:SymbolRegistry[key]=$Symbol(key);},// 19.4.2.5 Symbol.keyFor(sym)
keyFor:function keyFor(key){if(isSymbol(key))return keyOf(SymbolRegistry,key);throw TypeError(key+' is not a symbol!');},useSetter:function(){setter=true;},useSimple:function(){setter=false;}});$export($export.S+$export.F*!USE_NATIVE,'Object',{// 19.1.2.2 Object.create(O [, Properties])
create:$create,// 19.1.2.4 Object.defineProperty(O, P, Attributes)
defineProperty:$defineProperty,// 19.1.2.3 Object.defineProperties(O, Properties)
defineProperties:$defineProperties,// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
getOwnPropertyDescriptor:$getOwnPropertyDescriptor,// 19.1.2.7 Object.getOwnPropertyNames(O)
getOwnPropertyNames:$getOwnPropertyNames,// 19.1.2.8 Object.getOwnPropertySymbols(O)
getOwnPropertySymbols:$getOwnPropertySymbols});// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON&&$export($export.S+$export.F*(!USE_NATIVE||$fails(function(){var S=$Symbol();// MS Edge converts symbol values to JSON as {}
// WebKit converts symbol values to JSON as null
// V8 throws on boxed symbols
return _stringify([S])!='[null]'||_stringify({a:S})!='{}'||_stringify(Object(S))!='{}';})),'JSON',{stringify:function stringify(it){if(it===undefined||isSymbol(it))return;// IE8 returns string on undefined
var args=[it],i=1,replacer,$replacer;while(arguments.length>i)args.push(arguments[i++]);replacer=args[1];if(typeof replacer=='function')$replacer=replacer;if($replacer||!isArray(replacer))replacer=function(key,value){if($replacer)value=$replacer.call(this,key,value);if(!isSymbol(value))return value;};args[1]=replacer;return _stringify.apply($JSON,args);}});// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE]||__webpack_require__(22)($Symbol[PROTOTYPE],TO_PRIMITIVE,$Symbol[PROTOTYPE].valueOf);// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol,'Symbol');// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math,'Math',true);// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON,'JSON',true);/***/},/* 109 *//***/function(module,exports,__webpack_require__){var META=__webpack_require__(32)('meta'),isObject=__webpack_require__(26),has=__webpack_require__(18),setDesc=__webpack_require__(16).f,id=0;var isExtensible=Object.isExtensible||function(){return true;};var FREEZE=!__webpack_require__(27)(function(){return isExtensible(Object.preventExtensions({}));});var setMeta=function(it){setDesc(it,META,{value:{i:'O'+ ++id,// object ID
w:{}// weak collections IDs
}});};var fastKey=function(it,create){// return primitive with prefix
if(!isObject(it))return typeof it=='symbol'?it:(typeof it=='string'?'S':'P')+it;if(!has(it,META)){// can't set metadata to uncaught frozen object
if(!isExtensible(it))return'F';// not necessary to add metadata
if(!create)return'E';// add missing metadata
setMeta(it);// return object ID
}return it[META].i;};var getWeak=function(it,create){if(!has(it,META)){// can't set metadata to uncaught frozen object
if(!isExtensible(it))return true;// not necessary to add metadata
if(!create)return false;// add missing metadata
setMeta(it);// return hash weak collections IDs
}return it[META].w;};// add metadata on freeze-family methods calling
var onFreeze=function(it){if(FREEZE&&meta.NEED&&isExtensible(it)&&!has(it,META))setMeta(it);return it;};var meta=module.exports={KEY:META,NEED:false,fastKey:fastKey,getWeak:getWeak,onFreeze:onFreeze};/***/},/* 110 *//***/function(module,exports,__webpack_require__){var getKeys=__webpack_require__(25),toIObject=__webpack_require__(14);module.exports=function(object,el){var O=toIObject(object),keys=getKeys(O),length=keys.length,index=0,key;while(length>index)if(O[key=keys[index++]]===el)return key;};/***/},/* 111 *//***/function(module,exports,__webpack_require__){// all enumerable object keys, includes symbols
var getKeys=__webpack_require__(25),gOPS=__webpack_require__(68),pIE=__webpack_require__(53);module.exports=function(it){var result=getKeys(it),getSymbols=gOPS.f;if(getSymbols){var symbols=getSymbols(it),isEnum=pIE.f,i=0,key;while(symbols.length>i)if(isEnum.call(it,key=symbols[i++]))result.push(key);}return result;};/***/},/* 112 *//***/function(module,exports,__webpack_require__){// 7.2.2 IsArray(argument)
var cof=__webpack_require__(41);module.exports=Array.isArray||function isArray(arg){return cof(arg)=='Array';};/***/},/* 113 *//***/function(module,exports,__webpack_require__){// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject=__webpack_require__(14),gOPN=__webpack_require__(69).f,toString={}.toString;var windowNames=typeof window=='object'&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];var getWindowNames=function(it){try{return gOPN(it);}catch(e){return windowNames.slice();}};module.exports.f=function getOwnPropertyNames(it){return windowNames&&toString.call(it)=='[object Window]'?getWindowNames(it):gOPN(toIObject(it));};/***/},/* 114 *//***/function(module,exports){/***/},/* 115 *//***/function(module,exports,__webpack_require__){__webpack_require__(52)('asyncIterator');/***/},/* 116 *//***/function(module,exports,__webpack_require__){__webpack_require__(52)('observable');/***/},/* 117 *//***/function(module,exports,__webpack_require__){__webpack_require__(118);var $Object=__webpack_require__(11).Object;module.exports=function defineProperty(it,key,desc){return $Object.defineProperty(it,key,desc);};/***/},/* 118 *//***/function(module,exports,__webpack_require__){var $export=__webpack_require__(19);// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S+$export.F*!__webpack_require__(20),'Object',{defineProperty:__webpack_require__(16).f});/***/},/* 119 *//***/function(module,exports,__webpack_require__){module.exports={"default":__webpack_require__(120),__esModule:true};/***/},/* 120 *//***/function(module,exports,__webpack_require__){__webpack_require__(121);module.exports=__webpack_require__(11).Object.setPrototypeOf;/***/},/* 121 *//***/function(module,exports,__webpack_require__){// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export=__webpack_require__(19);$export($export.S,'Object',{setPrototypeOf:__webpack_require__(122).set});/***/},/* 122 *//***/function(module,exports,__webpack_require__){// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */var isObject=__webpack_require__(26),anObject=__webpack_require__(23);var check=function(O,proto){anObject(O);if(!isObject(proto)&&proto!==null)throw TypeError(proto+": can't set as prototype!");};module.exports={set:Object.setPrototypeOf||('__proto__'in{}?// eslint-disable-line
function(test,buggy,set){try{set=__webpack_require__(46)(Function.call,__webpack_require__(54).f(Object.prototype,'__proto__').set,2);set(test,[]);buggy=!(test instanceof Array);}catch(e){buggy=true;}return function setPrototypeOf(O,proto){check(O,proto);if(buggy)O.__proto__=proto;else set(O,proto);return O;};}({},false):undefined),check:check};/***/},/* 123 *//***/function(module,exports,__webpack_require__){__webpack_require__(124);var $Object=__webpack_require__(11).Object;module.exports=function create(P,D){return $Object.create(P,D);};/***/},/* 124 *//***/function(module,exports,__webpack_require__){var $export=__webpack_require__(19);// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S,'Object',{create:__webpack_require__(49)});/***/},/* 125 *//***/function(module,exports,__webpack_require__){module.exports={"default":__webpack_require__(126),__esModule:true};/***/},/* 126 *//***/function(module,exports,__webpack_require__){__webpack_require__(127);var $Object=__webpack_require__(11).Object;module.exports=function getOwnPropertyDescriptor(it,key){return $Object.getOwnPropertyDescriptor(it,key);};/***/},/* 127 *//***/function(module,exports,__webpack_require__){// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject=__webpack_require__(14),$getOwnPropertyDescriptor=__webpack_require__(54).f;__webpack_require__(62)('getOwnPropertyDescriptor',function(){return function getOwnPropertyDescriptor(it,key){return $getOwnPropertyDescriptor(toIObject(it),key);};});/***/},/* 128 *//***/function(module,exports,__webpack_require__){"use strict";// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
/**
 * Array.prototype.find
 *
 * Original source : https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/find
 * See also : https://tc39.github.io/ecma262/#sec-array.prototype.find
 */if(!Array.prototype.find){Object.defineProperty(Array.prototype,'find',{// Note: ES6 arrow function syntax is not used on purpose to avoid this to be undefined
value:function value(predicate){// 1. Let O be ? ToObject(this value).
if(this==null){throw new TypeError('"this" is null or not defined');}var o=Object(this);// 2. Let len be ? ToLength(? Get(O, "length")).
var len=o.length>>>0;// 3. If IsCallable(predicate) is false, throw a TypeError exception.
if(typeof predicate!=='function'){throw new TypeError('predicate must be a function');}// 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
var thisArg=arguments[1];// 5. Let k be 0.
var k=0;// 6. Repeat, while k < len
while(k<len){// a. Let Pk be ! ToString(k).
// b. Let kValue be ? Get(O, Pk).
// c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
// d. If testResult is true, return kValue.
var kValue=o[k];if(predicate.call(thisArg,kValue,k,o)){return kValue;}// e. Increase k by 1.
k++;}// 7. Return undefined.
return undefined;}});}/***/},/* 129 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _vendor=__webpack_require__(56);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var BOLD='font-weight: bold; font-size: 13px;';// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var INFO='color: #006600;'+BOLD;var DEBUG='color: #0000ff;'+BOLD;var WARN='color: #ff8000;'+BOLD;var ERROR='color: #ff0000;'+BOLD;var LEVEL_DEBUG=0;var LEVEL_INFO=1;var LEVEL_WARN=2;var LEVEL_ERROR=3;var LEVEL_DISABLED=LEVEL_ERROR;var COLORS=[DEBUG,INFO,WARN,ERROR,ERROR];var DESCRIPTIONS=['debug','info','warn','error','disabled'];var Log=function(){function Log(){var _this=this;var level=arguments.length>0&&arguments[0]!==undefined?arguments[0]:LEVEL_INFO;var offLevel=arguments.length>1&&arguments[1]!==undefined?arguments[1]:LEVEL_DISABLED;(0,_classCallCheck3.default)(this,Log);this.kibo=new _vendor.Kibo();this.kibo.down(['ctrl shift d'],function(){return _this.onOff();});this.BLACKLIST=['timeupdate','playback:timeupdate','playback:progress','container:hover','container:timeupdate','container:progress'];this.level=level;this.offLevel=offLevel;}Log.prototype.debug=function debug(klass){this.log(klass,LEVEL_DEBUG,Array.prototype.slice.call(arguments,1));};Log.prototype.info=function info(klass){this.log(klass,LEVEL_INFO,Array.prototype.slice.call(arguments,1));};Log.prototype.warn=function warn(klass){this.log(klass,LEVEL_WARN,Array.prototype.slice.call(arguments,1));};Log.prototype.error=function error(klass){this.log(klass,LEVEL_ERROR,Array.prototype.slice.call(arguments,1));};Log.prototype.onOff=function onOff(){if(this.level===this.offLevel){this.level=this.previousLevel;}else{this.previousLevel=this.level;this.level=this.offLevel;}// handle instances where console.log is unavailable
if(window.console&&window.console.log){window.console.log('%c[Clappr.Log] set log level to '+DESCRIPTIONS[this.level],WARN);}};Log.prototype.level=function level(newLevel){this.level=newLevel;};Log.prototype.log=function log(klass,level,message){if(this.BLACKLIST.indexOf(message[0])>=0)return;if(level<this.level)return;if(!message){message=klass;klass=null;}var color=COLORS[level];var klassDescription='';if(klass){klassDescription='['+klass+']';}if(window.console&&window.console.log){window.console.log.apply(console,['%c['+DESCRIPTIONS[level]+']'+klassDescription,color].concat(message));}};return Log;}();exports.default=Log;Log.LEVEL_DEBUG=LEVEL_DEBUG;Log.LEVEL_INFO=LEVEL_INFO;Log.LEVEL_WARN=LEVEL_WARN;Log.LEVEL_ERROR=LEVEL_ERROR;Log.getInstance=function(){if(this._instance===undefined){this._instance=new this();this._instance.previousLevel=this._instance.level;this._instance.level=this._instance.offLevel;}return this._instance;};Log.setLevel=function(level){this.getInstance().level=level;};Log.debug=function(){this.getInstance().debug.apply(this.getInstance(),arguments);};Log.info=function(){this.getInstance().info.apply(this.getInstance(),arguments);};Log.warn=function(){this.getInstance().warn.apply(this.getInstance(),arguments);};Log.error=function(){this.getInstance().error.apply(this.getInstance(),arguments);};module.exports=exports['default'];/***/},/* 130 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});/* eslint-disable */// Kibo is released under the MIT License. Copyright (c) 2013 marquete.
// see https://github.com/marquete/kibo
var Kibo=function Kibo(element){this.element=element||window.document;this.initialize();};Kibo.KEY_NAMES_BY_CODE={8:'backspace',9:'tab',13:'enter',16:'shift',17:'ctrl',18:'alt',20:'caps_lock',27:'esc',32:'space',37:'left',38:'up',39:'right',40:'down',48:'0',49:'1',50:'2',51:'3',52:'4',53:'5',54:'6',55:'7',56:'8',57:'9',65:'a',66:'b',67:'c',68:'d',69:'e',70:'f',71:'g',72:'h',73:'i',74:'j',75:'k',76:'l',77:'m',78:'n',79:'o',80:'p',81:'q',82:'r',83:'s',84:'t',85:'u',86:'v',87:'w',88:'x',89:'y',90:'z',112:'f1',113:'f2',114:'f3',115:'f4',116:'f5',117:'f6',118:'f7',119:'f8',120:'f9',121:'f10',122:'f11',123:'f12'};Kibo.KEY_CODES_BY_NAME={};(function(){for(var key in Kibo.KEY_NAMES_BY_CODE){if(Object.prototype.hasOwnProperty.call(Kibo.KEY_NAMES_BY_CODE,key)){Kibo.KEY_CODES_BY_NAME[Kibo.KEY_NAMES_BY_CODE[key]]=+key;}}})();Kibo.MODIFIERS=['shift','ctrl','alt'];Kibo.registerEvent=function(){if(document.addEventListener){return function(element,eventName,func){element.addEventListener(eventName,func,false);};}else if(document.attachEvent){return function(element,eventName,func){element.attachEvent('on'+eventName,func);};}}();Kibo.unregisterEvent=function(){if(document.removeEventListener){return function(element,eventName,func){element.removeEventListener(eventName,func,false);};}else if(document.detachEvent){return function(element,eventName,func){element.detachEvent('on'+eventName,func);};}}();Kibo.stringContains=function(string,substring){return string.indexOf(substring)!==-1;};Kibo.neatString=function(string){return string.replace(/^\s+|\s+$/g,'').replace(/\s+/g,' ');};Kibo.capitalize=function(string){return string.toLowerCase().replace(/^./,function(match){return match.toUpperCase();});};Kibo.isString=function(what){return Kibo.stringContains(Object.prototype.toString.call(what),'String');};Kibo.arrayIncludes=function(){if(Array.prototype.indexOf){return function(haystack,needle){return haystack.indexOf(needle)!==-1;};}else{return function(haystack,needle){for(var i=0;i<haystack.length;i++){if(haystack[i]===needle){return true;}}return false;};}}();Kibo.extractModifiers=function(keyCombination){var modifiers,i;modifiers=[];for(i=0;i<Kibo.MODIFIERS.length;i++){if(Kibo.stringContains(keyCombination,Kibo.MODIFIERS[i])){modifiers.push(Kibo.MODIFIERS[i]);}}return modifiers;};Kibo.extractKey=function(keyCombination){var keys,i;keys=Kibo.neatString(keyCombination).split(' ');for(i=0;i<keys.length;i++){if(!Kibo.arrayIncludes(Kibo.MODIFIERS,keys[i])){return keys[i];}}};Kibo.modifiersAndKey=function(keyCombination){var result,key;if(Kibo.stringContains(keyCombination,'any')){return Kibo.neatString(keyCombination).split(' ').slice(0,2).join(' ');}result=Kibo.extractModifiers(keyCombination);key=Kibo.extractKey(keyCombination);if(key&&!Kibo.arrayIncludes(Kibo.MODIFIERS,key)){result.push(key);}return result.join(' ');};Kibo.keyName=function(keyCode){return Kibo.KEY_NAMES_BY_CODE[keyCode+''];};Kibo.keyCode=function(keyName){return+Kibo.KEY_CODES_BY_NAME[keyName];};Kibo.prototype.initialize=function(){var i,that=this;this.lastKeyCode=-1;this.lastModifiers={};for(i=0;i<Kibo.MODIFIERS.length;i++){this.lastModifiers[Kibo.MODIFIERS[i]]=false;}this.keysDown={any:[]};this.keysUp={any:[]};this.downHandler=this.handler('down');this.upHandler=this.handler('up');Kibo.registerEvent(this.element,'keydown',this.downHandler);Kibo.registerEvent(this.element,'keyup',this.upHandler);Kibo.registerEvent(window,'unload',function unloader(){Kibo.unregisterEvent(that.element,'keydown',that.downHandler);Kibo.unregisterEvent(that.element,'keyup',that.upHandler);Kibo.unregisterEvent(window,'unload',unloader);});};Kibo.prototype.handler=function(upOrDown){var that=this;return function(e){var i,registeredKeys,lastModifiersAndKey;e=e||window.event;that.lastKeyCode=e.keyCode;for(i=0;i<Kibo.MODIFIERS.length;i++){that.lastModifiers[Kibo.MODIFIERS[i]]=e[Kibo.MODIFIERS[i]+'Key'];}if(Kibo.arrayIncludes(Kibo.MODIFIERS,Kibo.keyName(that.lastKeyCode))){that.lastModifiers[Kibo.keyName(that.lastKeyCode)]=true;}registeredKeys=that['keys'+Kibo.capitalize(upOrDown)];for(i=0;i<registeredKeys.any.length;i++){if(registeredKeys.any[i](e)===false&&e.preventDefault){e.preventDefault();}}lastModifiersAndKey=that.lastModifiersAndKey();if(registeredKeys[lastModifiersAndKey]){for(i=0;i<registeredKeys[lastModifiersAndKey].length;i++){if(registeredKeys[lastModifiersAndKey][i](e)===false&&e.preventDefault){e.preventDefault();}}}};};Kibo.prototype.registerKeys=function(upOrDown,newKeys,func){var i,keys,registeredKeys=this['keys'+Kibo.capitalize(upOrDown)];if(Kibo.isString(newKeys)){newKeys=[newKeys];}for(i=0;i<newKeys.length;i++){keys=newKeys[i];keys=Kibo.modifiersAndKey(keys+'');if(registeredKeys[keys]){registeredKeys[keys].push(func);}else{registeredKeys[keys]=[func];}}return this;};// jshint maxdepth:5
Kibo.prototype.unregisterKeys=function(upOrDown,newKeys,func){var i,j,keys,registeredKeys=this['keys'+Kibo.capitalize(upOrDown)];if(Kibo.isString(newKeys)){newKeys=[newKeys];}for(i=0;i<newKeys.length;i++){keys=newKeys[i];keys=Kibo.modifiersAndKey(keys+'');if(func===null){delete registeredKeys[keys];}else{if(registeredKeys[keys]){for(j=0;j<registeredKeys[keys].length;j++){if(String(registeredKeys[keys][j])===String(func)){registeredKeys[keys].splice(j,1);break;}}}}}return this;};Kibo.prototype.off=function(keys){return this.unregisterKeys('down',keys,null);};Kibo.prototype.delegate=function(upOrDown,keys,func){return func!==null||func!==undefined?this.registerKeys(upOrDown,keys,func):this.unregisterKeys(upOrDown,keys,func);};Kibo.prototype.down=function(keys,func){return this.delegate('down',keys,func);};Kibo.prototype.up=function(keys,func){return this.delegate('up',keys,func);};Kibo.prototype.lastKey=function(modifier){if(!modifier){return Kibo.keyName(this.lastKeyCode);}return this.lastModifiers[modifier];};Kibo.prototype.lastModifiersAndKey=function(){var result,i;result=[];for(i=0;i<Kibo.MODIFIERS.length;i++){if(this.lastKey(Kibo.MODIFIERS[i])){result.push(Kibo.MODIFIERS[i]);}}if(!Kibo.arrayIncludes(result,this.lastKey())){result.push(this.lastKey());}return result.join(' ');};exports.default=Kibo;module.exports=exports['default'];/***/},/* 131 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _core_factory=__webpack_require__(132);var _core_factory2=_interopRequireDefault(_core_factory);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_core_factory2.default;module.exports=exports['default'];/***/},/* 132 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _base_object=__webpack_require__(17);var _base_object2=_interopRequireDefault(_base_object);var _core=__webpack_require__(72);var _core2=_interopRequireDefault(_core);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * The Core Factory is responsible for instantiate the core and it's plugins.
 * @class CoreFactory
 * @constructor
 * @extends BaseObject
 * @module components
 */// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var CoreFactory=function(_BaseObject){(0,_inherits3.default)(CoreFactory,_BaseObject);(0,_createClass3.default)(CoreFactory,[{key:'loader',get:function get(){return this.player.loader;}/**
     * it builds the core factory
     * @method constructor
     * @param {Player} player the player object
     */}]);function CoreFactory(player){(0,_classCallCheck3.default)(this,CoreFactory);var _this=(0,_possibleConstructorReturn3.default)(this,_BaseObject.call(this));_this.player=player;_this._options=player.options;return _this;}/**
   * creates a core and its plugins
   * @method create
   * @return {Core} created core
   */CoreFactory.prototype.create=function create(){this.options.loader=this.loader;this.core=new _core2.default(this.options);this.addCorePlugins();this.core.createContainers(this.options);return this.core;};/**
   * given the core plugins (`loader.corePlugins`) it builds each one
   * @method addCorePlugins
   * @return {Core} the core with all plugins
   */CoreFactory.prototype.addCorePlugins=function addCorePlugins(){var _this2=this;this.loader.corePlugins.forEach(function(Plugin){var plugin=new Plugin(_this2.core);_this2.core.addPlugin(plugin);_this2.setupExternalInterface(plugin);});return this.core;};CoreFactory.prototype.setupExternalInterface=function setupExternalInterface(plugin){var externalFunctions=plugin.getExternalInterface();for(var key in externalFunctions){this.player[key]=externalFunctions[key].bind(plugin);}};return CoreFactory;}(_base_object2.default);exports.default=CoreFactory;module.exports=exports['default'];/***/},/* 133 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _utils=__webpack_require__(5);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _ui_object=__webpack_require__(21);var _ui_object2=_interopRequireDefault(_ui_object);var _browser=__webpack_require__(13);var _browser2=_interopRequireDefault(_browser);var _container_factory=__webpack_require__(134);var _container_factory2=_interopRequireDefault(_container_factory);var _media_control=__webpack_require__(74);var _media_control2=_interopRequireDefault(_media_control);var _mediator=__webpack_require__(24);var _mediator2=_interopRequireDefault(_mediator);var _player_info=__webpack_require__(34);var _player_info2=_interopRequireDefault(_player_info);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);var _style=__webpack_require__(149);var _style2=_interopRequireDefault(_style);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * The Core is responsible to manage Containers, the mediator, MediaControl
 * and the player state.
 * @class Core
 * @constructor
 * @extends UIObject
 * @module components
 */var Core=function(_UIObject){(0,_inherits3.default)(Core,_UIObject);(0,_createClass3.default)(Core,[{key:'events',get:function get(){return{'webkitfullscreenchange':'handleFullscreenChange','mousemove':'showMediaControl','mouseleave':'hideMediaControl'};}},{key:'attributes',get:function get(){return{'data-player':'',tabindex:9999};}/**
     * checks if the core is ready.
     * @property isReady
     * @type {Boolean} `true` if the core is ready, otherwise `false`
     */},{key:'isReady',get:function get(){return!!this.ready;}/**
     * The internationalization plugin.
     * @property i18n
     * @type {Strings}
     */},{key:'i18n',get:function get(){return this.getPlugin('strings')||{t:function t(key){return key;}};}}]);function Core(options){(0,_classCallCheck3.default)(this,Core);var _this=(0,_possibleConstructorReturn3.default)(this,_UIObject.call(this,options));_this.configureDomRecycler();_this.playerInfo=_player_info2.default.getInstance(options.playerId);_this.firstResize=true;_this.plugins=[];_this.containers=[];_this.setupMediaControl(null);//FIXME fullscreen api sucks
_this._boundFullscreenHandler=function(){return _this.handleFullscreenChange();};(0,_clapprZepto2.default)(document).bind('fullscreenchange',_this._boundFullscreenHandler);(0,_clapprZepto2.default)(document).bind('MSFullscreenChange',_this._boundFullscreenHandler);(0,_clapprZepto2.default)(document).bind('mozfullscreenchange',_this._boundFullscreenHandler);_browser2.default.isMobile&&(0,_clapprZepto2.default)(window).bind('resize',function(o){_this.handleWindowResize(o);});return _this;}Core.prototype.configureDomRecycler=function configureDomRecycler(){var recycleVideo=this.options&&this.options.playback&&this.options.playback.recycleVideo?true:false;_utils.DomRecycler.configure({recycleVideo:recycleVideo});};Core.prototype.createContainers=function createContainers(options){var _this2=this;this.defer=_clapprZepto2.default.Deferred();this.defer.promise(this);this.containerFactory=new _container_factory2.default(options,options.loader,this.i18n);this.containerFactory.createContainers().then(function(containers){return _this2.setupContainers(containers);}).then(function(containers){return _this2.resolveOnContainersReady(containers);});};Core.prototype.updateSize=function updateSize(){if(_utils.Fullscreen.isFullscreen()){this.setFullscreen();}else{this.setPlayerSize();}};Core.prototype.setFullscreen=function setFullscreen(){if(!_browser2.default.isiOS){this.$el.addClass('fullscreen');this.$el.removeAttr('style');this.playerInfo.previousSize={width:this.options.width,height:this.options.height};this.playerInfo.currentSize={width:(0,_clapprZepto2.default)(window).width(),height:(0,_clapprZepto2.default)(window).height()};}};Core.prototype.setPlayerSize=function setPlayerSize(){this.$el.removeClass('fullscreen');this.playerInfo.currentSize=this.playerInfo.previousSize;this.playerInfo.previousSize={width:(0,_clapprZepto2.default)(window).width(),height:(0,_clapprZepto2.default)(window).height()};this.resize(this.playerInfo.currentSize);};Core.prototype.resize=function resize(options){if(!(0,_utils.isNumber)(options.height)&&!(0,_utils.isNumber)(options.width)){this.el.style.height=''+options.height;this.el.style.width=''+options.width;}else{this.el.style.height=options.height+'px';this.el.style.width=options.width+'px';}this.playerInfo.previousSize={width:this.options.width,height:this.options.height};this.options.width=options.width;this.options.height=options.height;this.playerInfo.currentSize=options;this.triggerResize(this.playerInfo.currentSize);};Core.prototype.enableResizeObserver=function enableResizeObserver(){var _this3=this;var checkSizeCallback=function checkSizeCallback(){if(_this3.playerInfo.computedSize.width!=_this3.el.clientWidth||_this3.playerInfo.computedSize.height!=_this3.el.clientHeight){_this3.playerInfo.computedSize={width:_this3.el.clientWidth,height:_this3.el.clientHeight};_this3.triggerResize(_this3.playerInfo.computedSize);}};this.resizeObserverInterval=setInterval(checkSizeCallback,500);};Core.prototype.triggerResize=function triggerResize(newSize){var thereWasChange=this.firstResize||this.oldHeight!==newSize.height||this.oldWidth!==newSize.width;if(thereWasChange){_mediator2.default.trigger(this.options.playerId+':'+_events2.default.PLAYER_RESIZE,newSize);this.oldHeight=newSize.height;this.oldWidth=newSize.width;this.firstResize=false;}};Core.prototype.disableResizeObserver=function disableResizeObserver(){if(this.resizeObserverInterval)clearInterval(this.resizeObserverInterval);};Core.prototype.resolveOnContainersReady=function resolveOnContainersReady(containers){var _this4=this;_clapprZepto2.default.when.apply(_clapprZepto2.default,containers).done(function(){_this4.defer.resolve(_this4);_this4.ready=true;_this4.trigger(_events2.default.CORE_READY);});};Core.prototype.addPlugin=function addPlugin(plugin){this.plugins.push(plugin);};Core.prototype.hasPlugin=function hasPlugin(name){return!!this.getPlugin(name);};Core.prototype.getPlugin=function getPlugin(name){return this.plugins.filter(function(plugin){return plugin.name===name;})[0];};Core.prototype.load=function load(sources,mimeType){var _this5=this;this.options.mimeType=mimeType;sources=sources&&sources.constructor===Array?sources:[sources];this.containers.forEach(function(container){return container.destroy();});this.mediaControl.container=null;this.containerFactory.options=_clapprZepto2.default.extend(this.options,{sources:sources});this.containerFactory.createContainers().then(function(containers){_this5.setupContainers(containers);});};Core.prototype.destroy=function destroy(){this.disableResizeObserver();this.containers.forEach(function(container){return container.destroy();});this.plugins.forEach(function(plugin){return plugin.destroy();});this.$el.remove();this.mediaControl.destroy();(0,_clapprZepto2.default)(document).unbind('fullscreenchange',this._boundFullscreenHandler);(0,_clapprZepto2.default)(document).unbind('MSFullscreenChange',this._boundFullscreenHandler);(0,_clapprZepto2.default)(document).unbind('mozfullscreenchange',this._boundFullscreenHandler);};Core.prototype.handleFullscreenChange=function handleFullscreenChange(){this.trigger(_events2.default.CORE_FULLSCREEN,_utils.Fullscreen.isFullscreen());this.updateSize();this.mediaControl.show();};Core.prototype.handleWindowResize=function handleWindowResize(event){var orientation=(0,_clapprZepto2.default)(window).width()>(0,_clapprZepto2.default)(window).height()?'landscape':'portrait';if(this._screenOrientation===orientation)return;this._screenOrientation=orientation;this.trigger(_events2.default.CORE_SCREEN_ORIENTATION_CHANGED,{event:event,orientation:this._screenOrientation});};Core.prototype.setMediaControlContainer=function setMediaControlContainer(container){this.mediaControl.setContainer(container);this.mediaControl.render();};Core.prototype.disableMediaControl=function disableMediaControl(){this.mediaControl.disable();this.$el.removeClass('nocursor');};Core.prototype.enableMediaControl=function enableMediaControl(){this.mediaControl.enable();};Core.prototype.removeContainer=function removeContainer(container){this.stopListening(container);this.containers=this.containers.filter(function(c){return c!==container;});};Core.prototype.appendContainer=function appendContainer(container){this.listenTo(container,_events2.default.CONTAINER_DESTROYED,this.removeContainer);this.containers.push(container);};Core.prototype.setupContainers=function setupContainers(containers){containers.map(this.appendContainer.bind(this));this.trigger(_events2.default.CORE_CONTAINERS_CREATED);this.renderContainers();this.setupMediaControl(this.getCurrentContainer());this.render();this.$el.appendTo(this.options.parentElement);return this.containers;};Core.prototype.renderContainers=function renderContainers(){var _this6=this;this.containers.map(function(container){return _this6.el.appendChild(container.render().el);});};Core.prototype.createContainer=function createContainer(source,options){var container=this.containerFactory.createContainer(source,options);this.appendContainer(container);this.el.appendChild(container.render().el);return container;};Core.prototype.setupMediaControl=function setupMediaControl(container){if(this.mediaControl){this.mediaControl.setContainer(container);}else{this.mediaControl=this.createMediaControl(_clapprZepto2.default.extend({container:container,focusElement:this.el},this.options));this.listenTo(this.mediaControl,_events2.default.MEDIACONTROL_FULLSCREEN,this.toggleFullscreen);this.listenTo(this.mediaControl,_events2.default.MEDIACONTROL_SHOW,this.onMediaControlShow.bind(this,true));this.listenTo(this.mediaControl,_events2.default.MEDIACONTROL_HIDE,this.onMediaControlShow.bind(this,false));}};Core.prototype.createMediaControl=function createMediaControl(options){if(options.mediacontrol&&options.mediacontrol.external){return new options.mediacontrol.external(options).render();}else{return new _media_control2.default(options).render();}};Core.prototype.getCurrentContainer=function getCurrentContainer(){if(!this.mediaControl||!this.mediaControl.container){return this.containers[0];}return this.mediaControl.container;};Core.prototype.getCurrentPlayback=function getCurrentPlayback(){var container=this.getCurrentContainer();return container&&container.playback;};Core.prototype.getPlaybackType=function getPlaybackType(){var container=this.getCurrentContainer();return container&&container.getPlaybackType();};Core.prototype.toggleFullscreen=function toggleFullscreen(){if(!_utils.Fullscreen.isFullscreen()){_utils.Fullscreen.requestFullscreen(this.el);if(!_browser2.default.isiOS){this.$el.addClass('fullscreen');}}else{_utils.Fullscreen.cancelFullscreen();if(!_browser2.default.isiOS){this.$el.removeClass('fullscreen nocursor');}}this.mediaControl.show();};Core.prototype.showMediaControl=function showMediaControl(event){this.mediaControl.show(event);};Core.prototype.hideMediaControl=function hideMediaControl(){this.mediaControl.hide(this.options.hideMediaControlDelay);};Core.prototype.onMediaControlShow=function onMediaControlShow(showing){this.getCurrentContainer().trigger(showing?_events2.default.CONTAINER_MEDIACONTROL_SHOW:_events2.default.CONTAINER_MEDIACONTROL_HIDE);if(showing)this.$el.removeClass('nocursor');else if(_utils.Fullscreen.isFullscreen())this.$el.addClass('nocursor');};/**
   * enables to configure the container after its creation
   * @method configure
   * @param {Object} options all the options to change in form of a javascript object
   */Core.prototype.configure=function configure(options){var _this7=this;this._options=_clapprZepto2.default.extend(this._options,options);this.configureDomRecycler();var sources=options.source||options.sources;if(sources){this.load(sources,options.mimeType||this.options.mimeType);}else{this.trigger(_events2.default.CORE_OPTIONS_CHANGE);this.containers.forEach(function(container){container.configure(_this7.options);});}};Core.prototype.render=function render(){this.$style&&this.$style.remove();this.$style=_styler2.default.getStyleFor(_style2.default,{baseUrl:this.options.baseUrl});this.$el.append(this.$style);this.$el.append(this.mediaControl.render().el);this.options.width=this.options.width||this.$el.width();this.options.height=this.options.height||this.$el.height();var size={width:this.options.width,height:this.options.height};this.playerInfo.previousSize=this.playerInfo.currentSize=this.playerInfo.computedSize=size;this.updateSize();this.previousSize={width:this.$el.width(),height:this.$el.height()};this.enableResizeObserver();return this;};return Core;}(_ui_object2.default);// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
exports.default=Core;module.exports=exports['default'];/***/},/* 134 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _container_factory=__webpack_require__(135);var _container_factory2=_interopRequireDefault(_container_factory);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_container_factory2.default;module.exports=exports['default'];/***/},/* 135 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _typeof2=__webpack_require__(33);var _typeof3=_interopRequireDefault(_typeof2);var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _base_object=__webpack_require__(17);var _base_object2=_interopRequireDefault(_base_object);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _container=__webpack_require__(73);var _container2=_interopRequireDefault(_container);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
/**
 * The ContainerFactory is responsible for manage playback bootstrap and create containers.
 */var ContainerFactory=function(_BaseObject){(0,_inherits3.default)(ContainerFactory,_BaseObject);(0,_createClass3.default)(ContainerFactory,[{key:'options',get:function get(){return this._options;},set:function set(options){this._options=options;}}]);function ContainerFactory(options,loader,i18n){(0,_classCallCheck3.default)(this,ContainerFactory);var _this=(0,_possibleConstructorReturn3.default)(this,_BaseObject.call(this,options));_this._i18n=i18n;_this.loader=loader;return _this;}ContainerFactory.prototype.createContainers=function createContainers(){var _this2=this;return _clapprZepto2.default.Deferred(function(promise){promise.resolve(_this2.options.sources.map(function(source){return _this2.createContainer(source);}));});};ContainerFactory.prototype.findPlaybackPlugin=function findPlaybackPlugin(source,mimeType){return this.loader.playbackPlugins.filter(function(p){return p.canPlay(source,mimeType);})[0];};ContainerFactory.prototype.createContainer=function createContainer(source){var resolvedSource=null,mimeType=this.options.mimeType;if((typeof source==='undefined'?'undefined':(0,_typeof3.default)(source))==='object'){resolvedSource=source.source.toString();if(source.mimeType){mimeType=source.mimeType;}}else{resolvedSource=source.toString();}if(resolvedSource.match(/^\/\//))resolvedSource=window.location.protocol+resolvedSource;var options=_clapprZepto2.default.extend({},this.options,{src:resolvedSource,mimeType:mimeType});var playbackPlugin=this.findPlaybackPlugin(resolvedSource,mimeType);var playback=new playbackPlugin(options,this._i18n);options=_clapprZepto2.default.extend({},options,{playback:playback});var container=new _container2.default(options,this._i18n);var defer=_clapprZepto2.default.Deferred();defer.promise(container);this.addContainerPlugins(container);this.listenToOnce(container,_events2.default.CONTAINER_READY,function(){return defer.resolve(container);});return container;};ContainerFactory.prototype.addContainerPlugins=function addContainerPlugins(container){this.loader.containerPlugins.forEach(function(Plugin){container.addPlugin(new Plugin(container));});};return ContainerFactory;}(_base_object2.default);exports.default=ContainerFactory;module.exports=exports['default'];/***/},/* 136 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _ui_object=__webpack_require__(21);var _ui_object2=_interopRequireDefault(_ui_object);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _style=__webpack_require__(137);var _style2=_interopRequireDefault(_style);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * An abstraction to represent a container for a given playback
 * TODO: describe its responsabilities
 * @class Container
 * @constructor
 * @extends UIObject
 * @module base
 */var Container=function(_UIObject){(0,_inherits3.default)(Container,_UIObject);(0,_createClass3.default)(Container,[{key:'name',/**
     * container's name
     * @method name
     * @default Container
     * @return {String} container's name
     */get:function get(){return'Container';}},{key:'attributes',get:function get(){return{class:'container','data-container':''};}},{key:'events',get:function get(){return{'click':'clicked','dblclick':'dblClicked','doubleTap':'dblClicked','contextmenu':'onContextMenu','mouseenter':'mouseEnter','mouseleave':'mouseLeave'};}/**
     * Determine if the playback has ended.
     * @property ended
     * @type Boolean
     */},{key:'ended',get:function get(){return this.playback.ended;}/**
     * Determine if the playback is having to buffer in order for
     * playback to be smooth.
     * (i.e if a live stream is playing smoothly, this will be false)
     * @property buffering
     * @type Boolean
     */},{key:'buffering',get:function get(){return this.playback.buffering;}/**
     * The internationalization plugin.
     * @property i18n
     * @type {Strings}
     */},{key:'i18n',get:function get(){return this._i18n;}/**
     * checks if has closed caption tracks.
     * @property hasClosedCaptionsTracks
     * @type {Boolean}
     */},{key:'hasClosedCaptionsTracks',get:function get(){return this.playback.hasClosedCaptionsTracks;}/**
     * gets the available closed caption tracks.
     * @property closedCaptionsTracks
     * @type {Array} an array of objects with at least 'id' and 'name' properties
     */},{key:'closedCaptionsTracks',get:function get(){return this.playback.closedCaptionsTracks;}/**
     * gets the selected closed caption track index. (-1 is disabled)
     * @property closedCaptionsTrackId
     * @type {Number}
     */},{key:'closedCaptionsTrackId',get:function get(){return this.playback.closedCaptionsTrackId;}/**
     * sets the selected closed caption track index. (-1 is disabled)
     * @property closedCaptionsTrackId
     * @type {Number}
     */,set:function set(trackId){this.playback.closedCaptionsTrackId=trackId;}/**
     * it builds a container
     * @method constructor
     * @param {Object} options the options object
     * @param {Strings} i18n the internationalization component
     */}]);function Container(options,i18n){(0,_classCallCheck3.default)(this,Container);var _this=(0,_possibleConstructorReturn3.default)(this,_UIObject.call(this,options));_this._i18n=i18n;_this.currentTime=0;_this.volume=100;_this.playback=options.playback;_this.settings=_clapprZepto2.default.extend({},_this.playback.settings);_this.isReady=false;_this.mediaControlDisabled=false;_this.plugins=[_this.playback];_this.bindEvents();return _this;}/**
   * binds playback events to the methods of the container.
   * it listens to playback's events and triggers them as container events.
   *
   * | Playback |
   * |----------|
   * | progress |
   * | timeupdate |
   * | ready |
   * | buffering |
   * | bufferfull |
   * | settingsupdate |
   * | loadedmetadata |
   * | highdefinitionupdate |
   * | bitrate |
   * | playbackstate |
   * | dvr |
   * | mediacontrol_disable |
   * | mediacontrol_enable |
   * | ended |
   * | play |
   * | pause |
   * | error |
   *
   * ps: the events usually translate from PLABACK_x to CONTAINER_x, you can check all the events at `Event` class.
   *
   * @method bindEvents
   */Container.prototype.bindEvents=function bindEvents(){this.listenTo(this.playback,_events2.default.PLAYBACK_PROGRESS,this.progress);this.listenTo(this.playback,_events2.default.PLAYBACK_TIMEUPDATE,this.timeUpdated);this.listenTo(this.playback,_events2.default.PLAYBACK_READY,this.ready);this.listenTo(this.playback,_events2.default.PLAYBACK_BUFFERING,this.onBuffering);this.listenTo(this.playback,_events2.default.PLAYBACK_BUFFERFULL,this.bufferfull);this.listenTo(this.playback,_events2.default.PLAYBACK_SETTINGSUPDATE,this.settingsUpdate);this.listenTo(this.playback,_events2.default.PLAYBACK_LOADEDMETADATA,this.loadedMetadata);this.listenTo(this.playback,_events2.default.PLAYBACK_HIGHDEFINITIONUPDATE,this.highDefinitionUpdate);this.listenTo(this.playback,_events2.default.PLAYBACK_BITRATE,this.updateBitrate);this.listenTo(this.playback,_events2.default.PLAYBACK_PLAYBACKSTATE,this.playbackStateChanged);this.listenTo(this.playback,_events2.default.PLAYBACK_DVR,this.playbackDvrStateChanged);this.listenTo(this.playback,_events2.default.PLAYBACK_MEDIACONTROL_DISABLE,this.disableMediaControl);this.listenTo(this.playback,_events2.default.PLAYBACK_MEDIACONTROL_ENABLE,this.enableMediaControl);this.listenTo(this.playback,_events2.default.PLAYBACK_ENDED,this.onEnded);this.listenTo(this.playback,_events2.default.PLAYBACK_PLAY,this.playing);this.listenTo(this.playback,_events2.default.PLAYBACK_PAUSE,this.paused);this.listenTo(this.playback,_events2.default.PLAYBACK_STOP,this.stopped);this.listenTo(this.playback,_events2.default.PLAYBACK_ERROR,this.error);this.listenTo(this.playback,_events2.default.PLAYBACK_SUBTITLE_AVAILABLE,this.subtitleAvailable);this.listenTo(this.playback,_events2.default.PLAYBACK_SUBTITLE_CHANGED,this.subtitleChanged);};Container.prototype.subtitleAvailable=function subtitleAvailable(){this.trigger(_events2.default.CONTAINER_SUBTITLE_AVAILABLE);};Container.prototype.subtitleChanged=function subtitleChanged(track){this.trigger(_events2.default.CONTAINER_SUBTITLE_CHANGED,track);};Container.prototype.playbackStateChanged=function playbackStateChanged(state){this.trigger(_events2.default.CONTAINER_PLAYBACKSTATE,state);};Container.prototype.playbackDvrStateChanged=function playbackDvrStateChanged(dvrInUse){this.settings=this.playback.settings;this.dvrInUse=dvrInUse;this.trigger(_events2.default.CONTAINER_PLAYBACKDVRSTATECHANGED,dvrInUse);};Container.prototype.updateBitrate=function updateBitrate(newBitrate){this.trigger(_events2.default.CONTAINER_BITRATE,newBitrate);};Container.prototype.statsReport=function statsReport(metrics){this.trigger(_events2.default.CONTAINER_STATS_REPORT,metrics);};Container.prototype.getPlaybackType=function getPlaybackType(){return this.playback.getPlaybackType();};/**
   * returns `true` if DVR is enable otherwise `false`.
   * @method isDvrEnabled
   * @return {Boolean}
   */Container.prototype.isDvrEnabled=function isDvrEnabled(){return!!this.playback.dvrEnabled;};/**
   * returns `true` if DVR is in use otherwise `false`.
   * @method isDvrInUse
   * @return {Boolean}
   */Container.prototype.isDvrInUse=function isDvrInUse(){return!!this.dvrInUse;};/**
   * destroys the container
   * @method destroy
   */Container.prototype.destroy=function destroy(){this.trigger(_events2.default.CONTAINER_DESTROYED,this,this.name);this.stopListening();this.plugins.forEach(function(plugin){return plugin.destroy();});this.$el.remove();};Container.prototype.setStyle=function setStyle(style){this.$el.css(style);};Container.prototype.animate=function animate(style,duration){return this.$el.animate(style,duration).promise();};Container.prototype.ready=function ready(){this.isReady=true;this.trigger(_events2.default.CONTAINER_READY,this.name);};Container.prototype.isPlaying=function isPlaying(){return this.playback.isPlaying();};Container.prototype.getStartTimeOffset=function getStartTimeOffset(){return this.playback.getStartTimeOffset();};Container.prototype.getCurrentTime=function getCurrentTime(){return this.currentTime;};Container.prototype.getDuration=function getDuration(){return this.playback.getDuration();};Container.prototype.error=function error(errorObj){if(!this.isReady){this.ready();}this.trigger(_events2.default.CONTAINER_ERROR,{error:errorObj,container:this},this.name);};Container.prototype.loadedMetadata=function loadedMetadata(metadata){this.trigger(_events2.default.CONTAINER_LOADEDMETADATA,metadata);};Container.prototype.timeUpdated=function timeUpdated(timeProgress){this.currentTime=timeProgress.current;this.trigger(_events2.default.CONTAINER_TIMEUPDATE,timeProgress,this.name);};Container.prototype.progress=function progress(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}this.trigger.apply(this,[_events2.default.CONTAINER_PROGRESS].concat(args,[this.name]));};Container.prototype.playing=function playing(){this.trigger(_events2.default.CONTAINER_PLAY,this.name);};Container.prototype.paused=function paused(){this.trigger(_events2.default.CONTAINER_PAUSE,this.name);};/**
   * plays the playback
   * @method play
   */Container.prototype.play=function play(){this.playback.play();};/**
   * stops the playback
   * @method stop
   */Container.prototype.stop=function stop(){this.playback.stop();this.currentTime=0;};/**
   * pauses the playback
   * @method pause
   */Container.prototype.pause=function pause(){this.playback.pause();};Container.prototype.onEnded=function onEnded(){this.trigger(_events2.default.CONTAINER_ENDED,this,this.name);this.currentTime=0;};Container.prototype.stopped=function stopped(){this.trigger(_events2.default.CONTAINER_STOP);};Container.prototype.clicked=function clicked(){if(!this.options.chromeless||this.options.allowUserInteraction){this.trigger(_events2.default.CONTAINER_CLICK,this,this.name);}};Container.prototype.dblClicked=function dblClicked(){if(!this.options.chromeless||this.options.allowUserInteraction){this.trigger(_events2.default.CONTAINER_DBLCLICK,this,this.name);}};Container.prototype.onContextMenu=function onContextMenu(event){if(!this.options.chromeless||this.options.allowUserInteraction){this.trigger(_events2.default.CONTAINER_CONTEXTMENU,event,this.name);}};Container.prototype.seek=function seek(time){this.trigger(_events2.default.CONTAINER_SEEK,time,this.name);this.playback.seek(time);};Container.prototype.seekPercentage=function seekPercentage(percentage){var duration=this.getDuration();if(percentage>=0&&percentage<=100){var time=duration*(percentage/100);this.seek(time);}};Container.prototype.setVolume=function setVolume(value){this.volume=parseInt(value,10);this.trigger(_events2.default.CONTAINER_VOLUME,value,this.name);this.playback.volume(value);};Container.prototype.fullscreen=function fullscreen(){this.trigger(_events2.default.CONTAINER_FULLSCREEN,this.name);};Container.prototype.onBuffering=function onBuffering(){this.trigger(_events2.default.CONTAINER_STATE_BUFFERING,this.name);};Container.prototype.bufferfull=function bufferfull(){this.trigger(_events2.default.CONTAINER_STATE_BUFFERFULL,this.name);};/**
   * adds plugin to the container
   * @method addPlugin
   * @param {Object} plugin
   */Container.prototype.addPlugin=function addPlugin(plugin){this.plugins.push(plugin);};/**
   * checks if a plugin, given its name, exist
   * @method hasPlugin
   * @param {String} name
   * @return {Boolean}
   */Container.prototype.hasPlugin=function hasPlugin(name){return!!this.getPlugin(name);};/**
   * get the plugin given its name
   * @method getPlugin
   * @param {String} name
   */Container.prototype.getPlugin=function getPlugin(name){return this.plugins.filter(function(plugin){return plugin.name===name;})[0];};Container.prototype.mouseEnter=function mouseEnter(){if(!this.options.chromeless||this.options.allowUserInteraction){this.trigger(_events2.default.CONTAINER_MOUSE_ENTER);}};Container.prototype.mouseLeave=function mouseLeave(){if(!this.options.chromeless||this.options.allowUserInteraction){this.trigger(_events2.default.CONTAINER_MOUSE_LEAVE);}};Container.prototype.settingsUpdate=function settingsUpdate(){this.settings=this.playback.settings;this.trigger(_events2.default.CONTAINER_SETTINGSUPDATE);};Container.prototype.highDefinitionUpdate=function highDefinitionUpdate(isHD){this.trigger(_events2.default.CONTAINER_HIGHDEFINITIONUPDATE,isHD);};Container.prototype.isHighDefinitionInUse=function isHighDefinitionInUse(){return this.playback.isHighDefinitionInUse();};Container.prototype.disableMediaControl=function disableMediaControl(){if(!this.mediaControlDisabled){this.mediaControlDisabled=true;this.trigger(_events2.default.CONTAINER_MEDIACONTROL_DISABLE);}};Container.prototype.enableMediaControl=function enableMediaControl(){if(this.mediaControlDisabled){this.mediaControlDisabled=false;this.trigger(_events2.default.CONTAINER_MEDIACONTROL_ENABLE);}};Container.prototype.updateStyle=function updateStyle(){if(!this.options.chromeless||this.options.allowUserInteraction){this.$el.removeClass('chromeless');}else{this.$el.addClass('chromeless');}};/**
   * enables to configure the container after its creation
   * @method configure
   * @param {Object} options all the options to change in form of a javascript object
   */Container.prototype.configure=function configure(options){this._options=_clapprZepto2.default.extend(this._options,options);this.updateStyle();this.trigger(_events2.default.CONTAINER_OPTIONS_CHANGE);};Container.prototype.render=function render(){var s=_styler2.default.getStyleFor(_style2.default);this.$el.append(s);this.$el.append(this.playback.render().el);this.updateStyle();return this;};return Container;}(_ui_object2.default);// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
/**
 * Container is responsible for the video rendering and state
 */exports.default=Container;module.exports=exports['default'];/***/},/* 137 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,".container[data-container] {\n  position: absolute;\n  background-color: black;\n  height: 100%;\n  width: 100%; }\n  .container[data-container] .chromeless {\n    cursor: default; }\n\n[data-player]:not(.nocursor) .container[data-container]:not(.chromeless).pointer-enabled {\n  cursor: pointer; }\n",""]);// exports
/***/},/* 138 *//***/function(module,exports,__webpack_require__){"use strict";/* WEBPACK VAR INJECTION */(function(process){Object.defineProperty(exports,"__esModule",{value:true});var _stringify=__webpack_require__(139);var _stringify2=_interopRequireDefault(_stringify);var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _utils=__webpack_require__(5);var _vendor=__webpack_require__(56);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _ui_object=__webpack_require__(21);var _ui_object2=_interopRequireDefault(_ui_object);var _browser=__webpack_require__(13);var _browser2=_interopRequireDefault(_browser);var _mediator=__webpack_require__(24);var _mediator2=_interopRequireDefault(_mediator);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);var _mediaControl=__webpack_require__(141);var _mediaControl2=_interopRequireDefault(_mediaControl);var _mediaControl3=__webpack_require__(142);var _mediaControl4=_interopRequireDefault(_mediaControl3);var _play=__webpack_require__(58);var _play2=_interopRequireDefault(_play);var _pause=__webpack_require__(76);var _pause2=_interopRequireDefault(_pause);var _stop=__webpack_require__(143);var _stop2=_interopRequireDefault(_stop);var _volume=__webpack_require__(144);var _volume2=_interopRequireDefault(_volume);var _mute=__webpack_require__(145);var _mute2=_interopRequireDefault(_mute);var _expand=__webpack_require__(146);var _expand2=_interopRequireDefault(_expand);var _shrink=__webpack_require__(147);var _shrink2=_interopRequireDefault(_shrink);var _hd=__webpack_require__(148);var _hd2=_interopRequireDefault(_hd);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
/**
 * The MediaControl is responsible for displaying the Player controls.
 */var MediaControl=function(_UIObject){(0,_inherits3.default)(MediaControl,_UIObject);(0,_createClass3.default)(MediaControl,[{key:'name',get:function get(){return'MediaControl';}},{key:'disabled',get:function get(){return this.userDisabled||this.container&&this.container.getPlaybackType()===_playback2.default.NO_OP;}},{key:'attributes',get:function get(){return{'class':'media-control','data-media-control':''};}},{key:'events',get:function get(){return{'click [data-play]':'play','click [data-pause]':'pause','click [data-playpause]':'togglePlayPause','click [data-stop]':'stop','click [data-playstop]':'togglePlayStop','click [data-fullscreen]':'toggleFullscreen','click .bar-container[data-seekbar]':'seek','click .bar-container[data-volume]':'onVolumeClick','click .drawer-icon[data-volume]':'toggleMute','mouseenter .drawer-container[data-volume]':'showVolumeBar','mouseleave .drawer-container[data-volume]':'hideVolumeBar','mousedown .bar-container[data-volume]':'startVolumeDrag','mousemove .bar-container[data-volume]':'mousemoveOnVolumeBar','mousedown .bar-scrubber[data-seekbar]':'startSeekDrag','mousemove .bar-container[data-seekbar]':'mousemoveOnSeekBar','mouseleave .bar-container[data-seekbar]':'mouseleaveOnSeekBar','mouseenter .media-control-layer[data-controls]':'setUserKeepVisible','mouseleave .media-control-layer[data-controls]':'resetUserKeepVisible'};}},{key:'template',get:function get(){return(0,_template2.default)(_mediaControl4.default);}},{key:'stylesheet',get:function get(){return _styler2.default.getStyleFor(_mediaControl2.default,{baseUrl:this.options.baseUrl});}},{key:'volume',get:function get(){return this.container&&this.container.isReady?this.container.volume:this.intendedVolume;}},{key:'muted',get:function get(){return this.volume===0;}}]);function MediaControl(options){(0,_classCallCheck3.default)(this,MediaControl);var _this=(0,_possibleConstructorReturn3.default)(this,_UIObject.call(this,options));_this.persistConfig=_this.options.persistConfig;_this.container=options.container;_this.currentPositionValue=null;_this.currentDurationValue=null;var initialVolume=_this.persistConfig?_utils.Config.restore('volume'):100;_this.setVolume(_this.options.mute?0:initialVolume);_this.keepVisible=false;_this.fullScreenOnVideoTagSupported=null;// unknown
_this.addEventListeners();_this.settings={left:['play','stop','pause'],right:['volume'],default:['position','seekbar','duration']};if(_this.container){if(!_clapprZepto2.default.isEmptyObject(_this.container.settings)){_this.settings=_clapprZepto2.default.extend({},_this.container.settings);}}else{_this.settings={};}_this.userDisabled=false;if(_this.container&&_this.container.mediaControlDisabled||_this.options.chromeless){_this.disable();}_this.stopDragHandler=function(event){return _this.stopDrag(event);};_this.updateDragHandler=function(event){return _this.updateDrag(event);};(0,_clapprZepto2.default)(document).bind('mouseup',_this.stopDragHandler);(0,_clapprZepto2.default)(document).bind('mousemove',_this.updateDragHandler);return _this;}MediaControl.prototype.addEventListeners=function addEventListeners(){if(this.container){_mediator2.default.on(this.options.playerId+':'+_events2.default.PLAYER_RESIZE,this.playerResize,this);this.listenTo(this.container,_events2.default.CONTAINER_PLAY,this.changeTogglePlay);this.listenTo(this.container,_events2.default.CONTAINER_PAUSE,this.changeTogglePlay);this.listenTo(this.container,_events2.default.CONTAINER_STOP,this.changeTogglePlay);this.listenTo(this.container,_events2.default.CONTAINER_DBLCLICK,this.toggleFullscreen);this.listenTo(this.container,_events2.default.CONTAINER_TIMEUPDATE,this.onTimeUpdate);this.listenTo(this.container,_events2.default.CONTAINER_PROGRESS,this.updateProgressBar);this.listenTo(this.container,_events2.default.CONTAINER_SETTINGSUPDATE,this.settingsUpdate);this.listenTo(this.container,_events2.default.CONTAINER_PLAYBACKDVRSTATECHANGED,this.settingsUpdate);this.listenTo(this.container,_events2.default.CONTAINER_HIGHDEFINITIONUPDATE,this.highDefinitionUpdate);this.listenTo(this.container,_events2.default.CONTAINER_MEDIACONTROL_DISABLE,this.disable);this.listenTo(this.container,_events2.default.CONTAINER_MEDIACONTROL_ENABLE,this.enable);this.listenTo(this.container,_events2.default.CONTAINER_ENDED,this.ended);this.listenTo(this.container,_events2.default.CONTAINER_VOLUME,this.onVolumeChanged);if(this.container.playback.el.nodeName.toLowerCase()==='video'){// wait until the metadata has loaded and then check if fullscreen on video tag is supported
this.listenToOnce(this.container,_events2.default.CONTAINER_LOADEDMETADATA,this.onLoadedMetadataOnVideoTag);}}};MediaControl.prototype.disable=function disable(){this.userDisabled=true;this.hide();this.$el.hide();};MediaControl.prototype.enable=function enable(){if(this.options.chromeless)return;this.userDisabled=false;this.show();};MediaControl.prototype.play=function play(){this.container.play();};MediaControl.prototype.pause=function pause(){this.container.pause();};MediaControl.prototype.stop=function stop(){this.container.stop();};MediaControl.prototype.onVolumeChanged=function onVolumeChanged(){this.updateVolumeUI();};MediaControl.prototype.onLoadedMetadataOnVideoTag=function onLoadedMetadataOnVideoTag(){var video=this.container.playback.el;// video.webkitSupportsFullscreen is deprecated but iOS appears to only use this
// see https://github.com/clappr/clappr/issues/1127
if(!_utils.Fullscreen.fullscreenEnabled()&&video.webkitSupportsFullscreen){this.fullScreenOnVideoTagSupported=true;this.settingsUpdate();}};MediaControl.prototype.updateVolumeUI=function updateVolumeUI(){if(!this.rendered){// this will be called after a render
return;}// update volume bar scrubber/fill on bar mode
this.$volumeBarContainer.find('.bar-fill-2').css({});var containerWidth=this.$volumeBarContainer.width();var barWidth=this.$volumeBarBackground.width();var offset=(containerWidth-barWidth)/2.0;var pos=barWidth*this.volume/100.0+offset;this.$volumeBarFill.css({width:this.volume+'%'});this.$volumeBarScrubber.css({left:pos});// update volume bar segments on segmented bar mode
this.$volumeBarContainer.find('.segmented-bar-element').removeClass('fill');var item=Math.ceil(this.volume/10.0);this.$volumeBarContainer.find('.segmented-bar-element').slice(0,item).addClass('fill');this.$volumeIcon.html('');this.$volumeIcon.removeClass('muted');if(!this.muted){this.$volumeIcon.append(_volume2.default);}else{this.$volumeIcon.append(_mute2.default);this.$volumeIcon.addClass('muted');}this.applyButtonStyle(this.$volumeIcon);};MediaControl.prototype.changeTogglePlay=function changeTogglePlay(){this.$playPauseToggle.html('');this.$playStopToggle.html('');if(this.container&&this.container.isPlaying()){this.$playPauseToggle.append(_pause2.default);this.$playStopToggle.append(_stop2.default);this.trigger(_events2.default.MEDIACONTROL_PLAYING);}else{this.$playPauseToggle.append(_play2.default);this.$playStopToggle.append(_play2.default);this.trigger(_events2.default.MEDIACONTROL_NOTPLAYING);if(_browser2.default.isMobile){this.show();}}this.applyButtonStyle(this.$playPauseToggle);this.applyButtonStyle(this.$playStopToggle);};MediaControl.prototype.mousemoveOnSeekBar=function mousemoveOnSeekBar(event){if(this.settings.seekEnabled){var offsetX=event.pageX-this.$seekBarContainer.offset().left-this.$seekBarHover.width()/2;this.$seekBarHover.css({left:offsetX});}this.trigger(_events2.default.MEDIACONTROL_MOUSEMOVE_SEEKBAR,event);};MediaControl.prototype.mouseleaveOnSeekBar=function mouseleaveOnSeekBar(event){this.trigger(_events2.default.MEDIACONTROL_MOUSELEAVE_SEEKBAR,event);};MediaControl.prototype.onVolumeClick=function onVolumeClick(event){this.setVolume(this.getVolumeFromUIEvent(event));};MediaControl.prototype.mousemoveOnVolumeBar=function mousemoveOnVolumeBar(event){if(this.draggingVolumeBar){this.setVolume(this.getVolumeFromUIEvent(event));}};MediaControl.prototype.playerResize=function playerResize(size){this.$fullscreenToggle.html('');if(_utils.Fullscreen.isFullscreen()){this.$fullscreenToggle.append(_shrink2.default);}else{this.$fullscreenToggle.append(_expand2.default);}this.applyButtonStyle(this.$fullscreenToggle);this.$el.removeClass('w320');if(size.width<=320||this.options.hideVolumeBar){this.$el.addClass('w320');}};MediaControl.prototype.togglePlayPause=function togglePlayPause(){if(this.container.isPlaying()){this.container.pause();}else{this.container.play();}return false;};MediaControl.prototype.togglePlayStop=function togglePlayStop(){if(this.container.isPlaying()){this.container.stop();}else{this.container.play();}};MediaControl.prototype.startSeekDrag=function startSeekDrag(event){if(!this.settings.seekEnabled)return;this.draggingSeekBar=true;this.$el.addClass('dragging');this.$seekBarLoaded.addClass('media-control-notransition');this.$seekBarPosition.addClass('media-control-notransition');this.$seekBarScrubber.addClass('media-control-notransition');if(event){event.preventDefault();}};MediaControl.prototype.startVolumeDrag=function startVolumeDrag(event){this.draggingVolumeBar=true;this.$el.addClass('dragging');if(event){event.preventDefault();}};MediaControl.prototype.stopDrag=function stopDrag(event){if(this.draggingSeekBar){this.seek(event);}this.$el.removeClass('dragging');this.$seekBarLoaded.removeClass('media-control-notransition');this.$seekBarPosition.removeClass('media-control-notransition');this.$seekBarScrubber.removeClass('media-control-notransition dragging');this.draggingSeekBar=false;this.draggingVolumeBar=false;};MediaControl.prototype.updateDrag=function updateDrag(event){if(this.draggingSeekBar){event.preventDefault();var offsetX=event.pageX-this.$seekBarContainer.offset().left;var pos=offsetX/this.$seekBarContainer.width()*100;pos=Math.min(100,Math.max(pos,0));this.setSeekPercentage(pos);}else if(this.draggingVolumeBar){event.preventDefault();this.setVolume(this.getVolumeFromUIEvent(event));}};MediaControl.prototype.getVolumeFromUIEvent=function getVolumeFromUIEvent(event){var offsetY=event.pageX-this.$volumeBarContainer.offset().left;var volumeFromUI=offsetY/this.$volumeBarContainer.width()*100;return volumeFromUI;};MediaControl.prototype.toggleMute=function toggleMute(){this.setVolume(this.muted?100:0);};MediaControl.prototype.setVolume=function setVolume(value){var _this2=this;value=Math.min(100,Math.max(value,0));// this will hold the intended volume
// it may not actually get set to this straight away
// if the container is not ready etc
this.intendedVolume=value;this.persistConfig&&_utils.Config.persist('volume',value);var setWhenContainerReady=function setWhenContainerReady(){if(_this2.container.isReady){_this2.container.setVolume(value);}else{_this2.listenToOnce(_this2.container,_events2.default.CONTAINER_READY,function(){_this2.container.setVolume(value);});}};if(!this.container){this.listenToOnce(this,_events2.default.MEDIACONTROL_CONTAINERCHANGED,function(){setWhenContainerReady();});}else{setWhenContainerReady();}};MediaControl.prototype.toggleFullscreen=function toggleFullscreen(){this.trigger(_events2.default.MEDIACONTROL_FULLSCREEN,this.name);this.container.fullscreen();this.resetUserKeepVisible();};MediaControl.prototype.setContainer=function setContainer(container){if(this.container){this.stopListening(this.container);this.fullScreenOnVideoTagSupported=null;}_mediator2.default.off(this.options.playerId+':'+_events2.default.PLAYER_RESIZE,this.playerResize,this);this.container=container;// set the new container to match the volume of the last one
this.setVolume(this.intendedVolume);this.changeTogglePlay();this.addEventListeners();this.settingsUpdate();this.container.trigger(_events2.default.CONTAINER_PLAYBACKDVRSTATECHANGED,this.container.isDvrInUse());if(this.container.mediaControlDisabled){this.disable();}this.trigger(_events2.default.MEDIACONTROL_CONTAINERCHANGED);};MediaControl.prototype.showVolumeBar=function showVolumeBar(){if(this.hideVolumeId){clearTimeout(this.hideVolumeId);}this.$volumeBarContainer.removeClass('volume-bar-hide');};MediaControl.prototype.hideVolumeBar=function hideVolumeBar(){var _this3=this;var timeout=arguments.length>0&&arguments[0]!==undefined?arguments[0]:400;if(!this.$volumeBarContainer)return;if(this.draggingVolumeBar){this.hideVolumeId=setTimeout(function(){return _this3.hideVolumeBar();},timeout);}else{if(this.hideVolumeId){clearTimeout(this.hideVolumeId);}this.hideVolumeId=setTimeout(function(){return _this3.$volumeBarContainer.addClass('volume-bar-hide');},timeout);}};MediaControl.prototype.ended=function ended(){this.changeTogglePlay();};MediaControl.prototype.updateProgressBar=function updateProgressBar(progress){var loadedStart=progress.start/progress.total*100;var loadedEnd=progress.current/progress.total*100;this.$seekBarLoaded.css({left:loadedStart+'%',width:loadedEnd-loadedStart+'%'});};MediaControl.prototype.onTimeUpdate=function onTimeUpdate(timeProgress){if(this.draggingSeekBar)return;// TODO why should current time ever be negative?
var position=timeProgress.current<0?timeProgress.total:timeProgress.current;this.currentPositionValue=position;this.currentDurationValue=timeProgress.total;this.renderSeekBar();};MediaControl.prototype.renderSeekBar=function renderSeekBar(){if(this.currentPositionValue===null||this.currentDurationValue===null){// this will be triggered as soon as these beocome available
return;}// default to 100%
this.currentSeekBarPercentage=100;if(this.container.getPlaybackType()!==_playback2.default.LIVE||this.container.isDvrInUse()){this.currentSeekBarPercentage=this.currentPositionValue/this.currentDurationValue*100;}this.setSeekPercentage(this.currentSeekBarPercentage);var newPosition=(0,_utils.formatTime)(this.currentPositionValue);var newDuration=(0,_utils.formatTime)(this.currentDurationValue);if(newPosition!==this.displayedPosition){this.$position.text(newPosition);this.displayedPosition=newPosition;}if(newDuration!==this.displayedDuration){this.$duration.text(newDuration);this.displayedDuration=newDuration;}};MediaControl.prototype.seek=function seek(event){if(!this.settings.seekEnabled)return;var offsetX=event.pageX-this.$seekBarContainer.offset().left;var pos=offsetX/this.$seekBarContainer.width()*100;pos=Math.min(100,Math.max(pos,0));this.container.seekPercentage(pos);this.setSeekPercentage(pos);return false;};MediaControl.prototype.setKeepVisible=function setKeepVisible(){this.keepVisible=true;};MediaControl.prototype.resetKeepVisible=function resetKeepVisible(){this.keepVisible=false;};MediaControl.prototype.setUserKeepVisible=function setUserKeepVisible(){this.userKeepVisible=true;};MediaControl.prototype.resetUserKeepVisible=function resetUserKeepVisible(){this.userKeepVisible=false;};MediaControl.prototype.isVisible=function isVisible(){return!this.$el.hasClass('media-control-hide');};MediaControl.prototype.show=function show(event){var _this4=this;if(this.disabled){return;}var timeout=2000;if(!event||event.clientX!==this.lastMouseX&&event.clientY!==this.lastMouseY||navigator.userAgent.match(/firefox/i)){clearTimeout(this.hideId);this.$el.show();this.trigger(_events2.default.MEDIACONTROL_SHOW,this.name);this.$el.removeClass('media-control-hide');this.hideId=setTimeout(function(){return _this4.hide();},timeout);if(event){this.lastMouseX=event.clientX;this.lastMouseY=event.clientY;}}};MediaControl.prototype.hide=function hide(){var _this5=this;var delay=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;if(!this.isVisible()||_browser2.default.isMobile&&!this.container.isPlaying()){return;}var timeout=delay||2000;clearTimeout(this.hideId);if(!this.disabled&&this.options.hideMediaControl===false){return;}if(!this.disabled&&(delay||this.userKeepVisible||this.keepVisible||this.draggingSeekBar||this.draggingVolumeBar)){this.hideId=setTimeout(function(){return _this5.hide();},timeout);}else{this.trigger(_events2.default.MEDIACONTROL_HIDE,this.name);this.$el.addClass('media-control-hide');this.hideVolumeBar(0);}};MediaControl.prototype.settingsUpdate=function settingsUpdate(){var newSettings=this.getSettings();if(newSettings&&!this.fullScreenOnVideoTagSupported&&!_utils.Fullscreen.fullscreenEnabled()){// remove fullscreen from settings if it is present
newSettings.default&&(0,_utils.removeArrayItem)(newSettings.default,'fullscreen');newSettings.left&&(0,_utils.removeArrayItem)(newSettings.left,'fullscreen');newSettings.right&&(0,_utils.removeArrayItem)(newSettings.right,'fullscreen');}var settingsChanged=(0,_stringify2.default)(this.settings)!==(0,_stringify2.default)(newSettings);if(settingsChanged){this.settings=newSettings;this.render();}};MediaControl.prototype.getSettings=function getSettings(){return _clapprZepto2.default.extend(true,{},this.container.settings);};MediaControl.prototype.highDefinitionUpdate=function highDefinitionUpdate(isHD){var method=isHD?'addClass':'removeClass';this.$hdIndicator[method]('enabled');};MediaControl.prototype.createCachedElements=function createCachedElements(){var $layer=this.$el.find('.media-control-layer');this.$duration=$layer.find('.media-control-indicator[data-duration]');this.$fullscreenToggle=$layer.find('button.media-control-button[data-fullscreen]');this.$playPauseToggle=$layer.find('button.media-control-button[data-playpause]');this.$playStopToggle=$layer.find('button.media-control-button[data-playstop]');this.$position=$layer.find('.media-control-indicator[data-position]');this.$seekBarContainer=$layer.find('.bar-container[data-seekbar]');this.$seekBarHover=$layer.find('.bar-hover[data-seekbar]');this.$seekBarLoaded=$layer.find('.bar-fill-1[data-seekbar]');this.$seekBarPosition=$layer.find('.bar-fill-2[data-seekbar]');this.$seekBarScrubber=$layer.find('.bar-scrubber[data-seekbar]');this.$volumeBarContainer=$layer.find('.bar-container[data-volume]');this.$volumeContainer=$layer.find('.drawer-container[data-volume]');this.$volumeIcon=$layer.find('.drawer-icon[data-volume]');this.$volumeBarBackground=this.$el.find('.bar-background[data-volume]');this.$volumeBarFill=this.$el.find('.bar-fill-1[data-volume]');this.$volumeBarScrubber=this.$el.find('.bar-scrubber[data-volume]');this.$hdIndicator=this.$el.find('button.media-control-button[data-hd-indicator]');this.resetIndicators();this.initializeIcons();};MediaControl.prototype.resetIndicators=function resetIndicators(){this.displayedPosition=this.$position.text();this.displayedDuration=this.$duration.text();};MediaControl.prototype.initializeIcons=function initializeIcons(){var $layer=this.$el.find('.media-control-layer');$layer.find('button.media-control-button[data-play]').append(_play2.default);$layer.find('button.media-control-button[data-pause]').append(_pause2.default);$layer.find('button.media-control-button[data-stop]').append(_stop2.default);this.$playPauseToggle.append(_play2.default);this.$playStopToggle.append(_play2.default);this.$volumeIcon.append(_volume2.default);this.$fullscreenToggle.append(_expand2.default);this.$hdIndicator.append(_hd2.default);};MediaControl.prototype.setSeekPercentage=function setSeekPercentage(value){value=Math.max(Math.min(value,100.0),0);if(this.displayedSeekBarPercentage===value){// not changed since last update
return;}this.displayedSeekBarPercentage=value;this.$seekBarPosition.removeClass('media-control-notransition');this.$seekBarScrubber.removeClass('media-control-notransition');this.$seekBarPosition.css({width:value+'%'});this.$seekBarScrubber.css({left:value+'%'});};MediaControl.prototype.seekRelative=function seekRelative(delta){if(!this.settings.seekEnabled)return;var currentTime=this.container.getCurrentTime();var duration=this.container.getDuration();var position=Math.min(Math.max(currentTime+delta,0),duration);position=Math.min(position*100/duration,100);this.container.seekPercentage(position);};MediaControl.prototype.bindKeyAndShow=function bindKeyAndShow(key,cb){var _this6=this;this.kibo.down(key,function(){_this6.show();return cb();});};MediaControl.prototype.bindKeyEvents=function bindKeyEvents(){var _this7=this;this.unbindKeyEvents();this.kibo=new _vendor.Kibo(this.options.focusElement);this.bindKeyAndShow('space',function(){return _this7.togglePlayPause();});this.bindKeyAndShow('left',function(){return _this7.seekRelative(-5);});this.bindKeyAndShow('right',function(){return _this7.seekRelative(5);});this.bindKeyAndShow('shift left',function(){return _this7.seekRelative(-10);});this.bindKeyAndShow('shift right',function(){return _this7.seekRelative(10);});this.bindKeyAndShow('shift ctrl left',function(){return _this7.seekRelative(-15);});this.bindKeyAndShow('shift ctrl right',function(){return _this7.seekRelative(15);});// this.kibo.down(['']) // should it be here?
var keys=['1','2','3','4','5','6','7','8','9','0'];keys.forEach(function(i){_this7.bindKeyAndShow(i,function(){return _this7.settings.seekEnabled&&_this7.container.seekPercentage(i*10);});});};MediaControl.prototype.unbindKeyEvents=function unbindKeyEvents(){if(this.kibo){this.kibo.off('space');this.kibo.off('left');this.kibo.off('right');this.kibo.off('shift left');this.kibo.off('shift right');this.kibo.off('shift ctrl left');this.kibo.off('shift ctrl right');this.kibo.off(['1','2','3','4','5','6','7','8','9','0']);}};MediaControl.prototype.parseColors=function parseColors(){if(this.options.mediacontrol){this.buttonsColor=this.options.mediacontrol.buttons;var seekbarColor=this.options.mediacontrol.seekbar;this.$el.find('.bar-fill-2[data-seekbar]').css('background-color',seekbarColor);this.$el.find('.media-control-icon svg path').css('fill',this.buttonsColor);this.$el.find('.segmented-bar-element[data-volume]').css('boxShadow','inset 2px 0 0 '+this.buttonsColor);}};MediaControl.prototype.applyButtonStyle=function applyButtonStyle(element){if(this.buttonsColor&&element){(0,_clapprZepto2.default)(element).find('svg path').css('fill',this.buttonsColor);}};MediaControl.prototype.destroy=function destroy(){this.remove();(0,_clapprZepto2.default)(document).unbind('mouseup',this.stopDragHandler);(0,_clapprZepto2.default)(document).unbind('mousemove',this.updateDragHandler);this.unbindKeyEvents();};MediaControl.prototype.render=function render(){var _this8=this;var timeout=1000;this.$el.html(this.template({settings:this.settings}));this.$el.append(this.stylesheet);this.createCachedElements();this.$playPauseToggle.addClass('paused');this.$playStopToggle.addClass('stopped');this.changeTogglePlay();this.hideId=setTimeout(function(){return _this8.hide();},timeout);if(this.disabled){this.hide();}// Video volume cannot be changed with Safari on mobile devices
// Display mute/unmute icon only if Safari version >= 10
if(_browser2.default.isSafari&&_browser2.default.isMobile){if(_browser2.default.version<10){this.$volumeContainer.css('display','none');}else{this.$volumeBarContainer.css('display','none');}}this.$seekBarPosition.addClass('media-control-notransition');this.$seekBarScrubber.addClass('media-control-notransition');var previousSeekPercentage=0;if(this.displayedSeekBarPercentage){previousSeekPercentage=this.displayedSeekBarPercentage;}this.displayedSeekBarPercentage=null;this.setSeekPercentage(previousSeekPercentage);process.nextTick(function(){if(!_this8.settings.seekEnabled){_this8.$seekBarContainer.addClass('seek-disabled');}if(!_browser2.default.isMobile&&!_this8.options.disableKeyboardShortcuts){_this8.bindKeyEvents();}_this8.playerResize({width:_this8.options.width,height:_this8.options.height});_this8.hideVolumeBar(0);});this.parseColors();this.highDefinitionUpdate();this.rendered=true;this.updateVolumeUI();this.trigger(_events2.default.MEDIACONTROL_RENDERED);return this;};return MediaControl;}(_ui_object2.default);exports.default=MediaControl;MediaControl.extend=function(properties){return(0,_utils.extend)(MediaControl,properties);};module.exports=exports['default'];/* WEBPACK VAR INJECTION */}).call(exports,__webpack_require__(57));/***/},/* 139 *//***/function(module,exports,__webpack_require__){module.exports={"default":__webpack_require__(140),__esModule:true};/***/},/* 140 *//***/function(module,exports,__webpack_require__){var core=__webpack_require__(11),$JSON=core.JSON||(core.JSON={stringify:JSON.stringify});module.exports=function stringify(it){// eslint-disable-line no-unused-vars
return $JSON.stringify.apply($JSON,arguments);};/***/},/* 141 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,".media-control-notransition {\n  -webkit-transition: none !important;\n  -moz-transition: none !important;\n  transition: none !important; }\n\n.media-control[data-media-control] {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  z-index: 9999;\n  pointer-events: none; }\n  .media-control[data-media-control].dragging {\n    pointer-events: auto;\n    cursor: -webkit-grabbing !important;\n    cursor: grabbing !important;\n    cursor: url("+__webpack_require__(75)+"), move; }\n    .media-control[data-media-control].dragging * {\n      cursor: -webkit-grabbing !important;\n      cursor: grabbing !important;\n      cursor: url("+__webpack_require__(75)+"), move; }\n  .media-control[data-media-control] .media-control-background[data-background] {\n    position: absolute;\n    height: 40%;\n    width: 100%;\n    bottom: 0;\n    background: -webkit-linear-gradient(transparent, rgba(0, 0, 0, 0.9));\n    background: linear-gradient(transparent, rgba(0, 0, 0, 0.9));\n    -webkit-transition: opacity 0.6s ease-out;\n    -moz-transition: opacity 0.6s ease-out;\n    transition: opacity 0.6s ease-out; }\n  .media-control[data-media-control] .media-control-icon {\n    line-height: 0;\n    letter-spacing: 0;\n    speak: none;\n    color: #fff;\n    opacity: 0.5;\n    vertical-align: middle;\n    text-align: left;\n    -webkit-transition: all 0.1s ease;\n    -moz-transition: all 0.1s ease;\n    transition: all 0.1s ease; }\n  .media-control[data-media-control] .media-control-icon:hover {\n    color: white;\n    opacity: 0.75;\n    text-shadow: rgba(255, 255, 255, 0.8) 0 0 5px; }\n  .media-control[data-media-control].media-control-hide .media-control-background[data-background] {\n    opacity: 0; }\n  .media-control[data-media-control].media-control-hide .media-control-layer[data-controls] {\n    bottom: -50px; }\n    .media-control[data-media-control].media-control-hide .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-scrubber[data-seekbar] {\n      opacity: 0; }\n  .media-control[data-media-control] .media-control-layer[data-controls] {\n    position: absolute;\n    bottom: 7px;\n    width: 100%;\n    height: 32px;\n    font-size: 0;\n    vertical-align: middle;\n    pointer-events: auto;\n    -webkit-transition: bottom 0.4s ease-out;\n    -moz-transition: bottom 0.4s ease-out;\n    transition: bottom 0.4s ease-out; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-left-panel[data-media-control] {\n      position: absolute;\n      top: 0;\n      left: 4px;\n      height: 100%; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-center-panel[data-media-control] {\n      height: 100%;\n      text-align: center;\n      line-height: 32px; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-right-panel[data-media-control] {\n      position: absolute;\n      top: 0;\n      right: 4px;\n      height: 100%; }\n    .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button {\n      background-color: transparent;\n      border: 0;\n      margin: 0 6px;\n      padding: 0;\n      cursor: pointer;\n      display: inline-block;\n      width: 32px;\n      height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button svg {\n        width: 100%;\n        height: 22px; }\n        .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button svg path {\n          fill: white; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button:focus {\n        outline: none; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-play] {\n        float: left;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-pause] {\n        float: left;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-stop] {\n        float: left;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-fullscreen] {\n        float: right;\n        background-color: transparent;\n        border: 0;\n        height: 100%; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-hd-indicator] {\n        background-color: transparent;\n        border: 0;\n        cursor: default;\n        display: none;\n        float: right;\n        height: 100%; }\n        .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-hd-indicator].enabled {\n          display: block;\n          opacity: 1.0; }\n          .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-hd-indicator].enabled:hover {\n            opacity: 1.0;\n            text-shadow: none; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-playpause] {\n        float: left; }\n      .media-control[data-media-control] .media-control-layer[data-controls] button.media-control-button[data-playstop] {\n        float: left; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-position], .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-duration] {\n      display: inline-block;\n      font-size: 10px;\n      color: white;\n      cursor: default;\n      line-height: 32px;\n      position: relative; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-position] {\n      margin: 0 6px 0 7px; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-duration] {\n      color: rgba(255, 255, 255, 0.5);\n      margin-right: 6px; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .media-control-indicator[data-duration]:before {\n        content: \"|\";\n        margin-right: 7px; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] {\n      position: absolute;\n      top: -20px;\n      left: 0;\n      display: inline-block;\n      vertical-align: middle;\n      width: 100%;\n      height: 25px;\n      cursor: pointer; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] {\n        width: 100%;\n        height: 1px;\n        position: relative;\n        top: 12px;\n        background-color: #666666; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-1[data-seekbar] {\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          background-color: #c2c2c2;\n          -webkit-transition: all 0.1s ease-out;\n          -moz-transition: all 0.1s ease-out;\n          transition: all 0.1s ease-out; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-2[data-seekbar] {\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          background-color: #005aff;\n          -webkit-transition: all 0.1s ease-out;\n          -moz-transition: all 0.1s ease-out;\n          transition: all 0.1s ease-out; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-hover[data-seekbar] {\n          opacity: 0;\n          position: absolute;\n          top: -3px;\n          width: 5px;\n          height: 7px;\n          background-color: rgba(255, 255, 255, 0.5);\n          -webkit-transition: opacity 0.1s ease;\n          -moz-transition: opacity 0.1s ease;\n          transition: opacity 0.1s ease; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar]:hover .bar-background[data-seekbar] .bar-hover[data-seekbar] {\n        opacity: 1; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar].seek-disabled {\n        cursor: default; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar].seek-disabled:hover .bar-background[data-seekbar] .bar-hover[data-seekbar] {\n          opacity: 0; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-scrubber[data-seekbar] {\n        position: absolute;\n        -webkit-transform: translateX(-50%);\n        -moz-transform: translateX(-50%);\n        -ms-transform: translateX(-50%);\n        -o-transform: translateX(-50%);\n        transform: translateX(-50%);\n        top: 2px;\n        left: 0;\n        width: 20px;\n        height: 20px;\n        opacity: 1;\n        -webkit-transition: all 0.1s ease-out;\n        -moz-transition: all 0.1s ease-out;\n        transition: all 0.1s ease-out; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-scrubber[data-seekbar] .bar-scrubber-icon[data-seekbar] {\n          position: absolute;\n          left: 6px;\n          top: 6px;\n          width: 8px;\n          height: 8px;\n          border-radius: 10px;\n          box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.2);\n          background-color: white; }\n    .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] {\n      float: right;\n      display: inline-block;\n      height: 32px;\n      cursor: pointer;\n      margin: 0 6px;\n      box-sizing: border-box; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] {\n        float: left;\n        bottom: 0; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] {\n          background-color: transparent;\n          border: 0;\n          box-sizing: content-box;\n          width: 32px;\n          height: 32px;\n          opacity: 0.5; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume]:hover {\n            opacity: 0.75; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] svg {\n            height: 24px;\n            position: relative;\n            top: 3px; }\n            .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume] svg path {\n              fill: white; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .drawer-icon-container[data-volume] .drawer-icon[data-volume].muted svg {\n            margin-left: 2px; }\n      .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] {\n        float: left;\n        position: relative;\n        overflow: hidden;\n        top: 6px;\n        width: 42px;\n        height: 18px;\n        padding: 3px 0;\n        -webkit-transition: width 0.2s ease-out;\n        -moz-transition: width 0.2s ease-out;\n        transition: width 0.2s ease-out; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] {\n          height: 1px;\n          position: relative;\n          top: 7px;\n          margin: 0 3px;\n          background-color: #666666; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] .bar-fill-1[data-volume] {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 0;\n            height: 100%;\n            background-color: #c2c2c2;\n            -webkit-transition: all 0.1s ease-out;\n            -moz-transition: all 0.1s ease-out;\n            transition: all 0.1s ease-out; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] .bar-fill-2[data-volume] {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 0;\n            height: 100%;\n            background-color: #005aff;\n            -webkit-transition: all 0.1s ease-out;\n            -moz-transition: all 0.1s ease-out;\n            transition: all 0.1s ease-out; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-background[data-volume] .bar-hover[data-volume] {\n            opacity: 0;\n            position: absolute;\n            top: -3px;\n            width: 5px;\n            height: 7px;\n            background-color: rgba(255, 255, 255, 0.5);\n            -webkit-transition: opacity 0.1s ease;\n            -moz-transition: opacity 0.1s ease;\n            transition: opacity 0.1s ease; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-scrubber[data-volume] {\n          position: absolute;\n          -webkit-transform: translateX(-50%);\n          -moz-transform: translateX(-50%);\n          -ms-transform: translateX(-50%);\n          -o-transform: translateX(-50%);\n          transform: translateX(-50%);\n          top: 0px;\n          left: 0;\n          width: 20px;\n          height: 20px;\n          opacity: 1;\n          -webkit-transition: all 0.1s ease-out;\n          -moz-transition: all 0.1s ease-out;\n          transition: all 0.1s ease-out; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .bar-scrubber[data-volume] .bar-scrubber-icon[data-volume] {\n            position: absolute;\n            left: 6px;\n            top: 6px;\n            width: 8px;\n            height: 8px;\n            border-radius: 10px;\n            box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.2);\n            background-color: white; }\n        .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume] {\n          float: left;\n          width: 4px;\n          padding-left: 2px;\n          height: 12px;\n          opacity: 0.5;\n          box-shadow: inset 2px 0 0 white;\n          -webkit-transition: -webkit-transform 0.2s ease-out;\n          -moz-transition: -moz-transform 0.2s ease-out;\n          transition: transform 0.2s ease-out; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume].fill {\n            box-shadow: inset 2px 0 0 #fff;\n            opacity: 1; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume]:nth-of-type(1) {\n            padding-left: 0; }\n          .media-control[data-media-control] .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume] .segmented-bar-element[data-volume]:hover {\n            -webkit-transform: scaleY(1.5);\n            -moz-transform: scaleY(1.5);\n            -ms-transform: scaleY(1.5);\n            -o-transform: scaleY(1.5);\n            transform: scaleY(1.5); }\n  .media-control[data-media-control].w320 .media-control-layer[data-controls] .drawer-container[data-volume] .bar-container[data-volume].volume-bar-hide {\n    width: 0;\n    height: 12px;\n    top: 9px;\n    padding: 0; }\n",""]);// exports
/***/},/* 142 *//***/function(module,exports){module.exports="<div class=\"media-control-background\" data-background></div>\n<div class=\"media-control-layer\" data-controls>\n  <%  var renderBar = function(name) { %>\n      <div class=\"bar-container\" data-<%= name %>>\n        <div class=\"bar-background\" data-<%= name %>>\n          <div class=\"bar-fill-1\" data-<%= name %>></div>\n          <div class=\"bar-fill-2\" data-<%= name %>></div>\n          <div class=\"bar-hover\" data-<%= name %>></div>\n        </div>\n        <div class=\"bar-scrubber\" data-<%= name %>>\n          <div class=\"bar-scrubber-icon\" data-<%= name %>></div>\n        </div>\n      </div>\n  <%  }; %>\n  <%  var renderSegmentedBar = function(name, segments) {\n      segments = segments || 10; %>\n    <div class=\"bar-container\" data-<%= name %>>\n    <% for (var i = 0; i < segments; i++) { %>\n      <div class=\"segmented-bar-element\" data-<%= name %>></div>\n    <% } %>\n    </div>\n  <% }; %>\n  <% var renderDrawer = function(name, renderContent) { %>\n      <div class=\"drawer-container\" data-<%= name %>>\n        <div class=\"drawer-icon-container\" data-<%= name %>>\n          <div class=\"drawer-icon media-control-icon\" data-<%= name %>></div>\n          <span class=\"drawer-text\" data-<%= name %>></span>\n        </div>\n        <% renderContent(name); %>\n      </div>\n  <% }; %>\n  <% var renderIndicator = function(name) { %>\n      <div class=\"media-control-indicator\" data-<%= name %>></div>\n  <% }; %>\n  <% var renderButton = function(name) { %>\n    <button type=\"button\" class=\"media-control-button media-control-icon\" data-<%= name %> aria-label=\"<%= name %>\"></button>\n  <% }; %>\n  <%  var templates = {\n        bar: renderBar,\n        segmentedBar: renderSegmentedBar,\n      };\n      var render = function(settingsList) {\n        settingsList.forEach(function(setting) {\n          if(setting === \"seekbar\") {\n            renderBar(setting);\n          } else if (setting === \"volume\") {\n            renderDrawer(setting, settings.volumeBarTemplate ? templates[settings.volumeBarTemplate] : function(name) { return renderSegmentedBar(name); });\n          } else if (setting === \"duration\" || setting === \"position\") {\n            renderIndicator(setting);\n          } else {\n            renderButton(setting);\n          }\n        });\n      }; %>\n  <% if (settings.default && settings.default.length) { %>\n  <div class=\"media-control-center-panel\" data-media-control>\n    <% render(settings.default); %>\n  </div>\n  <% } %>\n  <% if (settings.left && settings.left.length) { %>\n  <div class=\"media-control-left-panel\" data-media-control>\n    <% render(settings.left); %>\n  </div>\n  <% } %>\n  <% if (settings.right && settings.right.length) { %>\n  <div class=\"media-control-right-panel\" data-media-control>\n    <% render(settings.right); %>\n  </div>\n  <% } %>\n</div>\n";/***/},/* 143 *//***/function(module,exports){module.exports="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"#010101\" d=\"M1.712 1.24h12.6v13.52h-12.6z\"></path></svg>";/***/},/* 144 *//***/function(module,exports){module.exports="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"#010101\" d=\"M11.5 11h-.002v1.502L7.798 10H4.5V6h3.297l3.7-2.502V4.5h.003V11zM11 4.49L7.953 6.5H5v3h2.953L11 11.51V4.49z\"></path></svg>";/***/},/* 145 *//***/function(module,exports){module.exports="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"#010101\" d=\"M9.75 11.51L6.7 9.5H3.75v-3H6.7L9.75 4.49v.664l.497.498V3.498L6.547 6H3.248v4h3.296l3.7 2.502v-2.154l-.497.5v.662zm3-5.165L12.404 6l-1.655 1.653L9.093 6l-.346.345L10.402 8 8.747 9.654l.346.347 1.655-1.653L12.403 10l.348-.346L11.097 8l1.655-1.655z\"></path></svg>";/***/},/* 146 *//***/function(module,exports){module.exports="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill=\"#010101\" d=\"M7.156 8L4 11.156V8.5H3V13h4.5v-1H4.844L8 8.844 7.156 8zM8.5 3v1h2.657L8 7.157 8.846 8 12 4.844V7.5h1V3H8.5z\"></path></svg>";/***/},/* 147 *//***/function(module,exports){module.exports="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill=\"#010101\" d=\"M13.5 3.344l-.844-.844L9.5 5.656V3h-1v4.5H13v-1h-2.656L13.5 3.344zM3 9.5h2.656L2.5 12.656l.844.844L6.5 10.344V13h1V8.5H3v1z\"></path></svg>";/***/},/* 148 *//***/function(module,exports){module.exports="<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\"><path fill=\"#010101\" d=\"M5.375 7.062H2.637V4.26H.502v7.488h2.135V8.9h2.738v2.848h2.133V4.26H5.375v2.802zm5.97-2.81h-2.84v7.496h2.798c2.65 0 4.195-1.607 4.195-3.77v-.022c0-2.162-1.523-3.704-4.154-3.704zm2.06 3.758c0 1.21-.81 1.896-2.03 1.896h-.83V6.093h.83c1.22 0 2.03.696 2.03 1.896v.02z\"></path></svg>";/***/},/* 149 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,"@font-face {\n  font-family: \"Roboto\";\n  font-style: normal;\n  font-weight: 400;\n  src: local(\"Roboto\"), local(\"Roboto-Regular\"), url("+__webpack_require__(150)+") format(\"truetype\"); }\n\n[data-player] {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  -o-user-select: none;\n  user-select: none;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-transform: translate3d(0, 0, 0);\n  -moz-transform: translate3d(0, 0, 0);\n  -ms-transform: translate3d(0, 0, 0);\n  -o-transform: translate3d(0, 0, 0);\n  transform: translate3d(0, 0, 0);\n  position: relative;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-style: normal;\n  font-weight: normal;\n  text-align: center;\n  overflow: hidden;\n  font-size: 100%;\n  font-family: \"Roboto\", \"Open Sans\", Arial, sans-serif;\n  text-shadow: 0 0 0;\n  box-sizing: border-box; }\n  [data-player] div, [data-player] span, [data-player] applet, [data-player] object, [data-player] iframe,\n  [data-player] h1, [data-player] h2, [data-player] h3, [data-player] h4, [data-player] h5, [data-player] h6, [data-player] p, [data-player] blockquote, [data-player] pre,\n  [data-player] a, [data-player] abbr, [data-player] acronym, [data-player] address, [data-player] big, [data-player] cite, [data-player] code,\n  [data-player] del, [data-player] dfn, [data-player] em, [data-player] img, [data-player] ins, [data-player] kbd, [data-player] q, [data-player] s, [data-player] samp,\n  [data-player] small, [data-player] strike, [data-player] strong, [data-player] sub, [data-player] sup, [data-player] tt, [data-player] var,\n  [data-player] b, [data-player] u, [data-player] i, [data-player] center,\n  [data-player] dl, [data-player] dt, [data-player] dd, [data-player] ol, [data-player] ul, [data-player] li,\n  [data-player] fieldset, [data-player] form, [data-player] label, [data-player] legend,\n  [data-player] table, [data-player] caption, [data-player] tbody, [data-player] tfoot, [data-player] thead, [data-player] tr, [data-player] th, [data-player] td,\n  [data-player] article, [data-player] aside, [data-player] canvas, [data-player] details, [data-player] embed,\n  [data-player] figure, [data-player] figcaption, [data-player] footer, [data-player] header, [data-player] hgroup,\n  [data-player] menu, [data-player] nav, [data-player] output, [data-player] ruby, [data-player] section, [data-player] summary,\n  [data-player] time, [data-player] mark, [data-player] audio, [data-player] video {\n    margin: 0;\n    padding: 0;\n    border: 0;\n    font: inherit;\n    font-size: 100%;\n    vertical-align: baseline; }\n  [data-player] table {\n    border-collapse: collapse;\n    border-spacing: 0; }\n  [data-player] caption, [data-player] th, [data-player] td {\n    text-align: left;\n    font-weight: normal;\n    vertical-align: middle; }\n  [data-player] q, [data-player] blockquote {\n    quotes: none; }\n    [data-player] q:before, [data-player] q:after, [data-player] blockquote:before, [data-player] blockquote:after {\n      content: \"\";\n      content: none; }\n  [data-player] a img {\n    border: none; }\n  [data-player]:focus {\n    outline: 0; }\n  [data-player] * {\n    max-width: none;\n    box-sizing: inherit;\n    float: none; }\n  [data-player] div {\n    display: block; }\n  [data-player].fullscreen {\n    width: 100% !important;\n    height: 100% !important;\n    top: 0;\n    left: 0; }\n  [data-player].nocursor {\n    cursor: none; }\n\n.clappr-style {\n  display: none !important; }\n",""]);// exports
/***/},/* 150 *//***/function(module,exports,__webpack_require__){module.exports=__webpack_require__.p+"38861cba61c66739c1452c3a71e39852.ttf";/***/},/* 151 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _create=__webpack_require__(71);var _create2=_interopRequireDefault(_create);var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _base_object=__webpack_require__(17);var _base_object2=_interopRequireDefault(_base_object);var _player_info=__webpack_require__(34);var _player_info2=_interopRequireDefault(_player_info);var _html5_video=__webpack_require__(35);var _html5_video2=_interopRequireDefault(_html5_video);var _flash=__webpack_require__(80);var _flash2=_interopRequireDefault(_flash);var _html5_audio=__webpack_require__(81);var _html5_audio2=_interopRequireDefault(_html5_audio);var _flashls=__webpack_require__(82);var _flashls2=_interopRequireDefault(_flashls);var _hls=__webpack_require__(83);var _hls2=_interopRequireDefault(_hls);var _html_img=__webpack_require__(84);var _html_img2=_interopRequireDefault(_html_img);var _no_op=__webpack_require__(85);var _no_op2=_interopRequireDefault(_no_op);var _spinner_three_bounce=__webpack_require__(179);var _spinner_three_bounce2=_interopRequireDefault(_spinner_three_bounce);var _stats=__webpack_require__(183);var _stats2=_interopRequireDefault(_stats);var _watermark=__webpack_require__(185);var _watermark2=_interopRequireDefault(_watermark);var _poster=__webpack_require__(86);var _poster2=_interopRequireDefault(_poster);var _google_analytics=__webpack_require__(192);var _google_analytics2=_interopRequireDefault(_google_analytics);var _click_to_pause=__webpack_require__(194);var _click_to_pause2=_interopRequireDefault(_click_to_pause);var _dvr_controls=__webpack_require__(196);var _dvr_controls2=_interopRequireDefault(_dvr_controls);var _closed_captions=__webpack_require__(200);var _closed_captions2=_interopRequireDefault(_closed_captions);var _favicon=__webpack_require__(205);var _favicon2=_interopRequireDefault(_favicon);var _seek_time=__webpack_require__(207);var _seek_time2=_interopRequireDefault(_seek_time);var _sources=__webpack_require__(211);var _sources2=_interopRequireDefault(_sources);var _end_video=__webpack_require__(212);var _end_video2=_interopRequireDefault(_end_video);var _strings=__webpack_require__(213);var _strings2=_interopRequireDefault(_strings);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * It keeps a list of the default plugins (playback, container, core) and it merges external plugins with its internals.
 * @class Loader
 * @constructor
 * @extends BaseObject
 * @module components
 *//* Playback Plugins */// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var Loader=function(_BaseObject){(0,_inherits3.default)(Loader,_BaseObject);/**
   * builds the loader
   * @method constructor
   * @param {Object} externalPlugins the external plugins
   * @param {Number} playerId you can embed multiple instances of clappr, therefore this is the unique id of each one.
   */function Loader(externalPlugins,playerId){(0,_classCallCheck3.default)(this,Loader);var _this=(0,_possibleConstructorReturn3.default)(this,_BaseObject.call(this));_this.playerId=playerId;_this.playbackPlugins=[_hls2.default,_html5_video2.default,_html5_audio2.default,_flash2.default,_flashls2.default,_html_img2.default,_no_op2.default];_this.containerPlugins=[_spinner_three_bounce2.default,_watermark2.default,_poster2.default,_stats2.default,_google_analytics2.default,_click_to_pause2.default];_this.corePlugins=[_dvr_controls2.default,_closed_captions2.default,_favicon2.default,_seek_time2.default,_sources2.default,_end_video2.default,_strings2.default];if(externalPlugins){if(!Array.isArray(externalPlugins)){_this.validateExternalPluginsType(externalPlugins);}_this.addExternalPlugins(externalPlugins);}return _this;}/**
   * groups by type the external plugins that were passed through `options.plugins` it they're on a flat array
   * @method addExternalPlugins
   * @private
   * @param {Object} an config object or an array of plugins
   * @return {Object} plugins the config object with the plugins separated by type
   */Loader.prototype.groupPluginsByType=function groupPluginsByType(plugins){if(Array.isArray(plugins)){plugins=plugins.reduce(function(memo,plugin){memo[plugin.type]||(memo[plugin.type]=[]);memo[plugin.type].push(plugin);return memo;},{});}return plugins;};Loader.prototype.removeDups=function removeDups(list){var groupUp=function groupUp(plugins,plugin){plugins[plugin.prototype.name]&&delete plugins[plugin.prototype.name];plugins[plugin.prototype.name]=plugin;return plugins;};var pluginsMap=list.reduceRight(groupUp,(0,_create2.default)(null));var plugins=[];for(var key in pluginsMap){plugins.unshift(pluginsMap[key]);}return plugins;};/**
   * adds all the external plugins that were passed through `options.plugins`
   * @method addExternalPlugins
   * @private
   * @param {Object} plugins the config object with all plugins
   */Loader.prototype.addExternalPlugins=function addExternalPlugins(plugins){plugins=this.groupPluginsByType(plugins);if(plugins.playback){this.playbackPlugins=this.removeDups(plugins.playback.concat(this.playbackPlugins));}if(plugins.container){this.containerPlugins=this.removeDups(plugins.container.concat(this.containerPlugins));}if(plugins.core){this.corePlugins=this.removeDups(plugins.core.concat(this.corePlugins));}_player_info2.default.getInstance(this.playerId).playbackPlugins=this.playbackPlugins;};/**
   * validate if the external plugins that were passed through `options.plugins` are associated to the correct type
   * @method validateExternalPluginsType
   * @private
   * @param {Object} plugins the config object with all plugins
   */Loader.prototype.validateExternalPluginsType=function validateExternalPluginsType(plugins){var plugintypes=['playback','container','core'];plugintypes.forEach(function(type){(plugins[type]||[]).forEach(function(el){var errorMessage='external '+el.type+' plugin on '+type+' array';if(el.type!==type){throw new ReferenceError(errorMessage);}});});};return Loader;}(_base_object2.default);/* Core Plugins *//* Container Plugins */exports.default=Loader;module.exports=exports['default'];/***/},/* 152 *//***/function(module,exports,__webpack_require__){"use strict";/* WEBPACK VAR INJECTION */(function(process){Object.defineProperty(exports,"__esModule",{value:true});var _from=__webpack_require__(78);var _from2=_interopRequireDefault(_from);var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _toConsumableArray2=__webpack_require__(79);var _toConsumableArray3=_interopRequireDefault(_toConsumableArray2);var _keys=__webpack_require__(31);var _keys2=_interopRequireDefault(_keys);var _utils=__webpack_require__(5);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _browser=__webpack_require__(13);var _browser2=_interopRequireDefault(_browser);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _style=__webpack_require__(161);var _style2=_interopRequireDefault(_style);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _tracks=__webpack_require__(162);var _tracks2=_interopRequireDefault(_tracks);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var MIMETYPES={'mp4':['avc1.42E01E','avc1.58A01E','avc1.4D401E','avc1.64001E','mp4v.20.8','mp4v.20.240','mp4a.40.2'].map(function(codec){return'video/mp4; codecs="'+codec+', mp4a.40.2"';}),'ogg':['video/ogg; codecs="theora, vorbis"','video/ogg; codecs="dirac"','video/ogg; codecs="theora, speex"'],'3gpp':['video/3gpp; codecs="mp4v.20.8, samr"'],'webm':['video/webm; codecs="vp8, vorbis"'],'mkv':['video/x-matroska; codecs="theora, vorbis"'],'m3u8':['application/x-mpegurl']};// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
MIMETYPES['ogv']=MIMETYPES['ogg'];MIMETYPES['3gp']=MIMETYPES['3gpp'];var AUDIO_MIMETYPES={'wav':['audio/wav'],'mp3':['audio/mp3','audio/mpeg;codecs="mp3"'],'aac':['audio/mp4;codecs="mp4a.40.5"'],'oga':['audio/ogg']};var KNOWN_AUDIO_MIMETYPES=(0,_keys2.default)(AUDIO_MIMETYPES).reduce(function(acc,k){return[].concat((0,_toConsumableArray3.default)(acc),(0,_toConsumableArray3.default)(AUDIO_MIMETYPES[k]));},[]);// TODO: rename this Playback to HTML5Playback (breaking change, only after 0.3.0)
var HTML5Video=function(_Playback){(0,_inherits3.default)(HTML5Video,_Playback);(0,_createClass3.default)(HTML5Video,[{key:'name',get:function get(){return'html5_video';}},{key:'tagName',get:function get(){return this.isAudioOnly?'audio':'video';}},{key:'isAudioOnly',get:function get(){var resourceUrl=this.options.src;var mimeTypes=HTML5Video._mimeTypesForUrl(resourceUrl,AUDIO_MIMETYPES,this.options.mimeType);return this.options.playback&&this.options.playback.audioOnly||this.options.audioOnly||KNOWN_AUDIO_MIMETYPES.indexOf(mimeTypes[0])>=0;}},{key:'attributes',get:function get(){return{'data-html5-video':''};}},{key:'events',get:function get(){return{'canplay':'_onCanPlay','canplaythrough':'_handleBufferingEvents','durationchange':'_onDurationChange','ended':'_onEnded','error':'_onError','loadeddata':'_onLoadedData','loadedmetadata':'_onLoadedMetadata','pause':'_onPause','playing':'_onPlaying','progress':'_onProgress','seeked':'_handleBufferingEvents','seeking':'_handleBufferingEvents','stalled':'_handleBufferingEvents','timeupdate':'_onTimeUpdate','waiting':'_onWaiting'};}/**
     * Determine if the playback has ended.
     * @property ended
     * @type Boolean
     */},{key:'ended',get:function get(){return this.el.ended;}/**
     * Determine if the playback is having to buffer in order for
     * playback to be smooth.
     * This is related to the PLAYBACK_BUFFERING and PLAYBACK_BUFFERFULL events
     * @property buffering
     * @type Boolean
     */},{key:'buffering',get:function get(){return!!this._bufferingState;}}]);function HTML5Video(){(0,_classCallCheck3.default)(this,HTML5Video);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var _this=(0,_possibleConstructorReturn3.default)(this,_Playback.call.apply(_Playback,[this].concat(args)));_this._destroyed=false;_this._loadStarted=false;_this._playheadMoving=false;_this._playheadMovingTimer=null;_this._stopped=false;_this._ccTrackId=-1;_this._setupSrc(_this.options.src);// backwards compatibility (TODO: remove on 0.3.0)
_this.options.playback||(_this.options.playback=_this.options||{});_this.options.playback.disableContextMenu=_this.options.playback.disableContextMenu||_this.options.disableVideoTagContextMenu;var playbackConfig=_this.options.playback;var preload=playbackConfig.preload||(_browser2.default.isSafari?'auto':_this.options.preload);var posterUrl=void 0;// FIXME: poster plugin should always convert poster to object with expected properties ?
if(_this.options.poster){if(typeof _this.options.poster==='string'){posterUrl=_this.options.poster;}else if(typeof _this.options.poster.url==='string'){posterUrl=_this.options.poster.url;}}_clapprZepto2.default.extend(_this.el,{loop:_this.options.loop,poster:posterUrl,preload:preload||'metadata',controls:(playbackConfig.controls||_this.options.useVideoTagDefaultControls)&&'controls',crossOrigin:playbackConfig.crossOrigin,'x-webkit-playsinline':playbackConfig.playInline});playbackConfig.playInline&&_this.$el.attr({playsinline:'playsinline'});playbackConfig.crossOrigin&&_this.$el.attr({crossorigin:playbackConfig.crossOrigin});// TODO should settings be private?
_this.settings={default:['seekbar']};_this.settings.left=['playpause','position','duration'];_this.settings.right=['fullscreen','volume','hd-indicator'];playbackConfig.externalTracks&&_this._setupExternalTracks(playbackConfig.externalTracks);// https://github.com/clappr/clappr/issues/1076
_this.options.autoPlay&&process.nextTick(function(){return!_this._destroyed&&_this.play();});return _this;}HTML5Video.prototype._setupExternalTracks=function _setupExternalTracks(tracks){this._externalTracks=tracks.map(function(track){return{kind:track.kind||'subtitles',// Default is 'subtitles'
label:track.label,lang:track.lang,src:track.src};});};/**
   * Sets the source url on the <video> element, and also the 'src' property.
   * @method setupSrc
   * @private
   * @param {String} srcUrl The source URL.
   */HTML5Video.prototype._setupSrc=function _setupSrc(srcUrl){if(this.el.src===srcUrl){return;}this._ccIsSetup=false;this.el.src=srcUrl;this._src=this.el.src;};HTML5Video.prototype._onLoadedMetadata=function _onLoadedMetadata(e){this._handleBufferingEvents();this.trigger(_events2.default.PLAYBACK_LOADEDMETADATA,{duration:e.target.duration,data:e});this._updateSettings();var autoSeekFromUrl=typeof this._options.autoSeekFromUrl==='undefined'||this._options.autoSeekFromUrl;if(this.getPlaybackType()!==_playback2.default.LIVE&&autoSeekFromUrl){this._checkInitialSeek();}};HTML5Video.prototype._onDurationChange=function _onDurationChange(){this._updateSettings();this._onTimeUpdate();// onProgress uses the duration
this._onProgress();};HTML5Video.prototype._updateSettings=function _updateSettings(){// we can't figure out if hls resource is VoD or not until it is being loaded or duration has changed.
// that's why we check it again and update media control accordingly.
if(this.getPlaybackType()===_playback2.default.VOD||this.getPlaybackType()===_playback2.default.AOD){this.settings.left=['playpause','position','duration'];}else{this.settings.left=['playstop'];}this.settings.seekEnabled=this.isSeekEnabled();this.trigger(_events2.default.PLAYBACK_SETTINGSUPDATE);};HTML5Video.prototype.isSeekEnabled=function isSeekEnabled(){return isFinite(this.getDuration());};HTML5Video.prototype.getPlaybackType=function getPlaybackType(){var onDemandType=this.tagName==='audio'?_playback2.default.AOD:_playback2.default.VOD;return[0,undefined,Infinity].indexOf(this.el.duration)>=0?_playback2.default.LIVE:onDemandType;};HTML5Video.prototype.isHighDefinitionInUse=function isHighDefinitionInUse(){return false;};// On mobile device, HTML5 video element "retains" user action consent if
// load() method is called. See Player.consent().
HTML5Video.prototype.consent=function consent(){!this.isPlaying()&&this.el.load();};HTML5Video.prototype.play=function play(){this.trigger(_events2.default.PLAYBACK_PLAY_INTENT);this._stopped=false;this._setupSrc(this._src);this._handleBufferingEvents();var promise=this.el.play();// For more details, see https://developers.google.com/web/updates/2016/03/play-returns-promise
if(promise&&promise.catch){promise.catch(function(){});}};HTML5Video.prototype.pause=function pause(){this.el.pause();};HTML5Video.prototype.stop=function stop(){this.pause();this._stopped=true;// src will be added again in play()
this.el.removeAttribute('src');this._stopPlayheadMovingChecks();this._handleBufferingEvents();this.trigger(_events2.default.PLAYBACK_STOP);};HTML5Video.prototype.volume=function volume(value){if(value===0){this.$el.attr({muted:'true'});this.el.muted=true;}else{this.$el.attr({muted:null});this.el.muted=false;}try{this.el.volume=value/100;}catch(e){console.log(e);}};HTML5Video.prototype.mute=function mute(){this.el.volume=0;};HTML5Video.prototype.unmute=function unmute(){this.el.volume=1;};HTML5Video.prototype.isMuted=function isMuted(){return!!this.el.volume;};HTML5Video.prototype.isPlaying=function isPlaying(){return!this.el.paused&&!this.el.ended;};HTML5Video.prototype._startPlayheadMovingChecks=function _startPlayheadMovingChecks(){if(this._playheadMovingTimer!==null){return;}this._playheadMovingTimeOnCheck=null;this._determineIfPlayheadMoving();this._playheadMovingTimer=setInterval(this._determineIfPlayheadMoving.bind(this),500);};HTML5Video.prototype._stopPlayheadMovingChecks=function _stopPlayheadMovingChecks(){if(this._playheadMovingTimer===null){return;}clearInterval(this._playheadMovingTimer);this._playheadMovingTimer=null;this._playheadMoving=false;};HTML5Video.prototype._determineIfPlayheadMoving=function _determineIfPlayheadMoving(){var before=this._playheadMovingTimeOnCheck;var now=this.el.currentTime;this._playheadMoving=before!==now;this._playheadMovingTimeOnCheck=now;this._handleBufferingEvents();};// this seems to happen when the user is having to wait
// for something to happen AFTER A USER INTERACTION
// e.g the player might be buffering, but when `play()` is called
// only at this point will this be called.
// Or the user may seek somewhere but the new area requires buffering,
// so it will fire then as well.
// On devices where playing is blocked until requested with a user action,
// buffering may start, but never finish until the user initiates a play,
// but this only happens when play is actually requested
HTML5Video.prototype._onWaiting=function _onWaiting(){this._loadStarted=true;this._handleBufferingEvents();};// called after the first frame has loaded
// note this doesn't fire on ios before the user has requested play
// ideally the "loadstart" event would be used instead, but this fires
// before a user has requested play on iOS, and also this is always fired
// even if the preload setting is "none". In both these cases this causes
// infinite buffering until the user does something which isn't great.
HTML5Video.prototype._onLoadedData=function _onLoadedData(){this._loadStarted=true;this._handleBufferingEvents();};// note this doesn't fire on ios before user has requested play
HTML5Video.prototype._onCanPlay=function _onCanPlay(){this._handleBufferingEvents();};HTML5Video.prototype._onPlaying=function _onPlaying(){this._checkForClosedCaptions();this._startPlayheadMovingChecks();this._handleBufferingEvents();this.trigger(_events2.default.PLAYBACK_PLAY);};HTML5Video.prototype._onPause=function _onPause(){this._stopPlayheadMovingChecks();this._handleBufferingEvents();this.trigger(_events2.default.PLAYBACK_PAUSE);};HTML5Video.prototype._onEnded=function _onEnded(){this._handleBufferingEvents();this.trigger(_events2.default.PLAYBACK_ENDED,this.name);};// The playback should be classed as buffering if the following are true:
// - the ready state is less then HAVE_FUTURE_DATA or the playhead isn't moving and it should be
// - the media hasn't "ended",
// - the media hasn't been stopped
// - loading has started
HTML5Video.prototype._handleBufferingEvents=function _handleBufferingEvents(){var playheadShouldBeMoving=!this.el.ended&&!this.el.paused;var buffering=this._loadStarted&&!this.el.ended&&!this._stopped&&(playheadShouldBeMoving&&!this._playheadMoving||this.el.readyState<this.el.HAVE_FUTURE_DATA);if(this._bufferingState!==buffering){this._bufferingState=buffering;if(buffering){this.trigger(_events2.default.PLAYBACK_BUFFERING,this.name);}else{this.trigger(_events2.default.PLAYBACK_BUFFERFULL,this.name);}}};HTML5Video.prototype._onError=function _onError(){this.trigger(_events2.default.PLAYBACK_ERROR,this.el.error,this.name);};HTML5Video.prototype.destroy=function destroy(){this._destroyed=true;this.handleTextTrackChange&&this.el.textTracks.removeEventListener('change',this.handleTextTrackChange);this.$el.remove();this.el.src='';this._src=null;_utils.DomRecycler.garbage(this.$el);};HTML5Video.prototype.seek=function seek(time){this.el.currentTime=time;};HTML5Video.prototype.seekPercentage=function seekPercentage(percentage){var time=this.el.duration*(percentage/100);this.seek(time);};HTML5Video.prototype._checkInitialSeek=function _checkInitialSeek(){var seekTime=(0,_utils.seekStringToSeconds)();if(seekTime!==0){this.seek(seekTime);}};HTML5Video.prototype.getCurrentTime=function getCurrentTime(){return this.el.currentTime;};HTML5Video.prototype.getDuration=function getDuration(){return this.el.duration;};HTML5Video.prototype._onTimeUpdate=function _onTimeUpdate(){this._handleBufferingEvents();if(this.getPlaybackType()===_playback2.default.LIVE){this.trigger(_events2.default.PLAYBACK_TIMEUPDATE,{current:1,total:1},this.name);}else{this.trigger(_events2.default.PLAYBACK_TIMEUPDATE,{current:this.el.currentTime,total:this.el.duration},this.name);}};HTML5Video.prototype._onProgress=function _onProgress(){if(!this.el.buffered.length){return;}var buffered=[];var bufferedPos=0;for(var i=0;i<this.el.buffered.length;i++){buffered=[].concat((0,_toConsumableArray3.default)(buffered),[{start:this.el.buffered.start(i),end:this.el.buffered.end(i)}]);if(this.el.currentTime>=buffered[i].start&&this.el.currentTime<=buffered[i].end){bufferedPos=i;}}var progress={start:buffered[bufferedPos].start,current:buffered[bufferedPos].end,total:this.el.duration};this.trigger(_events2.default.PLAYBACK_PROGRESS,progress,buffered);};HTML5Video.prototype._typeFor=function _typeFor(src){var mimeTypes=HTML5Video._mimeTypesForUrl(src,MIMETYPES,this.options.mimeType);if(mimeTypes.length==0){mimeTypes=HTML5Video._mimeTypesForUrl(src,AUDIO_MIMETYPES,this.options.mimeType);}var mimeType=mimeTypes[0]||'';return mimeType.split(';')[0];};HTML5Video.prototype._ready=function _ready(){if(this._isReadyState){return;}this._isReadyState=true;this.trigger(_events2.default.PLAYBACK_READY,this.name);};HTML5Video.prototype._checkForClosedCaptions=function _checkForClosedCaptions(){// Check if CC available only if current playback is HTML5Video
if(this.isHTML5Video&&!this._ccIsSetup){if(this.hasClosedCaptionsTracks){this.trigger(_events2.default.PLAYBACK_SUBTITLE_AVAILABLE);var trackId=this.closedCaptionsTrackId;this.closedCaptionsTrackId=trackId;this.handleTextTrackChange=this._handleTextTrackChange.bind(this);this.el.textTracks.addEventListener('change',this.handleTextTrackChange);}this._ccIsSetup=true;}};HTML5Video.prototype._handleTextTrackChange=function _handleTextTrackChange(){var tracks=this.closedCaptionsTracks;var track=tracks.find(function(track){return track.track.mode==='showing';})||{id:-1};if(this._ccTrackId!==track.id){this._ccTrackId=track.id;this.trigger(_events2.default.PLAYBACK_SUBTITLE_CHANGED,{id:track.id});}};HTML5Video.prototype.render=function render(){var style=_styler2.default.getStyleFor(_style2.default);if(this.options.playback.disableContextMenu){this.$el.on('contextmenu',function(){return false;});}if(this._externalTracks&&this._externalTracks.length>0){this.$el.html(this.template({tracks:this._externalTracks}));}this.$el.append(style);this._ready();return this;};(0,_createClass3.default)(HTML5Video,[{key:'isReady',get:function get(){return this._isReadyState;}},{key:'isHTML5Video',get:function get(){return this.name===HTML5Video.prototype.name;}},{key:'closedCaptionsTracks',get:function get(){var id=0;var trackId=function trackId(){return id++;};var textTracks=this.el.textTracks?(0,_from2.default)(this.el.textTracks):[];return textTracks.filter(function(track){return track.kind==='subtitles'||track.kind==='captions';}).map(function(track){return{id:trackId(),name:track.label,track:track};});}},{key:'closedCaptionsTrackId',get:function get(){return this._ccTrackId;},set:function set(trackId){if(!(0,_utils.isNumber)(trackId)){return;}var tracks=this.closedCaptionsTracks;var showingTrack=void 0;// Note: -1 is for hide all tracks
if(trackId!==-1){showingTrack=tracks.find(function(track){return track.id===trackId;});if(!showingTrack){return;// Track id not found
}if(showingTrack.track.mode==='showing'){return;// Track already showing
}}// Since it is possible to display multiple tracks,
// ensure that all tracks are hidden.
tracks.filter(function(track){return track.track.mode!=='hidden';}).forEach(function(track){return track.track.mode='hidden';});showingTrack&&(showingTrack.track.mode='showing');this._ccTrackId=trackId;this.trigger(_events2.default.PLAYBACK_SUBTITLE_CHANGED,{id:trackId});}},{key:'template',get:function get(){return(0,_template2.default)(_tracks2.default);}}]);return HTML5Video;}(_playback2.default);exports.default=HTML5Video;HTML5Video._mimeTypesForUrl=function(resourceUrl,mimeTypesByExtension,mimeType){var extension=(resourceUrl.split('?')[0].match(/.*\.(.*)$/)||[])[1];var mimeTypes=mimeType||extension&&mimeTypesByExtension[extension.toLowerCase()]||[];return mimeTypes.constructor===Array?mimeTypes:[mimeTypes];};HTML5Video._canPlay=function(type,mimeTypesByExtension,resourceUrl,mimeType){var mimeTypes=HTML5Video._mimeTypesForUrl(resourceUrl,mimeTypesByExtension,mimeType);var media=document.createElement(type);return!!mimeTypes.filter(function(mediaType){return!!media.canPlayType(mediaType).replace(/no/,'');})[0];};HTML5Video.canPlay=function(resourceUrl,mimeType){return HTML5Video._canPlay('audio',AUDIO_MIMETYPES,resourceUrl,mimeType)||HTML5Video._canPlay('video',MIMETYPES,resourceUrl,mimeType);};module.exports=exports['default'];/* WEBPACK VAR INJECTION */}).call(exports,__webpack_require__(57));/***/},/* 153 *//***/function(module,exports,__webpack_require__){__webpack_require__(65);__webpack_require__(154);module.exports=__webpack_require__(11).Array.from;/***/},/* 154 *//***/function(module,exports,__webpack_require__){"use strict";var ctx=__webpack_require__(46),$export=__webpack_require__(19),toObject=__webpack_require__(39),call=__webpack_require__(155),isArrayIter=__webpack_require__(156),toLength=__webpack_require__(61),createProperty=__webpack_require__(157),getIterFn=__webpack_require__(158);$export($export.S+$export.F*!__webpack_require__(160)(function(iter){Array.from(iter);}),'Array',{// 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
from:function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){var O=toObject(arrayLike),C=typeof this=='function'?this:Array,aLen=arguments.length,mapfn=aLen>1?arguments[1]:undefined,mapping=mapfn!==undefined,index=0,iterFn=getIterFn(O),length,result,step,iterator;if(mapping)mapfn=ctx(mapfn,aLen>2?arguments[2]:undefined,2);// if object isn't iterable or it's array with default iterator - use simple case
if(iterFn!=undefined&&!(C==Array&&isArrayIter(iterFn))){for(iterator=iterFn.call(O),result=new C();!(step=iterator.next()).done;index++){createProperty(result,index,mapping?call(iterator,mapfn,[step.value,index],true):step.value);}}else{length=toLength(O.length);for(result=new C(length);length>index;index++){createProperty(result,index,mapping?mapfn(O[index],index):O[index]);}}result.length=index;return result;}});/***/},/* 155 *//***/function(module,exports,__webpack_require__){// call something on iterator step with safe closing on error
var anObject=__webpack_require__(23);module.exports=function(iterator,fn,value,entries){try{return entries?fn(anObject(value)[0],value[1]):fn(value);// 7.4.6 IteratorClose(iterator, completion)
}catch(e){var ret=iterator['return'];if(ret!==undefined)anObject(ret.call(iterator));throw e;}};/***/},/* 156 *//***/function(module,exports,__webpack_require__){// check on default Array iterator
var Iterators=__webpack_require__(29),ITERATOR=__webpack_require__(12)('iterator'),ArrayProto=Array.prototype;module.exports=function(it){return it!==undefined&&(Iterators.Array===it||ArrayProto[ITERATOR]===it);};/***/},/* 157 *//***/function(module,exports,__webpack_require__){"use strict";var $defineProperty=__webpack_require__(16),createDesc=__webpack_require__(28);module.exports=function(object,index,value){if(index in object)$defineProperty.f(object,index,createDesc(0,value));else object[index]=value;};/***/},/* 158 *//***/function(module,exports,__webpack_require__){var classof=__webpack_require__(159),ITERATOR=__webpack_require__(12)('iterator'),Iterators=__webpack_require__(29);module.exports=__webpack_require__(11).getIteratorMethod=function(it){if(it!=undefined)return it[ITERATOR]||it['@@iterator']||Iterators[classof(it)];};/***/},/* 159 *//***/function(module,exports,__webpack_require__){// getting tag from 19.1.3.6 Object.prototype.toString()
var cof=__webpack_require__(41),TAG=__webpack_require__(12)('toStringTag')// ES3 wrong here
,ARG=cof(function(){return arguments;}())=='Arguments';// fallback for IE11 Script Access Denied error
var tryGet=function(it,key){try{return it[key];}catch(e){/* empty */}};module.exports=function(it){var O,T,B;return it===undefined?'Undefined':it===null?'Null'// @@toStringTag case
:typeof(T=tryGet(O=Object(it),TAG))=='string'?T// builtinTag case
:ARG?cof(O)// ES3 arguments fallback
:(B=cof(O))=='Object'&&typeof O.callee=='function'?'Arguments':B;};/***/},/* 160 *//***/function(module,exports,__webpack_require__){var ITERATOR=__webpack_require__(12)('iterator'),SAFE_CLOSING=false;try{var riter=[7][ITERATOR]();riter['return']=function(){SAFE_CLOSING=true;};Array.from(riter,function(){throw 2;});}catch(e){/* empty */}module.exports=function(exec,skipClosing){if(!skipClosing&&!SAFE_CLOSING)return false;var safe=false;try{var arr=[7],iter=arr[ITERATOR]();iter.next=function(){return{done:safe=true};};arr[ITERATOR]=function(){return iter;};exec(arr);}catch(e){/* empty */}return safe;};/***/},/* 161 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,"[data-html5-video] {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  display: block; }\n",""]);// exports
/***/},/* 162 *//***/function(module,exports){module.exports="<% for (var i = 0; i < tracks.length; i++) { %>\n  <track data-html5-video-track=\"<%= i %>\" kind=\"<%= tracks[i].kind %>\" label=\"<%= tracks[i].label %>\" srclang=\"<%= tracks[i].lang %>\" src=\"<%= tracks[i].src %>\" />\n<% }; %>\n";/***/},/* 163 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _utils=__webpack_require__(5);var _base_flash_playback=__webpack_require__(59);var _base_flash_playback2=_interopRequireDefault(_base_flash_playback);var _browser=__webpack_require__(13);var _browser2=_interopRequireDefault(_browser);var _mediator=__webpack_require__(24);var _mediator2=_interopRequireDefault(_mediator);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _Player=__webpack_require__(167);var _Player2=_interopRequireDefault(_Player);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var MAX_ATTEMPTS=60;// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var Flash=function(_BaseFlashPlayback){(0,_inherits3.default)(Flash,_BaseFlashPlayback);(0,_createClass3.default)(Flash,[{key:'name',get:function get(){return'flash';}},{key:'swfPath',get:function get(){return(0,_template2.default)(_Player2.default)({baseUrl:this._baseUrl});}/**
     * Determine if the playback has ended.
     * @property ended
     * @type Boolean
     */},{key:'ended',get:function get(){return this._currentState==='ENDED';}/**
     * Determine if the playback is buffering.
     * This is related to the PLAYBACK_BUFFERING and PLAYBACK_BUFFERFULL events
     * @property buffering
     * @type Boolean
     */},{key:'buffering',get:function get(){return!!this._bufferingState&&this._currentState!=='ENDED';}}]);function Flash(){(0,_classCallCheck3.default)(this,Flash);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var _this=(0,_possibleConstructorReturn3.default)(this,_BaseFlashPlayback.call.apply(_BaseFlashPlayback,[this].concat(args)));_this._src=_this.options.src;_this._baseUrl=_this.options.baseUrl;_this._autoPlay=_this.options.autoPlay;_this.settings={default:['seekbar']};_this.settings.left=['playpause','position','duration'];_this.settings.right=['fullscreen','volume'];_this.settings.seekEnabled=true;_this._isReadyState=false;_this._addListeners();return _this;}Flash.prototype._bootstrap=function _bootstrap(){var _this2=this;if(this.el.playerPlay){this.el.width='100%';this.el.height='100%';if(this._currentState==='PLAYING'){this._firstPlay();}else{this._currentState='IDLE';this._autoPlay&&this.play();}(0,_clapprZepto2.default)('<div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%" />').insertAfter(this.$el);if(this.getDuration()>0){this._metadataLoaded();}else{_mediator2.default.once(this.uniqueId+':timeupdate',this._metadataLoaded,this);}}else{this._attempts=this._attempts||0;if(++this._attempts<=MAX_ATTEMPTS){setTimeout(function(){return _this2._bootstrap();},50);}else{this.trigger(_events2.default.PLAYBACK_ERROR,{message:'Max number of attempts reached'},this.name);}}};Flash.prototype._metadataLoaded=function _metadataLoaded(){this._isReadyState=true;this.trigger(_events2.default.PLAYBACK_READY,this.name);this.trigger(_events2.default.PLAYBACK_SETTINGSUPDATE,this.name);};Flash.prototype.getPlaybackType=function getPlaybackType(){return _playback2.default.VOD;};Flash.prototype.isHighDefinitionInUse=function isHighDefinitionInUse(){return false;};Flash.prototype._updateTime=function _updateTime(){this.trigger(_events2.default.PLAYBACK_TIMEUPDATE,{current:this.el.getPosition(),total:this.el.getDuration()},this.name);};Flash.prototype._addListeners=function _addListeners(){_mediator2.default.on(this.uniqueId+':progress',this._progress,this);_mediator2.default.on(this.uniqueId+':timeupdate',this._updateTime,this);_mediator2.default.on(this.uniqueId+':statechanged',this._checkState,this);_mediator2.default.on(this.uniqueId+':flashready',this._bootstrap,this);};Flash.prototype.stopListening=function stopListening(){_BaseFlashPlayback.prototype.stopListening.call(this);_mediator2.default.off(this.uniqueId+':progress');_mediator2.default.off(this.uniqueId+':timeupdate');_mediator2.default.off(this.uniqueId+':statechanged');_mediator2.default.off(this.uniqueId+':flashready');};Flash.prototype._checkState=function _checkState(){if(this._isIdle||this._currentState==='PAUSED'){return;}else if(this._currentState!=='PLAYING_BUFFERING'&&this.el.getState()==='PLAYING_BUFFERING'){this._bufferingState=true;this.trigger(_events2.default.PLAYBACK_BUFFERING,this.name);this._currentState='PLAYING_BUFFERING';}else if(this.el.getState()==='PLAYING'){this._bufferingState=false;this.trigger(_events2.default.PLAYBACK_BUFFERFULL,this.name);this._currentState='PLAYING';}else if(this.el.getState()==='IDLE'){this._currentState='IDLE';}else if(this.el.getState()==='ENDED'){this.trigger(_events2.default.PLAYBACK_ENDED,this.name);this.trigger(_events2.default.PLAYBACK_TIMEUPDATE,{current:0,total:this.el.getDuration()},this.name);this._currentState='ENDED';this._isIdle=true;}};Flash.prototype._progress=function _progress(){if(this._currentState!=='IDLE'&&this._currentState!=='ENDED'){this.trigger(_events2.default.PLAYBACK_PROGRESS,{start:0,current:this.el.getBytesLoaded(),total:this.el.getBytesTotal()});}};Flash.prototype._firstPlay=function _firstPlay(){var _this3=this;if(this.el.playerPlay){this._isIdle=false;this.el.playerPlay(this._src);this.listenToOnce(this,_events2.default.PLAYBACK_BUFFERFULL,function(){return _this3._checkInitialSeek();});this._currentState='PLAYING';}else{this.listenToOnce(this,_events2.default.PLAYBACK_READY,this._firstPlay);}};Flash.prototype._checkInitialSeek=function _checkInitialSeek(){var seekTime=(0,_utils.seekStringToSeconds)(window.location.href);if(seekTime!==0){this.seekSeconds(seekTime);}};Flash.prototype.play=function play(){this.trigger(_events2.default.PLAYBACK_PLAY_INTENT);if(this._currentState==='PAUSED'||this._currentState==='PLAYING_BUFFERING'){this._currentState='PLAYING';this.el.playerResume();this.trigger(_events2.default.PLAYBACK_PLAY,this.name);}else if(this._currentState!=='PLAYING'){this._firstPlay();this.trigger(_events2.default.PLAYBACK_PLAY,this.name);}};Flash.prototype.volume=function volume(value){var _this4=this;if(this.isReady){this.el.playerVolume(value);}else{this.listenToOnce(this,_events2.default.PLAYBACK_BUFFERFULL,function(){return _this4.volume(value);});}};Flash.prototype.pause=function pause(){this._currentState='PAUSED';this.el.playerPause();this.trigger(_events2.default.PLAYBACK_PAUSE,this.name);};Flash.prototype.stop=function stop(){this.el.playerStop();this.trigger(_events2.default.PLAYBACK_STOP);this.trigger(_events2.default.PLAYBACK_TIMEUPDATE,{current:0,total:0},this.name);};Flash.prototype.isPlaying=function isPlaying(){return!!(this.isReady&&this._currentState.indexOf('PLAYING')>-1);};Flash.prototype.getDuration=function getDuration(){return this.el.getDuration();};Flash.prototype.seekPercentage=function seekPercentage(percentage){var _this5=this;if(this.el.getDuration()>0){var seekSeconds=this.el.getDuration()*(percentage/100);this.seek(seekSeconds);}else{this.listenToOnce(this,_events2.default.PLAYBACK_BUFFERFULL,function(){return _this5.seekPercentage(percentage);});}};Flash.prototype.seek=function seek(time){var _this6=this;if(this.isReady&&this.el.playerSeek){this.el.playerSeek(time);this.trigger(_events2.default.PLAYBACK_TIMEUPDATE,{current:time,total:this.el.getDuration()},this.name);if(this._currentState==='PAUSED'){this.el.playerPause();}}else{this.listenToOnce(this,_events2.default.PLAYBACK_BUFFERFULL,function(){return _this6.seek(time);});}};Flash.prototype.destroy=function destroy(){clearInterval(this.bootstrapId);_BaseFlashPlayback.prototype.stopListening.call(this);this.$el.remove();};(0,_createClass3.default)(Flash,[{key:'isReady',get:function get(){return this._isReadyState;}}]);return Flash;}(_base_flash_playback2.default);exports.default=Flash;Flash.canPlay=function(resource){if(!_browser2.default.hasFlash||!resource||resource.constructor!==String){return false;}else{var resourceParts=resource.split('?')[0].match(/.*\.(.*)$/)||[];return resourceParts.length>1&&!_browser2.default.isMobile&&resourceParts[1].toLowerCase().match(/^(mp4|mov|f4v|3gpp|3gp)$/);}};module.exports=exports['default'];/***/},/* 164 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _browser=__webpack_require__(13);var _browser2=_interopRequireDefault(_browser);var _flash=__webpack_require__(165);var _flash2=_interopRequireDefault(_flash);var _flash3=__webpack_require__(166);var _flash4=_interopRequireDefault(_flash3);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2015 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var IE_CLASSID='clsid:d27cdb6e-ae6d-11cf-96b8-444553540000';var BaseFlashPlayback=function(_Playback){(0,_inherits3.default)(BaseFlashPlayback,_Playback);function BaseFlashPlayback(){(0,_classCallCheck3.default)(this,BaseFlashPlayback);return(0,_possibleConstructorReturn3.default)(this,_Playback.apply(this,arguments));}BaseFlashPlayback.prototype.setElement=function setElement(element){this.$el=element;this.el=element[0];};BaseFlashPlayback.prototype.render=function render(){this.$el.html(this.template({cid:this.cid,swfPath:this.swfPath,baseUrl:this.baseUrl,playbackId:this.uniqueId,wmode:this.wmode,callbackName:'window.Clappr.flashlsCallbacks.'+this.cid}));if(_browser2.default.isIE){this.$('embed').remove();if(_browser2.default.isLegacyIE){this.$el.attr('classid',IE_CLASSID);}}this.el.id=this.cid;this.$el.append(_styler2.default.getStyleFor(_flash4.default));return this;};(0,_createClass3.default)(BaseFlashPlayback,[{key:'tagName',get:function get(){return'object';}},{key:'swfPath',get:function get(){return'';}},{key:'wmode',get:function get(){return'transparent';}},{key:'template',get:function get(){return(0,_template2.default)(_flash2.default);}},{key:'attributes',get:function get(){var type='application/x-shockwave-flash';if(_browser2.default.isLegacyIE){type='';}return{class:'clappr-flash-playback',type:type,width:'100%',height:'100%',data:this.swfPath,'data-flash-playback':this.name};}}]);return BaseFlashPlayback;}(_playback2.default);exports.default=BaseFlashPlayback;module.exports=exports['default'];/***/},/* 165 *//***/function(module,exports){module.exports="<param name=\"movie\" value=\"<%= swfPath %>\">\n<param name=\"quality\" value=\"autohigh\">\n<param name=\"swliveconnect\" value=\"true\">\n<param name=\"allowScriptAccess\" value=\"always\">\n<param name=\"bgcolor\" value=\"#000000\">\n<param name=\"allowFullScreen\" value=\"false\">\n<param name=\"wmode\" value=\"<%= wmode %>\">\n<param name=\"tabindex\" value=\"1\">\n<param name=\"FlashVars\" value=\"playbackId=<%= playbackId %>&callback=<%= callbackName %>\">\n<embed\n  name=\"<%= cid %>\"\n  type=\"application/x-shockwave-flash\"\n  disabled=\"disabled\"\n  tabindex=\"-1\"\n  enablecontextmenu=\"false\"\n  allowScriptAccess=\"always\"\n  quality=\"autohigh\"\n  pluginspage=\"http://www.macromedia.com/go/getflashplayer\"\n  wmode=\"<%= wmode %>\"\n  swliveconnect=\"true\"\n  allowfullscreen=\"false\"\n  bgcolor=\"#000000\"\n  FlashVars=\"playbackId=<%= playbackId %>&callback=<%= callbackName %>\"\n  data=\"<%= swfPath %>\"\n  src=\"<%= swfPath %>\"\n  width=\"100%\"\n  height=\"100%\">\n</embed>\n";/***/},/* 166 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,".clappr-flash-playback[data-flash-playback] {\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  pointer-events: none; }\n",""]);// exports
/***/},/* 167 *//***/function(module,exports,__webpack_require__){module.exports=__webpack_require__.p+"4b76590b32dab62bc95c1b7951efae78.swf";/***/},/* 168 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _html5_video=__webpack_require__(35);var _html5_video2=_interopRequireDefault(_html5_video);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// TODO: remove this playback and change HTML5Video to HTML5Playback (breaking change, only after 0.3.0)
var HTML5Audio=function(_HTML5Video){(0,_inherits3.default)(HTML5Audio,_HTML5Video);function HTML5Audio(){(0,_classCallCheck3.default)(this,HTML5Audio);return(0,_possibleConstructorReturn3.default)(this,_HTML5Video.apply(this,arguments));}HTML5Audio.prototype.updateSettings=function updateSettings(){this.settings.left=['playpause','position','duration'];this.settings.seekEnabled=this.isSeekEnabled();this.trigger(_events2.default.PLAYBACK_SETTINGSUPDATE);};HTML5Audio.prototype.getPlaybackType=function getPlaybackType(){return _playback2.default.AOD;};(0,_createClass3.default)(HTML5Audio,[{key:'name',get:function get(){return'html5_audio';}},{key:'tagName',get:function get(){return'audio';}},{key:'isAudioOnly',get:function get(){return true;}}]);return HTML5Audio;}(_html5_video2.default);// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
exports.default=HTML5Audio;HTML5Audio.canPlay=function(resourceUrl,mimeType){var mimetypes={'wav':['audio/wav'],'mp3':['audio/mp3','audio/mpeg;codecs="mp3"'],'aac':['audio/mp4;codecs="mp4a.40.5"'],'oga':['audio/ogg']};return _html5_video2.default._canPlay('audio',mimetypes,resourceUrl,mimeType);};module.exports=exports['default'];/***/},/* 169 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _base_flash_playback=__webpack_require__(59);var _base_flash_playback2=_interopRequireDefault(_base_flash_playback);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _mediator=__webpack_require__(24);var _mediator2=_interopRequireDefault(_mediator);var _browser=__webpack_require__(13);var _browser2=_interopRequireDefault(_browser);var _flashls_events=__webpack_require__(170);var _flashls_events2=_interopRequireDefault(_flashls_events);var _HLSPlayer=__webpack_require__(171);var _HLSPlayer2=_interopRequireDefault(_HLSPlayer);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var MAX_ATTEMPTS=60;// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var AUTO=-1;var FlasHLS=function(_BaseFlashPlayback){(0,_inherits3.default)(FlasHLS,_BaseFlashPlayback);(0,_createClass3.default)(FlasHLS,[{key:'name',get:function get(){return'flashls';}},{key:'swfPath',get:function get(){return(0,_template2.default)(_HLSPlayer2.default)({baseUrl:this._baseUrl});}},{key:'levels',get:function get(){return this._levels||[];}},{key:'currentLevel',get:function get(){if(this._currentLevel===null||this._currentLevel===undefined){return AUTO;}else{return this._currentLevel;//0 is a valid level ID
}},set:function set(id){this._currentLevel=id;this.trigger(_events2.default.PLAYBACK_LEVEL_SWITCH_START);this.el.playerSetCurrentLevel(id);}/**
     * Determine if the playback has ended.
     * @property ended
     * @type Boolean
     */},{key:'ended',get:function get(){return this._hasEnded;}/**
     * Determine if the playback is buffering.
     * This is related to the PLAYBACK_BUFFERING and PLAYBACK_BUFFERFULL events
     * @property buffering
     * @type Boolean
     */},{key:'buffering',get:function get(){return!!this._bufferingState&&!this._hasEnded;}}]);function FlasHLS(){(0,_classCallCheck3.default)(this,FlasHLS);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var _this=(0,_possibleConstructorReturn3.default)(this,_BaseFlashPlayback.call.apply(_BaseFlashPlayback,[this].concat(args)));_this._src=_this.options.src;_this._baseUrl=_this.options.baseUrl;_this._initHlsParameters(_this.options);// TODO can this be private?
_this.highDefinition=false;_this._autoPlay=_this.options.autoPlay;_this._loop=_this.options.loop;_this._defaultSettings={left:['playstop'],default:['seekbar'],right:['fullscreen','volume','hd-indicator'],seekEnabled:false};_this.settings=_clapprZepto2.default.extend({},_this._defaultSettings);_this._playbackType=_playback2.default.LIVE;_this._hasEnded=false;_this._addListeners();return _this;}FlasHLS.prototype._initHlsParameters=function _initHlsParameters(options){this._autoStartLoad=options.autoStartLoad===undefined?true:options.autoStartLoad;this._capLevelToStage=options.capLevelToStage===undefined?false:options.capLevelToStage;this._maxLevelCappingMode=options.maxLevelCappingMode===undefined?'downscale':options.maxLevelCappingMode;this._minBufferLength=options.minBufferLength===undefined?-1:options.minBufferLength;this._minBufferLengthCapping=options.minBufferLengthCapping===undefined?-1:options.minBufferLengthCapping;this._maxBufferLength=options.maxBufferLength===undefined?120:options.maxBufferLength;this._maxBackBufferLength=options.maxBackBufferLength===undefined?30:options.maxBackBufferLength;this._lowBufferLength=options.lowBufferLength===undefined?3:options.lowBufferLength;this._mediaTimePeriod=options.mediaTimePeriod===undefined?100:options.mediaTimePeriod;this._fpsDroppedMonitoringPeriod=options.fpsDroppedMonitoringPeriod===undefined?5000:options.fpsDroppedMonitoringPeriod;this._fpsDroppedMonitoringThreshold=options.fpsDroppedMonitoringThreshold===undefined?0.2:options.fpsDroppedMonitoringThreshold;this._capLevelonFPSDrop=options.capLevelonFPSDrop===undefined?false:options.capLevelonFPSDrop;this._smoothAutoSwitchonFPSDrop=options.smoothAutoSwitchonFPSDrop===undefined?this.capLevelonFPSDrop:options.smoothAutoSwitchonFPSDrop;this._switchDownOnLevelError=options.switchDownOnLevelError===undefined?true:options.switchDownOnLevelError;this._seekMode=options.seekMode===undefined?'ACCURATE':options.seekMode;this._keyLoadMaxRetry=options.keyLoadMaxRetry===undefined?3:options.keyLoadMaxRetry;this._keyLoadMaxRetryTimeout=options.keyLoadMaxRetryTimeout===undefined?64000:options.keyLoadMaxRetryTimeout;this._fragmentLoadMaxRetry=options.fragmentLoadMaxRetry===undefined?3:options.fragmentLoadMaxRetry;this._fragmentLoadMaxRetryTimeout=options.fragmentLoadMaxRetryTimeout===undefined?4000:options.fragmentLoadMaxRetryTimeout;this._fragmentLoadSkipAfterMaxRetry=options.fragmentLoadSkipAfterMaxRetry===undefined?true:options.fragmentLoadSkipAfterMaxRetry;this._maxSkippedFragments=options.maxSkippedFragments===undefined?5:options.maxSkippedFragments;this._flushLiveURLCache=options.flushLiveURLCache===undefined?false:options.flushLiveURLCache;this._initialLiveManifestSize=options.initialLiveManifestSize===undefined?1:options.initialLiveManifestSize;this._manifestLoadMaxRetry=options.manifestLoadMaxRetry===undefined?3:options.manifestLoadMaxRetry;this._manifestLoadMaxRetryTimeout=options.manifestLoadMaxRetryTimeout===undefined?64000:options.manifestLoadMaxRetryTimeout;this._manifestRedundantLoadmaxRetry=options.manifestRedundantLoadmaxRetry===undefined?3:options.manifestRedundantLoadmaxRetry;this._startFromBitrate=options.startFromBitrate===undefined?-1:options.startFromBitrate;this._startFromLevel=options.startFromLevel===undefined?-1:options.startFromLevel;this._autoStartMaxDuration=options.autoStartMaxDuration===undefined?-1:options.autoStartMaxDuration;this._seekFromLevel=options.seekFromLevel===undefined?-1:options.seekFromLevel;this._useHardwareVideoDecoder=options.useHardwareVideoDecoder===undefined?false:options.useHardwareVideoDecoder;this._hlsLogEnabled=options.hlsLogEnabled===undefined?true:options.hlsLogEnabled;this._logDebug=options.logDebug===undefined?false:options.logDebug;this._logDebug2=options.logDebug2===undefined?false:options.logDebug2;this._logWarn=options.logWarn===undefined?true:options.logWarn;this._logError=options.logError===undefined?true:options.logError;this._hlsMinimumDvrSize=options.hlsMinimumDvrSize===undefined?60:options.hlsMinimumDvrSize;};FlasHLS.prototype._addListeners=function _addListeners(){var _this2=this;_mediator2.default.on(this.cid+':flashready',function(){return _this2._bootstrap();});_mediator2.default.on(this.cid+':timeupdate',function(timeMetrics){return _this2._updateTime(timeMetrics);});_mediator2.default.on(this.cid+':playbackstate',function(state){return _this2._setPlaybackState(state);});_mediator2.default.on(this.cid+':levelchanged',function(level){return _this2._levelChanged(level);});_mediator2.default.on(this.cid+':error',function(code,url,message){return _this2._flashPlaybackError(code,url,message);});_mediator2.default.on(this.cid+':fragmentloaded',function(loadmetrics){return _this2._onFragmentLoaded(loadmetrics);});_mediator2.default.on(this.cid+':levelendlist',function(level){return _this2._onLevelEndlist(level);});};FlasHLS.prototype.stopListening=function stopListening(){_BaseFlashPlayback.prototype.stopListening.call(this);_mediator2.default.off(this.cid+':flashready');_mediator2.default.off(this.cid+':timeupdate');_mediator2.default.off(this.cid+':playbackstate');_mediator2.default.off(this.cid+':levelchanged');_mediator2.default.off(this.cid+':playbackerror');_mediator2.default.off(this.cid+':fragmentloaded');_mediator2.default.off(this.cid+':manifestloaded');_mediator2.default.off(this.cid+':levelendlist');};FlasHLS.prototype._bootstrap=function _bootstrap(){var _this3=this;if(this.el.playerLoad){this.el.width='100%';this.el.height='100%';this._isReadyState=true;this._srcLoaded=false;this._currentState='IDLE';this._setFlashSettings();this._updatePlaybackType();if(this._autoPlay||this._shouldPlayOnManifestLoaded){this.play();}this.trigger(_events2.default.PLAYBACK_READY,this.name);}else{this._bootstrapAttempts=this._bootstrapAttempts||0;if(++this._bootstrapAttempts<=MAX_ATTEMPTS){setTimeout(function(){return _this3._bootstrap();},50);}else{this.trigger(_events2.default.PLAYBACK_ERROR,{message:'Max number of attempts reached'},this.name);}}};FlasHLS.prototype._setFlashSettings=function _setFlashSettings(){this.el.playerSetAutoStartLoad(this._autoStartLoad);this.el.playerSetCapLevelToStage(this._capLevelToStage);this.el.playerSetMaxLevelCappingMode(this._maxLevelCappingMode);this.el.playerSetMinBufferLength(this._minBufferLength);this.el.playerSetMinBufferLengthCapping(this._minBufferLengthCapping);this.el.playerSetMaxBufferLength(this._maxBufferLength);this.el.playerSetMaxBackBufferLength(this._maxBackBufferLength);this.el.playerSetLowBufferLength(this._lowBufferLength);this.el.playerSetMediaTimePeriod(this._mediaTimePeriod);this.el.playerSetFpsDroppedMonitoringPeriod(this._fpsDroppedMonitoringPeriod);this.el.playerSetFpsDroppedMonitoringThreshold(this._fpsDroppedMonitoringThreshold);this.el.playerSetCapLevelonFPSDrop(this._capLevelonFPSDrop);this.el.playerSetSmoothAutoSwitchonFPSDrop(this._smoothAutoSwitchonFPSDrop);this.el.playerSetSwitchDownOnLevelError(this._switchDownOnLevelError);this.el.playerSetSeekMode(this._seekMode);this.el.playerSetKeyLoadMaxRetry(this._keyLoadMaxRetry);this.el.playerSetKeyLoadMaxRetryTimeout(this._keyLoadMaxRetryTimeout);this.el.playerSetFragmentLoadMaxRetry(this._fragmentLoadMaxRetry);this.el.playerSetFragmentLoadMaxRetryTimeout(this._fragmentLoadMaxRetryTimeout);this.el.playerSetFragmentLoadSkipAfterMaxRetry(this._fragmentLoadSkipAfterMaxRetry);this.el.playerSetMaxSkippedFragments(this._maxSkippedFragments);this.el.playerSetFlushLiveURLCache(this._flushLiveURLCache);this.el.playerSetInitialLiveManifestSize(this._initialLiveManifestSize);this.el.playerSetManifestLoadMaxRetry(this._manifestLoadMaxRetry);this.el.playerSetManifestLoadMaxRetryTimeout(this._manifestLoadMaxRetryTimeout);this.el.playerSetManifestRedundantLoadmaxRetry(this._manifestRedundantLoadmaxRetry);this.el.playerSetStartFromBitrate(this._startFromBitrate);this.el.playerSetStartFromLevel(this._startFromLevel);this.el.playerSetAutoStartMaxDuration(this._autoStartMaxDuration);this.el.playerSetSeekFromLevel(this._seekFromLevel);this.el.playerSetUseHardwareVideoDecoder(this._useHardwareVideoDecoder);this.el.playerSetLogInfo(this._hlsLogEnabled);this.el.playerSetLogDebug(this._logDebug);this.el.playerSetLogDebug2(this._logDebug2);this.el.playerSetLogWarn(this._logWarn);this.el.playerSetLogError(this._logError);};FlasHLS.prototype.setAutoStartLoad=function setAutoStartLoad(autoStartLoad){this._autoStartLoad=autoStartLoad;this.el.playerSetAutoStartLoad(this._autoStartLoad);};FlasHLS.prototype.setCapLevelToStage=function setCapLevelToStage(capLevelToStage){this._capLevelToStage=capLevelToStage;this.el.playerSetCapLevelToStage(this._capLevelToStage);};FlasHLS.prototype.setMaxLevelCappingMode=function setMaxLevelCappingMode(maxLevelCappingMode){this._maxLevelCappingMode=maxLevelCappingMode;this.el.playerSetMaxLevelCappingMode(this._maxLevelCappingMode);};FlasHLS.prototype.setSetMinBufferLength=function setSetMinBufferLength(minBufferLength){this._minBufferLength=minBufferLength;this.el.playerSetMinBufferLength(this._minBufferLength);};FlasHLS.prototype.setMinBufferLengthCapping=function setMinBufferLengthCapping(minBufferLengthCapping){this._minBufferLengthCapping=minBufferLengthCapping;this.el.playerSetMinBufferLengthCapping(this._minBufferLengthCapping);};FlasHLS.prototype.setMaxBufferLength=function setMaxBufferLength(maxBufferLength){this._maxBufferLength=maxBufferLength;this.el.playerSetMaxBufferLength(this._maxBufferLength);};FlasHLS.prototype.setMaxBackBufferLength=function setMaxBackBufferLength(maxBackBufferLength){this._maxBackBufferLength=maxBackBufferLength;this.el.playerSetMaxBackBufferLength(this._maxBackBufferLength);};FlasHLS.prototype.setLowBufferLength=function setLowBufferLength(lowBufferLength){this._lowBufferLength=lowBufferLength;this.el.playerSetLowBufferLength(this._lowBufferLength);};FlasHLS.prototype.setMediaTimePeriod=function setMediaTimePeriod(mediaTimePeriod){this._mediaTimePeriod=mediaTimePeriod;this.el.playerSetMediaTimePeriod(this._mediaTimePeriod);};FlasHLS.prototype.setFpsDroppedMonitoringPeriod=function setFpsDroppedMonitoringPeriod(fpsDroppedMonitoringPeriod){this._fpsDroppedMonitoringPeriod=fpsDroppedMonitoringPeriod;this.el.playerSetFpsDroppedMonitoringPeriod(this._fpsDroppedMonitoringPeriod);};FlasHLS.prototype.setFpsDroppedMonitoringThreshold=function setFpsDroppedMonitoringThreshold(fpsDroppedMonitoringThreshold){this._fpsDroppedMonitoringThreshold=fpsDroppedMonitoringThreshold;this.el.playerSetFpsDroppedMonitoringThreshold(this._fpsDroppedMonitoringThreshold);};FlasHLS.prototype.setCapLevelonFPSDrop=function setCapLevelonFPSDrop(capLevelonFPSDrop){this._capLevelonFPSDrop=capLevelonFPSDrop;this.el.playerSetCapLevelonFPSDrop(this._capLevelonFPSDrop);};FlasHLS.prototype.setSmoothAutoSwitchonFPSDrop=function setSmoothAutoSwitchonFPSDrop(smoothAutoSwitchonFPSDrop){this._smoothAutoSwitchonFPSDrop=smoothAutoSwitchonFPSDrop;this.el.playerSetSmoothAutoSwitchonFPSDrop(this._smoothAutoSwitchonFPSDrop);};FlasHLS.prototype.setSwitchDownOnLevelError=function setSwitchDownOnLevelError(switchDownOnLevelError){this._switchDownOnLevelError=switchDownOnLevelError;this.el.playerSetSwitchDownOnLevelError(this._switchDownOnLevelError);};FlasHLS.prototype.setSeekMode=function setSeekMode(seekMode){this._seekMode=seekMode;this.el.playerSetSeekMode(this._seekMode);};FlasHLS.prototype.setKeyLoadMaxRetry=function setKeyLoadMaxRetry(keyLoadMaxRetry){this._keyLoadMaxRetry=keyLoadMaxRetry;this.el.playerSetKeyLoadMaxRetry(this._keyLoadMaxRetry);};FlasHLS.prototype.setKeyLoadMaxRetryTimeout=function setKeyLoadMaxRetryTimeout(keyLoadMaxRetryTimeout){this._keyLoadMaxRetryTimeout=keyLoadMaxRetryTimeout;this.el.playerSetKeyLoadMaxRetryTimeout(this._keyLoadMaxRetryTimeout);};FlasHLS.prototype.setFragmentLoadMaxRetry=function setFragmentLoadMaxRetry(fragmentLoadMaxRetry){this._fragmentLoadMaxRetry=fragmentLoadMaxRetry;this.el.playerSetFragmentLoadMaxRetry(this._fragmentLoadMaxRetry);};FlasHLS.prototype.setFragmentLoadMaxRetryTimeout=function setFragmentLoadMaxRetryTimeout(fragmentLoadMaxRetryTimeout){this._fragmentLoadMaxRetryTimeout=fragmentLoadMaxRetryTimeout;this.el.playerSetFragmentLoadMaxRetryTimeout(this._fragmentLoadMaxRetryTimeout);};FlasHLS.prototype.setFragmentLoadSkipAfterMaxRetry=function setFragmentLoadSkipAfterMaxRetry(fragmentLoadSkipAfterMaxRetry){this._fragmentLoadSkipAfterMaxRetry=fragmentLoadSkipAfterMaxRetry;this.el.playerSetFragmentLoadSkipAfterMaxRetry(this._fragmentLoadSkipAfterMaxRetry);};FlasHLS.prototype.setMaxSkippedFragments=function setMaxSkippedFragments(maxSkippedFragments){this._maxSkippedFragments=maxSkippedFragments;this.el.playerSetMaxSkippedFragments(this._maxSkippedFragments);};FlasHLS.prototype.setFlushLiveURLCache=function setFlushLiveURLCache(flushLiveURLCache){this._flushLiveURLCache=flushLiveURLCache;this.el.playerSetFlushLiveURLCache(this._flushLiveURLCache);};FlasHLS.prototype.setInitialLiveManifestSize=function setInitialLiveManifestSize(initialLiveManifestSize){this._initialLiveManifestSize=initialLiveManifestSize;this.el.playerSetInitialLiveManifestSize(this._initialLiveManifestSize);};FlasHLS.prototype.setManifestLoadMaxRetry=function setManifestLoadMaxRetry(manifestLoadMaxRetry){this._manifestLoadMaxRetry=manifestLoadMaxRetry;this.el.playerSetManifestLoadMaxRetry(this._manifestLoadMaxRetry);};FlasHLS.prototype.setManifestLoadMaxRetryTimeout=function setManifestLoadMaxRetryTimeout(manifestLoadMaxRetryTimeout){this._manifestLoadMaxRetryTimeout=manifestLoadMaxRetryTimeout;this.el.playerSetManifestLoadMaxRetryTimeout(this._manifestLoadMaxRetryTimeout);};FlasHLS.prototype.setManifestRedundantLoadmaxRetry=function setManifestRedundantLoadmaxRetry(manifestRedundantLoadmaxRetry){this._manifestRedundantLoadmaxRetry=manifestRedundantLoadmaxRetry;this.el.playerSetManifestRedundantLoadmaxRetry(this._manifestRedundantLoadmaxRetry);};FlasHLS.prototype.setStartFromBitrate=function setStartFromBitrate(startFromBitrate){this._startFromBitrate=startFromBitrate;this.el.playerSetStartFromBitrate(this._startFromBitrate);};FlasHLS.prototype.setStartFromLevel=function setStartFromLevel(startFromLevel){this._startFromLevel=startFromLevel;this.el.playerSetStartFromLevel(this._startFromLevel);};FlasHLS.prototype.setAutoStartMaxDuration=function setAutoStartMaxDuration(autoStartMaxDuration){this._autoStartMaxDuration=autoStartMaxDuration;this.el.playerSetAutoStartMaxDuration(this._autoStartMaxDuration);};FlasHLS.prototype.setSeekFromLevel=function setSeekFromLevel(seekFromLevel){this._seekFromLevel=seekFromLevel;this.el.playerSetSeekFromLevel(this._seekFromLevel);};FlasHLS.prototype.setUseHardwareVideoDecoder=function setUseHardwareVideoDecoder(useHardwareVideoDecoder){this._useHardwareVideoDecoder=useHardwareVideoDecoder;this.el.playerSetUseHardwareVideoDecoder(this._useHardwareVideoDecoder);};FlasHLS.prototype.setSetLogInfo=function setSetLogInfo(hlsLogEnabled){this._hlsLogEnabled=hlsLogEnabled;this.el.playerSetLogInfo(this._hlsLogEnabled);};FlasHLS.prototype.setLogDebug=function setLogDebug(logDebug){this._logDebug=logDebug;this.el.playerSetLogDebug(this._logDebug);};FlasHLS.prototype.setLogDebug2=function setLogDebug2(logDebug2){this._logDebug2=logDebug2;this.el.playerSetLogDebug2(this._logDebug2);};FlasHLS.prototype.setLogWarn=function setLogWarn(logWarn){this._logWarn=logWarn;this.el.playerSetLogWarn(this._logWarn);};FlasHLS.prototype.setLogError=function setLogError(logError){this._logError=logError;this.el.playerSetLogError(this._logError);};FlasHLS.prototype._levelChanged=function _levelChanged(level){var currentLevel=this.el.getLevels()[level];if(currentLevel){this.highDefinition=currentLevel.height>=720||currentLevel.bitrate/1000>=2000;this.trigger(_events2.default.PLAYBACK_HIGHDEFINITIONUPDATE,this.highDefinition);if(!this._levels||this._levels.length===0)this._fillLevels();this.trigger(_events2.default.PLAYBACK_BITRATE,{height:currentLevel.height,width:currentLevel.width,bandwidth:currentLevel.bitrate,bitrate:currentLevel.bitrate,level:level});this.trigger(_events2.default.PLAYBACK_LEVEL_SWITCH_END);}};FlasHLS.prototype._updateTime=function _updateTime(timeMetrics){if(this._currentState==='IDLE'){return;}var duration=this._normalizeDuration(timeMetrics.duration);var position=Math.min(Math.max(timeMetrics.position,0),duration);var previousDVRStatus=this._dvrEnabled;var livePlayback=this._playbackType===_playback2.default.LIVE;this._dvrEnabled=livePlayback&&duration>this._hlsMinimumDvrSize;if(duration===100||livePlayback===undefined){return;}if(this._dvrEnabled!==previousDVRStatus){this._updateSettings();this.trigger(_events2.default.PLAYBACK_SETTINGSUPDATE,this.name);}if(livePlayback&&(!this._dvrEnabled||!this._dvrInUse)){position=duration;}this.trigger(_events2.default.PLAYBACK_TIMEUPDATE,{current:position,total:duration},this.name);};FlasHLS.prototype.play=function play(){this.trigger(_events2.default.PLAYBACK_PLAY_INTENT);if(this._currentState==='PAUSED'){this.el.playerResume();}else if(!this._srcLoaded&&this._currentState!=='PLAYING'){this._firstPlay();}else{this.el.playerPlay();}};FlasHLS.prototype.getPlaybackType=function getPlaybackType(){return this._playbackType?this._playbackType:null;};FlasHLS.prototype.getCurrentLevelIndex=function getCurrentLevelIndex(){return this._currentLevel;};FlasHLS.prototype.getCurrentLevel=function getCurrentLevel(){return this.levels[this.currentLevel];};FlasHLS.prototype.getCurrentBitrate=function getCurrentBitrate(){return this.levels[this.currentLevel].bitrate;};FlasHLS.prototype.setCurrentLevel=function setCurrentLevel(level){this.currentLevel=level;};FlasHLS.prototype.isHighDefinitionInUse=function isHighDefinitionInUse(){return this.highDefinition;};FlasHLS.prototype.getLevels=function getLevels(){return this.levels;};FlasHLS.prototype._setPlaybackState=function _setPlaybackState(state){if(['PLAYING_BUFFERING','PAUSED_BUFFERING'].indexOf(state)>=0){this._bufferingState=true;this.trigger(_events2.default.PLAYBACK_BUFFERING,this.name);this._updateCurrentState(state);}else if(['PLAYING','PAUSED'].indexOf(state)>=0){if(['PLAYING_BUFFERING','PAUSED_BUFFERING','IDLE'].indexOf(this._currentState)>=0){this._bufferingState=false;this.trigger(_events2.default.PLAYBACK_BUFFERFULL,this.name);}this._updateCurrentState(state);}else if(state==='IDLE'){this._srcLoaded=false;if(this._loop&&['PLAYING_BUFFERING','PLAYING'].indexOf(this._currentState)>=0){this.play();this.seek(0);}else{this._updateCurrentState(state);this._hasEnded=true;this.trigger(_events2.default.PLAYBACK_TIMEUPDATE,{current:0,total:this.getDuration()},this.name);this.trigger(_events2.default.PLAYBACK_ENDED,this.name);}}};FlasHLS.prototype._updateCurrentState=function _updateCurrentState(state){this._currentState=state;if(state!=='IDLE'){this._hasEnded=false;}this._updatePlaybackType();if(state==='PLAYING'){this.trigger(_events2.default.PLAYBACK_PLAY,this.name);}else if(state==='PAUSED'){this.trigger(_events2.default.PLAYBACK_PAUSE,this.name);}};FlasHLS.prototype._updatePlaybackType=function _updatePlaybackType(){this._playbackType=this.el.getType();if(this._playbackType){this._playbackType=this._playbackType.toLowerCase();if(this._playbackType===_playback2.default.VOD){this._startReportingProgress();}else{this._stopReportingProgress();}}this.trigger(_events2.default.PLAYBACK_PLAYBACKSTATE,{type:this._playbackType});};FlasHLS.prototype._startReportingProgress=function _startReportingProgress(){if(!this._reportingProgress){this._reportingProgress=true;}};FlasHLS.prototype._stopReportingProgress=function _stopReportingProgress(){this._reportingProgress=false;};FlasHLS.prototype._onFragmentLoaded=function _onFragmentLoaded(loadmetrics){this.trigger(_events2.default.PLAYBACK_FRAGMENT_LOADED,loadmetrics);if(this._reportingProgress&&this.el.getPosition){var buffered=this.el.getPosition()+this.el.getbufferLength();this.trigger(_events2.default.PLAYBACK_PROGRESS,{start:this.el.getPosition(),current:buffered,total:this.el.getDuration()});}};FlasHLS.prototype._onLevelEndlist=function _onLevelEndlist(){this._updatePlaybackType();};FlasHLS.prototype._firstPlay=function _firstPlay(){var _this4=this;this._shouldPlayOnManifestLoaded=true;if(this.el.playerLoad){_mediator2.default.once(this.cid+':manifestloaded',function(duration,loadmetrics){return _this4._manifestLoaded(duration,loadmetrics);});this._setFlashSettings();//ensure flushLiveURLCache will work (#327)
this.el.playerLoad(this._src);this._srcLoaded=true;}};FlasHLS.prototype.volume=function volume(value){var _this5=this;if(this.isReady){this.el.playerVolume(value);}else{this.listenToOnce(this,_events2.default.PLAYBACK_BUFFERFULL,function(){return _this5.volume(value);});}};FlasHLS.prototype.pause=function pause(){if(this._playbackType!==_playback2.default.LIVE||this._dvrEnabled){this.el.playerPause();if(this._playbackType===_playback2.default.LIVE&&this._dvrEnabled){this._updateDvr(true);}}};FlasHLS.prototype.stop=function stop(){this._srcLoaded=false;this.el.playerStop();this.trigger(_events2.default.PLAYBACK_STOP);this.trigger(_events2.default.PLAYBACK_TIMEUPDATE,{current:0,total:0},this.name);};FlasHLS.prototype.isPlaying=function isPlaying(){if(this._currentState){return!!this._currentState.match(/playing/i);}return false;};FlasHLS.prototype.getDuration=function getDuration(){return this._normalizeDuration(this.el.getDuration());};FlasHLS.prototype._normalizeDuration=function _normalizeDuration(duration){if(this._playbackType===_playback2.default.LIVE){// estimate 10 seconds of buffer time for live streams for seek positions
duration=Math.max(0,duration-10);}return duration;};FlasHLS.prototype.seekPercentage=function seekPercentage(percentage){var duration=this.el.getDuration();var time=0;if(percentage>0){time=duration*percentage/100;}this.seek(time);};FlasHLS.prototype.seek=function seek(time){var duration=this.getDuration();if(this._playbackType===_playback2.default.LIVE){// seek operations to a time within 3 seconds from live stream will position playhead back to live
var dvrInUse=duration-time>3;this._updateDvr(dvrInUse);}this.el.playerSeek(time);this.trigger(_events2.default.PLAYBACK_TIMEUPDATE,{current:time,total:duration},this.name);};FlasHLS.prototype._updateDvr=function _updateDvr(dvrInUse){var previousDvrInUse=!!this._dvrInUse;this._dvrInUse=dvrInUse;if(this._dvrInUse!==previousDvrInUse){this._updateSettings();this.trigger(_events2.default.PLAYBACK_DVR,this._dvrInUse);this.trigger(_events2.default.PLAYBACK_STATS_ADD,{'dvr':this._dvrInUse});}};FlasHLS.prototype._flashPlaybackError=function _flashPlaybackError(code,url,message){this.trigger(_events2.default.PLAYBACK_ERROR,{code:code,url:url,message:message});this.trigger(_events2.default.PLAYBACK_STOP);};FlasHLS.prototype._manifestLoaded=function _manifestLoaded(duration,loadmetrics){if(this._shouldPlayOnManifestLoaded){this._shouldPlayOnManifestLoaded=false;// this method initialises the player (and starts playback)
// this needs to happen before PLAYBACK_LOADEDMETADATA is fired
// as the user may call seek() in a LOADEDMETADATA listener.
/// when playerPlay() is called the player seeks to 0
this.el.playerPlay();}this._fillLevels();this.trigger(_events2.default.PLAYBACK_LOADEDMETADATA,{duration:duration,data:loadmetrics});};FlasHLS.prototype._fillLevels=function _fillLevels(){var levels=this.el.getLevels();var levelsLength=levels.length;this._levels=[];for(var index=0;index<levelsLength;index++){this._levels.push({id:index,label:levels[index].height+'p',level:levels[index]});}this.trigger(_events2.default.PLAYBACK_LEVELS_AVAILABLE,this._levels);};FlasHLS.prototype.destroy=function destroy(){this.stopListening();this.$el.remove();};FlasHLS.prototype._updateSettings=function _updateSettings(){this.settings=_clapprZepto2.default.extend({},this._defaultSettings);if(this._playbackType===_playback2.default.VOD||this._dvrInUse){this.settings.left=['playpause','position','duration'];this.settings.seekEnabled=true;}else if(this._dvrEnabled){this.settings.left=['playpause'];this.settings.seekEnabled=true;}else{this.settings.seekEnabled=false;}};FlasHLS.prototype._createCallbacks=function _createCallbacks(){var _this6=this;if(!window.Clappr){window.Clappr={};}if(!window.Clappr.flashlsCallbacks){window.Clappr.flashlsCallbacks={};}this.flashlsEvents=new _flashls_events2.default(this.cid);window.Clappr.flashlsCallbacks[this.cid]=function(eventName,args){_this6.flashlsEvents[eventName].apply(_this6.flashlsEvents,args);};};FlasHLS.prototype.render=function render(){_BaseFlashPlayback.prototype.render.call(this);this._createCallbacks();return this;};(0,_createClass3.default)(FlasHLS,[{key:'isReady',get:function get(){return this._isReadyState;}},{key:'dvrEnabled',get:function get(){return!!this._dvrEnabled;}}]);return FlasHLS;}(_base_flash_playback2.default);exports.default=FlasHLS;FlasHLS.canPlay=function(resource,mimeType){var resourceParts=resource.split('?')[0].match(/.*\.(.*)$/)||[];return _browser2.default.hasFlash&&(resourceParts.length>1&&resourceParts[1].toLowerCase()==='m3u8'||mimeType==='application/x-mpegURL'||mimeType==='application/vnd.apple.mpegurl');};module.exports=exports['default'];/***/},/* 170 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _mediator=__webpack_require__(24);var _mediator2=_interopRequireDefault(_mediator);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var HLSEvents=function(){function HLSEvents(instanceId){(0,_classCallCheck3.default)(this,HLSEvents);this.instanceId=instanceId;}HLSEvents.prototype.ready=function ready(){_mediator2.default.trigger(this.instanceId+':flashready');};HLSEvents.prototype.videoSize=function videoSize(width,height){_mediator2.default.trigger(this.instanceId+':videosizechanged',width,height);};HLSEvents.prototype.complete=function complete(){_mediator2.default.trigger(this.instanceId+':complete');};HLSEvents.prototype.error=function error(code,url,message){_mediator2.default.trigger(this.instanceId+':error',code,url,message);};HLSEvents.prototype.manifest=function manifest(duration,loadmetrics){_mediator2.default.trigger(this.instanceId+':manifestloaded',duration,loadmetrics);};HLSEvents.prototype.audioLevelLoaded=function audioLevelLoaded(loadmetrics){_mediator2.default.trigger(this.instanceId+':audiolevelloaded',loadmetrics);};HLSEvents.prototype.levelLoaded=function levelLoaded(loadmetrics){_mediator2.default.trigger(this.instanceId+':levelloaded',loadmetrics);};HLSEvents.prototype.levelEndlist=function levelEndlist(level){_mediator2.default.trigger(this.instanceId+':levelendlist',level);};HLSEvents.prototype.fragmentLoaded=function fragmentLoaded(loadmetrics){_mediator2.default.trigger(this.instanceId+':fragmentloaded',loadmetrics);};HLSEvents.prototype.fragmentPlaying=function fragmentPlaying(playmetrics){_mediator2.default.trigger(this.instanceId+':fragmentplaying',playmetrics);};HLSEvents.prototype.position=function position(timemetrics){_mediator2.default.trigger(this.instanceId+':timeupdate',timemetrics);};HLSEvents.prototype.state=function state(newState){_mediator2.default.trigger(this.instanceId+':playbackstate',newState);};HLSEvents.prototype.seekState=function seekState(newState){_mediator2.default.trigger(this.instanceId+':seekstate',newState);};HLSEvents.prototype.switch=function _switch(newLevel){_mediator2.default.trigger(this.instanceId+':levelchanged',newLevel);};HLSEvents.prototype.audioTracksListChange=function audioTracksListChange(trackList){_mediator2.default.trigger(this.instanceId+':audiotracklistchanged',trackList);};HLSEvents.prototype.audioTrackChange=function audioTrackChange(trackId){_mediator2.default.trigger(this.instanceId+':audiotrackchanged',trackId);};return HLSEvents;}();exports.default=HLSEvents;module.exports=exports['default'];/***/},/* 171 *//***/function(module,exports,__webpack_require__){module.exports=__webpack_require__.p+"809981e5b09d5336c45d72d0869ada2a.swf";/***/},/* 172 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _toConsumableArray2=__webpack_require__(79);var _toConsumableArray3=_interopRequireDefault(_toConsumableArray2);var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _html5_video=__webpack_require__(35);var _html5_video2=_interopRequireDefault(_html5_video);var _hls=__webpack_require__(173);var _hls2=_interopRequireDefault(_hls);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _utils=__webpack_require__(5);var _log=__webpack_require__(55);var _log2=_interopRequireDefault(_log);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var AUTO=-1;var HLS=function(_HTML5VideoPlayback){(0,_inherits3.default)(HLS,_HTML5VideoPlayback);(0,_createClass3.default)(HLS,[{key:'name',get:function get(){return'hls';}},{key:'levels',get:function get(){return this._levels||[];}},{key:'currentLevel',get:function get(){if(this._currentLevel===null||this._currentLevel===undefined){return AUTO;}else{return this._currentLevel;//0 is a valid level ID
}},set:function set(id){this._currentLevel=id;this.trigger(_events2.default.PLAYBACK_LEVEL_SWITCH_START);this._hls.currentLevel=this._currentLevel;}},{key:'_startTime',get:function get(){if(this._playbackType===_playback2.default.LIVE&&this._playlistType!=='EVENT'){return this._extrapolatedStartTime;}return this._playableRegionStartTime;}},{key:'_now',get:function get(){return(0,_utils.now)();}// the time in the video element which should represent the start of the sliding window
// extrapolated to increase in real time (instead of jumping as the early segments are removed)
},{key:'_extrapolatedStartTime',get:function get(){if(!this._localStartTimeCorrelation){return this._playableRegionStartTime;}var corr=this._localStartTimeCorrelation;var timePassed=this._now-corr.local;var extrapolatedWindowStartTime=(corr.remote+timePassed)/1000;// cap at the end of the extrapolated window duration
return Math.min(extrapolatedWindowStartTime,this._playableRegionStartTime+this._extrapolatedWindowDuration);}// the time in the video element which should represent the end of the content
// extrapolated to increase in real time (instead of jumping as segments are added)
},{key:'_extrapolatedEndTime',get:function get(){var actualEndTime=this._playableRegionStartTime+this._playableRegionDuration;if(!this._localEndTimeCorrelation){return actualEndTime;}var corr=this._localEndTimeCorrelation;var timePassed=this._now-corr.local;var extrapolatedEndTime=(corr.remote+timePassed)/1000;return Math.max(actualEndTime-this._extrapolatedWindowDuration,Math.min(extrapolatedEndTime,actualEndTime));}},{key:'_duration',get:function get(){return this._extrapolatedEndTime-this._startTime;}// Returns the duration (seconds) of the window that the extrapolated start time is allowed
// to move in before being capped.
// The extrapolated start time should never reach the cap at the end of the window as the
// window should slide as chunks are removed from the start.
// This also applies to the extrapolated end time in the same way.
//
// If chunks aren't being removed for some reason that the start time will reach and remain fixed at
// playableRegionStartTime + extrapolatedWindowDuration
//
//                                <-- window duration -->
// I.e   playableRegionStartTime |-----------------------|
//                               | -->   .       .       .
//                               .   --> | -->   .       .
//                               .       .   --> | -->   .
//                               .       .       .   --> |
//                               .       .       .       .
//                                 extrapolatedStartTime
},{key:'_extrapolatedWindowDuration',get:function get(){if(this._segmentTargetDuration===null){return 0;}return this._extrapolatedWindowNumSegments*this._segmentTargetDuration;}}],[{key:'HLSJS',get:function get(){return _hls2.default;}}]);function HLS(){(0,_classCallCheck3.default)(this,HLS);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}// backwards compatibility (TODO: remove on 0.3.0)
var _this=(0,_possibleConstructorReturn3.default)(this,_HTML5VideoPlayback.call.apply(_HTML5VideoPlayback,[this].concat(args)));_this.options.playback||(_this.options.playback=_this.options);_this._minDvrSize=typeof _this.options.hlsMinimumDvrSize==='undefined'?60:_this.options.hlsMinimumDvrSize;// The size of the start time extrapolation window measured as a multiple of segments.
// Should be 2 or higher, or 0 to disable. Should only need to be increased above 2 if more than one segment is
// removed from the start of the playlist at a time. E.g if the playlist is cached for 10 seconds and new chunks are
// added/removed every 5.
_this._extrapolatedWindowNumSegments=!_this.options.playback||typeof _this.options.playback.extrapolatedWindowNumSegments==='undefined'?2:_this.options.playback.extrapolatedWindowNumSegments;_this._playbackType=_playback2.default.VOD;_this._lastTimeUpdate=null;_this._lastDuration=null;// for hls streams which have dvr with a sliding window,
// the content at the start of the playlist is removed as new
// content is appended at the end.
// this means the actual playable start time will increase as the
// start content is deleted
// For streams with dvr where the entire recording is kept from the
// beginning this should stay as 0
_this._playableRegionStartTime=0;// {local, remote} remote is the time in the video element that should represent 0
//                 local is the system time when the 'remote' measurment took place
_this._localStartTimeCorrelation=null;// {local, remote} remote is the time in the video element that should represents the end
//                 local is the system time when the 'remote' measurment took place
_this._localEndTimeCorrelation=null;// if content is removed from the beginning then this empty area should
// be ignored. "playableRegionDuration" excludes the empty area
_this._playableRegionDuration=0;// true when the actual duration is longer than hlsjs's live sync point
// when this is false playableRegionDuration will be the actual duration
// when this is true playableRegionDuration will exclude the time after the sync point
_this._durationExcludesAfterLiveSyncPoint=false;// #EXT-X-TARGETDURATION
_this._segmentTargetDuration=null;// #EXT-X-PLAYLIST-TYPE
_this._playlistType=null;_this._recoverAttemptsRemaining=_this.options.hlsRecoverAttempts||16;_this._startTimeUpdateTimer();return _this;}HLS.prototype._setupHls=function _setupHls(){var _this2=this;this._ccIsSetup=false;this._ccTracksUpdated=false;this._hls=new _hls2.default(this.options.playback.hlsjsConfig||{});this._hls.on(_hls2.default.Events.MEDIA_ATTACHED,function(){return _this2._hls.loadSource(_this2.options.src);});this._hls.on(_hls2.default.Events.LEVEL_LOADED,function(evt,data){return _this2._updatePlaybackType(evt,data);});this._hls.on(_hls2.default.Events.LEVEL_UPDATED,function(evt,data){return _this2._onLevelUpdated(evt,data);});this._hls.on(_hls2.default.Events.LEVEL_SWITCH,function(evt,data){return _this2._onLevelSwitch(evt,data);});this._hls.on(_hls2.default.Events.FRAG_LOADED,function(evt,data){return _this2._onFragmentLoaded(evt,data);});this._hls.on(_hls2.default.Events.ERROR,function(evt,data){return _this2._onHLSJSError(evt,data);});this._hls.on(_hls2.default.Events.SUBTITLE_TRACK_LOADED,function(evt,data){return _this2._onSubtitleLoaded(evt,data);});this._hls.on(_hls2.default.Events.SUBTITLE_TRACKS_UPDATED,function(){return _this2._ccTracksUpdated=true;});this._hls.attachMedia(this.el);};HLS.prototype._recover=function _recover(evt,data){if(!this._recoveredDecodingError){this._recoveredDecodingError=true;this._hls.recoverMediaError();}else if(!this._recoveredAudioCodecError){this._recoveredAudioCodecError=true;this._hls.swapAudioCodec();this._hls.recoverMediaError();}else{_log2.default.error('hlsjs: failed to recover');this.trigger(_events2.default.PLAYBACK_ERROR,'hlsjs: could not recover from error, evt '+evt+', data '+data+' ',this.name);}};// override
HLS.prototype._setupSrc=function _setupSrc(srcUrl){// eslint-disable-line no-unused-vars
// this playback manages the src on the video element itself
};HLS.prototype._startTimeUpdateTimer=function _startTimeUpdateTimer(){var _this3=this;this._timeUpdateTimer=setInterval(function(){_this3._onDurationChange();_this3._onTimeUpdate();},100);};HLS.prototype._stopTimeUpdateTimer=function _stopTimeUpdateTimer(){clearInterval(this._timeUpdateTimer);};// the duration on the video element itself should not be used
// as this does not necesarily represent the duration of the stream
// https://github.com/clappr/clappr/issues/668#issuecomment-157036678
HLS.prototype.getDuration=function getDuration(){return this._duration;};HLS.prototype.getCurrentTime=function getCurrentTime(){// e.g. can be < 0 if user pauses near the start
// eventually they will then be kicked to the end by hlsjs if they run out of buffer
// before the official start time
return Math.max(0,this.el.currentTime-this._startTime);};// the time that "0" now represents relative to when playback started
// for a stream with a sliding window this will increase as content is
// removed from the beginning
HLS.prototype.getStartTimeOffset=function getStartTimeOffset(){return this._startTime;};HLS.prototype.seekPercentage=function seekPercentage(percentage){var seekTo=this._duration;if(percentage>0){seekTo=this._duration*(percentage/100);}this.seek(seekTo);};HLS.prototype.seek=function seek(time){if(time<0){_log2.default.warn('Attempt to seek to a negative time. Resetting to live point. Use seekToLivePoint() to seek to the live point.');time=this.getDuration();}// assume live if time within 3 seconds of end of stream
this.dvrEnabled&&this._updateDvr(time<this.getDuration()-3);time+=this._startTime;_HTML5VideoPlayback.prototype.seek.call(this,time);};HLS.prototype.seekToLivePoint=function seekToLivePoint(){this.seek(this.getDuration());};HLS.prototype._updateDvr=function _updateDvr(status){this.trigger(_events2.default.PLAYBACK_DVR,status);this.trigger(_events2.default.PLAYBACK_STATS_ADD,{'dvr':status});};HLS.prototype._updateSettings=function _updateSettings(){if(this._playbackType===_playback2.default.VOD){this.settings.left=['playpause','position','duration'];}else if(this.dvrEnabled){this.settings.left=['playpause'];}else{this.settings.left=['playstop'];}this.settings.seekEnabled=this.isSeekEnabled();this.trigger(_events2.default.PLAYBACK_SETTINGSUPDATE);};HLS.prototype._onHLSJSError=function _onHLSJSError(evt,data){// only report/handle errors if they are fatal
// hlsjs should automatically handle non fatal errors
if(data.fatal){if(this._recoverAttemptsRemaining>0){this._recoverAttemptsRemaining-=1;switch(data.type){case _hls2.default.ErrorTypes.NETWORK_ERROR:switch(data.details){// The following network errors cannot be recovered with HLS.startLoad()
// For more details, see https://github.com/video-dev/hls.js/blob/master/doc/design.md#error-detection-and-handling
// For "level load" fatal errors, see https://github.com/video-dev/hls.js/issues/1138
case _hls2.default.ErrorDetails.MANIFEST_LOAD_ERROR:case _hls2.default.ErrorDetails.MANIFEST_LOAD_TIMEOUT:case _hls2.default.ErrorDetails.MANIFEST_PARSING_ERROR:case _hls2.default.ErrorDetails.LEVEL_LOAD_ERROR:case _hls2.default.ErrorDetails.LEVEL_LOAD_TIMEOUT:_log2.default.error('hlsjs: unrecoverable network fatal error, evt '+evt+', data '+data+' ');this.trigger(_events2.default.PLAYBACK_ERROR,{evt:evt,data:data},this.name);break;default:_log2.default.warn('hlsjs: trying to recover from network error, evt '+evt+', data '+data+' ');this._hls.startLoad();break;}break;case _hls2.default.ErrorTypes.MEDIA_ERROR:_log2.default.warn('hlsjs: trying to recover from media error, evt '+evt+', data '+data+' ');this._recover(evt,data);break;default:_log2.default.error('hlsjs: trying to recover from error, evt '+evt+', data '+data+' ');this.trigger(_events2.default.PLAYBACK_ERROR,'hlsjs: could not recover from error, evt '+evt+', data '+data+' ',this.name);break;}}else{_log2.default.error('hlsjs: could not recover from error after maximum number of attempts, evt '+evt+', data '+data+' ');this.trigger(_events2.default.PLAYBACK_ERROR,{evt:evt,data:data},this.name);}}else{_log2.default.warn('hlsjs: non-fatal error occurred, evt '+evt+', data '+data+' ');}};HLS.prototype._onTimeUpdate=function _onTimeUpdate(){var update={current:this.getCurrentTime(),total:this.getDuration()};var isSame=this._lastTimeUpdate&&update.current===this._lastTimeUpdate.current&&update.total===this._lastTimeUpdate.total;if(isSame){return;}this._lastTimeUpdate=update;this.trigger(_events2.default.PLAYBACK_TIMEUPDATE,update,this.name);};HLS.prototype._onDurationChange=function _onDurationChange(){var duration=this.getDuration();if(this._lastDuration===duration){return;}this._lastDuration=duration;_HTML5VideoPlayback.prototype._onDurationChange.call(this);};HLS.prototype._onProgress=function _onProgress(){if(!this.el.buffered.length){return;}var buffered=[];var bufferedPos=0;for(var i=0;i<this.el.buffered.length;i++){buffered=[].concat((0,_toConsumableArray3.default)(buffered),[{// for a stream with sliding window dvr something that is buffered my slide off the start of the timeline
start:Math.max(0,this.el.buffered.start(i)-this._playableRegionStartTime),end:Math.max(0,this.el.buffered.end(i)-this._playableRegionStartTime)}]);if(this.el.currentTime>=buffered[i].start&&this.el.currentTime<=buffered[i].end){bufferedPos=i;}}var progress={start:buffered[bufferedPos].start,current:buffered[bufferedPos].end,total:this.getDuration()};this.trigger(_events2.default.PLAYBACK_PROGRESS,progress,buffered);};HLS.prototype.play=function play(){if(!this._hls){this._setupHls();}_HTML5VideoPlayback.prototype.play.call(this);};HLS.prototype.pause=function pause(){if(!this._hls){return;}_HTML5VideoPlayback.prototype.pause.call(this);if(this.dvrEnabled){this._updateDvr(true);}};HLS.prototype.stop=function stop(){if(this._hls){_HTML5VideoPlayback.prototype.stop.call(this);this._hls.destroy();delete this._hls;}};HLS.prototype.destroy=function destroy(){this._stopTimeUpdateTimer();if(this._hls){this._hls.destroy();delete this._hls;}_HTML5VideoPlayback.prototype.destroy.call(this);};HLS.prototype._updatePlaybackType=function _updatePlaybackType(evt,data){this._playbackType=data.details.live?_playback2.default.LIVE:_playback2.default.VOD;this._fillLevels();this._onLevelUpdated(evt,data);// Live stream subtitle tracks detection hack (may not immediately available)
if(this._ccTracksUpdated&&this._playbackType===_playback2.default.LIVE&&this.hasClosedCaptionsTracks){this._onSubtitleLoaded();}};HLS.prototype._fillLevels=function _fillLevels(){this._levels=this._hls.levels.map(function(level,index){return{id:index,level:level,label:level.bitrate/1000+'Kbps'};});this.trigger(_events2.default.PLAYBACK_LEVELS_AVAILABLE,this._levels);};HLS.prototype._onLevelUpdated=function _onLevelUpdated(evt,data){this._segmentTargetDuration=data.details.targetduration;this._playlistType=data.details.type||null;var startTimeChanged=false;var durationChanged=false;var fragments=data.details.fragments;var previousPlayableRegionStartTime=this._playableRegionStartTime;var previousPlayableRegionDuration=this._playableRegionDuration;if(fragments.length===0){return;}if(this._playableRegionStartTime!==fragments[0].start){startTimeChanged=true;this._playableRegionStartTime=fragments[0].start;}if(startTimeChanged){if(!this._localStartTimeCorrelation){// set the correlation to map to middle of the extrapolation window
this._localStartTimeCorrelation={local:this._now,remote:(fragments[0].start+this._extrapolatedWindowDuration/2)*1000};}else{// check if the correlation still works
var corr=this._localStartTimeCorrelation;var timePassed=this._now-corr.local;// this should point to a time within the extrapolation window
var startTime=(corr.remote+timePassed)/1000;if(startTime<fragments[0].start){// our start time is now earlier than the first chunk
// (maybe the chunk was removed early)
// reset correlation so that it sits at the beginning of the first available chunk
this._localStartTimeCorrelation={local:this._now,remote:fragments[0].start*1000};}else if(startTime>previousPlayableRegionStartTime+this._extrapolatedWindowDuration){// start time was past the end of the old extrapolation window (so would have been capped)
// see if now that time would be inside the window, and if it would be set the correlation
// so that it resumes from the time it was at at the end of the old window
// update the correlation so that the time starts counting again from the value it's on now
this._localStartTimeCorrelation={local:this._now,remote:Math.max(fragments[0].start,previousPlayableRegionStartTime+this._extrapolatedWindowDuration)*1000};}}}var newDuration=data.details.totalduration;// if it's a live stream then shorten the duration to remove access
// to the area after hlsjs's live sync point
// seeks to areas after this point sometimes have issues
if(this._playbackType===_playback2.default.LIVE){var fragmentTargetDuration=data.details.targetduration;var hlsjsConfig=this.options.playback||{};var liveSyncDurationCount=hlsjsConfig.liveSyncDurationCount||_hls2.default.DefaultConfig.liveSyncDurationCount;var hiddenAreaDuration=fragmentTargetDuration*liveSyncDurationCount;if(hiddenAreaDuration<=newDuration){newDuration-=hiddenAreaDuration;this._durationExcludesAfterLiveSyncPoint=true;}else{this._durationExcludesAfterLiveSyncPoint=false;}}if(newDuration!==this._playableRegionDuration){durationChanged=true;this._playableRegionDuration=newDuration;}// Note the end time is not the playableRegionDuration
// The end time will always increase even if content is removed from the beginning
var endTime=fragments[0].start+newDuration;var previousEndTime=previousPlayableRegionStartTime+previousPlayableRegionDuration;var endTimeChanged=endTime!==previousEndTime;if(endTimeChanged){if(!this._localEndTimeCorrelation){// set the correlation to map to the end
this._localEndTimeCorrelation={local:this._now,remote:endTime*1000};}else{// check if the correlation still works
var _corr=this._localEndTimeCorrelation;var _timePassed=this._now-_corr.local;// this should point to a time within the extrapolation window from the end
var extrapolatedEndTime=(_corr.remote+_timePassed)/1000;if(extrapolatedEndTime>endTime){this._localEndTimeCorrelation={local:this._now,remote:endTime*1000};}else if(extrapolatedEndTime<endTime-this._extrapolatedWindowDuration){// our extrapolated end time is now earlier than the extrapolation window from the actual end time
// (maybe a chunk became available early)
// reset correlation so that it sits at the beginning of the extrapolation window from the end time
this._localEndTimeCorrelation={local:this._now,remote:(endTime-this._extrapolatedWindowDuration)*1000};}else if(extrapolatedEndTime>previousEndTime){// end time was past the old end time (so would have been capped)
// set the correlation so that it resumes from the time it was at at the end of the old window
this._localEndTimeCorrelation={local:this._now,remote:previousEndTime*1000};}}}// now that the values have been updated call any methods that use on them so they get the updated values
// immediately
durationChanged&&this._onDurationChange();startTimeChanged&&this._onProgress();};HLS.prototype._onFragmentLoaded=function _onFragmentLoaded(evt,data){this.trigger(_events2.default.PLAYBACK_FRAGMENT_LOADED,data);};HLS.prototype._onSubtitleLoaded=function _onSubtitleLoaded(){// This event may be triggered multiple times
// Setup CC only once (disable CC by default)
if(!this._ccIsSetup){this.trigger(_events2.default.PLAYBACK_SUBTITLE_AVAILABLE);var trackId=this._playbackType===_playback2.default.LIVE?-1:this.closedCaptionsTrackId;this.closedCaptionsTrackId=trackId;this._ccIsSetup=true;}};HLS.prototype._onLevelSwitch=function _onLevelSwitch(evt,data){if(!this.levels.length){this._fillLevels();}this.trigger(_events2.default.PLAYBACK_LEVEL_SWITCH_END);this.trigger(_events2.default.PLAYBACK_LEVEL_SWITCH,data);var currentLevel=this._hls.levels[data.level];if(currentLevel){// TODO should highDefinition be private and maybe have a read only accessor if it's used somewhere
this.highDefinition=currentLevel.height>=720||currentLevel.bitrate/1000>=2000;this.trigger(_events2.default.PLAYBACK_HIGHDEFINITIONUPDATE,this.highDefinition);this.trigger(_events2.default.PLAYBACK_BITRATE,{height:currentLevel.height,width:currentLevel.width,bandwidth:currentLevel.bitrate,bitrate:currentLevel.bitrate,level:data.level});}};HLS.prototype.getPlaybackType=function getPlaybackType(){return this._playbackType;};HLS.prototype.isSeekEnabled=function isSeekEnabled(){return this._playbackType===_playback2.default.VOD||this.dvrEnabled;};(0,_createClass3.default)(HLS,[{key:'dvrEnabled',get:function get(){// enabled when:
// - the duration does not include content after hlsjs's live sync point
// - the playable region duration is longer than the configured duration to enable dvr after
// - the playback type is LIVE.
return this._durationExcludesAfterLiveSyncPoint&&this._duration>=this._minDvrSize&&this.getPlaybackType()===_playback2.default.LIVE;}}]);return HLS;}(_html5_video2.default);exports.default=HLS;HLS.canPlay=function(resource,mimeType){var resourceParts=resource.split('?')[0].match(/.*\.(.*)$/)||[];var isHls=resourceParts.length>1&&resourceParts[1].toLowerCase()==='m3u8'||mimeType==='application/x-mpegURL'||mimeType==='application/vnd.apple.mpegurl';return!!(_hls2.default.isSupported()&&isHls);};module.exports=exports['default'];/***/},/* 173 *//***/function(module,exports,__webpack_require__){var require;var require;(function(f){if(true){module.exports=f();}else if(typeof define==="function"&&define.amd){define([],f);}else{var g;if(typeof window!=="undefined"){g=window;}else if(typeof global!=="undefined"){g=global;}else if(typeof self!=="undefined"){g=self;}else{g=this;}g.Hls=f();}})(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f;}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e);},l,l.exports,e,t,n,r);}return n[o].exports;}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s;}({1:[function(_dereq_,module,exports){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
function EventEmitter(){this._events=this._events||{};this._maxListeners=this._maxListeners||undefined;}module.exports=EventEmitter;// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter=EventEmitter;EventEmitter.prototype._events=undefined;EventEmitter.prototype._maxListeners=undefined;// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners=10;// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||n<0||isNaN(n))throw TypeError('n must be a positive number');this._maxListeners=n;return this;};EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(!this._events)this._events={};// If there is no 'error' event listener then throw.
if(type==='error'){if(!this._events.error||isObject(this._events.error)&&!this._events.error.length){er=arguments[1];if(er instanceof Error){throw er;// Unhandled 'error' event
}else{// At least give some kind of context to the user
var err=new Error('Uncaught, unspecified "error" event. ('+er+')');err.context=er;throw err;}}}handler=this._events[type];if(isUndefined(handler))return false;if(isFunction(handler)){switch(arguments.length){// fast cases
case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;// slower
default:args=Array.prototype.slice.call(arguments,1);handler.apply(this,args);}}else if(isObject(handler)){args=Array.prototype.slice.call(arguments,1);listeners=handler.slice();len=listeners.length;for(i=0;i<len;i++)listeners[i].apply(this,args);}return true;};EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError('listener must be a function');if(!this._events)this._events={};// To avoid recursion in the case that type === "newListener"! Before
// adding it to the listeners, first emit "newListener".
if(this._events.newListener)this.emit('newListener',type,isFunction(listener.listener)?listener.listener:listener);if(!this._events[type])// Optimize the case of one listener. Don't need the extra array object.
this._events[type]=listener;else if(isObject(this._events[type]))// If we've already got an array, just append.
this._events[type].push(listener);else// Adding the second element, need to change to array.
this._events[type]=[this._events[type],listener];// Check for listener leak
if(isObject(this._events[type])&&!this._events[type].warned){if(!isUndefined(this._maxListeners)){m=this._maxListeners;}else{m=EventEmitter.defaultMaxListeners;}if(m&&m>0&&this._events[type].length>m){this._events[type].warned=true;console.error('(node) warning: possible EventEmitter memory '+'leak detected. %d listeners added. '+'Use emitter.setMaxListeners() to increase limit.',this._events[type].length);if(typeof console.trace==='function'){// not supported in IE 10
console.trace();}}}return this;};EventEmitter.prototype.on=EventEmitter.prototype.addListener;EventEmitter.prototype.once=function(type,listener){if(!isFunction(listener))throw TypeError('listener must be a function');var fired=false;function g(){this.removeListener(type,g);if(!fired){fired=true;listener.apply(this,arguments);}}g.listener=listener;this.on(type,g);return this;};// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError('listener must be a function');if(!this._events||!this._events[type])return this;list=this._events[type];length=list.length;position=-1;if(list===listener||isFunction(list.listener)&&list.listener===listener){delete this._events[type];if(this._events.removeListener)this.emit('removeListener',type,listener);}else if(isObject(list)){for(i=length;i-->0;){if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break;}}if(position<0)return this;if(list.length===1){list.length=0;delete this._events[type];}else{list.splice(position,1);}if(this._events.removeListener)this.emit('removeListener',type,listener);}return this;};EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;// not listening for removeListener, no need to emit
if(!this._events.removeListener){if(arguments.length===0)this._events={};else if(this._events[type])delete this._events[type];return this;}// emit removeListener for all listeners on all events
if(arguments.length===0){for(key in this._events){if(key==='removeListener')continue;this.removeAllListeners(key);}this.removeAllListeners('removeListener');this._events={};return this;}listeners=this._events[type];if(isFunction(listeners)){this.removeListener(type,listeners);}else if(listeners){// LIFO order
while(listeners.length)this.removeListener(type,listeners[listeners.length-1]);}delete this._events[type];return this;};EventEmitter.prototype.listeners=function(type){var ret;if(!this._events||!this._events[type])ret=[];else if(isFunction(this._events[type]))ret=[this._events[type]];else ret=this._events[type].slice();return ret;};EventEmitter.prototype.listenerCount=function(type){if(this._events){var evlistener=this._events[type];if(isFunction(evlistener))return 1;else if(evlistener)return evlistener.length;}return 0;};EventEmitter.listenerCount=function(emitter,type){return emitter.listenerCount(type);};function isFunction(arg){return typeof arg==='function';}function isNumber(arg){return typeof arg==='number';}function isObject(arg){return typeof arg==='object'&&arg!==null;}function isUndefined(arg){return arg===void 0;}},{}],2:[function(_dereq_,module,exports){// see https://tools.ietf.org/html/rfc1808
/* jshint ignore:start */(function(root){/* jshint ignore:end */var URL_REGEX=/^((?:[^\/;?#]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;var FIRST_SEGMENT_REGEX=/^([^\/;?#]*)(.*)$/;var SLASH_DOT_REGEX=/(?:\/|^)\.(?=\/)/g;var SLASH_DOT_DOT_REGEX=/(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;var URLToolkit={// jshint ignore:line
// If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
// E.g
// With opts.alwaysNormalize = false (default, spec compliant)
// http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
// With opts.alwaysNormalize = true (default, not spec compliant)
// http://a.com/b/cd + /e/f/../g => http://a.com/e/g
buildAbsoluteURL:function(baseURL,relativeURL,opts){opts=opts||{};// remove any remaining space and CRLF
baseURL=baseURL.trim();relativeURL=relativeURL.trim();if(!relativeURL){// 2a) If the embedded URL is entirely empty, it inherits the
// entire base URL (i.e., is set equal to the base URL)
// and we are done.
if(!opts.alwaysNormalize){return baseURL;}var basePartsForNormalise=this.parseURL(baseURL);if(!baseParts){throw new Error('Error trying to parse base URL.');}basePartsForNormalise.path=URLToolkit.normalizePath(basePartsForNormalise.path);return URLToolkit.buildURLFromParts(basePartsForNormalise);}var relativeParts=this.parseURL(relativeURL);if(!relativeParts){throw new Error('Error trying to parse relative URL.');}if(relativeParts.scheme){// 2b) If the embedded URL starts with a scheme name, it is
// interpreted as an absolute URL and we are done.
if(!opts.alwaysNormalize){return relativeURL;}relativeParts.path=URLToolkit.normalizePath(relativeParts.path);return URLToolkit.buildURLFromParts(relativeParts);}var baseParts=this.parseURL(baseURL);if(!baseParts){throw new Error('Error trying to parse base URL.');}if(!baseParts.netLoc&&baseParts.path&&baseParts.path[0]!=='/'){// If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
// This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
var pathParts=FIRST_SEGMENT_REGEX.exec(baseParts.path);baseParts.netLoc=pathParts[1];baseParts.path=pathParts[2];}if(baseParts.netLoc&&!baseParts.path){baseParts.path='/';}var builtParts={// 2c) Otherwise, the embedded URL inherits the scheme of
// the base URL.
scheme:baseParts.scheme,netLoc:relativeParts.netLoc,path:null,params:relativeParts.params,query:relativeParts.query,fragment:relativeParts.fragment};if(!relativeParts.netLoc){// 3) If the embedded URL's <net_loc> is non-empty, we skip to
// Step 7.  Otherwise, the embedded URL inherits the <net_loc>
// (if any) of the base URL.
builtParts.netLoc=baseParts.netLoc;// 4) If the embedded URL path is preceded by a slash "/", the
// path is not relative and we skip to Step 7.
if(relativeParts.path[0]!=='/'){if(!relativeParts.path){// 5) If the embedded URL path is empty (and not preceded by a
// slash), then the embedded URL inherits the base URL path
builtParts.path=baseParts.path;// 5a) if the embedded URL's <params> is non-empty, we skip to
// step 7; otherwise, it inherits the <params> of the base
// URL (if any) and
if(!relativeParts.params){builtParts.params=baseParts.params;// 5b) if the embedded URL's <query> is non-empty, we skip to
// step 7; otherwise, it inherits the <query> of the base
// URL (if any) and we skip to step 7.
if(!relativeParts.query){builtParts.query=baseParts.query;}}}else{// 6) The last segment of the base URL's path (anything
// following the rightmost slash "/", or the entire path if no
// slash is present) is removed and the embedded URL's path is
// appended in its place.
var baseURLPath=baseParts.path;var newPath=baseURLPath.substring(0,baseURLPath.lastIndexOf('/')+1)+relativeParts.path;builtParts.path=URLToolkit.normalizePath(newPath);}}}if(builtParts.path===null){builtParts.path=opts.alwaysNormalize?URLToolkit.normalizePath(relativeParts.path):relativeParts.path;}return URLToolkit.buildURLFromParts(builtParts);},parseURL:function(url){var parts=URL_REGEX.exec(url);if(!parts){return null;}return{scheme:parts[1]||'',netLoc:parts[2]||'',path:parts[3]||'',params:parts[4]||'',query:parts[5]||'',fragment:parts[6]||''};},normalizePath:function(path){// The following operations are
// then applied, in order, to the new path:
// 6a) All occurrences of "./", where "." is a complete path
// segment, are removed.
// 6b) If the path ends with "." as a complete path segment,
// that "." is removed.
path=path.split('').reverse().join('').replace(SLASH_DOT_REGEX,'');// 6c) All occurrences of "<segment>/../", where <segment> is a
// complete path segment not equal to "..", are removed.
// Removal of these path segments is performed iteratively,
// removing the leftmost matching pattern on each iteration,
// until no matching pattern remains.
// 6d) If the path ends with "<segment>/..", where <segment> is a
// complete path segment not equal to "..", that
// "<segment>/.." is removed.
while(path.length!==(path=path.replace(SLASH_DOT_DOT_REGEX,'')).length){}// jshint ignore:line
return path.split('').reverse().join('');},buildURLFromParts:function(parts){return parts.scheme+parts.netLoc+parts.path+parts.params+parts.query+parts.fragment;}};/* jshint ignore:start */if(typeof exports==='object'&&typeof module==='object')module.exports=URLToolkit;else if(typeof define==='function'&&define.amd)define([],function(){return URLToolkit;});else if(typeof exports==='object')exports["URLToolkit"]=URLToolkit;else root["URLToolkit"]=URLToolkit;})(this);/* jshint ignore:end */},{}],3:[function(_dereq_,module,exports){var bundleFn=arguments[3];var sources=arguments[4];var cache=arguments[5];var stringify=JSON.stringify;module.exports=function(fn,options){var wkey;var cacheKeys=Object.keys(cache);for(var i=0,l=cacheKeys.length;i<l;i++){var key=cacheKeys[i];var exp=cache[key].exports;// Using babel as a transpiler to use esmodule, the export will always
// be an object with the default export as a property of it. To ensure
// the existing api and babel esmodule exports are both supported we
// check for both
if(exp===fn||exp&&exp.default===fn){wkey=key;break;}}if(!wkey){wkey=Math.floor(Math.pow(16,8)*Math.random()).toString(16);var wcache={};for(var i=0,l=cacheKeys.length;i<l;i++){var key=cacheKeys[i];wcache[key]=key;}sources[wkey]=[Function(['require','module','exports'],'('+fn+')(self)'),wcache];}var skey=Math.floor(Math.pow(16,8)*Math.random()).toString(16);var scache={};scache[wkey]=wkey;sources[skey]=[Function(['require'],// try to call default if defined to also support babel esmodule
// exports
'var f = require('+stringify(wkey)+');'+'(f.default ? f.default : f)(self);'),scache];var workerSources={};resolveSources(skey);function resolveSources(key){workerSources[key]=true;for(var depPath in sources[key][1]){var depKey=sources[key][1][depPath];if(!workerSources[depKey]){resolveSources(depKey);}}}var src='('+bundleFn+')({'+Object.keys(workerSources).map(function(key){return stringify(key)+':['+sources[key][0]+','+stringify(sources[key][1])+']';}).join(',')+'},{},['+stringify(skey)+'])';var URL=window.URL||window.webkitURL||window.mozURL||window.msURL;var blob=new Blob([src],{type:'text/javascript'});if(options&&options.bare){return blob;}var workerUrl=URL.createObjectURL(blob);var worker=new Worker(workerUrl);worker.objectURL=workerUrl;return worker;};},{}],4:[function(_dereq_,module,exports){/**
 * HLS config
 */'use strict';Object.defineProperty(exports,"__esModule",{value:true});exports.hlsDefaultConfig=undefined;var _abrController=_dereq_(5);var _abrController2=_interopRequireDefault(_abrController);var _bufferController=_dereq_(8);var _bufferController2=_interopRequireDefault(_bufferController);var _capLevelController=_dereq_(9);var _capLevelController2=_interopRequireDefault(_capLevelController);var _fpsController=_dereq_(10);var _fpsController2=_interopRequireDefault(_fpsController);var _xhrLoader=_dereq_(58);var _xhrLoader2=_interopRequireDefault(_xhrLoader);var _audioTrackController=_dereq_(7);var _audioTrackController2=_interopRequireDefault(_audioTrackController);var _audioStreamController=_dereq_(6);var _audioStreamController2=_interopRequireDefault(_audioStreamController);var _cues=_dereq_(50);var _cues2=_interopRequireDefault(_cues);var _timelineController=_dereq_(16);var _timelineController2=_interopRequireDefault(_timelineController);var _subtitleTrackController=_dereq_(15);var _subtitleTrackController2=_interopRequireDefault(_subtitleTrackController);var _subtitleStreamController=_dereq_(14);var _subtitleStreamController2=_interopRequireDefault(_subtitleStreamController);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}//#endif
//#endif
//#if subtitle
//import FetchLoader from './utils/fetch-loader';
//#if altaudio
var hlsDefaultConfig=exports.hlsDefaultConfig={autoStartLoad:true,// used by stream-controller
startPosition:-1,// used by stream-controller
defaultAudioCodec:undefined,// used by stream-controller
debug:false,// used by logger
capLevelOnFPSDrop:false,// used by fps-controller
capLevelToPlayerSize:false,// used by cap-level-controller
initialLiveManifestSize:1,// used by stream-controller
maxBufferLength:30,// used by stream-controller
maxBufferSize:60*1000*1000,// used by stream-controller
maxBufferHole:0.5,// used by stream-controller
maxSeekHole:2,// used by stream-controller
lowBufferWatchdogPeriod:0.5,// used by stream-controller
highBufferWatchdogPeriod:3,// used by stream-controller
nudgeOffset:0.1,// used by stream-controller
nudgeMaxRetry:3,// used by stream-controller
maxFragLookUpTolerance:0.25,// used by stream-controller
liveSyncDurationCount:3,// used by stream-controller
liveMaxLatencyDurationCount:Infinity,// used by stream-controller
liveSyncDuration:undefined,// used by stream-controller
liveMaxLatencyDuration:undefined,// used by stream-controller
maxMaxBufferLength:600,// used by stream-controller
enableWorker:true,// used by demuxer
enableSoftwareAES:true,// used by decrypter
manifestLoadingTimeOut:10000,// used by playlist-loader
manifestLoadingMaxRetry:1,// used by playlist-loader
manifestLoadingRetryDelay:1000,// used by playlist-loader
manifestLoadingMaxRetryTimeout:64000,// used by playlist-loader
startLevel:undefined,// used by level-controller
levelLoadingTimeOut:10000,// used by playlist-loader
levelLoadingMaxRetry:4,// used by playlist-loader
levelLoadingRetryDelay:1000,// used by playlist-loader
levelLoadingMaxRetryTimeout:64000,// used by playlist-loader
fragLoadingTimeOut:20000,// used by fragment-loader
fragLoadingMaxRetry:6,// used by fragment-loader
fragLoadingRetryDelay:1000,// used by fragment-loader
fragLoadingMaxRetryTimeout:64000,// used by fragment-loader
fragLoadingLoopThreshold:3,// used by stream-controller
startFragPrefetch:false,// used by stream-controller
fpsDroppedMonitoringPeriod:5000,// used by fps-controller
fpsDroppedMonitoringThreshold:0.2,// used by fps-controller
appendErrorMaxRetry:3,// used by buffer-controller
loader:_xhrLoader2.default,//loader: FetchLoader,
fLoader:undefined,pLoader:undefined,xhrSetup:undefined,fetchSetup:undefined,abrController:_abrController2.default,bufferController:_bufferController2.default,capLevelController:_capLevelController2.default,fpsController:_fpsController2.default,//#if altaudio
audioStreamController:_audioStreamController2.default,audioTrackController:_audioTrackController2.default,//#endif
//#if subtitle
subtitleStreamController:_subtitleStreamController2.default,subtitleTrackController:_subtitleTrackController2.default,timelineController:_timelineController2.default,cueHandler:_cues2.default,enableCEA708Captions:true,// used by timeline-controller
enableWebVTT:true,// used by timeline-controller
captionsTextTrack1Label:'English',// used by timeline-controller
captionsTextTrack1LanguageCode:'en',// used by timeline-controller
captionsTextTrack2Label:'Spanish',// used by timeline-controller
captionsTextTrack2LanguageCode:'es',// used by timeline-controller
//#endif
stretchShortVideoTrack:false,// used by mp4-remuxer
forceKeyFrameOnDiscontinuity:true,// used by ts-demuxer
abrEwmaFastLive:3,// used by abr-controller
abrEwmaSlowLive:9,// used by abr-controller
abrEwmaFastVoD:3,// used by abr-controller
abrEwmaSlowVoD:9,// used by abr-controller
abrEwmaDefaultEstimate:5e5,// 500 kbps  // used by abr-controller
abrBandWidthFactor:0.95,// used by abr-controller
abrBandWidthUpFactor:0.7,// used by abr-controller
abrMaxWithRealBitrate:false,// used by abr-controller
maxStarvationDelay:4,// used by abr-controller
maxLoadingDelay:4,// used by abr-controller
minAutoBitrate:0// used by hls
};},{"10":10,"14":14,"15":15,"16":16,"5":5,"50":50,"58":58,"6":6,"7":7,"8":8,"9":9}],5:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _bufferHelper=_dereq_(37);var _bufferHelper2=_interopRequireDefault(_bufferHelper);var _errors=_dereq_(33);var _logger=_dereq_(53);var _ewmaBandwidthEstimator=_dereq_(51);var _ewmaBandwidthEstimator2=_interopRequireDefault(_ewmaBandwidthEstimator);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */var AbrController=function(_EventHandler){_inherits(AbrController,_EventHandler);function AbrController(hls){_classCallCheck(this,AbrController);var _this=_possibleConstructorReturn(this,(AbrController.__proto__||Object.getPrototypeOf(AbrController)).call(this,hls,_events2.default.FRAG_LOADING,_events2.default.FRAG_LOADED,_events2.default.FRAG_BUFFERED,_events2.default.ERROR));_this.lastLoadedFragLevel=0;_this._nextAutoLevel=-1;_this.hls=hls;_this.onCheck=_this._abandonRulesCheck.bind(_this);return _this;}_createClass(AbrController,[{key:'destroy',value:function destroy(){this.clearTimer();_eventHandler2.default.prototype.destroy.call(this);}},{key:'onFragLoading',value:function onFragLoading(data){var frag=data.frag;if(frag.type==='main'){if(!this.timer){this.timer=setInterval(this.onCheck,100);}// lazy init of bw Estimator, rationale is that we use different params for Live/VoD
// so we need to wait for stream manifest / playlist type to instantiate it.
if(!this._bwEstimator){var hls=this.hls,level=data.frag.level,isLive=hls.levels[level].details.live,config=hls.config,ewmaFast=void 0,ewmaSlow=void 0;if(isLive){ewmaFast=config.abrEwmaFastLive;ewmaSlow=config.abrEwmaSlowLive;}else{ewmaFast=config.abrEwmaFastVoD;ewmaSlow=config.abrEwmaSlowVoD;}this._bwEstimator=new _ewmaBandwidthEstimator2.default(hls,ewmaSlow,ewmaFast,config.abrEwmaDefaultEstimate);}this.fragCurrent=frag;}}},{key:'_abandonRulesCheck',value:function _abandonRulesCheck(){/*
        monitor fragment retrieval time...
        we compute expected time of arrival of the complete fragment.
        we compare it to expected time of buffer starvation
      */var hls=this.hls,v=hls.media,frag=this.fragCurrent,loader=frag.loader,minAutoLevel=hls.minAutoLevel;// if loader has been destroyed or loading has been aborted, stop timer and return
if(!loader||loader.stats&&loader.stats.aborted){_logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');this.clearTimer();return;}var stats=loader.stats;/* only monitor frag retrieval time if
      (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */if(v&&(!v.paused&&v.playbackRate!==0||!v.readyState)&&frag.autoLevel&&frag.level){var requestDelay=performance.now()-stats.trequest,playbackRate=Math.abs(v.playbackRate);// monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
if(requestDelay>500*frag.duration/playbackRate){var levels=hls.levels,loadRate=Math.max(1,stats.bw?stats.bw/8:stats.loaded*1000/requestDelay),// byte/s; at least 1 byte/s to avoid division by zero
// compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
level=levels[frag.level],levelBitrate=level.realBitrate?Math.max(level.realBitrate,level.bitrate):level.bitrate,expectedLen=stats.total?stats.total:Math.max(stats.loaded,Math.round(frag.duration*levelBitrate/8)),pos=v.currentTime,fragLoadedDelay=(expectedLen-stats.loaded)/loadRate,bufferStarvationDelay=(_bufferHelper2.default.bufferInfo(v,pos,hls.config.maxBufferHole).end-pos)/playbackRate;// consider emergency switch down only if we have less than 2 frag buffered AND
// time to finish loading current fragment is bigger than buffer starvation delay
// ie if we risk buffer starvation if bw does not increase quickly
if(bufferStarvationDelay<2*frag.duration/playbackRate&&fragLoadedDelay>bufferStarvationDelay){var fragLevelNextLoadedDelay=void 0,nextLoadLevel=void 0;// lets iterate through lower level and try to find the biggest one that could avoid rebuffering
// we start from current level - 1 and we step down , until we find a matching level
for(nextLoadLevel=frag.level-1;nextLoadLevel>minAutoLevel;nextLoadLevel--){// compute time to load next fragment at lower level
// 0.8 : consider only 80% of current bw to be conservative
// 8 = bits per byte (bps/Bps)
var levelNextBitrate=levels[nextLoadLevel].realBitrate?Math.max(levels[nextLoadLevel].realBitrate,levels[nextLoadLevel].bitrate):levels[nextLoadLevel].bitrate;fragLevelNextLoadedDelay=frag.duration*levelNextBitrate/(8*0.8*loadRate);if(fragLevelNextLoadedDelay<bufferStarvationDelay){// we found a lower level that be rebuffering free with current estimated bw !
break;}}// only emergency switch down if it takes less time to load new fragment at lowest level instead
// of finishing loading current one ...
if(fragLevelNextLoadedDelay<fragLoadedDelay){_logger.logger.warn('loading too slow, abort fragment loading and switch to level '+nextLoadLevel+':fragLoadedDelay['+nextLoadLevel+']<fragLoadedDelay['+(frag.level-1)+'];bufferStarvationDelay:'+fragLevelNextLoadedDelay.toFixed(1)+'<'+fragLoadedDelay.toFixed(1)+':'+bufferStarvationDelay.toFixed(1));// force next load level in auto mode
hls.nextLoadLevel=nextLoadLevel;// update bw estimate for this fragment before cancelling load (this will help reducing the bw)
this._bwEstimator.sample(requestDelay,stats.loaded);//abort fragment loading
loader.abort();// stop abandon rules timer
this.clearTimer();hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED,{frag:frag,stats:stats});}}}}}},{key:'onFragLoaded',value:function onFragLoaded(data){var frag=data.frag;if(frag.type==='main'&&!isNaN(frag.sn)){// stop monitoring bw once frag loaded
this.clearTimer();// store level id after successful fragment load
this.lastLoadedFragLevel=frag.level;// reset forced auto level value so that next level will be selected
this._nextAutoLevel=-1;// compute level average bitrate
if(this.hls.config.abrMaxWithRealBitrate){var level=this.hls.levels[frag.level];var loadedBytes=(level.loaded?level.loaded.bytes:0)+data.stats.loaded;var loadedDuration=(level.loaded?level.loaded.duration:0)+data.frag.duration;level.loaded={bytes:loadedBytes,duration:loadedDuration};level.realBitrate=Math.round(8*loadedBytes/loadedDuration);}// if fragment has been loaded to perform a bitrate test,
if(data.frag.bitrateTest){var stats=data.stats;stats.tparsed=stats.tbuffered=stats.tload;this.onFragBuffered(data);}}}},{key:'onFragBuffered',value:function onFragBuffered(data){var stats=data.stats,frag=data.frag;// only update stats on first frag buffering
// if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
// and leading to wrong bw estimation
// on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
if(stats.aborted!==true&&frag.loadCounter===1&&frag.type==='main'&&!isNaN(frag.sn)&&(!frag.bitrateTest||stats.tload===stats.tbuffered)){// use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
// in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
// as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
var fragLoadingProcessingMs=stats.tparsed-stats.trequest;_logger.logger.log('latency/loading/parsing/append/kbps:'+Math.round(stats.tfirst-stats.trequest)+'/'+Math.round(stats.tload-stats.tfirst)+'/'+Math.round(stats.tparsed-stats.tload)+'/'+Math.round(stats.tbuffered-stats.tparsed)+'/'+Math.round(8*stats.loaded/(stats.tbuffered-stats.trequest)));this._bwEstimator.sample(fragLoadingProcessingMs,stats.loaded);stats.bwEstimate=this._bwEstimator.getEstimate();// if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
if(frag.bitrateTest){this.bitrateTestDelay=fragLoadingProcessingMs/1000;}else{this.bitrateTestDelay=0;}}}},{key:'onError',value:function onError(data){// stop timer in case of frag loading error
switch(data.details){case _errors.ErrorDetails.FRAG_LOAD_ERROR:case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:this.clearTimer();break;default:break;}}},{key:'clearTimer',value:function clearTimer(){if(this.timer){clearInterval(this.timer);this.timer=null;}}// return next auto level
},{key:'_findBestLevel',value:function _findBestLevel(currentLevel,currentFragDuration,currentBw,minAutoLevel,maxAutoLevel,maxFetchDuration,bwFactor,bwUpFactor,levels){for(var i=maxAutoLevel;i>=minAutoLevel;i--){var levelInfo=levels[i],levelDetails=levelInfo.details,avgDuration=levelDetails?levelDetails.totalduration/levelDetails.fragments.length:currentFragDuration,live=levelDetails?levelDetails.live:false,adjustedbw=void 0;// follow algorithm captured from stagefright :
// https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
// Pick the highest bandwidth stream below or equal to estimated bandwidth.
// consider only 80% of the available bandwidth, but if we are switching up,
// be even more conservative (70%) to avoid overestimating and immediately
// switching back.
if(i<=currentLevel){adjustedbw=bwFactor*currentBw;}else{adjustedbw=bwUpFactor*currentBw;}var bitrate=levels[i].realBitrate?Math.max(levels[i].realBitrate,levels[i].bitrate):levels[i].bitrate,fetchDuration=bitrate*avgDuration/adjustedbw;_logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: '+i+'/'+Math.round(adjustedbw)+'/'+bitrate+'/'+avgDuration+'/'+maxFetchDuration+'/'+fetchDuration);// if adjusted bw is greater than level bitrate AND
if(adjustedbw>bitrate&&(// fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
// we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
// special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
!fetchDuration||live&&!this.bitrateTestDelay||fetchDuration<maxFetchDuration)){// as we are looping from highest to lowest, this will return the best achievable quality level
return i;}}// not enough time budget even with quality level 0 ... rebuffering might happen
return-1;}},{key:'nextAutoLevel',get:function get(){var forcedAutoLevel=this._nextAutoLevel;var bwEstimator=this._bwEstimator;// in case next auto level has been forced, and bw not available or not reliable, return forced value
if(forcedAutoLevel!==-1&&(!bwEstimator||!bwEstimator.canEstimate())){return forcedAutoLevel;}// compute next level using ABR logic
var nextABRAutoLevel=this._nextABRAutoLevel;// if forced auto level has been defined, use it to cap ABR computed quality level
if(forcedAutoLevel!==-1){nextABRAutoLevel=Math.min(forcedAutoLevel,nextABRAutoLevel);}return nextABRAutoLevel;},set:function set(nextLevel){this._nextAutoLevel=nextLevel;}},{key:'_nextABRAutoLevel',get:function get(){var hls=this.hls,maxAutoLevel=hls.maxAutoLevel,levels=hls.levels,config=hls.config,minAutoLevel=hls.minAutoLevel;var v=hls.media,currentLevel=this.lastLoadedFragLevel,currentFragDuration=this.fragCurrent?this.fragCurrent.duration:0,pos=v?v.currentTime:0,// playbackRate is the absolute value of the playback rate; if v.playbackRate is 0, we use 1 to load as
// if we're playing back at the normal rate.
playbackRate=v&&v.playbackRate!==0?Math.abs(v.playbackRate):1.0,avgbw=this._bwEstimator?this._bwEstimator.getEstimate():config.abrEwmaDefaultEstimate,// bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
bufferStarvationDelay=(_bufferHelper2.default.bufferInfo(v,pos,config.maxBufferHole).end-pos)/playbackRate;// First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
var bestLevel=this._findBestLevel(currentLevel,currentFragDuration,avgbw,minAutoLevel,maxAutoLevel,bufferStarvationDelay,config.abrBandWidthFactor,config.abrBandWidthUpFactor,levels);if(bestLevel>=0){return bestLevel;}else{_logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');// not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
// if no matching level found, logic will return 0
var maxStarvationDelay=currentFragDuration?Math.min(currentFragDuration,config.maxStarvationDelay):config.maxStarvationDelay,bwFactor=config.abrBandWidthFactor,bwUpFactor=config.abrBandWidthUpFactor;if(bufferStarvationDelay===0){// in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
var bitrateTestDelay=this.bitrateTestDelay;if(bitrateTestDelay){// if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
// max video loading delay used in  automatic start level selection :
// in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
// the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
// cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
var maxLoadingDelay=currentFragDuration?Math.min(currentFragDuration,config.maxLoadingDelay):config.maxLoadingDelay;maxStarvationDelay=maxLoadingDelay-bitrateTestDelay;_logger.logger.trace('bitrate test took '+Math.round(1000*bitrateTestDelay)+'ms, set first fragment max fetchDuration to '+Math.round(1000*maxStarvationDelay)+' ms');// don't use conservative factor on bitrate test
bwFactor=bwUpFactor=1;}}bestLevel=this._findBestLevel(currentLevel,currentFragDuration,avgbw,minAutoLevel,maxAutoLevel,bufferStarvationDelay+maxStarvationDelay,bwFactor,bwUpFactor,levels);return Math.max(bestLevel,0);}}}]);return AbrController;}(_eventHandler2.default);exports.default=AbrController;},{"33":33,"34":34,"35":35,"37":37,"51":51,"53":53}],6:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _binarySearch=_dereq_(48);var _binarySearch2=_interopRequireDefault(_binarySearch);var _bufferHelper=_dereq_(37);var _bufferHelper2=_interopRequireDefault(_bufferHelper);var _demuxer=_dereq_(25);var _demuxer2=_interopRequireDefault(_demuxer);var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _levelHelper=_dereq_(38);var _levelHelper2=_interopRequireDefault(_levelHelper);var _timeRanges=_dereq_(54);var _timeRanges2=_interopRequireDefault(_timeRanges);var _errors=_dereq_(33);var _logger=_dereq_(53);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */var State={STOPPED:'STOPPED',STARTING:'STARTING',IDLE:'IDLE',PAUSED:'PAUSED',KEY_LOADING:'KEY_LOADING',FRAG_LOADING:'FRAG_LOADING',FRAG_LOADING_WAITING_RETRY:'FRAG_LOADING_WAITING_RETRY',WAITING_TRACK:'WAITING_TRACK',PARSING:'PARSING',PARSED:'PARSED',BUFFER_FLUSHING:'BUFFER_FLUSHING',ENDED:'ENDED',ERROR:'ERROR',WAITING_INIT_PTS:'WAITING_INIT_PTS'};var AudioStreamController=function(_EventHandler){_inherits(AudioStreamController,_EventHandler);function AudioStreamController(hls){_classCallCheck(this,AudioStreamController);var _this=_possibleConstructorReturn(this,(AudioStreamController.__proto__||Object.getPrototypeOf(AudioStreamController)).call(this,hls,_events2.default.MEDIA_ATTACHED,_events2.default.MEDIA_DETACHING,_events2.default.AUDIO_TRACKS_UPDATED,_events2.default.AUDIO_TRACK_SWITCHING,_events2.default.AUDIO_TRACK_LOADED,_events2.default.KEY_LOADED,_events2.default.FRAG_LOADED,_events2.default.FRAG_PARSING_INIT_SEGMENT,_events2.default.FRAG_PARSING_DATA,_events2.default.FRAG_PARSED,_events2.default.ERROR,_events2.default.BUFFER_CREATED,_events2.default.BUFFER_APPENDED,_events2.default.BUFFER_FLUSHED,_events2.default.INIT_PTS_FOUND));_this.config=hls.config;_this.audioCodecSwap=false;_this.ticks=0;_this._state=State.STOPPED;_this.ontick=_this.tick.bind(_this);_this.initPTS=[];_this.waitingFragment=null;return _this;}_createClass(AudioStreamController,[{key:'destroy',value:function destroy(){this.stopLoad();if(this.timer){clearInterval(this.timer);this.timer=null;}_eventHandler2.default.prototype.destroy.call(this);this.state=State.STOPPED;}//Signal that video PTS was found
},{key:'onInitPtsFound',value:function onInitPtsFound(data){var demuxerId=data.id,cc=data.frag.cc,initPTS=data.initPTS;if(demuxerId==='main'){//Always update the new INIT PTS
//Can change due level switch
this.initPTS[cc]=initPTS;_logger.logger.log('InitPTS for cc:'+cc+' found from video track:'+initPTS);//If we are waiting we need to demux/remux the waiting frag
//With the new initPTS
if(this.state===State.WAITING_INIT_PTS){_logger.logger.log('sending pending audio frag to demuxer');this.state=State.FRAG_LOADING;//We have audio frag waiting or video pts
//Let process it
this.onFragLoaded(this.waitingFragment);//Lets clean the waiting frag
this.waitingFragment=null;}}}},{key:'startLoad',value:function startLoad(startPosition){if(this.tracks){var lastCurrentTime=this.lastCurrentTime;this.stopLoad();if(!this.timer){this.timer=setInterval(this.ontick,100);}this.fragLoadError=0;if(lastCurrentTime>0&&startPosition===-1){_logger.logger.log('audio:override startPosition with lastCurrentTime @'+lastCurrentTime.toFixed(3));this.state=State.IDLE;}else{this.lastCurrentTime=this.startPosition?this.startPosition:startPosition;this.state=State.STARTING;}this.nextLoadPosition=this.startPosition=this.lastCurrentTime;this.tick();}else{this.startPosition=startPosition;this.state=State.STOPPED;}}},{key:'stopLoad',value:function stopLoad(){var frag=this.fragCurrent;if(frag){if(frag.loader){frag.loader.abort();}this.fragCurrent=null;}this.fragPrevious=null;if(this.demuxer){this.demuxer.destroy();this.demuxer=null;}this.state=State.STOPPED;}},{key:'tick',value:function tick(){this.ticks++;if(this.ticks===1){this.doTick();if(this.ticks>1){setTimeout(this.tick,1);}this.ticks=0;}}},{key:'doTick',value:function doTick(){var pos,track,trackDetails,hls=this.hls,config=hls.config;//logger.log('audioStream:' + this.state);
switch(this.state){case State.ERROR://don't do anything in error state to avoid breaking further ...
case State.PAUSED://don't do anything in paused state either ...
case State.BUFFER_FLUSHING:break;case State.STARTING:this.state=State.WAITING_TRACK;this.loadedmetadata=false;break;case State.IDLE:var tracks=this.tracks;// audio tracks not received => exit loop
if(!tracks){break;}// if video not attached AND
// start fragment already requested OR start frag prefetch disable
// exit loop
// => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
if(!this.media&&(this.startFragRequested||!config.startFragPrefetch)){break;}// determine next candidate fragment to be loaded, based on current position and
//  end of buffer position
// if we have not yet loaded any fragment, start loading from start position
if(this.loadedmetadata){pos=this.media.currentTime;}else{pos=this.nextLoadPosition;}var media=this.mediaBuffer?this.mediaBuffer:this.media,bufferInfo=_bufferHelper2.default.bufferInfo(media,pos,config.maxBufferHole),bufferLen=bufferInfo.len,bufferEnd=bufferInfo.end,fragPrevious=this.fragPrevious,maxBufLen=config.maxMaxBufferLength,audioSwitch=this.audioSwitch,trackId=this.trackId;// if buffer length is less than maxBufLen try to load a new fragment
if((bufferLen<maxBufLen||audioSwitch)&&trackId<tracks.length){trackDetails=tracks[trackId].details;// if track info not retrieved yet, switch state and wait for track retrieval
if(typeof trackDetails==='undefined'){this.state=State.WAITING_TRACK;break;}// we just got done loading the final fragment, check if we need to finalize media stream
if(!audioSwitch&&!trackDetails.live&&fragPrevious&&fragPrevious.sn===trackDetails.endSN){// if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
// we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
// between different renditions. using half frag duration should help cope with these cases.
if(!this.media.seeking||this.media.duration-bufferEnd<fragPrevious.duration/2){// Finalize the media stream
this.hls.trigger(_events2.default.BUFFER_EOS,{type:'audio'});this.state=State.ENDED;break;}}// find fragment index, contiguous with end of buffer position
var fragments=trackDetails.fragments,fragLen=fragments.length,start=fragments[0].start,end=fragments[fragLen-1].start+fragments[fragLen-1].duration,frag=void 0;// When switching audio track, reload audio as close as possible to currentTime
if(audioSwitch){if(trackDetails.live&&!trackDetails.PTSKnown){_logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');bufferEnd=0;}else{bufferEnd=pos;// if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
if(trackDetails.PTSKnown&&pos<start){// if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
if(bufferInfo.end>start||bufferInfo.nextStart){_logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');this.media.currentTime=start+0.05;}else{return;}}}}if(trackDetails.initSegment&&!trackDetails.initSegment.data){frag=trackDetails.initSegment;}// if bufferEnd before start of playlist, load first fragment
else if(bufferEnd<=start){frag=fragments[0];if(trackDetails.live&&frag.loadIdx&&frag.loadIdx===this.fragLoadIdx){// we just loaded this first fragment, and we are still lagging behind the start of the live playlist
// let's force seek to start
var nextBuffered=bufferInfo.nextStart?bufferInfo.nextStart:start;_logger.logger.log('no alt audio available @currentTime:'+this.media.currentTime+', seeking @'+(nextBuffered+0.05));this.media.currentTime=nextBuffered+0.05;return;}}else{var foundFrag=void 0;var maxFragLookUpTolerance=config.maxFragLookUpTolerance;var fragNext=fragPrevious?fragments[fragPrevious.sn-fragments[0].sn+1]:undefined;var fragmentWithinToleranceTest=function fragmentWithinToleranceTest(candidate){// offset should be within fragment boundary - config.maxFragLookUpTolerance
// this is to cope with situations like
// bufferEnd = 9.991
// frag[] : [0,10]
// frag[1] : [10,20]
// bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
//              frag start               frag start+duration
//                  |-----------------------------|
//              <--->                         <--->
//  ...--------><-----------------------------><---------....
// previous frag         matching fragment         next frag
//  return -1             return 0                 return 1
//logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
// Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
var candidateLookupTolerance=Math.min(maxFragLookUpTolerance,candidate.duration);if(candidate.start+candidate.duration-candidateLookupTolerance<=bufferEnd){return 1;}// if maxFragLookUpTolerance will have negative value then don't return -1 for first element
else if(candidate.start-candidateLookupTolerance>bufferEnd&&candidate.start){return-1;}return 0;};if(bufferEnd<end){if(bufferEnd>end-maxFragLookUpTolerance){maxFragLookUpTolerance=0;}// Prefer the next fragment if it's within tolerance
if(fragNext&&!fragmentWithinToleranceTest(fragNext)){foundFrag=fragNext;}else{foundFrag=_binarySearch2.default.search(fragments,fragmentWithinToleranceTest);}}else{// reach end of playlist
foundFrag=fragments[fragLen-1];}if(foundFrag){frag=foundFrag;start=foundFrag.start;//logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
if(fragPrevious&&frag.level===fragPrevious.level&&frag.sn===fragPrevious.sn){if(frag.sn<trackDetails.endSN){frag=fragments[frag.sn+1-trackDetails.startSN];_logger.logger.log('SN just loaded, load next one: '+frag.sn);}else{frag=null;}}}}if(frag){//logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
if(frag.decryptdata&&frag.decryptdata.uri!=null&&frag.decryptdata.key==null){_logger.logger.log('Loading key for '+frag.sn+' of ['+trackDetails.startSN+' ,'+trackDetails.endSN+'],track '+trackId);this.state=State.KEY_LOADING;hls.trigger(_events2.default.KEY_LOADING,{frag:frag});}else{_logger.logger.log('Loading '+frag.sn+' of ['+trackDetails.startSN+' ,'+trackDetails.endSN+'],track '+trackId+', currentTime:'+pos+',bufferEnd:'+bufferEnd.toFixed(3));// ensure that we are not reloading the same fragments in loop ...
if(this.fragLoadIdx!==undefined){this.fragLoadIdx++;}else{this.fragLoadIdx=0;}if(frag.loadCounter){frag.loadCounter++;var maxThreshold=config.fragLoadingLoopThreshold;// if this frag has already been loaded 3 times, and if it has been reloaded recently
if(frag.loadCounter>maxThreshold&&Math.abs(this.fragLoadIdx-frag.loadIdx)<maxThreshold){hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR,fatal:false,frag:frag});return;}}else{frag.loadCounter=1;}frag.loadIdx=this.fragLoadIdx;this.fragCurrent=frag;this.startFragRequested=true;if(!isNaN(frag.sn)){this.nextLoadPosition=frag.start+frag.duration;}hls.trigger(_events2.default.FRAG_LOADING,{frag:frag});this.state=State.FRAG_LOADING;}}}break;case State.WAITING_TRACK:track=this.tracks[this.trackId];// check if playlist is already loaded
if(track&&track.details){this.state=State.IDLE;}break;case State.FRAG_LOADING_WAITING_RETRY:var now=performance.now();var retryDate=this.retryDate;media=this.media;var isSeeking=media&&media.seeking;// if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
if(!retryDate||now>=retryDate||isSeeking){_logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');this.state=State.IDLE;}break;case State.WAITING_INIT_PTS:case State.STOPPED:case State.FRAG_LOADING:case State.PARSING:case State.PARSED:case State.ENDED:break;default:break;}}},{key:'onMediaAttached',value:function onMediaAttached(data){var media=this.media=this.mediaBuffer=data.media;this.onvseeking=this.onMediaSeeking.bind(this);this.onvended=this.onMediaEnded.bind(this);media.addEventListener('seeking',this.onvseeking);media.addEventListener('ended',this.onvended);var config=this.config;if(this.tracks&&config.autoStartLoad){this.startLoad(config.startPosition);}}},{key:'onMediaDetaching',value:function onMediaDetaching(){var media=this.media;if(media&&media.ended){_logger.logger.log('MSE detaching and video ended, reset startPosition');this.startPosition=this.lastCurrentTime=0;}// reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
var tracks=this.tracks;if(tracks){// reset fragment load counter
tracks.forEach(function(track){if(track.details){track.details.fragments.forEach(function(fragment){fragment.loadCounter=undefined;});}});}// remove video listeners
if(media){media.removeEventListener('seeking',this.onvseeking);media.removeEventListener('ended',this.onvended);this.onvseeking=this.onvseeked=this.onvended=null;}this.media=this.mediaBuffer=null;this.loadedmetadata=false;this.stopLoad();}},{key:'onMediaSeeking',value:function onMediaSeeking(){if(this.state===State.ENDED){// switch to IDLE state to check for potential new fragment
this.state=State.IDLE;}if(this.media){this.lastCurrentTime=this.media.currentTime;}// avoid reporting fragment loop loading error in case user is seeking several times on same position
if(this.fragLoadIdx!==undefined){this.fragLoadIdx+=2*this.config.fragLoadingLoopThreshold;}// tick to speed up processing
this.tick();}},{key:'onMediaEnded',value:function onMediaEnded(){// reset startPosition and lastCurrentTime to restart playback @ stream beginning
this.startPosition=this.lastCurrentTime=0;}},{key:'onAudioTracksUpdated',value:function onAudioTracksUpdated(data){_logger.logger.log('audio tracks updated');this.tracks=data.audioTracks;}},{key:'onAudioTrackSwitching',value:function onAudioTrackSwitching(data){// if any URL found on new audio track, it is an alternate audio track
var altAudio=!!data.url;this.trackId=data.id;this.state=State.IDLE;this.fragCurrent=null;this.state=State.PAUSED;this.waitingFragment=null;// destroy useless demuxer when switching audio to main
if(!altAudio){if(this.demuxer){this.demuxer.destroy();this.demuxer=null;}}else{// switching to audio track, start timer if not already started
if(!this.timer){this.timer=setInterval(this.ontick,100);}}//should we switch tracks ?
if(altAudio){this.audioSwitch=true;//main audio track are handled by stream-controller, just do something if switching to alt audio track
this.state=State.IDLE;// increase fragment load Index to avoid frag loop loading error after buffer flush
if(this.fragLoadIdx!==undefined){this.fragLoadIdx+=2*this.config.fragLoadingLoopThreshold;}}this.tick();}},{key:'onAudioTrackLoaded',value:function onAudioTrackLoaded(data){var newDetails=data.details,trackId=data.id,track=this.tracks[trackId],duration=newDetails.totalduration,sliding=0;_logger.logger.log('track '+trackId+' loaded ['+newDetails.startSN+','+newDetails.endSN+'],duration:'+duration);if(newDetails.live){var curDetails=track.details;if(curDetails&&newDetails.fragments.length>0){// we already have details for that level, merge them
_levelHelper2.default.mergeDetails(curDetails,newDetails);sliding=newDetails.fragments[0].start;// TODO
//this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
if(newDetails.PTSKnown){_logger.logger.log('live audio playlist sliding:'+sliding.toFixed(3));}else{_logger.logger.log('live audio playlist - outdated PTS, unknown sliding');}}else{newDetails.PTSKnown=false;_logger.logger.log('live audio playlist - first load, unknown sliding');}}else{newDetails.PTSKnown=false;}track.details=newDetails;// compute start position
if(!this.startFragRequested){// compute start position if set to -1. use it straight away if value is defined
if(this.startPosition===-1){// first, check if start time offset has been set in playlist, if yes, use this value
var startTimeOffset=newDetails.startTimeOffset;if(!isNaN(startTimeOffset)){_logger.logger.log('start time offset found in playlist, adjust startPosition to '+startTimeOffset);this.startPosition=startTimeOffset;}else{this.startPosition=0;}}this.nextLoadPosition=this.startPosition;}// only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
if(this.state===State.WAITING_TRACK){this.state=State.IDLE;}//trigger handler right now
this.tick();}},{key:'onKeyLoaded',value:function onKeyLoaded(){if(this.state===State.KEY_LOADING){this.state=State.IDLE;this.tick();}}},{key:'onFragLoaded',value:function onFragLoaded(data){var fragCurrent=this.fragCurrent,fragLoaded=data.frag;if(this.state===State.FRAG_LOADING&&fragCurrent&&fragLoaded.type==='audio'&&fragLoaded.level===fragCurrent.level&&fragLoaded.sn===fragCurrent.sn){var track=this.tracks[this.trackId],details=track.details,duration=details.totalduration,trackId=fragCurrent.level,sn=fragCurrent.sn,cc=fragCurrent.cc,audioCodec=this.config.defaultAudioCodec||track.audioCodec||'mp4a.40.2',stats=this.stats=data.stats;if(sn==='initSegment'){this.state=State.IDLE;stats.tparsed=stats.tbuffered=performance.now();details.initSegment.data=data.payload;this.hls.trigger(_events2.default.FRAG_BUFFERED,{stats:stats,frag:fragCurrent,id:'audio'});this.tick();}else{this.state=State.PARSING;// transmux the MPEG-TS data to ISO-BMFF segments
this.appended=false;if(!this.demuxer){this.demuxer=new _demuxer2.default(this.hls,'audio');}//Check if we have video initPTS
// If not we need to wait for it
var initPTS=this.initPTS[cc];var initSegmentData=details.initSegment?details.initSegment.data:[];if(details.initSegment||initPTS!==undefined){this.pendingBuffering=true;_logger.logger.log('Demuxing '+sn+' of ['+details.startSN+' ,'+details.endSN+'],track '+trackId);// time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
var accurateTimeOffset=false;//details.PTSKnown || !details.live;
this.demuxer.push(data.payload,initSegmentData,audioCodec,null,fragCurrent,duration,accurateTimeOffset,initPTS);}else{_logger.logger.log('unknown video PTS for continuity counter '+cc+', waiting for video PTS before demuxing audio frag '+sn+' of ['+details.startSN+' ,'+details.endSN+'],track '+trackId);this.waitingFragment=data;this.state=State.WAITING_INIT_PTS;}}}this.fragLoadError=0;}},{key:'onFragParsingInitSegment',value:function onFragParsingInitSegment(data){var fragCurrent=this.fragCurrent;var fragNew=data.frag;if(fragCurrent&&data.id==='audio'&&fragNew.sn===fragCurrent.sn&&fragNew.level===fragCurrent.level&&this.state===State.PARSING){var tracks=data.tracks,track=void 0;// delete any video track found on audio demuxer
if(tracks.video){delete tracks.video;}// include levelCodec in audio and video tracks
track=tracks.audio;if(track){track.levelCodec='mp4a.40.2';track.id=data.id;this.hls.trigger(_events2.default.BUFFER_CODECS,tracks);_logger.logger.log('audio track:audio,container:'+track.container+',codecs[level/parsed]=['+track.levelCodec+'/'+track.codec+']');var initSegment=track.initSegment;if(initSegment){var appendObj={type:'audio',data:initSegment,parent:'audio',content:'initSegment'};if(this.audioSwitch){this.pendingData=[appendObj];}else{this.appended=true;// arm pending Buffering flag before appending a segment
this.pendingBuffering=true;this.hls.trigger(_events2.default.BUFFER_APPENDING,appendObj);}}//trigger handler right now
this.tick();}}}},{key:'onFragParsingData',value:function onFragParsingData(data){var _this2=this;var fragCurrent=this.fragCurrent;var fragNew=data.frag;if(fragCurrent&&data.id==='audio'&&data.type==='audio'&&fragNew.sn===fragCurrent.sn&&fragNew.level===fragCurrent.level&&this.state===State.PARSING){var trackId=this.trackId,track=this.tracks[trackId],hls=this.hls;if(isNaN(data.endPTS)){data.endPTS=data.startPTS+fragCurrent.duration;data.endDTS=data.startDTS+fragCurrent.duration;}_logger.logger.log('parsed '+data.type+',PTS:['+data.startPTS.toFixed(3)+','+data.endPTS.toFixed(3)+'],DTS:['+data.startDTS.toFixed(3)+'/'+data.endDTS.toFixed(3)+'],nb:'+data.nb);_levelHelper2.default.updateFragPTSDTS(track.details,fragCurrent,data.startPTS,data.endPTS);var audioSwitch=this.audioSwitch,media=this.media,appendOnBufferFlush=false;//Only flush audio from old audio tracks when PTS is known on new audio track
if(audioSwitch&&media){if(media.readyState){var currentTime=media.currentTime;_logger.logger.log('switching audio track : currentTime:'+currentTime);if(currentTime>=data.startPTS){_logger.logger.log('switching audio track : flushing all audio');this.state=State.BUFFER_FLUSHING;hls.trigger(_events2.default.BUFFER_FLUSHING,{startOffset:0,endOffset:Number.POSITIVE_INFINITY,type:'audio'});appendOnBufferFlush=true;//Lets announce that the initial audio track switch flush occur
this.audioSwitch=false;hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED,{id:trackId});}}else{//Lets announce that the initial audio track switch flush occur
this.audioSwitch=false;hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED,{id:trackId});}}var pendingData=this.pendingData;if(!this.audioSwitch){[data.data1,data.data2].forEach(function(buffer){if(buffer&&buffer.length){pendingData.push({type:data.type,data:buffer,parent:'audio',content:'data'});}});if(!appendOnBufferFlush&&pendingData.length){pendingData.forEach(function(appendObj){// only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
// in that case it is useless to append following segments
if(_this2.state===State.PARSING){// arm pending Buffering flag before appending a segment
_this2.pendingBuffering=true;_this2.hls.trigger(_events2.default.BUFFER_APPENDING,appendObj);}});this.pendingData=[];this.appended=true;}}//trigger handler right now
this.tick();}}},{key:'onFragParsed',value:function onFragParsed(data){var fragCurrent=this.fragCurrent;var fragNew=data.frag;if(fragCurrent&&data.id==='audio'&&fragNew.sn===fragCurrent.sn&&fragNew.level===fragCurrent.level&&this.state===State.PARSING){this.stats.tparsed=performance.now();this.state=State.PARSED;this._checkAppendedParsed();}}},{key:'onBufferCreated',value:function onBufferCreated(data){var audioTrack=data.tracks.audio;if(audioTrack){this.mediaBuffer=audioTrack.buffer;this.loadedmetadata=true;}}},{key:'onBufferAppended',value:function onBufferAppended(data){if(data.parent==='audio'){var state=this.state;if(state===State.PARSING||state===State.PARSED){// check if all buffers have been appended
this.pendingBuffering=data.pending>0;this._checkAppendedParsed();}}}},{key:'_checkAppendedParsed',value:function _checkAppendedParsed(){//trigger handler right now
if(this.state===State.PARSED&&(!this.appended||!this.pendingBuffering)){var frag=this.fragCurrent,stats=this.stats,hls=this.hls;if(frag){this.fragPrevious=frag;stats.tbuffered=performance.now();hls.trigger(_events2.default.FRAG_BUFFERED,{stats:stats,frag:frag,id:'audio'});var media=this.mediaBuffer?this.mediaBuffer:this.media;_logger.logger.log('audio buffered : '+_timeRanges2.default.toString(media.buffered));if(this.audioSwitch&&this.appended){this.audioSwitch=false;hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED,{id:this.trackId});}this.state=State.IDLE;}this.tick();}}},{key:'onError',value:function onError(data){var frag=data.frag;// don't handle frag error not related to audio fragment
if(frag&&frag.type!=='audio'){return;}switch(data.details){case _errors.ErrorDetails.FRAG_LOAD_ERROR:case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:if(!data.fatal){var loadError=this.fragLoadError;if(loadError){loadError++;}else{loadError=1;}var config=this.config;if(loadError<=config.fragLoadingMaxRetry){this.fragLoadError=loadError;// reset load counter to avoid frag loop loading error
frag.loadCounter=0;// exponential backoff capped to config.fragLoadingMaxRetryTimeout
var delay=Math.min(Math.pow(2,loadError-1)*config.fragLoadingRetryDelay,config.fragLoadingMaxRetryTimeout);_logger.logger.warn('audioStreamController: frag loading failed, retry in '+delay+' ms');this.retryDate=performance.now()+delay;// retry loading state
this.state=State.FRAG_LOADING_WAITING_RETRY;}else{_logger.logger.error('audioStreamController: '+data.details+' reaches max retry, redispatch as fatal ...');// switch error to fatal
data.fatal=true;this.state=State.ERROR;}}break;case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:case _errors.ErrorDetails.KEY_LOAD_ERROR:case _errors.ErrorDetails.KEY_LOAD_TIMEOUT://  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
if(this.state!==State.ERROR){// if fatal error, stop processing, otherwise move to IDLE to retry loading
this.state=data.fatal?State.ERROR:State.IDLE;_logger.logger.warn('audioStreamController: '+data.details+' while loading frag,switch to '+this.state+' state ...');}break;case _errors.ErrorDetails.BUFFER_FULL_ERROR:// if in appending state
if(data.parent==='audio'&&(this.state===State.PARSING||this.state===State.PARSED)){var media=this.mediaBuffer,currentTime=this.media.currentTime,mediaBuffered=media&&_bufferHelper2.default.isBuffered(media,currentTime)&&_bufferHelper2.default.isBuffered(media,currentTime+0.5);// reduce max buf len if current position is buffered
if(mediaBuffered){var _config=this.config;if(_config.maxMaxBufferLength>=_config.maxBufferLength){// reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
_config.maxMaxBufferLength/=2;_logger.logger.warn('audio:reduce max buffer length to '+_config.maxMaxBufferLength+'s');// increase fragment load Index to avoid frag loop loading error after buffer flush
this.fragLoadIdx+=2*_config.fragLoadingLoopThreshold;}this.state=State.IDLE;}else{// current position is not buffered, but browser is still complaining about buffer full error
// this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
// in that case flush the whole audio buffer to recover
_logger.logger.warn('buffer full error also media.currentTime is not buffered, flush audio buffer');this.fragCurrent=null;// flush everything
this.state=State.BUFFER_FLUSHING;this.hls.trigger(_events2.default.BUFFER_FLUSHING,{startOffset:0,endOffset:Number.POSITIVE_INFINITY,type:'audio'});}}break;default:break;}}},{key:'onBufferFlushed',value:function onBufferFlushed(){var _this3=this;var pendingData=this.pendingData;if(pendingData&&pendingData.length){_logger.logger.log('appending pending audio data on Buffer Flushed');pendingData.forEach(function(appendObj){_this3.hls.trigger(_events2.default.BUFFER_APPENDING,appendObj);});this.appended=true;this.pendingData=[];this.state=State.PARSED;}else{// move to IDLE once flush complete. this should trigger new fragment loading
this.state=State.IDLE;// reset reference to frag
this.fragPrevious=null;this.tick();}}},{key:'state',set:function set(nextState){if(this.state!==nextState){var previousState=this.state;this._state=nextState;_logger.logger.log('audio stream:'+previousState+'->'+nextState);}},get:function get(){return this._state;}}]);return AudioStreamController;}(_eventHandler2.default);exports.default=AudioStreamController;},{"25":25,"33":33,"34":34,"35":35,"37":37,"38":38,"48":48,"53":53,"54":54}],7:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _logger=_dereq_(53);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */var AudioTrackController=function(_EventHandler){_inherits(AudioTrackController,_EventHandler);function AudioTrackController(hls){_classCallCheck(this,AudioTrackController);var _this=_possibleConstructorReturn(this,(AudioTrackController.__proto__||Object.getPrototypeOf(AudioTrackController)).call(this,hls,_events2.default.MANIFEST_LOADING,_events2.default.MANIFEST_LOADED,_events2.default.AUDIO_TRACK_LOADED));_this.ticks=0;_this.ontick=_this.tick.bind(_this);return _this;}_createClass(AudioTrackController,[{key:'destroy',value:function destroy(){_eventHandler2.default.prototype.destroy.call(this);}},{key:'tick',value:function tick(){this.ticks++;if(this.ticks===1){this.doTick();if(this.ticks>1){setTimeout(this.tick,1);}this.ticks=0;}}},{key:'doTick',value:function doTick(){this.updateTrack(this.trackId);}},{key:'onManifestLoading',value:function onManifestLoading(){// reset audio tracks on manifest loading
this.tracks=[];this.trackId=-1;}},{key:'onManifestLoaded',value:function onManifestLoaded(data){var _this2=this;var tracks=data.audioTracks||[];var defaultFound=false;this.tracks=tracks;this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED,{audioTracks:tracks});// loop through available audio tracks and autoselect default if needed
var id=0;tracks.forEach(function(track){if(track.default){_this2.audioTrack=id;defaultFound=true;return;}id++;});if(defaultFound===false&&tracks.length){_logger.logger.log('no default audio track defined, use first audio track as default');this.audioTrack=0;}}},{key:'onAudioTrackLoaded',value:function onAudioTrackLoaded(data){if(data.id<this.tracks.length){_logger.logger.log('audioTrack '+data.id+' loaded');this.tracks[data.id].details=data.details;// check if current playlist is a live playlist
if(data.details.live&&!this.timer){// if live playlist we will have to reload it periodically
// set reload period to playlist target duration
this.timer=setInterval(this.ontick,1000*data.details.targetduration);}if(!data.details.live&&this.timer){// playlist is not live and timer is armed : stopping it
clearInterval(this.timer);this.timer=null;}}}/** get alternate audio tracks list from playlist **/},{key:'setAudioTrackInternal',value:function setAudioTrackInternal(newId){// check if level idx is valid
if(newId>=0&&newId<this.tracks.length){// stopping live reloading timer if any
if(this.timer){clearInterval(this.timer);this.timer=null;}this.trackId=newId;_logger.logger.log('switching to audioTrack '+newId);var audioTrack=this.tracks[newId],hls=this.hls,type=audioTrack.type,url=audioTrack.url,eventObj={id:newId,type:type,url:url};// keep AUDIO_TRACK_SWITCH for legacy reason
hls.trigger(_events2.default.AUDIO_TRACK_SWITCH,eventObj);hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING,eventObj);// check if we need to load playlist for this audio Track
var details=audioTrack.details;if(url&&(details===undefined||details.live===true)){// track not retrieved yet, or live playlist we need to (re)load it
_logger.logger.log('(re)loading playlist for audioTrack '+newId);hls.trigger(_events2.default.AUDIO_TRACK_LOADING,{url:url,id:newId});}}}},{key:'updateTrack',value:function updateTrack(newId){// check if level idx is valid
if(newId>=0&&newId<this.tracks.length){// stopping live reloading timer if any
if(this.timer){clearInterval(this.timer);this.timer=null;}this.trackId=newId;_logger.logger.log('updating audioTrack '+newId);var audioTrack=this.tracks[newId],url=audioTrack.url;// check if we need to load playlist for this audio Track
var details=audioTrack.details;if(url&&(details===undefined||details.live===true)){// track not retrieved yet, or live playlist we need to (re)load it
_logger.logger.log('(re)loading playlist for audioTrack '+newId);this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING,{url:url,id:newId});}}}},{key:'audioTracks',get:function get(){return this.tracks;}/** get index of the selected audio track (index in audio track lists) **/},{key:'audioTrack',get:function get(){return this.trackId;}/** select an audio track, based on its index in audio track lists**/,set:function set(audioTrackId){if(this.trackId!==audioTrackId||this.tracks[audioTrackId].details===undefined){this.setAudioTrackInternal(audioTrackId);}}}]);return AudioTrackController;}(_eventHandler2.default);exports.default=AudioTrackController;},{"34":34,"35":35,"53":53}],8:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _logger=_dereq_(53);var _errors=_dereq_(33);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */var BufferController=function(_EventHandler){_inherits(BufferController,_EventHandler);function BufferController(hls){_classCallCheck(this,BufferController);// the value that we have set mediasource.duration to
// (the actual duration may be tweaked slighly by the browser)
var _this=_possibleConstructorReturn(this,(BufferController.__proto__||Object.getPrototypeOf(BufferController)).call(this,hls,_events2.default.MEDIA_ATTACHING,_events2.default.MEDIA_DETACHING,_events2.default.MANIFEST_PARSED,_events2.default.BUFFER_RESET,_events2.default.BUFFER_APPENDING,_events2.default.BUFFER_CODECS,_events2.default.BUFFER_EOS,_events2.default.BUFFER_FLUSHING,_events2.default.LEVEL_PTS_UPDATED,_events2.default.LEVEL_UPDATED));_this._msDuration=null;// the value that we want to set mediaSource.duration to
_this._levelDuration=null;// Source Buffer listeners
_this.onsbue=_this.onSBUpdateEnd.bind(_this);_this.onsbe=_this.onSBUpdateError.bind(_this);_this.pendingTracks={};_this.tracks={};return _this;}_createClass(BufferController,[{key:'destroy',value:function destroy(){_eventHandler2.default.prototype.destroy.call(this);}},{key:'onLevelPtsUpdated',value:function onLevelPtsUpdated(data){var type=data.type;var audioTrack=this.tracks.audio;// Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
// in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
// is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
// `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
// event if SB is in updating state.
// More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486
if(type==='audio'&&audioTrack&&audioTrack.container==='audio/mpeg'){// Chrome audio mp3 track
var audioBuffer=this.sourceBuffer.audio;var delta=Math.abs(audioBuffer.timestampOffset-data.start);// adjust timestamp offset if time delta is greater than 100ms
if(delta>0.1){var updating=audioBuffer.updating;try{audioBuffer.abort();}catch(err){updating=true;_logger.logger.warn('can not abort audio buffer: '+err);}if(!updating){_logger.logger.warn('change mpeg audio timestamp offset from '+audioBuffer.timestampOffset+' to '+data.start);audioBuffer.timestampOffset=data.start;}else{this.audioTimestampOffset=data.start;}}}}},{key:'onManifestParsed',value:function onManifestParsed(data){var audioExpected=data.audio,videoExpected=data.video,sourceBufferNb=0;// in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
// sourcebuffers will be created all at once when the expected nb of tracks will be reached
// in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
// it will contain the expected nb of source buffers, no need to compute it
if(data.altAudio&&(audioExpected||videoExpected)){sourceBufferNb=(audioExpected?1:0)+(videoExpected?1:0);_logger.logger.log(sourceBufferNb+' sourceBuffer(s) expected');}this.sourceBufferNb=sourceBufferNb;}},{key:'onMediaAttaching',value:function onMediaAttaching(data){var media=this.media=data.media;if(media){// setup the media source
var ms=this.mediaSource=new MediaSource();//Media Source listeners
this.onmso=this.onMediaSourceOpen.bind(this);this.onmse=this.onMediaSourceEnded.bind(this);this.onmsc=this.onMediaSourceClose.bind(this);ms.addEventListener('sourceopen',this.onmso);ms.addEventListener('sourceended',this.onmse);ms.addEventListener('sourceclose',this.onmsc);// link video and media Source
media.src=URL.createObjectURL(ms);}}},{key:'onMediaDetaching',value:function onMediaDetaching(){_logger.logger.log('media source detaching');var ms=this.mediaSource;if(ms){if(ms.readyState==='open'){try{// endOfStream could trigger exception if any sourcebuffer is in updating state
// we don't really care about checking sourcebuffer state here,
// as we are anyway detaching the MediaSource
// let's just avoid this exception to propagate
ms.endOfStream();}catch(err){_logger.logger.warn('onMediaDetaching:'+err.message+' while calling endOfStream');}}ms.removeEventListener('sourceopen',this.onmso);ms.removeEventListener('sourceended',this.onmse);ms.removeEventListener('sourceclose',this.onmsc);// Detach properly the MediaSource from the HTMLMediaElement as
// suggested in https://github.com/w3c/media-source/issues/53.
if(this.media){URL.revokeObjectURL(this.media.src);this.media.removeAttribute('src');this.media.load();}this.mediaSource=null;this.media=null;this.pendingTracks={};this.tracks={};this.sourceBuffer={};this.flushRange=[];this.segments=[];this.appended=0;}this.onmso=this.onmse=this.onmsc=null;this.hls.trigger(_events2.default.MEDIA_DETACHED);}},{key:'onMediaSourceOpen',value:function onMediaSourceOpen(){_logger.logger.log('media source opened');this.hls.trigger(_events2.default.MEDIA_ATTACHED,{media:this.media});var mediaSource=this.mediaSource;if(mediaSource){// once received, don't listen anymore to sourceopen event
mediaSource.removeEventListener('sourceopen',this.onmso);}this.checkPendingTracks();}},{key:'checkPendingTracks',value:function checkPendingTracks(){// if any buffer codecs pending, check if we have enough to create sourceBuffers
var pendingTracks=this.pendingTracks,pendingTracksNb=Object.keys(pendingTracks).length;// if any pending tracks and (if nb of pending tracks gt or equal than expected nb or if unknown expected nb)
if(pendingTracksNb&&(this.sourceBufferNb<=pendingTracksNb||this.sourceBufferNb===0)){// ok, let's create them now !
this.createSourceBuffers(pendingTracks);this.pendingTracks={};// append any pending segments now !
this.doAppending();}}},{key:'onMediaSourceClose',value:function onMediaSourceClose(){_logger.logger.log('media source closed');}},{key:'onMediaSourceEnded',value:function onMediaSourceEnded(){_logger.logger.log('media source ended');}},{key:'onSBUpdateEnd',value:function onSBUpdateEnd(){// update timestampOffset
if(this.audioTimestampOffset){var audioBuffer=this.sourceBuffer.audio;_logger.logger.warn('change mpeg audio timestamp offset from '+audioBuffer.timestampOffset+' to '+this.audioTimestampOffset);audioBuffer.timestampOffset=this.audioTimestampOffset;delete this.audioTimestampOffset;}if(this._needsFlush){this.doFlush();}if(this._needsEos){this.checkEos();}this.appending=false;var parent=this.parent;// count nb of pending segments waiting for appending on this sourcebuffer
var pending=this.segments.reduce(function(counter,segment){return segment.parent===parent?counter+1:counter;},0);this.hls.trigger(_events2.default.BUFFER_APPENDED,{parent:parent,pending:pending});// don't append in flushing mode
if(!this._needsFlush){this.doAppending();}this.updateMediaElementDuration();}},{key:'onSBUpdateError',value:function onSBUpdateError(event){_logger.logger.error('sourceBuffer error:',event);// according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
// this error might not always be fatal (it is fatal if decode error is set, in that case
// it will be followed by a mediaElement error ...)
this.hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.BUFFER_APPENDING_ERROR,fatal:false});// we don't need to do more than that, as accordin to the spec, updateend will be fired just after
}},{key:'onBufferReset',value:function onBufferReset(){var sourceBuffer=this.sourceBuffer;for(var type in sourceBuffer){var sb=sourceBuffer[type];try{this.mediaSource.removeSourceBuffer(sb);sb.removeEventListener('updateend',this.onsbue);sb.removeEventListener('error',this.onsbe);}catch(err){}}this.sourceBuffer={};this.flushRange=[];this.segments=[];this.appended=0;}},{key:'onBufferCodecs',value:function onBufferCodecs(tracks){// if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
// if sourcebuffers already created, do nothing ...
if(Object.keys(this.sourceBuffer).length===0){for(var trackName in tracks){this.pendingTracks[trackName]=tracks[trackName];}var mediaSource=this.mediaSource;if(mediaSource&&mediaSource.readyState==='open'){// try to create sourcebuffers if mediasource opened
this.checkPendingTracks();}}}},{key:'createSourceBuffers',value:function createSourceBuffers(tracks){var sourceBuffer=this.sourceBuffer,mediaSource=this.mediaSource;for(var trackName in tracks){if(!sourceBuffer[trackName]){var track=tracks[trackName];// use levelCodec as first priority
var codec=track.levelCodec||track.codec;var mimeType=track.container+';codecs='+codec;_logger.logger.log('creating sourceBuffer('+mimeType+')');try{var sb=sourceBuffer[trackName]=mediaSource.addSourceBuffer(mimeType);sb.addEventListener('updateend',this.onsbue);sb.addEventListener('error',this.onsbe);this.tracks[trackName]={codec:codec,container:track.container};track.buffer=sb;}catch(err){_logger.logger.error('error while trying to add sourceBuffer:'+err.message);this.hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR,fatal:false,err:err,mimeType:mimeType});}}}this.hls.trigger(_events2.default.BUFFER_CREATED,{tracks:tracks});}},{key:'onBufferAppending',value:function onBufferAppending(data){if(!this._needsFlush){if(!this.segments){this.segments=[data];}else{this.segments.push(data);}this.doAppending();}}},{key:'onBufferAppendFail',value:function onBufferAppendFail(data){_logger.logger.error('sourceBuffer error:',data.event);// according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
// this error might not always be fatal (it is fatal if decode error is set, in that case
// it will be followed by a mediaElement error ...)
this.hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.BUFFER_APPENDING_ERROR,fatal:false});}// on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()
},{key:'onBufferEos',value:function onBufferEos(data){var sb=this.sourceBuffer;var dataType=data.type;for(var type in sb){if(!dataType||type===dataType){if(!sb[type].ended){sb[type].ended=true;_logger.logger.log(type+' sourceBuffer now EOS');}}}this.checkEos();}// if all source buffers are marked as ended, signal endOfStream() to MediaSource.
},{key:'checkEos',value:function checkEos(){var sb=this.sourceBuffer,mediaSource=this.mediaSource;if(!mediaSource||mediaSource.readyState!=='open'){this._needsEos=false;return;}for(var type in sb){var sbobj=sb[type];if(!sbobj.ended){return;}if(sbobj.updating){this._needsEos=true;return;}}_logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');//Notify the media element that it now has all of the media data
try{mediaSource.endOfStream();}catch(e){_logger.logger.warn('exception while calling mediaSource.endOfStream()');}this._needsEos=false;}},{key:'onBufferFlushing',value:function onBufferFlushing(data){this.flushRange.push({start:data.startOffset,end:data.endOffset,type:data.type});// attempt flush immediatly
this.flushBufferCounter=0;this.doFlush();}},{key:'onLevelUpdated',value:function onLevelUpdated(event){var details=event.details;if(details.fragments.length===0){return;}this._levelDuration=details.totalduration+details.fragments[0].start;this.updateMediaElementDuration();}// https://github.com/video-dev/hls.js/issues/355
},{key:'updateMediaElementDuration',value:function updateMediaElementDuration(){var media=this.media,mediaSource=this.mediaSource,sourceBuffer=this.sourceBuffer,levelDuration=this._levelDuration;if(levelDuration===null||!media||!mediaSource||!sourceBuffer||media.readyState===0||mediaSource.readyState!=='open'){return;}for(var type in sourceBuffer){if(sourceBuffer[type].updating){// can't set duration whilst a buffer is updating
return;}}if(this._msDuration===null){// initialise to the value that the media source is reporting
this._msDuration=mediaSource.duration;}var duration=media.duration;// levelDuration was the last value we set.
// not using mediaSource.duration as the browser may tweak this value
// only update mediasource duration if its value increase, this is to avoid
// flushing already buffered portion when switching between quality level
if(levelDuration>this._msDuration&&levelDuration>duration||duration===Infinity||isNaN(duration)){_logger.logger.log('Updating mediasource duration to '+levelDuration.toFixed(3));this._msDuration=mediaSource.duration=levelDuration;}}},{key:'doFlush',value:function doFlush(){// loop through all buffer ranges to flush
while(this.flushRange.length){var range=this.flushRange[0];// flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
if(this.flushBuffer(range.start,range.end,range.type)){// range flushed, remove from flush array
this.flushRange.shift();this.flushBufferCounter=0;}else{this._needsFlush=true;// avoid looping, wait for SB update end to retrigger a flush
return;}}if(this.flushRange.length===0){// everything flushed
this._needsFlush=false;// let's recompute this.appended, which is used to avoid flush looping
var appended=0;var sourceBuffer=this.sourceBuffer;try{for(var type in sourceBuffer){appended+=sourceBuffer[type].buffered.length;}}catch(error){// error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
// this is harmess at this stage, catch this to avoid reporting an internal exception
_logger.logger.error('error while accessing sourceBuffer.buffered');}this.appended=appended;this.hls.trigger(_events2.default.BUFFER_FLUSHED);}}},{key:'doAppending',value:function doAppending(){var hls=this.hls,sourceBuffer=this.sourceBuffer,segments=this.segments;if(Object.keys(sourceBuffer).length){if(this.media.error){this.segments=[];_logger.logger.error('trying to append although a media error occured, flush segment and abort');return;}if(this.appending){//logger.log(`sb appending in progress`);
return;}if(segments&&segments.length){var segment=segments.shift();try{var type=segment.type,sb=sourceBuffer[type];if(sb){if(!sb.updating){// reset sourceBuffer ended flag before appending segment
sb.ended=false;//logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
this.parent=segment.parent;sb.appendBuffer(segment.data);this.appendError=0;this.appended++;this.appending=true;}else{segments.unshift(segment);}}else{// in case we don't have any source buffer matching with this segment type,
// it means that Mediasource fails to create sourcebuffer
// discard this segment, and trigger update end
this.onSBUpdateEnd();}}catch(err){// in case any error occured while appending, put back segment in segments table
_logger.logger.error('error while trying to append buffer:'+err.message);segments.unshift(segment);var event={type:_errors.ErrorTypes.MEDIA_ERROR,parent:segment.parent};if(err.code!==22){if(this.appendError){this.appendError++;}else{this.appendError=1;}event.details=_errors.ErrorDetails.BUFFER_APPEND_ERROR;/* with UHD content, we could get loop of quota exceeded error until
                browser is able to evict some data from sourcebuffer. retrying help recovering this
              */if(this.appendError>hls.config.appendErrorMaxRetry){_logger.logger.log('fail '+hls.config.appendErrorMaxRetry+' times to append segment in sourceBuffer');segments=[];event.fatal=true;hls.trigger(_events2.default.ERROR,event);return;}else{event.fatal=false;hls.trigger(_events2.default.ERROR,event);}}else{// QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
// let's stop appending any segments, and report BUFFER_FULL_ERROR error
this.segments=[];event.details=_errors.ErrorDetails.BUFFER_FULL_ERROR;event.fatal=false;hls.trigger(_events2.default.ERROR,event);return;}}}}}/*
      flush specified buffered range,
      return true once range has been flushed.
      as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
    */},{key:'flushBuffer',value:function flushBuffer(startOffset,endOffset,typeIn){var sb,i,bufStart,bufEnd,flushStart,flushEnd,sourceBuffer=this.sourceBuffer;if(Object.keys(sourceBuffer).length){_logger.logger.log('flushBuffer,pos/start/end: '+this.media.currentTime.toFixed(3)+'/'+startOffset+'/'+endOffset);// safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
if(this.flushBufferCounter<this.appended){for(var type in sourceBuffer){// check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
// if no, let's flush all sourcebuffers
if(typeIn&&type!==typeIn){continue;}sb=sourceBuffer[type];// we are going to flush buffer, mark source buffer as 'not ended'
sb.ended=false;if(!sb.updating){try{for(i=0;i<sb.buffered.length;i++){bufStart=sb.buffered.start(i);bufEnd=sb.buffered.end(i);// workaround firefox not able to properly flush multiple buffered range.
if(navigator.userAgent.toLowerCase().indexOf('firefox')!==-1&&endOffset===Number.POSITIVE_INFINITY){flushStart=startOffset;flushEnd=endOffset;}else{flushStart=Math.max(bufStart,startOffset);flushEnd=Math.min(bufEnd,endOffset);}/* sometimes sourcebuffer.remove() does not flush
                     the exact expected time range.
                     to avoid rounding issues/infinite loop,
                     only flush buffer range of length greater than 500ms.
                  */if(Math.min(flushEnd,bufEnd)-flushStart>0.5){this.flushBufferCounter++;_logger.logger.log('flush '+type+' ['+flushStart+','+flushEnd+'], of ['+bufStart+','+bufEnd+'], pos:'+this.media.currentTime);sb.remove(flushStart,flushEnd);return false;}}}catch(e){_logger.logger.warn('exception while accessing sourcebuffer, it might have been removed from MediaSource');}}else{//logger.log('abort ' + type + ' append in progress');
// this will abort any appending in progress
//sb.abort();
_logger.logger.warn('cannot flush, sb updating in progress');return false;}}}else{_logger.logger.warn('abort flushing too many retries');}_logger.logger.log('buffer flushed');}// everything flushed !
return true;}}]);return BufferController;}(_eventHandler2.default);exports.default=BufferController;},{"33":33,"34":34,"35":35,"53":53}],9:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */var CapLevelController=function(_EventHandler){_inherits(CapLevelController,_EventHandler);function CapLevelController(hls){_classCallCheck(this,CapLevelController);return _possibleConstructorReturn(this,(CapLevelController.__proto__||Object.getPrototypeOf(CapLevelController)).call(this,hls,_events2.default.FPS_DROP_LEVEL_CAPPING,_events2.default.MEDIA_ATTACHING,_events2.default.MANIFEST_PARSED));}_createClass(CapLevelController,[{key:'destroy',value:function destroy(){if(this.hls.config.capLevelToPlayerSize){this.media=this.restrictedLevels=null;this.autoLevelCapping=Number.POSITIVE_INFINITY;if(this.timer){this.timer=clearInterval(this.timer);}}}},{key:'onFpsDropLevelCapping',value:function onFpsDropLevelCapping(data){if(!this.restrictedLevels){this.restrictedLevels=[];}if(!this.isLevelRestricted(data.droppedLevel)){this.restrictedLevels.push(data.droppedLevel);}}},{key:'onMediaAttaching',value:function onMediaAttaching(data){this.media=data.media instanceof HTMLVideoElement?data.media:null;}},{key:'onManifestParsed',value:function onManifestParsed(data){var hls=this.hls;if(hls.config.capLevelToPlayerSize){this.autoLevelCapping=Number.POSITIVE_INFINITY;this.levels=data.levels;hls.firstLevel=this.getMaxLevel(data.firstLevel);clearInterval(this.timer);this.timer=setInterval(this.detectPlayerSize.bind(this),1000);this.detectPlayerSize();}}},{key:'detectPlayerSize',value:function detectPlayerSize(){if(this.media){var levelsLength=this.levels?this.levels.length:0;if(levelsLength){var hls=this.hls;hls.autoLevelCapping=this.getMaxLevel(levelsLength-1);if(hls.autoLevelCapping>this.autoLevelCapping){// if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
// usually happen when the user go to the fullscreen mode.
hls.streamController.nextLevelSwitch();}this.autoLevelCapping=hls.autoLevelCapping;}}}/*
    * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
    */},{key:'getMaxLevel',value:function getMaxLevel(capLevelIndex){var result=0,i=void 0,level=void 0,mWidth=this.mediaWidth,mHeight=this.mediaHeight,lWidth=0,lHeight=0;for(i=0;i<=capLevelIndex;i++){level=this.levels[i];if(this.isLevelRestricted(i)){break;}result=i;lWidth=level.width;lHeight=level.height;if(mWidth<=lWidth||mHeight<=lHeight){break;}}return result;}},{key:'isLevelRestricted',value:function isLevelRestricted(level){return this.restrictedLevels&&this.restrictedLevels.indexOf(level)!==-1?true:false;}},{key:'contentScaleFactor',get:function get(){var pixelRatio=1;try{pixelRatio=window.devicePixelRatio;}catch(e){}return pixelRatio;}},{key:'mediaWidth',get:function get(){var width=void 0;var media=this.media;if(media){width=media.width||media.clientWidth||media.offsetWidth;width*=this.contentScaleFactor;}return width;}},{key:'mediaHeight',get:function get(){var height=void 0;var media=this.media;if(media){height=media.height||media.clientHeight||media.offsetHeight;height*=this.contentScaleFactor;}return height;}}]);return CapLevelController;}(_eventHandler2.default);exports.default=CapLevelController;},{"34":34,"35":35}],10:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _logger=_dereq_(53);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */var FPSController=function(_EventHandler){_inherits(FPSController,_EventHandler);function FPSController(hls){_classCallCheck(this,FPSController);return _possibleConstructorReturn(this,(FPSController.__proto__||Object.getPrototypeOf(FPSController)).call(this,hls,_events2.default.MEDIA_ATTACHING));}_createClass(FPSController,[{key:'destroy',value:function destroy(){if(this.timer){clearInterval(this.timer);}this.isVideoPlaybackQualityAvailable=false;}},{key:'onMediaAttaching',value:function onMediaAttaching(data){var config=this.hls.config;if(config.capLevelOnFPSDrop){var video=this.video=data.media instanceof HTMLVideoElement?data.media:null;if(typeof video.getVideoPlaybackQuality==='function'){this.isVideoPlaybackQualityAvailable=true;}clearInterval(this.timer);this.timer=setInterval(this.checkFPSInterval.bind(this),config.fpsDroppedMonitoringPeriod);}}},{key:'checkFPS',value:function checkFPS(video,decodedFrames,droppedFrames){var currentTime=performance.now();if(decodedFrames){if(this.lastTime){var currentPeriod=currentTime-this.lastTime,currentDropped=droppedFrames-this.lastDroppedFrames,currentDecoded=decodedFrames-this.lastDecodedFrames,droppedFPS=1000*currentDropped/currentPeriod,hls=this.hls;hls.trigger(_events2.default.FPS_DROP,{currentDropped:currentDropped,currentDecoded:currentDecoded,totalDroppedFrames:droppedFrames});if(droppedFPS>0){//logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
if(currentDropped>hls.config.fpsDroppedMonitoringThreshold*currentDecoded){var currentLevel=hls.currentLevel;_logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: '+currentLevel);if(currentLevel>0&&(hls.autoLevelCapping===-1||hls.autoLevelCapping>=currentLevel)){currentLevel=currentLevel-1;hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING,{level:currentLevel,droppedLevel:hls.currentLevel});hls.autoLevelCapping=currentLevel;hls.streamController.nextLevelSwitch();}}}}this.lastTime=currentTime;this.lastDroppedFrames=droppedFrames;this.lastDecodedFrames=decodedFrames;}}},{key:'checkFPSInterval',value:function checkFPSInterval(){var video=this.video;if(video){if(this.isVideoPlaybackQualityAvailable){var videoPlaybackQuality=video.getVideoPlaybackQuality();this.checkFPS(video,videoPlaybackQuality.totalVideoFrames,videoPlaybackQuality.droppedVideoFrames);}else{this.checkFPS(video,video.webkitDecodedFrameCount,video.webkitDroppedFrameCount);}}}}]);return FPSController;}(_eventHandler2.default);exports.default=FPSController;},{"34":34,"35":35,"53":53}],11:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * id3 metadata track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */var ID3TrackController=function(_EventHandler){_inherits(ID3TrackController,_EventHandler);function ID3TrackController(hls){_classCallCheck(this,ID3TrackController);var _this=_possibleConstructorReturn(this,(ID3TrackController.__proto__||Object.getPrototypeOf(ID3TrackController)).call(this,hls,_events2.default.MEDIA_ATTACHED,_events2.default.MEDIA_DETACHING,_events2.default.FRAG_PARSING_METADATA));_this.id3Track=undefined;_this.media=undefined;return _this;}_createClass(ID3TrackController,[{key:'destroy',value:function destroy(){_eventHandler2.default.prototype.destroy.call(this);}// Add ID3 metatadata text track.
},{key:'onMediaAttached',value:function onMediaAttached(data){this.media=data.media;if(!this.media){return;}this.id3Track=this.media.addTextTrack('metadata','id3');this.id3Track.mode='hidden';}},{key:'onMediaDetaching',value:function onMediaDetaching(){this.media=undefined;}},{key:'onFragParsingMetadata',value:function onFragParsingMetadata(data){var fragment=data.frag;var samples=data.samples;var startTime=fragment.start;var endTime=fragment.start+fragment.duration;// Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
if(startTime===endTime){endTime+=0.0001;}// Attempt to recreate Safari functionality by creating
// WebKitDataCue objects when available and store the decoded
// ID3 data in the value property of the cue
var Cue=window.WebKitDataCue||window.VTTCue||window.TextTrackCue;for(var i=0;i<samples.length;i++){var id3Frame=this.parseID3Frame(samples[i].data);var frame=this.decodeID3Frame(id3Frame);if(frame){var cue=new Cue(startTime,endTime,'');cue.value=frame;this.id3Track.addCue(cue);}}}},{key:'parseID3Frame',value:function parseID3Frame(data){if(data.length<21){return undefined;}/* http://id3.org/id3v2.3.0
      [0]     = 'I'
      [1]     = 'D'
      [2]     = '3'
      [3,4]   = {Version}
      [5]     = {Flags}
      [6-9]   = {ID3 Size}
      [10-13] = {Frame ID}
      [14-17] = {Frame Size}
      [18,19] = {Frame Flags}
      */if(data[0]===73&&// I
data[1]===68&&// D
data[2]===51){// 3
var type=String.fromCharCode(data[10],data[11],data[12],data[13]);data=data.subarray(20);return{type:type,data:data};}}},{key:'decodeID3Frame',value:function decodeID3Frame(frame){if(frame.type==='TXXX'){return this.decodeTxxxFrame(frame);}else if(frame.type==='PRIV'){return this.decodePrivFrame(frame);}else if(frame.type[0]==='T'){return this.decodeTextFrame(frame);}else{return undefined;}}},{key:'decodeTxxxFrame',value:function decodeTxxxFrame(frame){/*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{Value}
      */if(frame.size<2){return undefined;}if(frame.data[0]!==3){//only support UTF-8
return undefined;}var index=1;var description=this.utf8ArrayToStr(frame.data.subarray(index));index+=description.length+1;var value=this.utf8ArrayToStr(frame.data.subarray(index));return{key:'TXXX',description:description,data:value};}},{key:'decodeTextFrame',value:function decodeTextFrame(frame){/*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Value}
      */if(frame.size<2){return undefined;}if(frame.data[0]!==3){//only support UTF-8
return undefined;}var data=frame.data.subarray(1);return{key:frame.type,data:this.utf8ArrayToStr(data)};}},{key:'decodePrivFrame',value:function decodePrivFrame(frame){/*
      Format: <text string>\0<binary data>
      */if(frame.size<2){return undefined;}var owner=this.utf8ArrayToStr(frame.data);var privateData=frame.data.subarray(owner.length+1);return{key:'PRIV',info:owner,data:privateData.buffer};}// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
/* utf.js - UTF-8 <=> UTF-16 convertion
     *
     * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0
     * LastModified: Dec 25 1999
     * This library is free.  You can redistribute it and/or modify it.
     */},{key:'utf8ArrayToStr',value:function utf8ArrayToStr(array){var char2=void 0;var char3=void 0;var out='';var i=0;var length=array.length;while(i<length){var c=array[i++];switch(c>>4){case 0:return out;case 1:case 2:case 3:case 4:case 5:case 6:case 7:// 0xxxxxxx
out+=String.fromCharCode(c);break;case 12:case 13:// 110x xxxx   10xx xxxx
char2=array[i++];out+=String.fromCharCode((c&0x1F)<<6|char2&0x3F);break;case 14:// 1110 xxxx  10xx xxxx  10xx xxxx
char2=array[i++];char3=array[i++];out+=String.fromCharCode((c&0x0F)<<12|(char2&0x3F)<<6|(char3&0x3F)<<0);break;}}return out;}}]);return ID3TrackController;}(_eventHandler2.default);exports.default=ID3TrackController;},{"34":34,"35":35}],12:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _logger=_dereq_(53);var _errors=_dereq_(33);var _bufferHelper=_dereq_(37);var _bufferHelper2=_interopRequireDefault(_bufferHelper);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */var LevelController=function(_EventHandler){_inherits(LevelController,_EventHandler);function LevelController(hls){_classCallCheck(this,LevelController);var _this=_possibleConstructorReturn(this,(LevelController.__proto__||Object.getPrototypeOf(LevelController)).call(this,hls,_events2.default.MANIFEST_LOADED,_events2.default.LEVEL_LOADED,_events2.default.FRAG_LOADED,_events2.default.ERROR));_this.ontick=_this.tick.bind(_this);_this._manualLevel=-1;return _this;}_createClass(LevelController,[{key:'destroy',value:function destroy(){if(this.timer){clearTimeout(this.timer);this.timer=null;}this._manualLevel=-1;}},{key:'startLoad',value:function startLoad(){this.canload=true;var levels=this._levels;// clean up live level details to force reload them, and reset load errors
if(levels){levels.forEach(function(level){level.loadError=0;var levelDetails=level.details;if(levelDetails&&levelDetails.live){level.details=undefined;}});}// speed up live playlist refresh if timer exists
if(this.timer){this.tick();}}},{key:'stopLoad',value:function stopLoad(){this.canload=false;}},{key:'onManifestLoaded',value:function onManifestLoaded(data){var levels0=[],levels=[],bitrateStart,bitrateSet={},videoCodecFound=false,audioCodecFound=false,hls=this.hls,brokenmp4inmp3=/chrome|firefox/.test(navigator.userAgent.toLowerCase()),checkSupported=function checkSupported(type,codec){return MediaSource.isTypeSupported(type+'/mp4;codecs='+codec);};// regroup redundant level together
data.levels.forEach(function(level){if(level.videoCodec){videoCodecFound=true;}// erase audio codec info if browser does not support mp4a.40.34. demuxer will autodetect codec and fallback to mpeg/audio
if(brokenmp4inmp3&&level.audioCodec&&level.audioCodec.indexOf('mp4a.40.34')!==-1){level.audioCodec=undefined;}if(level.audioCodec||level.attrs&&level.attrs.AUDIO){audioCodecFound=true;}var redundantLevelId=bitrateSet[level.bitrate];if(redundantLevelId===undefined){bitrateSet[level.bitrate]=levels0.length;level.url=[level.url];level.urlId=0;levels0.push(level);}else{levels0[redundantLevelId].url.push(level.url);}});// remove audio-only level if we also have levels with audio+video codecs signalled
if(videoCodecFound&&audioCodecFound){levels0.forEach(function(level){if(level.videoCodec){levels.push(level);}});}else{levels=levels0;}// only keep level with supported audio/video codecs
levels=levels.filter(function(level){var audioCodec=level.audioCodec,videoCodec=level.videoCodec;return(!audioCodec||checkSupported('audio',audioCodec))&&(!videoCodec||checkSupported('video',videoCodec));});if(levels.length){// start bitrate is the first bitrate of the manifest
bitrateStart=levels[0].bitrate;// sort level on bitrate
levels.sort(function(a,b){return a.bitrate-b.bitrate;});this._levels=levels;// find index of first level in sorted levels
for(var i=0;i<levels.length;i++){if(levels[i].bitrate===bitrateStart){this._firstLevel=i;_logger.logger.log('manifest loaded,'+levels.length+' level(s) found, first bitrate:'+bitrateStart);break;}}hls.trigger(_events2.default.MANIFEST_PARSED,{levels:levels,firstLevel:this._firstLevel,stats:data.stats,audio:audioCodecFound,video:videoCodecFound,altAudio:data.audioTracks.length>0});}else{hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,fatal:true,url:hls.url,reason:'no level with compatible codecs found in manifest'});}return;}},{key:'setLevelInternal',value:function setLevelInternal(newLevel){var levels=this._levels;var hls=this.hls;// check if level idx is valid
if(newLevel>=0&&newLevel<levels.length){// stopping live reloading timer if any
if(this.timer){clearTimeout(this.timer);this.timer=null;}if(this._level!==newLevel){_logger.logger.log('switching to level '+newLevel);this._level=newLevel;var levelProperties=levels[newLevel];levelProperties.level=newLevel;// LEVEL_SWITCH to be deprecated in next major release
hls.trigger(_events2.default.LEVEL_SWITCH,levelProperties);hls.trigger(_events2.default.LEVEL_SWITCHING,levelProperties);}var level=levels[newLevel],levelDetails=level.details;// check if we need to load playlist for this level
if(!levelDetails||levelDetails.live===true){// level not retrieved yet, or live playlist we need to (re)load it
var urlId=level.urlId;hls.trigger(_events2.default.LEVEL_LOADING,{url:level.url[urlId],level:newLevel,id:urlId});}}else{// invalid level id given, trigger error
hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.OTHER_ERROR,details:_errors.ErrorDetails.LEVEL_SWITCH_ERROR,level:newLevel,fatal:false,reason:'invalid level idx'});}}},{key:'onError',value:function onError(data){if(data.fatal){return;}var details=data.details,hls=this.hls,levelId=void 0,level=void 0,levelError=false;// try to recover not fatal errors
switch(details){case _errors.ErrorDetails.FRAG_LOAD_ERROR:case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:case _errors.ErrorDetails.KEY_LOAD_ERROR:case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:levelId=data.frag.level;break;case _errors.ErrorDetails.LEVEL_LOAD_ERROR:case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:levelId=data.context.level;levelError=true;break;case _errors.ErrorDetails.REMUX_ALLOC_ERROR:levelId=data.level;break;default:break;}/* try to switch to a redundant stream if any available.
       * if no redundant stream available, emergency switch down (if in auto mode and current level not 0)
       * otherwise, we cannot recover this network error ...
       */if(levelId!==undefined){level=this._levels[levelId];if(!level.loadError){level.loadError=1;}else{level.loadError++;}// if any redundant streams available and if we haven't try them all (level.loadError is reseted on successful frag/level load.
// if level.loadError reaches nbRedundantLevel it means that we tried them all, no hope  => let's switch down
var nbRedundantLevel=level.url.length;if(nbRedundantLevel>1&&level.loadError<nbRedundantLevel){level.urlId=(level.urlId+1)%nbRedundantLevel;level.details=undefined;_logger.logger.warn('level controller,'+details+' for level '+levelId+': switching to redundant stream id '+level.urlId);}else{// we could try to recover if in auto mode and current level not lowest level (0)
var recoverable=this._manualLevel===-1&&levelId;if(recoverable){_logger.logger.warn('level controller,'+details+': switch-down for next fragment');hls.nextAutoLevel=Math.max(0,levelId-1);}else if(level&&level.details&&level.details.live){_logger.logger.warn('level controller,'+details+' on live stream, discard');if(levelError){// reset this._level so that another call to set level() will retrigger a frag load
this._level=undefined;}// other errors are handled by stream controller
}else if(details===_errors.ErrorDetails.LEVEL_LOAD_ERROR||details===_errors.ErrorDetails.LEVEL_LOAD_TIMEOUT){var media=hls.media,// 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
mediaBuffered=media&&_bufferHelper2.default.isBuffered(media,media.currentTime)&&_bufferHelper2.default.isBuffered(media,media.currentTime+0.5);if(mediaBuffered){var retryDelay=hls.config.levelLoadingRetryDelay;_logger.logger.warn('level controller,'+details+', but media buffered, retry in '+retryDelay+'ms');this.timer=setTimeout(this.ontick,retryDelay);// boolean used to inform stream controller not to switch back to IDLE on non fatal error
data.levelRetry=true;}else{_logger.logger.error('cannot recover '+details+' error');this._level=undefined;// stopping live reloading timer if any
if(this.timer){clearTimeout(this.timer);this.timer=null;}// switch error to fatal
data.fatal=true;}}}}}// reset level load error counter on successful frag loaded
},{key:'onFragLoaded',value:function onFragLoaded(data){var fragLoaded=data.frag;if(fragLoaded&&fragLoaded.type==='main'){var level=this._levels[fragLoaded.level];if(level){level.loadError=0;}}}},{key:'onLevelLoaded',value:function onLevelLoaded(data){var levelId=data.level;// only process level loaded events matching with expected level
if(levelId===this._level){var curLevel=this._levels[levelId];// reset level load error counter on successful level loaded
curLevel.loadError=0;var newDetails=data.details;// if current playlist is a live playlist, arm a timer to reload it
if(newDetails.live){var reloadInterval=1000*(newDetails.averagetargetduration?newDetails.averagetargetduration:newDetails.targetduration),curDetails=curLevel.details;if(curDetails&&newDetails.endSN===curDetails.endSN){// follow HLS Spec, If the client reloads a Playlist file and finds that it has not
// changed then it MUST wait for a period of one-half the target
// duration before retrying.
reloadInterval/=2;_logger.logger.log('same live playlist, reload twice faster');}// decrement reloadInterval with level loading delay
reloadInterval-=performance.now()-data.stats.trequest;// in any case, don't reload more than every second
reloadInterval=Math.max(1000,Math.round(reloadInterval));_logger.logger.log('live playlist, reload in '+reloadInterval+' ms');this.timer=setTimeout(this.ontick,reloadInterval);}else{this.timer=null;}}}},{key:'tick',value:function tick(){var levelId=this._level;if(levelId!==undefined&&this.canload){var level=this._levels[levelId];if(level&&level.url){var urlId=level.urlId;this.hls.trigger(_events2.default.LEVEL_LOADING,{url:level.url[urlId],level:levelId,id:urlId});}}}},{key:'levels',get:function get(){return this._levels;}},{key:'level',get:function get(){return this._level;},set:function set(newLevel){var levels=this._levels;if(levels&&levels.length>newLevel){if(this._level!==newLevel||levels[newLevel].details===undefined){this.setLevelInternal(newLevel);}}}},{key:'manualLevel',get:function get(){return this._manualLevel;},set:function set(newLevel){this._manualLevel=newLevel;if(this._startLevel===undefined){this._startLevel=newLevel;}if(newLevel!==-1){this.level=newLevel;}}},{key:'firstLevel',get:function get(){return this._firstLevel;},set:function set(newLevel){this._firstLevel=newLevel;}},{key:'startLevel',get:function get(){// hls.startLevel takes precedence over config.startLevel
// if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
if(this._startLevel===undefined){var configStartLevel=this.hls.config.startLevel;if(configStartLevel!==undefined){return configStartLevel;}else{return this._firstLevel;}}else{return this._startLevel;}},set:function set(newLevel){this._startLevel=newLevel;}},{key:'nextLoadLevel',get:function get(){if(this._manualLevel!==-1){return this._manualLevel;}else{return this.hls.nextAutoLevel;}},set:function set(nextLevel){this.level=nextLevel;if(this._manualLevel===-1){this.hls.nextAutoLevel=nextLevel;}}}]);return LevelController;}(_eventHandler2.default);exports.default=LevelController;},{"33":33,"34":34,"35":35,"37":37,"53":53}],13:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _binarySearch=_dereq_(48);var _binarySearch2=_interopRequireDefault(_binarySearch);var _bufferHelper=_dereq_(37);var _bufferHelper2=_interopRequireDefault(_bufferHelper);var _demuxer=_dereq_(25);var _demuxer2=_interopRequireDefault(_demuxer);var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _levelHelper=_dereq_(38);var _levelHelper2=_interopRequireDefault(_levelHelper);var _timeRanges=_dereq_(54);var _timeRanges2=_interopRequireDefault(_timeRanges);var _errors=_dereq_(33);var _logger=_dereq_(53);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */var State={STOPPED:'STOPPED',IDLE:'IDLE',KEY_LOADING:'KEY_LOADING',FRAG_LOADING:'FRAG_LOADING',FRAG_LOADING_WAITING_RETRY:'FRAG_LOADING_WAITING_RETRY',WAITING_LEVEL:'WAITING_LEVEL',PARSING:'PARSING',PARSED:'PARSED',BUFFER_FLUSHING:'BUFFER_FLUSHING',ENDED:'ENDED',ERROR:'ERROR'};var StreamController=function(_EventHandler){_inherits(StreamController,_EventHandler);function StreamController(hls){_classCallCheck(this,StreamController);var _this=_possibleConstructorReturn(this,(StreamController.__proto__||Object.getPrototypeOf(StreamController)).call(this,hls,_events2.default.MEDIA_ATTACHED,_events2.default.MEDIA_DETACHING,_events2.default.MANIFEST_LOADING,_events2.default.MANIFEST_PARSED,_events2.default.LEVEL_LOADED,_events2.default.KEY_LOADED,_events2.default.FRAG_LOADED,_events2.default.FRAG_LOAD_EMERGENCY_ABORTED,_events2.default.FRAG_PARSING_INIT_SEGMENT,_events2.default.FRAG_PARSING_DATA,_events2.default.FRAG_PARSED,_events2.default.ERROR,_events2.default.AUDIO_TRACK_SWITCHING,_events2.default.AUDIO_TRACK_SWITCHED,_events2.default.BUFFER_CREATED,_events2.default.BUFFER_APPENDED,_events2.default.BUFFER_FLUSHED));_this.config=hls.config;_this.audioCodecSwap=false;_this.ticks=0;_this._state=State.STOPPED;_this.ontick=_this.tick.bind(_this);return _this;}_createClass(StreamController,[{key:'destroy',value:function destroy(){this.stopLoad();if(this.timer){clearInterval(this.timer);this.timer=null;}_eventHandler2.default.prototype.destroy.call(this);this.state=State.STOPPED;}},{key:'startLoad',value:function startLoad(startPosition){if(this.levels){var lastCurrentTime=this.lastCurrentTime,hls=this.hls;this.stopLoad();if(!this.timer){this.timer=setInterval(this.ontick,100);}this.level=-1;this.fragLoadError=0;if(!this.startFragRequested){// determine load level
var startLevel=hls.startLevel;if(startLevel===-1){// -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
startLevel=0;this.bitrateTest=true;}// set new level to playlist loader : this will trigger start level load
// hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
this.level=hls.nextLoadLevel=startLevel;this.loadedmetadata=false;}// if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
if(lastCurrentTime>0&&startPosition===-1){_logger.logger.log('override startPosition with lastCurrentTime @'+lastCurrentTime.toFixed(3));startPosition=lastCurrentTime;}this.state=State.IDLE;this.nextLoadPosition=this.startPosition=this.lastCurrentTime=startPosition;this.tick();}else{this.forceStartLoad=true;this.state=State.STOPPED;}}},{key:'stopLoad',value:function stopLoad(){var frag=this.fragCurrent;if(frag){if(frag.loader){frag.loader.abort();}this.fragCurrent=null;}this.fragPrevious=null;if(this.demuxer){this.demuxer.destroy();this.demuxer=null;}this.state=State.STOPPED;this.forceStartLoad=false;}},{key:'tick',value:function tick(){this.ticks++;if(this.ticks===1){this.doTick();if(this.ticks>1){setTimeout(this.tick,1);}this.ticks=0;}}},{key:'doTick',value:function doTick(){switch(this.state){case State.ERROR://don't do anything in error state to avoid breaking further ...
break;case State.BUFFER_FLUSHING:// in buffer flushing state, reset fragLoadError counter
this.fragLoadError=0;break;case State.IDLE:this._doTickIdle();break;case State.WAITING_LEVEL:var level=this.levels[this.level];// check if playlist is already loaded
if(level&&level.details){this.state=State.IDLE;}break;case State.FRAG_LOADING_WAITING_RETRY:var now=performance.now();var retryDate=this.retryDate;// if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
if(!retryDate||now>=retryDate||this.media&&this.media.seeking){_logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');this.state=State.IDLE;}break;case State.ERROR:case State.STOPPED:case State.FRAG_LOADING:case State.PARSING:case State.PARSED:case State.ENDED:break;default:break;}// check buffer
this._checkBuffer();// check/update current fragment
this._checkFragmentChanged();}// Ironically the "idle" state is the on we do the most logic in it seems ....
// NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
//       played segment, or on pause/play/seek instead of naively checking every 100ms?
},{key:'_doTickIdle',value:function _doTickIdle(){var hls=this.hls,config=hls.config,media=this.media;// if video not attached AND
// start fragment already requested OR start frag prefetch disable
// exit loop
// => if start level loaded and media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
if(this.levelLastLoaded!==undefined&&!media&&(this.startFragRequested||!config.startFragPrefetch)){return;}// if we have not yet loaded any fragment, start loading from start position
var pos=void 0;if(this.loadedmetadata){pos=media.currentTime;}else{pos=this.nextLoadPosition;}// determine next load level
var level=hls.nextLoadLevel,levelInfo=this.levels[level];if(!levelInfo){return;}var levelBitrate=levelInfo.bitrate,maxBufLen=void 0;// compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
if(levelBitrate){maxBufLen=Math.max(8*config.maxBufferSize/levelBitrate,config.maxBufferLength);}else{maxBufLen=config.maxBufferLength;}maxBufLen=Math.min(maxBufLen,config.maxMaxBufferLength);// determine next candidate fragment to be loaded, based on current position and end of buffer position
// ensure up to `config.maxMaxBufferLength` of buffer upfront
var bufferInfo=_bufferHelper2.default.bufferInfo(this.mediaBuffer?this.mediaBuffer:media,pos,config.maxBufferHole),bufferLen=bufferInfo.len;// Stay idle if we are still with buffer margins
if(bufferLen>=maxBufLen){return;}// if buffer length is less than maxBufLen try to load a new fragment ...
_logger.logger.trace('buffer length of '+bufferLen.toFixed(3)+' is below max of '+maxBufLen.toFixed(3)+'. checking for more payload ...');// set next load level : this will trigger a playlist load if needed
this.level=hls.nextLoadLevel=level;var levelDetails=levelInfo.details;// if level info not retrieved yet, switch state and wait for level retrieval
// if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
// a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
if(typeof levelDetails==='undefined'||levelDetails.live&&this.levelLastLoaded!==level){this.state=State.WAITING_LEVEL;return;}// we just got done loading the final fragment, check if we need to finalize media stream
var fragPrevious=this.fragPrevious;if(!levelDetails.live&&fragPrevious&&fragPrevious.sn===levelDetails.endSN){// fragPrevious is last fragment. retrieve level duration using last frag start offset + duration
// real duration might be lower than initial duration if there are drifts between real frag duration and playlist signaling
var duration=Math.min(media.duration,fragPrevious.start+fragPrevious.duration);// if everything (almost) til the end is buffered, let's signal eos
// we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference (audio/video offsets...)
// tolerate up to one frag duration to cope with these cases.
// also cope with almost zero last frag duration (max last frag duration with 200ms) refer to https://github.com/video-dev/hls.js/pull/657
if(duration-Math.max(bufferInfo.end,fragPrevious.start)<=Math.max(0.2,fragPrevious.duration)){// Finalize the media stream
var data={};if(this.altAudio){data.type='video';}this.hls.trigger(_events2.default.BUFFER_EOS,data);this.state=State.ENDED;return;}}// if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
this._fetchPayloadOrEos(pos,bufferInfo,levelDetails);}},{key:'_fetchPayloadOrEos',value:function _fetchPayloadOrEos(pos,bufferInfo,levelDetails){var fragPrevious=this.fragPrevious,level=this.level,fragments=levelDetails.fragments,fragLen=fragments.length;// empty playlist
if(fragLen===0){return;}// find fragment index, contiguous with end of buffer position
var start=fragments[0].start,end=fragments[fragLen-1].start+fragments[fragLen-1].duration,bufferEnd=bufferInfo.end,frag=void 0;if(levelDetails.initSegment&&!levelDetails.initSegment.data){frag=levelDetails.initSegment;}else{// in case of live playlist we need to ensure that requested position is not located before playlist start
if(levelDetails.live){var initialLiveManifestSize=this.config.initialLiveManifestSize;if(fragLen<initialLiveManifestSize){_logger.logger.warn('Can not start playback of a level, reason: not enough fragments '+fragLen+' < '+initialLiveManifestSize);return;}frag=this._ensureFragmentAtLivePoint(levelDetails,bufferEnd,start,end,fragPrevious,fragments,fragLen);// if it explicitely returns null don't load any fragment and exit function now
if(frag===null){return;}}else{// VoD playlist: if bufferEnd before start of playlist, load first fragment
if(bufferEnd<start){frag=fragments[0];}}}if(!frag){frag=this._findFragment(start,fragPrevious,fragLen,fragments,bufferEnd,end,levelDetails);}if(frag){this._loadFragmentOrKey(frag,level,levelDetails,pos,bufferEnd);}return;}},{key:'_ensureFragmentAtLivePoint',value:function _ensureFragmentAtLivePoint(levelDetails,bufferEnd,start,end,fragPrevious,fragments,fragLen){var config=this.hls.config,media=this.media;var frag=void 0;// check if requested position is within seekable boundaries :
//logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
var maxLatency=config.liveMaxLatencyDuration!==undefined?config.liveMaxLatencyDuration:config.liveMaxLatencyDurationCount*levelDetails.targetduration;if(bufferEnd<Math.max(start-config.maxFragLookUpTolerance,end-maxLatency)){var liveSyncPosition=this.liveSyncPosition=this.computeLivePosition(start,levelDetails);_logger.logger.log('buffer end: '+bufferEnd.toFixed(3)+' is located too far from the end of live sliding playlist, reset currentTime to : '+liveSyncPosition.toFixed(3));bufferEnd=liveSyncPosition;if(media&&media.readyState&&media.duration>liveSyncPosition){media.currentTime=liveSyncPosition;}}// if end of buffer greater than live edge, don't load any fragment
// this could happen if live playlist intermittently slides in the past.
// level 1 loaded [182580161,182580167]
// level 1 loaded [182580162,182580169]
// Loading 182580168 of [182580162 ,182580169],level 1 ..
// Loading 182580169 of [182580162 ,182580169],level 1 ..
// level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
// level 1 loaded [182580164,182580171]
//
// don't return null in case media not loaded yet (readystate === 0)
if(levelDetails.PTSKnown&&bufferEnd>end&&media&&media.readyState){return null;}if(this.startFragRequested&&!levelDetails.PTSKnown){/* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
           try to load frag matching with next SN.
           even if SN are not synchronized between playlists, loading this frag will help us
           compute playlist sliding and find the right one after in case it was not the right consecutive one */if(fragPrevious){var targetSN=fragPrevious.sn+1;if(targetSN>=levelDetails.startSN&&targetSN<=levelDetails.endSN){frag=fragments[targetSN-levelDetails.startSN];_logger.logger.log('live playlist, switching playlist, load frag with next SN: '+frag.sn);}}if(!frag){/* we have no idea about which fragment should be loaded.
             so let's load mid fragment. it will help computing playlist sliding and find the right one
          */frag=fragments[Math.min(fragLen-1,Math.round(fragLen/2))];_logger.logger.log('live playlist, switching playlist, unknown, load middle frag : '+frag.sn);}}return frag;}},{key:'_findFragment',value:function _findFragment(start,fragPrevious,fragLen,fragments,bufferEnd,end,levelDetails){var config=this.hls.config;var frag=void 0;var foundFrag=void 0;var maxFragLookUpTolerance=config.maxFragLookUpTolerance;var fragNext=fragPrevious?fragments[fragPrevious.sn-fragments[0].sn+1]:undefined;var fragmentWithinToleranceTest=function fragmentWithinToleranceTest(candidate){// offset should be within fragment boundary - config.maxFragLookUpTolerance
// this is to cope with situations like
// bufferEnd = 9.991
// frag[] : [0,10]
// frag[1] : [10,20]
// bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
//              frag start               frag start+duration
//                  |-----------------------------|
//              <--->                         <--->
//  ...--------><-----------------------------><---------....
// previous frag         matching fragment         next frag
//  return -1             return 0                 return 1
//logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
// Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
var candidateLookupTolerance=Math.min(maxFragLookUpTolerance,candidate.duration);if(candidate.start+candidate.duration-candidateLookupTolerance<=bufferEnd){return 1;}// if maxFragLookUpTolerance will have negative value then don't return -1 for first element
else if(candidate.start-candidateLookupTolerance>bufferEnd&&candidate.start){return-1;}return 0;};if(bufferEnd<end){if(bufferEnd>end-maxFragLookUpTolerance){maxFragLookUpTolerance=0;}// Prefer the next fragment if it's within tolerance
if(fragNext&&!fragmentWithinToleranceTest(fragNext)){foundFrag=fragNext;}else{foundFrag=_binarySearch2.default.search(fragments,fragmentWithinToleranceTest);}}else{// reach end of playlist
foundFrag=fragments[fragLen-1];}if(foundFrag){frag=foundFrag;var curSNIdx=frag.sn-levelDetails.startSN;var sameLevel=fragPrevious&&frag.level===fragPrevious.level;var prevFrag=fragments[curSNIdx-1];var nextFrag=fragments[curSNIdx+1];//logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
if(fragPrevious&&frag.sn===fragPrevious.sn){if(sameLevel&&!frag.backtracked){if(frag.sn<levelDetails.endSN){var deltaPTS=fragPrevious.deltaPTS;// if there is a significant delta between audio and video, larger than max allowed hole,
// and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
// let's try to load previous fragment again to get last keyframe
// then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
if(deltaPTS&&deltaPTS>config.maxBufferHole&&fragPrevious.dropped&&curSNIdx){frag=prevFrag;_logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');// decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded
fragPrevious.loadCounter--;}else{frag=nextFrag;_logger.logger.log('SN just loaded, load next one: '+frag.sn);}}else{frag=null;}}else if(frag.backtracked){// Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
if(nextFrag&&nextFrag.backtracked){_logger.logger.warn('Already backtracked from fragment '+nextFrag.sn+', will not backtrack to fragment '+frag.sn+'. Loading fragment '+nextFrag.sn);frag=nextFrag;}else{// If a fragment has dropped frames and it's in a same level/sequence, load the previous fragment to try and find the keyframe
// Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
_logger.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');frag.dropped=0;if(prevFrag){if(prevFrag.loadCounter){prevFrag.loadCounter--;}frag=prevFrag;frag.backtracked=true;}else{frag=null;}}}}}return frag;}},{key:'_loadFragmentOrKey',value:function _loadFragmentOrKey(frag,level,levelDetails,pos,bufferEnd){var hls=this.hls,config=hls.config;//logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
if(frag.decryptdata&&frag.decryptdata.uri!=null&&frag.decryptdata.key==null){_logger.logger.log('Loading key for '+frag.sn+' of ['+levelDetails.startSN+' ,'+levelDetails.endSN+'],level '+level);this.state=State.KEY_LOADING;hls.trigger(_events2.default.KEY_LOADING,{frag:frag});}else{_logger.logger.log('Loading '+frag.sn+' of ['+levelDetails.startSN+' ,'+levelDetails.endSN+'],level '+level+', currentTime:'+pos.toFixed(3)+',bufferEnd:'+bufferEnd.toFixed(3));// ensure that we are not reloading the same fragments in loop ...
if(this.fragLoadIdx!==undefined){this.fragLoadIdx++;}else{this.fragLoadIdx=0;}if(frag.loadCounter){frag.loadCounter++;var maxThreshold=config.fragLoadingLoopThreshold;// if this frag has already been loaded 3 times, and if it has been reloaded recently
if(frag.loadCounter>maxThreshold&&Math.abs(this.fragLoadIdx-frag.loadIdx)<maxThreshold){hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR,fatal:false,frag:frag});return;}}else{frag.loadCounter=1;}frag.loadIdx=this.fragLoadIdx;this.fragCurrent=frag;this.startFragRequested=true;if(!isNaN(frag.sn)){this.nextLoadPosition=frag.start+frag.duration;}frag.autoLevel=hls.autoLevelEnabled;frag.bitrateTest=this.bitrateTest;hls.trigger(_events2.default.FRAG_LOADING,{frag:frag});// lazy demuxer init, as this could take some time ... do it during frag loading
if(!this.demuxer){this.demuxer=new _demuxer2.default(hls,'main');}this.state=State.FRAG_LOADING;return;}}},{key:'getBufferedFrag',value:function getBufferedFrag(position){return _binarySearch2.default.search(this._bufferedFrags,function(frag){if(position<frag.startPTS){return-1;}else if(position>frag.endPTS){return 1;}return 0;});}},{key:'followingBufferedFrag',value:function followingBufferedFrag(frag){if(frag){// try to get range of next fragment (500ms after this range)
return this.getBufferedFrag(frag.endPTS+0.5);}return null;}},{key:'_checkFragmentChanged',value:function _checkFragmentChanged(){var fragPlayingCurrent,currentTime,video=this.media;if(video&&video.readyState&&video.seeking===false){currentTime=video.currentTime;/* if video element is in seeked state, currentTime can only increase.
          (assuming that playback rate is positive ...)
          As sometimes currentTime jumps back to zero after a
          media decode error, check this, to avoid seeking back to
          wrong position after a media decode error
        */if(currentTime>video.playbackRate*this.lastCurrentTime){this.lastCurrentTime=currentTime;}if(_bufferHelper2.default.isBuffered(video,currentTime)){fragPlayingCurrent=this.getBufferedFrag(currentTime);}else if(_bufferHelper2.default.isBuffered(video,currentTime+0.1)){/* ensure that FRAG_CHANGED event is triggered at startup,
            when first video frame is displayed and playback is paused.
            add a tolerance of 100ms, in case current position is not buffered,
            check if current pos+100ms is buffered and use that buffer range
            for FRAG_CHANGED event reporting */fragPlayingCurrent=this.getBufferedFrag(currentTime+0.1);}if(fragPlayingCurrent){var fragPlaying=fragPlayingCurrent;if(fragPlaying!==this.fragPlaying){this.hls.trigger(_events2.default.FRAG_CHANGED,{frag:fragPlaying});var fragPlayingLevel=fragPlaying.level;if(!this.fragPlaying||this.fragPlaying.level!==fragPlayingLevel){this.hls.trigger(_events2.default.LEVEL_SWITCHED,{level:fragPlayingLevel});}this.fragPlaying=fragPlaying;}}}}/*
      on immediate level switch :
       - pause playback if playing
       - cancel any pending load request
       - and trigger a buffer flush
    */},{key:'immediateLevelSwitch',value:function immediateLevelSwitch(){_logger.logger.log('immediateLevelSwitch');if(!this.immediateSwitch){this.immediateSwitch=true;var media=this.media,previouslyPaused=void 0;if(media){previouslyPaused=media.paused;media.pause();}else{// don't restart playback after instant level switch in case media not attached
previouslyPaused=true;}this.previouslyPaused=previouslyPaused;}var fragCurrent=this.fragCurrent;if(fragCurrent&&fragCurrent.loader){fragCurrent.loader.abort();}this.fragCurrent=null;// increase fragment load Index to avoid frag loop loading error after buffer flush
this.fragLoadIdx+=2*this.config.fragLoadingLoopThreshold;// flush everything
this.flushMainBuffer(0,Number.POSITIVE_INFINITY);}/*
       on immediate level switch end, after new fragment has been buffered :
        - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
        - resume the playback if needed
    */},{key:'immediateLevelSwitchEnd',value:function immediateLevelSwitchEnd(){var media=this.media;if(media&&media.buffered.length){this.immediateSwitch=false;if(_bufferHelper2.default.isBuffered(media,media.currentTime)){// only nudge if currentTime is buffered
media.currentTime-=0.0001;}if(!this.previouslyPaused){media.play();}}}},{key:'nextLevelSwitch',value:function nextLevelSwitch(){/* try to switch ASAP without breaking video playback :
         in order to ensure smooth but quick level switching,
        we need to find the next flushable buffer range
        we should take into account new segment fetch time
      */var media=this.media;// ensure that media is defined and that metadata are available (to retrieve currentTime)
if(media&&media.readyState){var fetchdelay=void 0,fragPlayingCurrent=void 0,nextBufferedFrag=void 0;// increase fragment load Index to avoid frag loop loading error after buffer flush
this.fragLoadIdx+=2*this.config.fragLoadingLoopThreshold;fragPlayingCurrent=this.getBufferedFrag(media.currentTime);if(fragPlayingCurrent&&fragPlayingCurrent.startPTS>1){// flush buffer preceding current fragment (flush until current fragment start offset)
// minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
this.flushMainBuffer(0,fragPlayingCurrent.startPTS-1);}if(!media.paused){// add a safety delay of 1s
var nextLevelId=this.hls.nextLoadLevel,nextLevel=this.levels[nextLevelId],fragLastKbps=this.fragLastKbps;if(fragLastKbps&&this.fragCurrent){fetchdelay=this.fragCurrent.duration*nextLevel.bitrate/(1000*fragLastKbps)+1;}else{fetchdelay=0;}}else{fetchdelay=0;}//logger.log('fetchdelay:'+fetchdelay);
// find buffer range that will be reached once new fragment will be fetched
nextBufferedFrag=this.getBufferedFrag(media.currentTime+fetchdelay);if(nextBufferedFrag){// we can flush buffer range following this one without stalling playback
nextBufferedFrag=this.followingBufferedFrag(nextBufferedFrag);if(nextBufferedFrag){// if we are here, we can also cancel any loading/demuxing in progress, as they are useless
var fragCurrent=this.fragCurrent;if(fragCurrent&&fragCurrent.loader){fragCurrent.loader.abort();}this.fragCurrent=null;// flush position is the start position of this new buffer
this.flushMainBuffer(nextBufferedFrag.startPTS,Number.POSITIVE_INFINITY);}}}}},{key:'flushMainBuffer',value:function flushMainBuffer(startOffset,endOffset){this.state=State.BUFFER_FLUSHING;var flushScope={startOffset:startOffset,endOffset:endOffset};// if alternate audio tracks are used, only flush video, otherwise flush everything
if(this.altAudio){flushScope.type='video';}this.hls.trigger(_events2.default.BUFFER_FLUSHING,flushScope);}},{key:'onMediaAttached',value:function onMediaAttached(data){var media=this.media=this.mediaBuffer=data.media;this.onvseeking=this.onMediaSeeking.bind(this);this.onvseeked=this.onMediaSeeked.bind(this);this.onvended=this.onMediaEnded.bind(this);media.addEventListener('seeking',this.onvseeking);media.addEventListener('seeked',this.onvseeked);media.addEventListener('ended',this.onvended);var config=this.config;if(this.levels&&config.autoStartLoad){this.hls.startLoad(config.startPosition);}}},{key:'onMediaDetaching',value:function onMediaDetaching(){var media=this.media;if(media&&media.ended){_logger.logger.log('MSE detaching and video ended, reset startPosition');this.startPosition=this.lastCurrentTime=0;}// reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
var levels=this.levels;if(levels){// reset fragment load counter
levels.forEach(function(level){if(level.details){level.details.fragments.forEach(function(fragment){fragment.loadCounter=undefined;fragment.backtracked=undefined;});}});}// remove video listeners
if(media){media.removeEventListener('seeking',this.onvseeking);media.removeEventListener('seeked',this.onvseeked);media.removeEventListener('ended',this.onvended);this.onvseeking=this.onvseeked=this.onvended=null;}this.media=this.mediaBuffer=null;this.loadedmetadata=false;this.stopLoad();}},{key:'onMediaSeeking',value:function onMediaSeeking(){var media=this.media,currentTime=media?media.currentTime:undefined,config=this.config;if(!isNaN(currentTime)){_logger.logger.log('media seeking to '+currentTime.toFixed(3));}var mediaBuffer=this.mediaBuffer?this.mediaBuffer:media;var bufferInfo=_bufferHelper2.default.bufferInfo(mediaBuffer,currentTime,this.config.maxBufferHole);if(this.state===State.FRAG_LOADING){var fragCurrent=this.fragCurrent;// check if we are seeking to a unbuffered area AND if frag loading is in progress
if(bufferInfo.len===0&&fragCurrent){var tolerance=config.maxFragLookUpTolerance,fragStartOffset=fragCurrent.start-tolerance,fragEndOffset=fragCurrent.start+fragCurrent.duration+tolerance;// check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
if(currentTime<fragStartOffset||currentTime>fragEndOffset){if(fragCurrent.loader){_logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');fragCurrent.loader.abort();}this.fragCurrent=null;this.fragPrevious=null;// switch to IDLE state to load new fragment
this.state=State.IDLE;}else{_logger.logger.log('seeking outside of buffer but within currently loaded fragment range');}}}else if(this.state===State.ENDED){// if seeking to unbuffered area, clean up fragPrevious
if(bufferInfo.len===0){this.fragPrevious=0;}// switch to IDLE state to check for potential new fragment
this.state=State.IDLE;}if(media){this.lastCurrentTime=currentTime;}// avoid reporting fragment loop loading error in case user is seeking several times on same position
if(this.state!==State.FRAG_LOADING&&this.fragLoadIdx!==undefined){this.fragLoadIdx+=2*config.fragLoadingLoopThreshold;}// in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
if(!this.loadedmetadata){this.nextLoadPosition=this.startPosition=currentTime;}// tick to speed up processing
this.tick();}},{key:'onMediaSeeked',value:function onMediaSeeked(){var media=this.media,currentTime=media?media.currentTime:undefined;if(!isNaN(currentTime)){_logger.logger.log('media seeked to '+currentTime.toFixed(3));}// tick to speed up FRAGMENT_PLAYING triggering
this.tick();}},{key:'onMediaEnded',value:function onMediaEnded(){_logger.logger.log('media ended');// reset startPosition and lastCurrentTime to restart playback @ stream beginning
this.startPosition=this.lastCurrentTime=0;}},{key:'onManifestLoading',value:function onManifestLoading(){// reset buffer on manifest loading
_logger.logger.log('trigger BUFFER_RESET');this.hls.trigger(_events2.default.BUFFER_RESET);this._bufferedFrags=[];this.stalled=false;this.startPosition=this.lastCurrentTime=0;}},{key:'onManifestParsed',value:function onManifestParsed(data){var aac=false,heaac=false,codec;data.levels.forEach(function(level){// detect if we have different kind of audio codecs used amongst playlists
codec=level.audioCodec;if(codec){if(codec.indexOf('mp4a.40.2')!==-1){aac=true;}if(codec.indexOf('mp4a.40.5')!==-1){heaac=true;}}});this.audioCodecSwitch=aac&&heaac;if(this.audioCodecSwitch){_logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');}this.levels=data.levels;this.startLevelLoaded=false;this.startFragRequested=false;var config=this.config;if(config.autoStartLoad||this.forceStartLoad){this.hls.startLoad(config.startPosition);}}},{key:'onLevelLoaded',value:function onLevelLoaded(data){var newDetails=data.details,newLevelId=data.level,curLevel=this.levels[newLevelId],duration=newDetails.totalduration,sliding=0;_logger.logger.log('level '+newLevelId+' loaded ['+newDetails.startSN+','+newDetails.endSN+'],duration:'+duration);this.levelLastLoaded=newLevelId;if(newDetails.live){var curDetails=curLevel.details;if(curDetails&&newDetails.fragments.length>0){// we already have details for that level, merge them
_levelHelper2.default.mergeDetails(curDetails,newDetails);sliding=newDetails.fragments[0].start;this.liveSyncPosition=this.computeLivePosition(sliding,curDetails);if(newDetails.PTSKnown){_logger.logger.log('live playlist sliding:'+sliding.toFixed(3));}else{_logger.logger.log('live playlist - outdated PTS, unknown sliding');}}else{newDetails.PTSKnown=false;_logger.logger.log('live playlist - first load, unknown sliding');}}else{newDetails.PTSKnown=false;}// override level info
curLevel.details=newDetails;this.hls.trigger(_events2.default.LEVEL_UPDATED,{details:newDetails,level:newLevelId});if(this.startFragRequested===false){// compute start position if set to -1. use it straight away if value is defined
if(this.startPosition===-1||this.lastCurrentTime===-1){// first, check if start time offset has been set in playlist, if yes, use this value
var startTimeOffset=newDetails.startTimeOffset;if(!isNaN(startTimeOffset)){if(startTimeOffset<0){_logger.logger.log('negative start time offset '+startTimeOffset+', count from end of last fragment');startTimeOffset=sliding+duration+startTimeOffset;}_logger.logger.log('start time offset found in playlist, adjust startPosition to '+startTimeOffset);this.startPosition=startTimeOffset;}else{// if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
if(newDetails.live){this.startPosition=this.computeLivePosition(sliding,newDetails);_logger.logger.log('configure startPosition to '+this.startPosition);}else{this.startPosition=0;}}this.lastCurrentTime=this.startPosition;}this.nextLoadPosition=this.startPosition;}// only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
if(this.state===State.WAITING_LEVEL){this.state=State.IDLE;}//trigger handler right now
this.tick();}},{key:'onKeyLoaded',value:function onKeyLoaded(){if(this.state===State.KEY_LOADING){this.state=State.IDLE;this.tick();}}},{key:'onFragLoaded',value:function onFragLoaded(data){var fragCurrent=this.fragCurrent,fragLoaded=data.frag;if(this.state===State.FRAG_LOADING&&fragCurrent&&fragLoaded.type==='main'&&fragLoaded.level===fragCurrent.level&&fragLoaded.sn===fragCurrent.sn){var stats=data.stats,currentLevel=this.levels[fragCurrent.level],details=currentLevel.details;_logger.logger.log('Loaded  '+fragCurrent.sn+' of ['+details.startSN+' ,'+details.endSN+'],level '+fragCurrent.level);// reset frag bitrate test in any case after frag loaded event
this.bitrateTest=false;this.stats=stats;// if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
// then this means that we should be able to load a fragment at a higher quality level
if(fragLoaded.bitrateTest===true&&this.hls.nextLoadLevel){// switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
this.state=State.IDLE;this.startFragRequested=false;stats.tparsed=stats.tbuffered=performance.now();this.hls.trigger(_events2.default.FRAG_BUFFERED,{stats:stats,frag:fragCurrent,id:'main'});this.tick();}else if(fragLoaded.sn==='initSegment'){this.state=State.IDLE;stats.tparsed=stats.tbuffered=performance.now();details.initSegment.data=data.payload;this.hls.trigger(_events2.default.FRAG_BUFFERED,{stats:stats,frag:fragCurrent,id:'main'});this.tick();}else{this.state=State.PARSING;// transmux the MPEG-TS data to ISO-BMFF segments
var duration=details.totalduration,level=fragCurrent.level,sn=fragCurrent.sn,audioCodec=this.config.defaultAudioCodec||currentLevel.audioCodec;if(this.audioCodecSwap){_logger.logger.log('swapping playlist audio codec');if(audioCodec===undefined){audioCodec=this.lastAudioCodec;}if(audioCodec){if(audioCodec.indexOf('mp4a.40.5')!==-1){audioCodec='mp4a.40.2';}else{audioCodec='mp4a.40.5';}}}this.pendingBuffering=true;this.appended=false;_logger.logger.log('Parsing '+sn+' of ['+details.startSN+' ,'+details.endSN+'],level '+level+', cc '+fragCurrent.cc);var demuxer=this.demuxer;if(!demuxer){demuxer=this.demuxer=new _demuxer2.default(this.hls,'main');}// time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
var media=this.media;var mediaSeeking=media&&media.seeking;var accurateTimeOffset=!mediaSeeking&&(details.PTSKnown||!details.live);var initSegmentData=details.initSegment?details.initSegment.data:[];demuxer.push(data.payload,initSegmentData,audioCodec,currentLevel.videoCodec,fragCurrent,duration,accurateTimeOffset,undefined);}}this.fragLoadError=0;}},{key:'onFragParsingInitSegment',value:function onFragParsingInitSegment(data){var fragCurrent=this.fragCurrent;var fragNew=data.frag;if(fragCurrent&&data.id==='main'&&fragNew.sn===fragCurrent.sn&&fragNew.level===fragCurrent.level&&this.state===State.PARSING){var tracks=data.tracks,trackName,track;// if audio track is expected to come from audio stream controller, discard any coming from main
if(tracks.audio&&this.altAudio){delete tracks.audio;}// include levelCodec in audio and video tracks
track=tracks.audio;if(track){var audioCodec=this.levels[this.level].audioCodec,ua=navigator.userAgent.toLowerCase();if(audioCodec&&this.audioCodecSwap){_logger.logger.log('swapping playlist audio codec');if(audioCodec.indexOf('mp4a.40.5')!==-1){audioCodec='mp4a.40.2';}else{audioCodec='mp4a.40.5';}}// in case AAC and HE-AAC audio codecs are signalled in manifest
// force HE-AAC , as it seems that most browsers prefers that way,
// except for mono streams OR on FF
// these conditions might need to be reviewed ...
if(this.audioCodecSwitch){// don't force HE-AAC if mono stream
if(track.metadata.channelCount!==1&&// don't force HE-AAC if firefox
ua.indexOf('firefox')===-1){audioCodec='mp4a.40.5';}}// HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
if(ua.indexOf('android')!==-1&&track.container!=='audio/mpeg'){// Exclude mpeg audio
audioCodec='mp4a.40.2';_logger.logger.log('Android: force audio codec to '+audioCodec);}track.levelCodec=audioCodec;track.id=data.id;}track=tracks.video;if(track){track.levelCodec=this.levels[this.level].videoCodec;track.id=data.id;}this.hls.trigger(_events2.default.BUFFER_CODECS,tracks);// loop through tracks that are going to be provided to bufferController
for(trackName in tracks){track=tracks[trackName];_logger.logger.log('main track:'+trackName+',container:'+track.container+',codecs[level/parsed]=['+track.levelCodec+'/'+track.codec+']');var initSegment=track.initSegment;if(initSegment){this.appended=true;// arm pending Buffering flag before appending a segment
this.pendingBuffering=true;this.hls.trigger(_events2.default.BUFFER_APPENDING,{type:trackName,data:initSegment,parent:'main',content:'initSegment'});}}//trigger handler right now
this.tick();}}},{key:'onFragParsingData',value:function onFragParsingData(data){var _this2=this;var fragCurrent=this.fragCurrent;var fragNew=data.frag;if(fragCurrent&&data.id==='main'&&fragNew.sn===fragCurrent.sn&&fragNew.level===fragCurrent.level&&!(data.type==='audio'&&this.altAudio)&&// filter out main audio if audio track is loaded through audio stream controller
this.state===State.PARSING){var level=this.levels[this.level],frag=fragCurrent;if(isNaN(data.endPTS)){data.endPTS=data.startPTS+fragCurrent.duration;data.endDTS=data.startDTS+fragCurrent.duration;}_logger.logger.log('Parsed '+data.type+',PTS:['+data.startPTS.toFixed(3)+','+data.endPTS.toFixed(3)+'],DTS:['+data.startDTS.toFixed(3)+'/'+data.endDTS.toFixed(3)+'],nb:'+data.nb+',dropped:'+(data.dropped||0));// Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
if(data.type==='video'){frag.dropped=data.dropped;if(frag.dropped){if(!frag.backtracked){_logger.logger.warn('missing video frame(s), backtracking fragment');// Return back to the IDLE state without appending to buffer
// Causes findFragments to backtrack a segment and find the keyframe
// Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
frag.backtracked=true;this.nextLoadPosition=data.startPTS;this.state=State.IDLE;this.fragPrevious=frag;this.tick();return;}else{_logger.logger.warn('Already backtracked on this fragment, appending with the gap');}}else{// Only reset the backtracked flag if we've loaded the frag without any dropped frames
frag.backtracked=false;}}var drift=_levelHelper2.default.updateFragPTSDTS(level.details,frag,data.startPTS,data.endPTS,data.startDTS,data.endDTS),hls=this.hls;hls.trigger(_events2.default.LEVEL_PTS_UPDATED,{details:level.details,level:this.level,drift:drift,type:data.type,start:data.startPTS,end:data.endPTS});// has remuxer dropped video frames located before first keyframe ?
[data.data1,data.data2].forEach(function(buffer){// only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
// in that case it is useless to append following segments
if(buffer&&buffer.length&&_this2.state===State.PARSING){_this2.appended=true;// arm pending Buffering flag before appending a segment
_this2.pendingBuffering=true;hls.trigger(_events2.default.BUFFER_APPENDING,{type:data.type,data:buffer,parent:'main',content:'data'});}});//trigger handler right now
this.tick();}}},{key:'onFragParsed',value:function onFragParsed(data){var fragCurrent=this.fragCurrent;var fragNew=data.frag;if(fragCurrent&&data.id==='main'&&fragNew.sn===fragCurrent.sn&&fragNew.level===fragCurrent.level&&this.state===State.PARSING){this.stats.tparsed=performance.now();this.state=State.PARSED;this._checkAppendedParsed();}}},{key:'onAudioTrackSwitching',value:function onAudioTrackSwitching(data){// if any URL found on new audio track, it is an alternate audio track
var altAudio=!!data.url,trackId=data.id;// if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
// don't do anything if we switch to alt audio: audio stream controller is handling it.
// we will just have to change buffer scheduling on audioTrackSwitched
if(!altAudio){if(this.mediaBuffer!==this.media){_logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');this.mediaBuffer=this.media;var fragCurrent=this.fragCurrent;// we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
if(fragCurrent.loader){_logger.logger.log('switching to main audio track, cancel main fragment load');fragCurrent.loader.abort();}this.fragCurrent=null;this.fragPrevious=null;// destroy demuxer to force init segment generation (following audio switch)
if(this.demuxer){this.demuxer.destroy();this.demuxer=null;}// switch to IDLE state to load new fragment
this.state=State.IDLE;}var hls=this.hls;// switching to main audio, flush all audio and trigger track switched
hls.trigger(_events2.default.BUFFER_FLUSHING,{startOffset:0,endOffset:Number.POSITIVE_INFINITY,type:'audio'});hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED,{id:trackId});this.altAudio=false;}}},{key:'onAudioTrackSwitched',value:function onAudioTrackSwitched(data){var trackId=data.id,altAudio=!!this.hls.audioTracks[trackId].url;if(altAudio){var videoBuffer=this.videoBuffer;// if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
if(videoBuffer&&this.mediaBuffer!==videoBuffer){_logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');this.mediaBuffer=videoBuffer;}}this.altAudio=altAudio;this.tick();}},{key:'onBufferCreated',value:function onBufferCreated(data){var tracks=data.tracks,mediaTrack=void 0,name=void 0,alternate=false;for(var type in tracks){var track=tracks[type];if(track.id==='main'){name=type;mediaTrack=track;// keep video source buffer reference
if(type==='video'){this.videoBuffer=tracks[type].buffer;}}else{alternate=true;}}if(alternate&&mediaTrack){_logger.logger.log('alternate track found, use '+name+'.buffered to schedule main fragment loading');this.mediaBuffer=mediaTrack.buffer;}else{this.mediaBuffer=this.media;}}},{key:'onBufferAppended',value:function onBufferAppended(data){if(data.parent==='main'){var state=this.state;if(state===State.PARSING||state===State.PARSED){// check if all buffers have been appended
this.pendingBuffering=data.pending>0;this._checkAppendedParsed();}}}},{key:'_checkAppendedParsed',value:function _checkAppendedParsed(){//trigger handler right now
if(this.state===State.PARSED&&(!this.appended||!this.pendingBuffering)){var frag=this.fragCurrent;if(frag){var media=this.mediaBuffer?this.mediaBuffer:this.media;_logger.logger.log('main buffered : '+_timeRanges2.default.toString(media.buffered));// filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
var bufferedFrags=this._bufferedFrags.filter(function(frag){return _bufferHelper2.default.isBuffered(media,(frag.startPTS+frag.endPTS)/2);});// push new range
bufferedFrags.push(frag);// sort frags, as we use BinarySearch for lookup in getBufferedFrag ...
this._bufferedFrags=bufferedFrags.sort(function(a,b){return a.startPTS-b.startPTS;});this.fragPrevious=frag;var stats=this.stats;stats.tbuffered=performance.now();// we should get rid of this.fragLastKbps
this.fragLastKbps=Math.round(8*stats.total/(stats.tbuffered-stats.tfirst));this.hls.trigger(_events2.default.FRAG_BUFFERED,{stats:stats,frag:frag,id:'main'});this.state=State.IDLE;}this.tick();}}},{key:'onError',value:function onError(data){var frag=data.frag||this.fragCurrent;// don't handle frag error not related to main fragment
if(frag&&frag.type!=='main'){return;}var media=this.media,// 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
mediaBuffered=media&&_bufferHelper2.default.isBuffered(media,media.currentTime)&&_bufferHelper2.default.isBuffered(media,media.currentTime+0.5);switch(data.details){case _errors.ErrorDetails.FRAG_LOAD_ERROR:case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:case _errors.ErrorDetails.KEY_LOAD_ERROR:case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:if(!data.fatal){var loadError=this.fragLoadError;if(loadError){loadError++;}else{loadError=1;}var config=this.config;// keep retrying / don't raise fatal network error if current position is buffered or if in automode with current level not 0
if(loadError<=config.fragLoadingMaxRetry||mediaBuffered||frag.autoLevel&&frag.level){this.fragLoadError=loadError;// reset load counter to avoid frag loop loading error
frag.loadCounter=0;// exponential backoff capped to config.fragLoadingMaxRetryTimeout
var delay=Math.min(Math.pow(2,loadError-1)*config.fragLoadingRetryDelay,config.fragLoadingMaxRetryTimeout);_logger.logger.warn('mediaController: frag loading failed, retry in '+delay+' ms');this.retryDate=performance.now()+delay;// retry loading state
// if loadedmetadata is not set, it means that we are emergency switch down on first frag
// in that case, reset startFragRequested flag
if(!this.loadedmetadata){this.startFragRequested=false;this.nextLoadPosition=this.startPosition;}this.state=State.FRAG_LOADING_WAITING_RETRY;}else{_logger.logger.error('mediaController: '+data.details+' reaches max retry, redispatch as fatal ...');// switch error to fatal
data.fatal=true;this.state=State.ERROR;}}break;case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:if(!data.fatal){// if buffer is not empty
if(mediaBuffered){// try to reduce max buffer length : rationale is that we could get
// frag loop loading error because of buffer eviction
this._reduceMaxBufferLength(frag.duration);this.state=State.IDLE;}else{// buffer empty. report as fatal if in manual mode or if lowest level.
// level controller takes care of emergency switch down logic
if(!frag.autoLevel||frag.level===0){// switch error to fatal
data.fatal=true;this.state=State.ERROR;}}}break;case _errors.ErrorDetails.LEVEL_LOAD_ERROR:case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:if(this.state!==State.ERROR){if(data.fatal){// if fatal error, stop processing
this.state=State.ERROR;_logger.logger.warn('streamController: '+data.details+',switch to '+this.state+' state ...');}else{// in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE
if(!data.levelRetry&&this.state===State.WAITING_LEVEL){this.state=State.IDLE;}}}break;case _errors.ErrorDetails.BUFFER_FULL_ERROR:// if in appending state
if(data.parent==='main'&&(this.state===State.PARSING||this.state===State.PARSED)){// reduce max buf len if current position is buffered
if(mediaBuffered){this._reduceMaxBufferLength(this.config.maxBufferLength);this.state=State.IDLE;}else{// current position is not buffered, but browser is still complaining about buffer full error
// this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
// in that case flush the whole buffer to recover
_logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');this.fragCurrent=null;// flush everything
this.flushMainBuffer(0,Number.POSITIVE_INFINITY);}}break;default:break;}}},{key:'_reduceMaxBufferLength',value:function _reduceMaxBufferLength(minLength){var config=this.config;if(config.maxMaxBufferLength>=minLength){// reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
config.maxMaxBufferLength/=2;_logger.logger.warn('main:reduce max buffer length to '+config.maxMaxBufferLength+'s');// increase fragment load Index to avoid frag loop loading error after buffer flush
this.fragLoadIdx+=2*config.fragLoadingLoopThreshold;}}},{key:'_checkBuffer',value:function _checkBuffer(){var media=this.media;// if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek
if(media&&media.readyState){var currentTime=media.currentTime,mediaBuffer=this.mediaBuffer?this.mediaBuffer:media,buffered=mediaBuffer.buffered;// adjust currentTime to start position on loaded metadata
if(!this.loadedmetadata&&buffered.length){this.loadedmetadata=true;// only adjust currentTime if different from startPosition or if startPosition not buffered
// at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
var startPosition=media.seeking?currentTime:this.startPosition,startPositionBuffered=_bufferHelper2.default.isBuffered(mediaBuffer,startPosition);// if currentTime not matching with expected startPosition or startPosition not buffered
if(currentTime!==startPosition||!startPositionBuffered){_logger.logger.log('target start position:'+startPosition);// if startPosition not buffered, let's seek to buffered.start(0)
if(!startPositionBuffered){startPosition=buffered.start(0);_logger.logger.log('target start position not buffered, seek to buffered.start(0) '+startPosition);}_logger.logger.log('adjust currentTime from '+currentTime+' to '+startPosition);media.currentTime=startPosition;}}else if(this.immediateSwitch){this.immediateLevelSwitchEnd();}else{var bufferInfo=_bufferHelper2.default.bufferInfo(media,currentTime,0),expectedPlaying=!(media.paused||// not playing when media is paused
media.ended||// not playing when media is ended
media.buffered.length===0),// not playing if nothing buffered
jumpThreshold=0.5,// tolerance needed as some browsers stalls playback before reaching buffered range end
playheadMoving=currentTime!==this.lastCurrentTime,config=this.config;if(playheadMoving){// played moving, but was previously stalled => now not stuck anymore
if(this.stallReported){_logger.logger.warn('playback not stuck anymore @'+currentTime+', after '+Math.round(performance.now()-this.stalled)+'ms');this.stallReported=false;}this.stalled=undefined;this.nudgeRetry=0;}else{// playhead not moving
if(expectedPlaying){// playhead not moving BUT media expected to play
var tnow=performance.now();var hls=this.hls;if(!this.stalled){// stall just detected, store current time
this.stalled=tnow;this.stallReported=false;}else{// playback already stalled, check stalling duration
// if stalling for more than a given threshold, let's try to recover
var stalledDuration=tnow-this.stalled;var bufferLen=bufferInfo.len;var nudgeRetry=this.nudgeRetry||0;// have we reached stall deadline ?
if(bufferLen<=jumpThreshold&&stalledDuration>config.lowBufferWatchdogPeriod*1000){// report stalled error once
if(!this.stallReported){this.stallReported=true;_logger.logger.warn('playback stalling in low buffer @'+currentTime);hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.BUFFER_STALLED_ERROR,fatal:false,buffer:bufferLen});}// if buffer len is below threshold, try to jump to start of next buffer range if close
// no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)
var nextBufferStart=bufferInfo.nextStart,delta=nextBufferStart-currentTime;if(nextBufferStart&&delta<config.maxSeekHole&&delta>0){this.nudgeRetry=++nudgeRetry;var nudgeOffset=nudgeRetry*config.nudgeOffset;// next buffer is close ! adjust currentTime to nextBufferStart
// this will ensure effective video decoding
_logger.logger.log('adjust currentTime from '+media.currentTime+' to next buffered @ '+nextBufferStart+' + nudge '+nudgeOffset);media.currentTime=nextBufferStart+nudgeOffset;// reset stalled so to rearm watchdog timer
this.stalled=undefined;hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE,fatal:false,hole:nextBufferStart+nudgeOffset-currentTime});}}else if(bufferLen>jumpThreshold&&stalledDuration>config.highBufferWatchdogPeriod*1000){// report stalled error once
if(!this.stallReported){this.stallReported=true;_logger.logger.warn('playback stalling in high buffer @'+currentTime);hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.BUFFER_STALLED_ERROR,fatal:false,buffer:bufferLen});}// reset stalled so to rearm watchdog timer
this.stalled=undefined;this.nudgeRetry=++nudgeRetry;if(nudgeRetry<config.nudgeMaxRetry){var _currentTime=media.currentTime;var targetTime=_currentTime+nudgeRetry*config.nudgeOffset;_logger.logger.log('adjust currentTime from '+_currentTime+' to '+targetTime);// playback stalled in buffered area ... let's nudge currentTime to try to overcome this
media.currentTime=targetTime;hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.BUFFER_NUDGE_ON_STALL,fatal:false});}else{_logger.logger.error('still stuck in high buffer @'+currentTime+' after '+config.nudgeMaxRetry+', raise fatal error');hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.BUFFER_STALLED_ERROR,fatal:true});}}}}}}}}},{key:'onFragLoadEmergencyAborted',value:function onFragLoadEmergencyAborted(){this.state=State.IDLE;// if loadedmetadata is not set, it means that we are emergency switch down on first frag
// in that case, reset startFragRequested flag
if(!this.loadedmetadata){this.startFragRequested=false;this.nextLoadPosition=this.startPosition;}this.tick();}},{key:'onBufferFlushed',value:function onBufferFlushed(){/* after successful buffer flushing, filter flushed fragments from bufferedFrags
        use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
      */var media=this.mediaBuffer?this.mediaBuffer:this.media;this._bufferedFrags=this._bufferedFrags.filter(function(frag){return _bufferHelper2.default.isBuffered(media,(frag.startPTS+frag.endPTS)/2);});// increase fragment load Index to avoid frag loop loading error after buffer flush
this.fragLoadIdx+=2*this.config.fragLoadingLoopThreshold;// move to IDLE once flush complete. this should trigger new fragment loading
this.state=State.IDLE;// reset reference to frag
this.fragPrevious=null;}},{key:'swapAudioCodec',value:function swapAudioCodec(){this.audioCodecSwap=!this.audioCodecSwap;}},{key:'computeLivePosition',value:function computeLivePosition(sliding,levelDetails){var targetLatency=this.config.liveSyncDuration!==undefined?this.config.liveSyncDuration:this.config.liveSyncDurationCount*levelDetails.targetduration;return sliding+Math.max(0,levelDetails.totalduration-targetLatency);}},{key:'state',set:function set(nextState){if(this.state!==nextState){var previousState=this.state;this._state=nextState;_logger.logger.log('main stream:'+previousState+'->'+nextState);this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION,{previousState:previousState,nextState:nextState});}},get:function get(){return this._state;}},{key:'currentLevel',get:function get(){var media=this.media;if(media){var frag=this.getBufferedFrag(media.currentTime);if(frag){return frag.level;}}return-1;}},{key:'nextBufferedFrag',get:function get(){var media=this.media;if(media){// first get end range of current fragment
return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));}else{return null;}}},{key:'nextLevel',get:function get(){var frag=this.nextBufferedFrag;if(frag){return frag.level;}else{return-1;}}},{key:'liveSyncPosition',get:function get(){return this._liveSyncPosition;},set:function set(value){this._liveSyncPosition=value;}}]);return StreamController;}(_eventHandler2.default);exports.default=StreamController;},{"25":25,"33":33,"34":34,"35":35,"37":37,"38":38,"48":48,"53":53,"54":54}],14:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _logger=_dereq_(53);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Subtitle Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */var SubtitleStreamController=function(_EventHandler){_inherits(SubtitleStreamController,_EventHandler);function SubtitleStreamController(hls){_classCallCheck(this,SubtitleStreamController);var _this=_possibleConstructorReturn(this,(SubtitleStreamController.__proto__||Object.getPrototypeOf(SubtitleStreamController)).call(this,hls,_events2.default.ERROR,_events2.default.SUBTITLE_TRACKS_UPDATED,_events2.default.SUBTITLE_TRACK_SWITCH,_events2.default.SUBTITLE_TRACK_LOADED,_events2.default.SUBTITLE_FRAG_PROCESSED));_this.config=hls.config;_this.vttFragSNsProcessed={};_this.vttFragQueues=undefined;_this.currentlyProcessing=null;_this.currentTrackId=-1;return _this;}_createClass(SubtitleStreamController,[{key:'destroy',value:function destroy(){_eventHandler2.default.prototype.destroy.call(this);}// Remove all queued items and create a new, empty queue for each track.
},{key:'clearVttFragQueues',value:function clearVttFragQueues(){var _this2=this;this.vttFragQueues={};this.tracks.forEach(function(track){_this2.vttFragQueues[track.id]=[];});}// If no frag is being processed and queue isn't empty, initiate processing of next frag in line.
},{key:'nextFrag',value:function nextFrag(){if(this.currentlyProcessing===null&&this.currentTrackId>-1&&this.vttFragQueues[this.currentTrackId].length){var frag=this.currentlyProcessing=this.vttFragQueues[this.currentTrackId].shift();this.hls.trigger(_events2.default.FRAG_LOADING,{frag:frag});}}// When fragment has finished processing, add sn to list of completed if successful.
},{key:'onSubtitleFragProcessed',value:function onSubtitleFragProcessed(data){if(data.success){this.vttFragSNsProcessed[data.frag.trackId].push(data.frag.sn);}this.currentlyProcessing=null;this.nextFrag();}// If something goes wrong, procede to next frag, if we were processing one.
},{key:'onError',value:function onError(data){var frag=data.frag;// don't handle frag error not related to subtitle fragment
if(frag&&frag.type!=='subtitle'){return;}if(this.currentlyProcessing){this.currentlyProcessing=null;this.nextFrag();}}// Got all new subtitle tracks.
},{key:'onSubtitleTracksUpdated',value:function onSubtitleTracksUpdated(data){var _this3=this;_logger.logger.log('subtitle tracks updated');this.tracks=data.subtitleTracks;this.clearVttFragQueues();this.vttFragSNsProcessed={};this.tracks.forEach(function(track){_this3.vttFragSNsProcessed[track.id]=[];});}},{key:'onSubtitleTrackSwitch',value:function onSubtitleTrackSwitch(data){this.currentTrackId=data.id;this.clearVttFragQueues();}// Got a new set of subtitle fragments.
},{key:'onSubtitleTrackLoaded',value:function onSubtitleTrackLoaded(data){var processedFragSNs=this.vttFragSNsProcessed[data.id],fragQueue=this.vttFragQueues[data.id],currentFragSN=!!this.currentlyProcessing?this.currentlyProcessing.sn:-1;var alreadyProcessed=function alreadyProcessed(frag){return processedFragSNs.indexOf(frag.sn)>-1;};var alreadyInQueue=function alreadyInQueue(frag){return fragQueue.some(function(fragInQueue){return fragInQueue.sn===frag.sn;});};// Add all fragments that haven't been, aren't currently being and aren't waiting to be processed, to queue.
data.details.fragments.forEach(function(frag){if(!(alreadyProcessed(frag)||frag.sn===currentFragSN||alreadyInQueue(frag))){// Frags don't know their subtitle track ID, so let's just add that...
frag.trackId=data.id;fragQueue.push(frag);}});this.nextFrag();}}]);return SubtitleStreamController;}(_eventHandler2.default);exports.default=SubtitleStreamController;},{"34":34,"35":35,"53":53}],15:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _logger=_dereq_(53);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */function filterSubtitleTracks(textTrackList){var tracks=[];for(var i=0;i<textTrackList.length;i++){if(textTrackList[i].kind==='subtitles'){tracks.push(textTrackList[i]);}}return tracks;}var SubtitleTrackController=function(_EventHandler){_inherits(SubtitleTrackController,_EventHandler);function SubtitleTrackController(hls){_classCallCheck(this,SubtitleTrackController);var _this=_possibleConstructorReturn(this,(SubtitleTrackController.__proto__||Object.getPrototypeOf(SubtitleTrackController)).call(this,hls,_events2.default.MEDIA_ATTACHED,_events2.default.MEDIA_DETACHING,_events2.default.MANIFEST_LOADING,_events2.default.MANIFEST_LOADED,_events2.default.SUBTITLE_TRACK_LOADED));_this.tracks=[];_this.trackId=-1;_this.media=undefined;return _this;}_createClass(SubtitleTrackController,[{key:'destroy',value:function destroy(){_eventHandler2.default.prototype.destroy.call(this);}// Listen for subtitle track change, then extract the current track ID.
},{key:'onMediaAttached',value:function onMediaAttached(data){var _this2=this;this.media=data.media;if(!this.media){return;}this.media.textTracks.addEventListener('change',function(){// Media is undefined when switching streams via loadSource()
if(!_this2.media){return;}var trackId=-1;var tracks=filterSubtitleTracks(_this2.media.textTracks);for(var id=0;id<tracks.length;id++){if(tracks[id].mode==='showing'){trackId=id;}}// Setting current subtitleTrack will invoke code.
_this2.subtitleTrack=trackId;});}},{key:'onMediaDetaching',value:function onMediaDetaching(){// TODO: Remove event listeners.
this.media=undefined;}// Reset subtitle tracks on manifest loading
},{key:'onManifestLoading',value:function onManifestLoading(){this.tracks=[];this.trackId=-1;}// Fired whenever a new manifest is loaded.
},{key:'onManifestLoaded',value:function onManifestLoaded(data){var _this3=this;var tracks=data.subtitles||[];var defaultFound=false;this.tracks=tracks;this.trackId=-1;this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED,{subtitleTracks:tracks});// loop through available subtitle tracks and autoselect default if needed
// TODO: improve selection logic to handle forced, etc
tracks.forEach(function(track){if(track.default){_this3.subtitleTrack=track.id;defaultFound=true;}});}// Trigger subtitle track playlist reload.
},{key:'onTick',value:function onTick(){var trackId=this.trackId;var subtitleTrack=this.tracks[trackId];if(!subtitleTrack){return;}var details=subtitleTrack.details;// check if we need to load playlist for this subtitle Track
if(details===undefined||details.live===true){// track not retrieved yet, or live playlist we need to (re)load it
_logger.logger.log('(re)loading playlist for subtitle track '+trackId);this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING,{url:subtitleTrack.url,id:trackId});}}},{key:'onSubtitleTrackLoaded',value:function onSubtitleTrackLoaded(data){var _this4=this;if(data.id<this.tracks.length){_logger.logger.log('subtitle track '+data.id+' loaded');this.tracks[data.id].details=data.details;// check if current playlist is a live playlist
if(data.details.live&&!this.timer){// if live playlist we will have to reload it periodically
// set reload period to playlist target duration
this.timer=setInterval(function(){_this4.onTick();},1000*data.details.targetduration,this);}if(!data.details.live&&this.timer){// playlist is not live and timer is armed : stopping it
clearInterval(this.timer);this.timer=null;}}}/** get alternate subtitle tracks list from playlist **/},{key:'setSubtitleTrackInternal',value:function setSubtitleTrackInternal(newId){// check if level idx is valid
if(newId>=0&&newId<this.tracks.length){// stopping live reloading timer if any
if(this.timer){clearInterval(this.timer);this.timer=null;}this.trackId=newId;_logger.logger.log('switching to subtitle track '+newId);var subtitleTrack=this.tracks[newId];this.hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH,{id:newId});// check if we need to load playlist for this subtitle Track
var details=subtitleTrack.details;if(details===undefined||details.live===true){// track not retrieved yet, or live playlist we need to (re)load it
_logger.logger.log('(re)loading playlist for subtitle track '+newId);this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING,{url:subtitleTrack.url,id:newId});}}}},{key:'subtitleTracks',get:function get(){return this.tracks;}/** get index of the selected subtitle track (index in subtitle track lists) **/},{key:'subtitleTrack',get:function get(){return this.trackId;}/** select a subtitle track, based on its index in subtitle track lists**/,set:function set(subtitleTrackId){if(this.trackId!==subtitleTrackId){// || this.tracks[subtitleTrackId].details === undefined) {
this.setSubtitleTrackInternal(subtitleTrackId);}}}]);return SubtitleTrackController;}(_eventHandler2.default);exports.default=SubtitleTrackController;},{"34":34,"35":35,"53":53}],16:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _cea608Parser=_dereq_(49);var _cea608Parser2=_interopRequireDefault(_cea608Parser);var _webvttParser=_dereq_(57);var _webvttParser2=_interopRequireDefault(_webvttParser);var _logger=_dereq_(53);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */function clearCurrentCues(track){if(track&&track.cues){while(track.cues.length>0){track.removeCue(track.cues[0]);}}}function reuseVttTextTrack(inUseTrack,manifestTrack){return inUseTrack&&inUseTrack.label===manifestTrack.name&&!(inUseTrack.textTrack1||inUseTrack.textTrack2);}function intersection(x1,x2,y1,y2){return Math.min(x2,y2)-Math.max(x1,y1);}var TimelineController=function(_EventHandler){_inherits(TimelineController,_EventHandler);function TimelineController(hls){_classCallCheck(this,TimelineController);var _this=_possibleConstructorReturn(this,(TimelineController.__proto__||Object.getPrototypeOf(TimelineController)).call(this,hls,_events2.default.MEDIA_ATTACHING,_events2.default.MEDIA_DETACHING,_events2.default.FRAG_PARSING_USERDATA,_events2.default.MANIFEST_LOADING,_events2.default.MANIFEST_LOADED,_events2.default.FRAG_LOADED,_events2.default.LEVEL_SWITCHING,_events2.default.INIT_PTS_FOUND));_this.hls=hls;_this.config=hls.config;_this.enabled=true;_this.Cues=hls.config.cueHandler;_this.textTracks=[];_this.tracks=[];_this.unparsedVttFrags=[];_this.initPTS=undefined;_this.cueRanges=[];if(_this.config.enableCEA708Captions){var self=_this;var sendAddTrackEvent=function sendAddTrackEvent(track,media){var e=null;try{e=new window.Event('addtrack');}catch(err){//for IE11
e=document.createEvent('Event');e.initEvent('addtrack',false,false);}e.track=track;media.dispatchEvent(e);};var channel1={'newCue':function newCue(startTime,endTime,screen){if(!self.textTrack1){//Enable reuse of existing text track.
var existingTrack1=self.getExistingTrack('1');if(!existingTrack1){var textTrack1=self.createTextTrack('captions',self.config.captionsTextTrack1Label,self.config.captionsTextTrack1LanguageCode);if(textTrack1){textTrack1.textTrack1=true;self.textTrack1=textTrack1;}}else{self.textTrack1=existingTrack1;clearCurrentCues(self.textTrack1);sendAddTrackEvent(self.textTrack1,self.media);}}self.addCues('textTrack1',startTime,endTime,screen);}};var channel2={'newCue':function newCue(startTime,endTime,screen){if(!self.textTrack2){//Enable reuse of existing text track.
var existingTrack2=self.getExistingTrack('2');if(!existingTrack2){var textTrack2=self.createTextTrack('captions',self.config.captionsTextTrack2Label,self.config.captionsTextTrack1LanguageCode);if(textTrack2){textTrack2.textTrack2=true;self.textTrack2=textTrack2;}}else{self.textTrack2=existingTrack2;clearCurrentCues(self.textTrack2);sendAddTrackEvent(self.textTrack2,self.media);}}self.addCues('textTrack2',startTime,endTime,screen);}};_this.cea608Parser=new _cea608Parser2.default(0,channel1,channel2);}return _this;}_createClass(TimelineController,[{key:'addCues',value:function addCues(channel,startTime,endTime,screen){// skip cues which overlap more than 50% with previously parsed time ranges
var ranges=this.cueRanges;var merged=false;for(var i=ranges.length;i--;){var cueRange=ranges[i];var overlap=intersection(cueRange[0],cueRange[1],startTime,endTime);if(overlap>=0){cueRange[0]=Math.min(cueRange[0],startTime);cueRange[1]=Math.max(cueRange[1],endTime);merged=true;if(overlap/(endTime-startTime)>0.5){return;}}}if(!merged){ranges.push([startTime,endTime]);}this.Cues.newCue(this[channel],startTime,endTime,screen);}// Triggered when an initial PTS is found; used for synchronisation of WebVTT.
},{key:'onInitPtsFound',value:function onInitPtsFound(data){var _this2=this;if(typeof this.initPTS==='undefined'){this.initPTS=data.initPTS;}// Due to asynchrony, initial PTS may arrive later than the first VTT fragments are loaded.
// Parse any unparsed fragments upon receiving the initial PTS.
if(this.unparsedVttFrags.length){this.unparsedVttFrags.forEach(function(frag){_this2.onFragLoaded(frag);});this.unparsedVttFrags=[];}}},{key:'getExistingTrack',value:function getExistingTrack(channelNumber){var media=this.media;if(media){for(var i=0;i<media.textTracks.length;i++){var textTrack=media.textTracks[i];var propName='textTrack'+channelNumber;if(textTrack[propName]===true){return textTrack;}}}return null;}},{key:'createTextTrack',value:function createTextTrack(kind,label,lang){var media=this.media;if(media){return media.addTextTrack(kind,label,lang);}}},{key:'destroy',value:function destroy(){_eventHandler2.default.prototype.destroy.call(this);}},{key:'onMediaAttaching',value:function onMediaAttaching(data){this.media=data.media;}},{key:'onMediaDetaching',value:function onMediaDetaching(){clearCurrentCues(this.textTrack1);clearCurrentCues(this.textTrack2);}},{key:'onManifestLoading',value:function onManifestLoading(){this.lastSn=-1;// Detect discontiguity in fragment parsing
this.prevCC=-1;this.vttCCs={ccOffset:0,presentationOffset:0};// Detect discontinuity in subtitle manifests
// clear outdated subtitles
var media=this.media;if(media){var textTracks=media.textTracks;if(textTracks){for(var i=0;i<textTracks.length;i++){clearCurrentCues(textTracks[i]);}}}}},{key:'onManifestLoaded',value:function onManifestLoaded(data){var _this3=this;this.textTracks=[];this.unparsedVttFrags=this.unparsedVttFrags||[];this.initPTS=undefined;this.cueRanges=[];if(this.config.enableWebVTT){this.tracks=data.subtitles||[];var inUseTracks=this.media?this.media.textTracks:[];this.tracks.forEach(function(track,index){var textTrack=void 0;if(index<inUseTracks.length){var inUseTrack=inUseTracks[index];// Reuse tracks with the same label, but do not reuse 608/708 tracks
if(reuseVttTextTrack(inUseTrack,track)){textTrack=inUseTrack;}}if(!textTrack){textTrack=_this3.createTextTrack('subtitles',track.name,track.lang);}textTrack.mode=track.default?'showing':'hidden';_this3.textTracks.push(textTrack);});}}},{key:'onLevelSwitching',value:function onLevelSwitching(){this.enabled=this.hls.currentLevel.closedCaptions!=='NONE';}},{key:'onFragLoaded',value:function onFragLoaded(data){var frag=data.frag,payload=data.payload;if(frag.type==='main'){var sn=frag.sn;// if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
if(sn!==this.lastSn+1){var cea608Parser=this.cea608Parser;if(cea608Parser){cea608Parser.reset();}}this.lastSn=sn;}// If fragment is subtitle type, parse as WebVTT.
else if(frag.type==='subtitle'){if(payload.byteLength){// We need an initial synchronisation PTS. Store fragments as long as none has arrived.
if(typeof this.initPTS==='undefined'){this.unparsedVttFrags.push(data);return;}var vttCCs=this.vttCCs;if(!vttCCs[frag.cc]){vttCCs[frag.cc]={start:frag.start,prevCC:this.prevCC,new:true};this.prevCC=frag.cc;}var textTracks=this.textTracks,hls=this.hls;// Parse the WebVTT file contents.
_webvttParser2.default.parse(payload,this.initPTS,vttCCs,frag.cc,function(cues){var currentTrack=textTracks[frag.trackId];// Add cues and trigger event with success true.
cues.forEach(function(cue){// Sometimes there are cue overlaps on segmented vtts so the same
// cue can appear more than once in different vtt files.
// This avoid showing duplicated cues with same timecode and text.
if(!currentTrack.cues.getCueById(cue.id)){currentTrack.addCue(cue);}});hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED,{success:true,frag:frag});},function(e){// Something went wrong while parsing. Trigger event with success false.
_logger.logger.log('Failed to parse VTT cue: '+e);hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED,{success:false,frag:frag});});}else{// In case there is no payload, finish unsuccessfully.
this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED,{success:false,frag:frag});}}}},{key:'onFragParsingUserdata',value:function onFragParsingUserdata(data){// push all of the CEA-708 messages into the interpreter
// immediately. It will create the proper timestamps based on our PTS value
if(this.enabled&&this.config.enableCEA708Captions){for(var i=0;i<data.samples.length;i++){var ccdatas=this.extractCea608Data(data.samples[i].bytes);this.cea608Parser.addData(data.samples[i].pts,ccdatas);}}}},{key:'extractCea608Data',value:function extractCea608Data(byteArray){var count=byteArray[0]&31;var position=2;var tmpByte,ccbyte1,ccbyte2,ccValid,ccType;var actualCCBytes=[];for(var j=0;j<count;j++){tmpByte=byteArray[position++];ccbyte1=0x7F&byteArray[position++];ccbyte2=0x7F&byteArray[position++];ccValid=(4&tmpByte)!==0;ccType=3&tmpByte;if(ccbyte1===0&&ccbyte2===0){continue;}if(ccValid){if(ccType===0)// || ccType === 1
{actualCCBytes.push(ccbyte1);actualCCBytes.push(ccbyte2);}}}return actualCCBytes;}}]);return TimelineController;}(_eventHandler2.default);exports.default=TimelineController;},{"34":34,"35":35,"49":49,"53":53,"57":57}],17:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var AESCrypto=function(){function AESCrypto(subtle,iv){_classCallCheck(this,AESCrypto);this.subtle=subtle;this.aesIV=iv;}_createClass(AESCrypto,[{key:'decrypt',value:function decrypt(data,key){return this.subtle.decrypt({name:'AES-CBC',iv:this.aesIV},key,data);}}]);return AESCrypto;}();exports.default=AESCrypto;},{}],18:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var AESDecryptor=function(){function AESDecryptor(){_classCallCheck(this,AESDecryptor);// Static after running initTable
this.rcon=[0x0,0x1,0x2,0x4,0x8,0x10,0x20,0x40,0x80,0x1b,0x36];this.subMix=[new Uint32Array(256),new Uint32Array(256),new Uint32Array(256),new Uint32Array(256)];this.invSubMix=[new Uint32Array(256),new Uint32Array(256),new Uint32Array(256),new Uint32Array(256)];this.sBox=new Uint32Array(256);this.invSBox=new Uint32Array(256);// Changes during runtime
this.key=new Uint32Array(0);this.initTable();}// Using view.getUint32() also swaps the byte order.
_createClass(AESDecryptor,[{key:'uint8ArrayToUint32Array_',value:function uint8ArrayToUint32Array_(arrayBuffer){var view=new DataView(arrayBuffer);var newArray=new Uint32Array(4);for(var i=0;i<4;i++){newArray[i]=view.getUint32(i*4);}return newArray;}},{key:'initTable',value:function initTable(){var sBox=this.sBox;var invSBox=this.invSBox;var subMix=this.subMix;var subMix0=subMix[0];var subMix1=subMix[1];var subMix2=subMix[2];var subMix3=subMix[3];var invSubMix=this.invSubMix;var invSubMix0=invSubMix[0];var invSubMix1=invSubMix[1];var invSubMix2=invSubMix[2];var invSubMix3=invSubMix[3];var d=new Uint32Array(256);var x=0;var xi=0;var i=0;for(i=0;i<256;i++){if(i<128){d[i]=i<<1;}else{d[i]=i<<1^0x11b;}}for(i=0;i<256;i++){var sx=xi^xi<<1^xi<<2^xi<<3^xi<<4;sx=sx>>>8^sx&0xff^0x63;sBox[x]=sx;invSBox[sx]=x;// Compute multiplication
var x2=d[x];var x4=d[x2];var x8=d[x4];// Compute sub/invSub bytes, mix columns tables
var t=d[sx]*0x101^sx*0x1010100;subMix0[x]=t<<24|t>>>8;subMix1[x]=t<<16|t>>>16;subMix2[x]=t<<8|t>>>24;subMix3[x]=t;// Compute inv sub bytes, inv mix columns tables
t=x8*0x1010101^x4*0x10001^x2*0x101^x*0x1010100;invSubMix0[sx]=t<<24|t>>>8;invSubMix1[sx]=t<<16|t>>>16;invSubMix2[sx]=t<<8|t>>>24;invSubMix3[sx]=t;// Compute next counter
if(!x){x=xi=1;}else{x=x2^d[d[d[x8^x2]]];xi^=d[d[xi]];}}}},{key:'expandKey',value:function expandKey(keyBuffer){// convert keyBuffer to Uint32Array
var key=this.uint8ArrayToUint32Array_(keyBuffer);var sameKey=true;var offset=0;while(offset<key.length&&sameKey){sameKey=key[offset]===this.key[offset];offset++;}if(sameKey){return;}this.key=key;var keySize=this.keySize=key.length;if(keySize!==4&&keySize!==6&&keySize!==8){throw new Error('Invalid aes key size='+keySize);}var ksRows=this.ksRows=(keySize+6+1)*4;var ksRow=void 0;var invKsRow=void 0;var keySchedule=this.keySchedule=new Uint32Array(ksRows);var invKeySchedule=this.invKeySchedule=new Uint32Array(ksRows);var sbox=this.sBox;var rcon=this.rcon;var invSubMix=this.invSubMix;var invSubMix0=invSubMix[0];var invSubMix1=invSubMix[1];var invSubMix2=invSubMix[2];var invSubMix3=invSubMix[3];var prev=void 0;var t=void 0;for(ksRow=0;ksRow<ksRows;ksRow++){if(ksRow<keySize){prev=keySchedule[ksRow]=key[ksRow];continue;}t=prev;if(ksRow%keySize===0){// Rot word
t=t<<8|t>>>24;// Sub word
t=sbox[t>>>24]<<24|sbox[t>>>16&0xff]<<16|sbox[t>>>8&0xff]<<8|sbox[t&0xff];// Mix Rcon
t^=rcon[ksRow/keySize|0]<<24;}else if(keySize>6&&ksRow%keySize===4){// Sub word
t=sbox[t>>>24]<<24|sbox[t>>>16&0xff]<<16|sbox[t>>>8&0xff]<<8|sbox[t&0xff];}keySchedule[ksRow]=prev=(keySchedule[ksRow-keySize]^t)>>>0;}for(invKsRow=0;invKsRow<ksRows;invKsRow++){ksRow=ksRows-invKsRow;if(invKsRow&3){t=keySchedule[ksRow];}else{t=keySchedule[ksRow-4];}if(invKsRow<4||ksRow<=4){invKeySchedule[invKsRow]=t;}else{invKeySchedule[invKsRow]=invSubMix0[sbox[t>>>24]]^invSubMix1[sbox[t>>>16&0xff]]^invSubMix2[sbox[t>>>8&0xff]]^invSubMix3[sbox[t&0xff]];}invKeySchedule[invKsRow]=invKeySchedule[invKsRow]>>>0;}}// Adding this as a method greatly improves performance.
},{key:'networkToHostOrderSwap',value:function networkToHostOrderSwap(word){return word<<24|(word&0xff00)<<8|(word&0xff0000)>>8|word>>>24;}},{key:'decrypt',value:function decrypt(inputArrayBuffer,offset,aesIV){var nRounds=this.keySize+6;var invKeySchedule=this.invKeySchedule;var invSBOX=this.invSBox;var invSubMix=this.invSubMix;var invSubMix0=invSubMix[0];var invSubMix1=invSubMix[1];var invSubMix2=invSubMix[2];var invSubMix3=invSubMix[3];var initVector=this.uint8ArrayToUint32Array_(aesIV);var initVector0=initVector[0];var initVector1=initVector[1];var initVector2=initVector[2];var initVector3=initVector[3];var inputInt32=new Int32Array(inputArrayBuffer);var outputInt32=new Int32Array(inputInt32.length);var t0=void 0,t1=void 0,t2=void 0,t3=void 0;var s0=void 0,s1=void 0,s2=void 0,s3=void 0;var inputWords0=void 0,inputWords1=void 0,inputWords2=void 0,inputWords3=void 0;var ksRow,i;var swapWord=this.networkToHostOrderSwap;while(offset<inputInt32.length){inputWords0=swapWord(inputInt32[offset]);inputWords1=swapWord(inputInt32[offset+1]);inputWords2=swapWord(inputInt32[offset+2]);inputWords3=swapWord(inputInt32[offset+3]);s0=inputWords0^invKeySchedule[0];s1=inputWords3^invKeySchedule[1];s2=inputWords2^invKeySchedule[2];s3=inputWords1^invKeySchedule[3];ksRow=4;// Iterate through the rounds of decryption
for(i=1;i<nRounds;i++){t0=invSubMix0[s0>>>24]^invSubMix1[s1>>16&0xff]^invSubMix2[s2>>8&0xff]^invSubMix3[s3&0xff]^invKeySchedule[ksRow];t1=invSubMix0[s1>>>24]^invSubMix1[s2>>16&0xff]^invSubMix2[s3>>8&0xff]^invSubMix3[s0&0xff]^invKeySchedule[ksRow+1];t2=invSubMix0[s2>>>24]^invSubMix1[s3>>16&0xff]^invSubMix2[s0>>8&0xff]^invSubMix3[s1&0xff]^invKeySchedule[ksRow+2];t3=invSubMix0[s3>>>24]^invSubMix1[s0>>16&0xff]^invSubMix2[s1>>8&0xff]^invSubMix3[s2&0xff]^invKeySchedule[ksRow+3];// Update state
s0=t0;s1=t1;s2=t2;s3=t3;ksRow=ksRow+4;}// Shift rows, sub bytes, add round key
t0=invSBOX[s0>>>24]<<24^invSBOX[s1>>16&0xff]<<16^invSBOX[s2>>8&0xff]<<8^invSBOX[s3&0xff]^invKeySchedule[ksRow];t1=invSBOX[s1>>>24]<<24^invSBOX[s2>>16&0xff]<<16^invSBOX[s3>>8&0xff]<<8^invSBOX[s0&0xff]^invKeySchedule[ksRow+1];t2=invSBOX[s2>>>24]<<24^invSBOX[s3>>16&0xff]<<16^invSBOX[s0>>8&0xff]<<8^invSBOX[s1&0xff]^invKeySchedule[ksRow+2];t3=invSBOX[s3>>>24]<<24^invSBOX[s0>>16&0xff]<<16^invSBOX[s1>>8&0xff]<<8^invSBOX[s2&0xff]^invKeySchedule[ksRow+3];ksRow=ksRow+3;// Write
outputInt32[offset]=swapWord(t0^initVector0);outputInt32[offset+1]=swapWord(t3^initVector1);outputInt32[offset+2]=swapWord(t2^initVector2);outputInt32[offset+3]=swapWord(t1^initVector3);// reset initVector to last 4 unsigned int
initVector0=inputWords0;initVector1=inputWords1;initVector2=inputWords2;initVector3=inputWords3;offset=offset+4;}return outputInt32.buffer;}},{key:'destroy',value:function destroy(){this.key=undefined;this.keySize=undefined;this.ksRows=undefined;this.sBox=undefined;this.invSBox=undefined;this.subMix=undefined;this.invSubMix=undefined;this.keySchedule=undefined;this.invKeySchedule=undefined;this.rcon=undefined;}}]);return AESDecryptor;}();exports.default=AESDecryptor;},{}],19:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _aesCrypto=_dereq_(17);var _aesCrypto2=_interopRequireDefault(_aesCrypto);var _fastAesKey=_dereq_(20);var _fastAesKey2=_interopRequireDefault(_fastAesKey);var _aesDecryptor=_dereq_(18);var _aesDecryptor2=_interopRequireDefault(_aesDecryptor);var _errors=_dereq_(33);var _logger=_dereq_(53);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}/*globals self: false */var Decrypter=function(){function Decrypter(observer,config){_classCallCheck(this,Decrypter);this.observer=observer;this.config=config;this.logEnabled=true;try{var browserCrypto=crypto?crypto:self.crypto;this.subtle=browserCrypto.subtle||browserCrypto.webkitSubtle;}catch(e){}this.disableWebCrypto=!this.subtle;}_createClass(Decrypter,[{key:'isSync',value:function isSync(){return this.disableWebCrypto&&this.config.enableSoftwareAES;}},{key:'decrypt',value:function decrypt(data,key,iv,callback){var _this=this;if(this.disableWebCrypto&&this.config.enableSoftwareAES){if(this.logEnabled){_logger.logger.log('JS AES decrypt');this.logEnabled=false;}var decryptor=this.decryptor;if(!decryptor){this.decryptor=decryptor=new _aesDecryptor2.default();}decryptor.expandKey(key);callback(decryptor.decrypt(data,0,iv));}else{if(this.logEnabled){_logger.logger.log('WebCrypto AES decrypt');this.logEnabled=false;}var subtle=this.subtle;if(this.key!==key){this.key=key;this.fastAesKey=new _fastAesKey2.default(subtle,key);}this.fastAesKey.expandKey().then(function(aesKey){// decrypt using web crypto
var crypto=new _aesCrypto2.default(subtle,iv);crypto.decrypt(data,aesKey).catch(function(err){_this.onWebCryptoError(err,data,key,iv,callback);}).then(function(result){callback(result);});}).catch(function(err){_this.onWebCryptoError(err,data,key,iv,callback);});}}},{key:'onWebCryptoError',value:function onWebCryptoError(err,data,key,iv,callback){if(this.config.enableSoftwareAES){_logger.logger.log('WebCrypto Error, disable WebCrypto API');this.disableWebCrypto=true;this.logEnabled=true;this.decrypt(data,key,iv,callback);}else{_logger.logger.error('decrypting error : '+err.message);this.observer.trigger(Event.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.FRAG_DECRYPT_ERROR,fatal:true,reason:err.message});}}},{key:'destroy',value:function destroy(){var decryptor=this.decryptor;if(decryptor){decryptor.destroy();this.decryptor=undefined;}}}]);return Decrypter;}();exports.default=Decrypter;},{"17":17,"18":18,"20":20,"33":33,"53":53}],20:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var FastAESKey=function(){function FastAESKey(subtle,key){_classCallCheck(this,FastAESKey);this.subtle=subtle;this.key=key;}_createClass(FastAESKey,[{key:'expandKey',value:function expandKey(){return this.subtle.importKey('raw',this.key,{name:'AES-CBC'},false,['encrypt','decrypt']);}}]);return FastAESKey;}();exports.default=FastAESKey;},{}],21:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */var _adts=_dereq_(22);var _adts2=_interopRequireDefault(_adts);var _logger=_dereq_(53);var _id=_dereq_(27);var _id2=_interopRequireDefault(_id);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var AACDemuxer=function(){function AACDemuxer(observer,remuxer,config){_classCallCheck(this,AACDemuxer);this.observer=observer;this.config=config;this.remuxer=remuxer;}_createClass(AACDemuxer,[{key:'resetInitSegment',value:function resetInitSegment(initSegment,audioCodec,videoCodec,duration){this._audioTrack={container:'audio/adts',type:'audio',id:-1,sequenceNumber:0,isAAC:true,samples:[],len:0,manifestCodec:audioCodec,duration:duration,inputTimeScale:90000};}},{key:'resetTimeStamp',value:function resetTimeStamp(){}},{key:'append',// feed incoming data to the front of the parsing pipeline
value:function append(data,timeOffset,contiguous,accurateTimeOffset){var track,id3=new _id2.default(data),pts=90*id3.timeStamp,config,frameLength,frameDuration,frameIndex,offset,headerLength,stamp,length,aacSample;track=this._audioTrack;// Look for ADTS header
for(offset=id3.length,length=data.length;offset<length-1;offset++){if(data[offset]===0xff&&(data[offset+1]&0xf6)===0xf0){break;}}if(!track.samplerate){config=_adts2.default.getAudioConfig(this.observer,data,offset,track.manifestCodec);track.config=config.config;track.samplerate=config.samplerate;track.channelCount=config.channelCount;track.codec=config.codec;_logger.logger.log('parsed codec:'+track.codec+',rate:'+config.samplerate+',nb channel:'+config.channelCount);}frameIndex=0;frameDuration=1024*90000/track.samplerate;while(offset+5<length){// The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
headerLength=!!(data[offset+1]&0x01)?7:9;// retrieve frame size
frameLength=(data[offset+3]&0x03)<<11|data[offset+4]<<3|(data[offset+5]&0xE0)>>>5;frameLength-=headerLength;//stamp = pes.pts;
if(frameLength>0&&offset+headerLength+frameLength<=length){stamp=pts+frameIndex*frameDuration;//logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
aacSample={unit:data.subarray(offset+headerLength,offset+headerLength+frameLength),pts:stamp,dts:stamp};track.samples.push(aacSample);track.len+=frameLength;offset+=frameLength+headerLength;frameIndex++;// look for ADTS header (0xFFFx)
for(;offset<length-1;offset++){if(data[offset]===0xff&&(data[offset+1]&0xf6)===0xf0){break;}}}else{break;}}this.remuxer.remux(track,{samples:[]},{samples:[{pts:pts,dts:pts,data:id3.payload}],inputTimeScale:90000},{samples:[]},timeOffset,contiguous,accurateTimeOffset);}},{key:'destroy',value:function destroy(){}}],[{key:'probe',value:function probe(data){// check if data contains ID3 timestamp and ADTS sync word
var id3=new _id2.default(data),offset,length;if(id3.hasTimeStamp){// Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
// Layer bits (position 14 and 15) in header should be always 0 for ADTS
// More info https://wiki.multimedia.cx/index.php?title=ADTS
for(offset=id3.length,length=Math.min(data.length-1,offset+100);offset<length;offset++){if(data[offset]===0xff&&(data[offset+1]&0xf6)===0xf0){//logger.log('ADTS sync word found !');
return true;}}}return false;}}]);return AACDemuxer;}();exports.default=AACDemuxer;},{"22":22,"27":27,"53":53}],22:[function(_dereq_,module,exports){'use strict';var _logger=_dereq_(53);var _errors=_dereq_(33);/**
 *  ADTS parser helper
 */var ADTS={getAudioConfig:function getAudioConfig(observer,data,offset,audioCodec){var adtsObjectType,// :int
adtsSampleingIndex,// :int
adtsExtensionSampleingIndex,// :int
adtsChanelConfig,// :int
config,userAgent=navigator.userAgent.toLowerCase(),manifestCodec=audioCodec,adtsSampleingRates=[96000,88200,64000,48000,44100,32000,24000,22050,16000,12000,11025,8000,7350];// byte 2
adtsObjectType=((data[offset+2]&0xC0)>>>6)+1;adtsSampleingIndex=(data[offset+2]&0x3C)>>>2;if(adtsSampleingIndex>adtsSampleingRates.length-1){observer.trigger(Event.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.FRAG_PARSING_ERROR,fatal:true,reason:'invalid ADTS sampling index:'+adtsSampleingIndex});return;}adtsChanelConfig=(data[offset+2]&0x01)<<2;// byte 3
adtsChanelConfig|=(data[offset+3]&0xC0)>>>6;_logger.logger.log('manifest codec:'+audioCodec+',ADTS data:type:'+adtsObjectType+',sampleingIndex:'+adtsSampleingIndex+'['+adtsSampleingRates[adtsSampleingIndex]+'Hz],channelConfig:'+adtsChanelConfig);// firefox: freq less than 24kHz = AAC SBR (HE-AAC)
if(/firefox/i.test(userAgent)){if(adtsSampleingIndex>=6){adtsObjectType=5;config=new Array(4);// HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
// there is a factor 2 between frame sample rate and output sample rate
// multiply frequency by 2 (see table below, equivalent to substract 3)
adtsExtensionSampleingIndex=adtsSampleingIndex-3;}else{adtsObjectType=2;config=new Array(2);adtsExtensionSampleingIndex=adtsSampleingIndex;}// Android : always use AAC
}else if(userAgent.indexOf('android')!==-1){adtsObjectType=2;config=new Array(2);adtsExtensionSampleingIndex=adtsSampleingIndex;}else{/*  for other browsers (Chrome/Vivaldi/Opera ...)
          always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
      */adtsObjectType=5;config=new Array(4);// if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
if(audioCodec&&(audioCodec.indexOf('mp4a.40.29')!==-1||audioCodec.indexOf('mp4a.40.5')!==-1)||!audioCodec&&adtsSampleingIndex>=6){// HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
// there is a factor 2 between frame sample rate and output sample rate
// multiply frequency by 2 (see table below, equivalent to substract 3)
adtsExtensionSampleingIndex=adtsSampleingIndex-3;}else{// if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
// Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
if(audioCodec&&audioCodec.indexOf('mp4a.40.2')!==-1&&adtsSampleingIndex>=6&&adtsChanelConfig===1||!audioCodec&&adtsChanelConfig===1){adtsObjectType=2;config=new Array(2);}adtsExtensionSampleingIndex=adtsSampleingIndex;}}/* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
        ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()
      Audio Profile / Audio Object Type
      0: Null
      1: AAC Main
      2: AAC LC (Low Complexity)
      3: AAC SSR (Scalable Sample Rate)
      4: AAC LTP (Long Term Prediction)
      5: SBR (Spectral Band Replication)
      6: AAC Scalable
     sampling freq
      0: 96000 Hz
      1: 88200 Hz
      2: 64000 Hz
      3: 48000 Hz
      4: 44100 Hz
      5: 32000 Hz
      6: 24000 Hz
      7: 22050 Hz
      8: 16000 Hz
      9: 12000 Hz
      10: 11025 Hz
      11: 8000 Hz
      12: 7350 Hz
      13: Reserved
      14: Reserved
      15: frequency is written explictly
      Channel Configurations
      These are the channel configurations:
      0: Defined in AOT Specifc Config
      1: 1 channel: front-center
      2: 2 channels: front-left, front-right
    */// audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
config[0]=adtsObjectType<<3;// samplingFrequencyIndex
config[0]|=(adtsSampleingIndex&0x0E)>>1;config[1]|=(adtsSampleingIndex&0x01)<<7;// channelConfiguration
config[1]|=adtsChanelConfig<<3;if(adtsObjectType===5){// adtsExtensionSampleingIndex
config[1]|=(adtsExtensionSampleingIndex&0x0E)>>1;config[2]=(adtsExtensionSampleingIndex&0x01)<<7;// adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
//    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
config[2]|=2<<2;config[3]=0;}return{config:config,samplerate:adtsSampleingRates[adtsSampleingIndex],channelCount:adtsChanelConfig,codec:'mp4a.40.'+adtsObjectType,manifestCodec:manifestCodec};}};module.exports=ADTS;},{"33":33,"53":53}],23:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/*  inline demuxer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _errors=_dereq_(33);var _decrypter=_dereq_(19);var _decrypter2=_interopRequireDefault(_decrypter);var _aacdemuxer=_dereq_(21);var _aacdemuxer2=_interopRequireDefault(_aacdemuxer);var _mp4demuxer=_dereq_(29);var _mp4demuxer2=_interopRequireDefault(_mp4demuxer);var _tsdemuxer=_dereq_(32);var _tsdemuxer2=_interopRequireDefault(_tsdemuxer);var _mp3demuxer=_dereq_(28);var _mp3demuxer2=_interopRequireDefault(_mp3demuxer);var _mp4Remuxer=_dereq_(45);var _mp4Remuxer2=_interopRequireDefault(_mp4Remuxer);var _passthroughRemuxer=_dereq_(46);var _passthroughRemuxer2=_interopRequireDefault(_passthroughRemuxer);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var DemuxerInline=function(){function DemuxerInline(observer,typeSupported,config,vendor){_classCallCheck(this,DemuxerInline);this.observer=observer;this.typeSupported=typeSupported;this.config=config;this.vendor=vendor;}_createClass(DemuxerInline,[{key:'destroy',value:function destroy(){var demuxer=this.demuxer;if(demuxer){demuxer.destroy();}}},{key:'push',value:function push(data,decryptdata,initSegment,audioCodec,videoCodec,timeOffset,discontinuity,trackSwitch,contiguous,duration,accurateTimeOffset,defaultInitPTS){if(data.byteLength>0&&decryptdata!=null&&decryptdata.key!=null&&decryptdata.method==='AES-128'){var decrypter=this.decrypter;if(decrypter==null){decrypter=this.decrypter=new _decrypter2.default(this.observer,this.config);}var localthis=this;// performance.now() not available on WebWorker, at least on Safari Desktop
var startTime;try{startTime=performance.now();}catch(error){startTime=Date.now();}decrypter.decrypt(data,decryptdata.key.buffer,decryptdata.iv.buffer,function(decryptedData){var endTime;try{endTime=performance.now();}catch(error){endTime=Date.now();}localthis.observer.trigger(_events2.default.FRAG_DECRYPTED,{stats:{tstart:startTime,tdecrypt:endTime}});localthis.pushDecrypted(new Uint8Array(decryptedData),decryptdata,new Uint8Array(initSegment),audioCodec,videoCodec,timeOffset,discontinuity,trackSwitch,contiguous,duration,accurateTimeOffset,defaultInitPTS);});}else{this.pushDecrypted(new Uint8Array(data),decryptdata,new Uint8Array(initSegment),audioCodec,videoCodec,timeOffset,discontinuity,trackSwitch,contiguous,duration,accurateTimeOffset,defaultInitPTS);}}},{key:'pushDecrypted',value:function pushDecrypted(data,decryptdata,initSegment,audioCodec,videoCodec,timeOffset,discontinuity,trackSwitch,contiguous,duration,accurateTimeOffset,defaultInitPTS){var demuxer=this.demuxer;if(!demuxer||// in case of continuity change, we might switch from content type (AAC container to TS container for example)
// so let's check that current demuxer is still valid
discontinuity&&!this.probe(data)){var observer=this.observer;var typeSupported=this.typeSupported;var config=this.config;var muxConfig=[{demux:_tsdemuxer2.default,remux:_mp4Remuxer2.default},{demux:_mp3demuxer2.default,remux:_mp4Remuxer2.default},{demux:_aacdemuxer2.default,remux:_mp4Remuxer2.default},{demux:_mp4demuxer2.default,remux:_passthroughRemuxer2.default}];// probe for content type
for(var i in muxConfig){var mux=muxConfig[i];var probe=mux.demux.probe;if(probe(data)){var _remuxer=this.remuxer=new mux.remux(observer,config,typeSupported,this.vendor);demuxer=new mux.demux(observer,_remuxer,config,typeSupported);this.probe=probe;break;}}if(!demuxer){observer.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.FRAG_PARSING_ERROR,fatal:true,reason:'no demux matching with content found'});return;}this.demuxer=demuxer;}var remuxer=this.remuxer;if(discontinuity||trackSwitch){demuxer.resetInitSegment(initSegment,audioCodec,videoCodec,duration);remuxer.resetInitSegment();}if(discontinuity){demuxer.resetTimeStamp();remuxer.resetTimeStamp(defaultInitPTS);}if(typeof demuxer.setDecryptData==='function'){demuxer.setDecryptData(decryptdata);}demuxer.append(data,timeOffset,contiguous,accurateTimeOffset);}}]);return DemuxerInline;}();exports.default=DemuxerInline;},{"19":19,"21":21,"28":28,"29":29,"32":32,"33":33,"35":35,"45":45,"46":46}],24:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _demuxerInline=_dereq_(23);var _demuxerInline2=_interopRequireDefault(_demuxerInline);var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _logger=_dereq_(53);var _events3=_dereq_(1);var _events4=_interopRequireDefault(_events3);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */var DemuxerWorker=function DemuxerWorker(self){// observer setup
var observer=new _events4.default();observer.trigger=function trigger(event){for(var _len=arguments.length,data=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){data[_key-1]=arguments[_key];}observer.emit.apply(observer,[event,event].concat(data));};observer.off=function off(event){for(var _len2=arguments.length,data=Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){data[_key2-1]=arguments[_key2];}observer.removeListener.apply(observer,[event].concat(data));};var forwardMessage=function forwardMessage(ev,data){self.postMessage({event:ev,data:data});};self.addEventListener('message',function(ev){var data=ev.data;//console.log('demuxer cmd:' + data.cmd);
switch(data.cmd){case'init':var config=JSON.parse(data.config);self.demuxer=new _demuxerInline2.default(observer,data.typeSupported,config,data.vendor);try{(0,_logger.enableLogs)(config.debug===true);}catch(err){console.warn('demuxerWorker: unable to enable logs');}// signal end of worker init
forwardMessage('init',null);break;case'demux':self.demuxer.push(data.data,data.decryptdata,data.initSegment,data.audioCodec,data.videoCodec,data.timeOffset,data.discontinuity,data.trackSwitch,data.contiguous,data.duration,data.accurateTimeOffset,data.defaultInitPTS);break;default:break;}});// forward events to main thread
observer.on(_events2.default.FRAG_DECRYPTED,forwardMessage);observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT,forwardMessage);observer.on(_events2.default.FRAG_PARSED,forwardMessage);observer.on(_events2.default.ERROR,forwardMessage);observer.on(_events2.default.FRAG_PARSING_METADATA,forwardMessage);observer.on(_events2.default.FRAG_PARSING_USERDATA,forwardMessage);observer.on(_events2.default.INIT_PTS_FOUND,forwardMessage);// special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
observer.on(_events2.default.FRAG_PARSING_DATA,function(ev,data){var transferable=[];var message={event:ev,data:data};if(data.data1){message.data1=data.data1.buffer;transferable.push(data.data1.buffer);delete data.data1;}if(data.data2){message.data2=data.data2.buffer;transferable.push(data.data2.buffer);delete data.data2;}self.postMessage(message,transferable);});};exports.default=DemuxerWorker;},{"1":1,"23":23,"35":35,"53":53}],25:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _demuxerInline=_dereq_(23);var _demuxerInline2=_interopRequireDefault(_demuxerInline);var _demuxerWorker=_dereq_(24);var _demuxerWorker2=_interopRequireDefault(_demuxerWorker);var _logger=_dereq_(53);var _errors=_dereq_(33);var _events3=_dereq_(1);var _events4=_interopRequireDefault(_events3);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Demuxer=function(){function Demuxer(hls,id){_classCallCheck(this,Demuxer);this.hls=hls;this.id=id;// observer setup
var observer=this.observer=new _events4.default();var config=hls.config;observer.trigger=function trigger(event){for(var _len=arguments.length,data=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){data[_key-1]=arguments[_key];}observer.emit.apply(observer,[event,event].concat(data));};observer.off=function off(event){for(var _len2=arguments.length,data=Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){data[_key2-1]=arguments[_key2];}observer.removeListener.apply(observer,[event].concat(data));};var forwardMessage=function(ev,data){data=data||{};data.frag=this.frag;data.id=this.id;hls.trigger(ev,data);}.bind(this);// forward events to main thread
observer.on(_events2.default.FRAG_DECRYPTED,forwardMessage);observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT,forwardMessage);observer.on(_events2.default.FRAG_PARSING_DATA,forwardMessage);observer.on(_events2.default.FRAG_PARSED,forwardMessage);observer.on(_events2.default.ERROR,forwardMessage);observer.on(_events2.default.FRAG_PARSING_METADATA,forwardMessage);observer.on(_events2.default.FRAG_PARSING_USERDATA,forwardMessage);observer.on(_events2.default.INIT_PTS_FOUND,forwardMessage);var typeSupported={mp4:MediaSource.isTypeSupported('video/mp4'),mpeg:MediaSource.isTypeSupported('audio/mpeg'),mp3:MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')};// navigator.vendor is not always available in Web Worker
// refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
var vendor=navigator.vendor;if(config.enableWorker&&typeof Worker!=='undefined'){_logger.logger.log('demuxing in webworker');var w=void 0;try{var work=_dereq_(3);w=this.w=work(_demuxerWorker2.default);this.onwmsg=this.onWorkerMessage.bind(this);w.addEventListener('message',this.onwmsg);w.onerror=function(event){hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.OTHER_ERROR,details:_errors.ErrorDetails.INTERNAL_EXCEPTION,fatal:true,event:'demuxerWorker',err:{message:event.message+' ('+event.filename+':'+event.lineno+')'}});};w.postMessage({cmd:'init',typeSupported:typeSupported,vendor:vendor,id:id,config:JSON.stringify(config)});}catch(err){_logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');if(w){// revoke the Object URL that was used to create demuxer worker, so as not to leak it
URL.revokeObjectURL(w.objectURL);}this.demuxer=new _demuxerInline2.default(observer,typeSupported,config,vendor);this.w=undefined;}}else{this.demuxer=new _demuxerInline2.default(observer,typeSupported,config,vendor);}}_createClass(Demuxer,[{key:'destroy',value:function destroy(){var w=this.w;if(w){w.removeEventListener('message',this.onwmsg);w.terminate();this.w=null;}else{var demuxer=this.demuxer;if(demuxer){demuxer.destroy();this.demuxer=null;}}var observer=this.observer;if(observer){observer.removeAllListeners();this.observer=null;}}},{key:'push',value:function push(data,initSegment,audioCodec,videoCodec,frag,duration,accurateTimeOffset,defaultInitPTS){var w=this.w;var timeOffset=!isNaN(frag.startDTS)?frag.startDTS:frag.start;var decryptdata=frag.decryptdata;var lastFrag=this.frag;var discontinuity=!(lastFrag&&frag.cc===lastFrag.cc);var trackSwitch=!(lastFrag&&frag.level===lastFrag.level);var nextSN=lastFrag&&frag.sn===lastFrag.sn+1;var contiguous=!trackSwitch&&nextSN;if(discontinuity){_logger.logger.log(this.id+':discontinuity detected');}if(trackSwitch){_logger.logger.log(this.id+':switch detected');}this.frag=frag;if(w){// post fragment payload as transferable objects (no copy)
w.postMessage({cmd:'demux',data:data,decryptdata:decryptdata,initSegment:initSegment,audioCodec:audioCodec,videoCodec:videoCodec,timeOffset:timeOffset,discontinuity:discontinuity,trackSwitch:trackSwitch,contiguous:contiguous,duration:duration,accurateTimeOffset:accurateTimeOffset,defaultInitPTS:defaultInitPTS},[data]);}else{var demuxer=this.demuxer;if(demuxer){demuxer.push(data,decryptdata,initSegment,audioCodec,videoCodec,timeOffset,discontinuity,trackSwitch,contiguous,duration,accurateTimeOffset,defaultInitPTS);}}}},{key:'onWorkerMessage',value:function onWorkerMessage(ev){var data=ev.data,hls=this.hls;//console.log('onWorkerMessage:' + data.event);
switch(data.event){case'init':// revoke the Object URL that was used to create demuxer worker, so as not to leak it
URL.revokeObjectURL(this.w.objectURL);break;// special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
case _events2.default.FRAG_PARSING_DATA:data.data.data1=new Uint8Array(data.data1);if(data.data2){data.data.data2=new Uint8Array(data.data2);}/* falls through */default:data.data=data.data||{};data.data.frag=this.frag;data.data.id=this.id;hls.trigger(data.event,data.data);break;}}}]);return Demuxer;}();exports.default=Demuxer;},{"1":1,"23":23,"24":24,"3":3,"33":33,"35":35,"53":53}],26:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */var _logger=_dereq_(53);function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var ExpGolomb=function(){function ExpGolomb(data){_classCallCheck(this,ExpGolomb);this.data=data;// the number of bytes left to examine in this.data
this.bytesAvailable=data.byteLength;// the current word being examined
this.word=0;// :uint
// the number of bits left to examine in the current word
this.bitsAvailable=0;// :uint
}// ():void
_createClass(ExpGolomb,[{key:'loadWord',value:function loadWord(){var data=this.data,bytesAvailable=this.bytesAvailable,position=data.byteLength-bytesAvailable,workingBytes=new Uint8Array(4),availableBytes=Math.min(4,bytesAvailable);if(availableBytes===0){throw new Error('no bytes available');}workingBytes.set(data.subarray(position,position+availableBytes));this.word=new DataView(workingBytes.buffer).getUint32(0);// track the amount of this.data that has been processed
this.bitsAvailable=availableBytes*8;this.bytesAvailable-=availableBytes;}// (count:int):void
},{key:'skipBits',value:function skipBits(count){var skipBytes;// :int
if(this.bitsAvailable>count){this.word<<=count;this.bitsAvailable-=count;}else{count-=this.bitsAvailable;skipBytes=count>>3;count-=skipBytes>>3;this.bytesAvailable-=skipBytes;this.loadWord();this.word<<=count;this.bitsAvailable-=count;}}// (size:int):uint
},{key:'readBits',value:function readBits(size){var bits=Math.min(this.bitsAvailable,size),// :uint
valu=this.word>>>32-bits;// :uint
if(size>32){_logger.logger.error('Cannot read more than 32 bits at a time');}this.bitsAvailable-=bits;if(this.bitsAvailable>0){this.word<<=bits;}else if(this.bytesAvailable>0){this.loadWord();}bits=size-bits;if(bits>0&&this.bitsAvailable){return valu<<bits|this.readBits(bits);}else{return valu;}}// ():uint
},{key:'skipLZ',value:function skipLZ(){var leadingZeroCount;// :uint
for(leadingZeroCount=0;leadingZeroCount<this.bitsAvailable;++leadingZeroCount){if(0!==(this.word&0x80000000>>>leadingZeroCount)){// the first bit of working word is 1
this.word<<=leadingZeroCount;this.bitsAvailable-=leadingZeroCount;return leadingZeroCount;}}// we exhausted word and still have not found a 1
this.loadWord();return leadingZeroCount+this.skipLZ();}// ():void
},{key:'skipUEG',value:function skipUEG(){this.skipBits(1+this.skipLZ());}// ():void
},{key:'skipEG',value:function skipEG(){this.skipBits(1+this.skipLZ());}// ():uint
},{key:'readUEG',value:function readUEG(){var clz=this.skipLZ();// :uint
return this.readBits(clz+1)-1;}// ():int
},{key:'readEG',value:function readEG(){var valu=this.readUEG();// :int
if(0x01&valu){// the number is odd if the low order bit is set
return 1+valu>>>1;// add 1 to make it even, and divide by 2
}else{return-1*(valu>>>1);// divide by two then make it negative
}}// Some convenience functions
// :Boolean
},{key:'readBoolean',value:function readBoolean(){return 1===this.readBits(1);}// ():int
},{key:'readUByte',value:function readUByte(){return this.readBits(8);}// ():int
},{key:'readUShort',value:function readUShort(){return this.readBits(16);}// ():int
},{key:'readUInt',value:function readUInt(){return this.readBits(32);}/**
     * Advance the ExpGolomb decoder past a scaling list. The scaling
     * list is optionally transmitted as part of a sequence parameter
     * set and is not relevant to transmuxing.
     * @param count {number} the number of entries in this scaling list
     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
     */},{key:'skipScalingList',value:function skipScalingList(count){var lastScale=8,nextScale=8,j,deltaScale;for(j=0;j<count;j++){if(nextScale!==0){deltaScale=this.readEG();nextScale=(lastScale+deltaScale+256)%256;}lastScale=nextScale===0?lastScale:nextScale;}}/**
     * Read a sequence parameter set and return some interesting video
     * properties. A sequence parameter set is the H264 metadata that
     * describes the properties of upcoming video frames.
     * @param data {Uint8Array} the bytes of a sequence parameter set
     * @return {object} an object with configuration parsed from the
     * sequence parameter set, including the dimensions of the
     * associated video frames.
     */},{key:'readSPS',value:function readSPS(){var frameCropLeftOffset=0,frameCropRightOffset=0,frameCropTopOffset=0,frameCropBottomOffset=0,profileIdc,profileCompat,levelIdc,numRefFramesInPicOrderCntCycle,picWidthInMbsMinus1,picHeightInMapUnitsMinus1,frameMbsOnlyFlag,scalingListCount,i,readUByte=this.readUByte.bind(this),readBits=this.readBits.bind(this),readUEG=this.readUEG.bind(this),readBoolean=this.readBoolean.bind(this),skipBits=this.skipBits.bind(this),skipEG=this.skipEG.bind(this),skipUEG=this.skipUEG.bind(this),skipScalingList=this.skipScalingList.bind(this);readUByte();profileIdc=readUByte();// profile_idc
profileCompat=readBits(5);// constraint_set[0-4]_flag, u(5)
skipBits(3);// reserved_zero_3bits u(3),
levelIdc=readUByte();//level_idc u(8)
skipUEG();// seq_parameter_set_id
// some profiles have more optional data we don't need
if(profileIdc===100||profileIdc===110||profileIdc===122||profileIdc===244||profileIdc===44||profileIdc===83||profileIdc===86||profileIdc===118||profileIdc===128){var chromaFormatIdc=readUEG();if(chromaFormatIdc===3){skipBits(1);// separate_colour_plane_flag
}skipUEG();// bit_depth_luma_minus8
skipUEG();// bit_depth_chroma_minus8
skipBits(1);// qpprime_y_zero_transform_bypass_flag
if(readBoolean()){// seq_scaling_matrix_present_flag
scalingListCount=chromaFormatIdc!==3?8:12;for(i=0;i<scalingListCount;i++){if(readBoolean()){// seq_scaling_list_present_flag[ i ]
if(i<6){skipScalingList(16);}else{skipScalingList(64);}}}}}skipUEG();// log2_max_frame_num_minus4
var picOrderCntType=readUEG();if(picOrderCntType===0){readUEG();//log2_max_pic_order_cnt_lsb_minus4
}else if(picOrderCntType===1){skipBits(1);// delta_pic_order_always_zero_flag
skipEG();// offset_for_non_ref_pic
skipEG();// offset_for_top_to_bottom_field
numRefFramesInPicOrderCntCycle=readUEG();for(i=0;i<numRefFramesInPicOrderCntCycle;i++){skipEG();// offset_for_ref_frame[ i ]
}}skipUEG();// max_num_ref_frames
skipBits(1);// gaps_in_frame_num_value_allowed_flag
picWidthInMbsMinus1=readUEG();picHeightInMapUnitsMinus1=readUEG();frameMbsOnlyFlag=readBits(1);if(frameMbsOnlyFlag===0){skipBits(1);// mb_adaptive_frame_field_flag
}skipBits(1);// direct_8x8_inference_flag
if(readBoolean()){// frame_cropping_flag
frameCropLeftOffset=readUEG();frameCropRightOffset=readUEG();frameCropTopOffset=readUEG();frameCropBottomOffset=readUEG();}var pixelRatio=[1,1];if(readBoolean()){// vui_parameters_present_flag
if(readBoolean()){// aspect_ratio_info_present_flag
var aspectRatioIdc=readUByte();switch(aspectRatioIdc){case 1:pixelRatio=[1,1];break;case 2:pixelRatio=[12,11];break;case 3:pixelRatio=[10,11];break;case 4:pixelRatio=[16,11];break;case 5:pixelRatio=[40,33];break;case 6:pixelRatio=[24,11];break;case 7:pixelRatio=[20,11];break;case 8:pixelRatio=[32,11];break;case 9:pixelRatio=[80,33];break;case 10:pixelRatio=[18,11];break;case 11:pixelRatio=[15,11];break;case 12:pixelRatio=[64,33];break;case 13:pixelRatio=[160,99];break;case 14:pixelRatio=[4,3];break;case 15:pixelRatio=[3,2];break;case 16:pixelRatio=[2,1];break;case 255:{pixelRatio=[readUByte()<<8|readUByte(),readUByte()<<8|readUByte()];break;}}}}return{width:Math.ceil((picWidthInMbsMinus1+1)*16-frameCropLeftOffset*2-frameCropRightOffset*2),height:(2-frameMbsOnlyFlag)*(picHeightInMapUnitsMinus1+1)*16-(frameMbsOnlyFlag?2:4)*(frameCropTopOffset+frameCropBottomOffset),pixelRatio:pixelRatio};}},{key:'readSliceType',value:function readSliceType(){// skip NALu type
this.readUByte();// discard first_mb_in_slice
this.readUEG();// return slice_type
return this.readUEG();}}]);return ExpGolomb;}();exports.default=ExpGolomb;},{"53":53}],27:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * ID3 parser
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */var _logger=_dereq_(53);function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}//import Hex from '../utils/hex';
var ID3=function(){function ID3(data){_classCallCheck(this,ID3);this._hasTimeStamp=false;this._length=0;var offset=0,byte1,byte2,byte3,byte4,tagSize,endPos,header,len;do{header=this.readUTF(data,offset,3);offset+=3;// first check for ID3 header
if(header==='ID3'){// skip 24 bits
offset+=3;// retrieve tag(s) length
byte1=data[offset++]&0x7f;byte2=data[offset++]&0x7f;byte3=data[offset++]&0x7f;byte4=data[offset++]&0x7f;tagSize=(byte1<<21)+(byte2<<14)+(byte3<<7)+byte4;endPos=offset+tagSize;//logger.log(`ID3 tag found, size/end: ${tagSize}/${endPos}`);
// read ID3 tags
this._parseID3Frames(data,offset,endPos);offset=endPos;}else if(header==='3DI'){// http://id3.org/id3v2.4.0-structure chapter 3.4.   ID3v2 footer
offset+=7;_logger.logger.log('3DI footer found, end: '+offset);}else{offset-=3;len=offset;if(len){//logger.log(`ID3 len: ${len}`);
if(!this.hasTimeStamp){_logger.logger.warn('ID3 tag found, but no timestamp');}this._length=len;this._payload=data.subarray(0,len);}return;}}while(true);}_createClass(ID3,[{key:'readUTF',value:function readUTF(data,start,len){var result='',offset=start,end=start+len;do{result+=String.fromCharCode(data[offset++]);}while(offset<end);return result;}},{key:'_parseID3Frames',value:function _parseID3Frames(data,offset,endPos){var tagId,tagLen,tagStart,tagFlags,timestamp;while(offset+8<=endPos){tagId=this.readUTF(data,offset,4);offset+=4;tagLen=data[offset++]<<24+data[offset++]<<16+data[offset++]<<8+data[offset++];tagFlags=data[offset++]<<8+data[offset++];tagStart=offset;//logger.log("ID3 tag id:" + tagId);
switch(tagId){case'PRIV'://logger.log('parse frame:' + Hex.hexDump(data.subarray(offset,endPos)));
// owner should be "com.apple.streaming.transportStreamTimestamp"
if(this.readUTF(data,offset,44)==='com.apple.streaming.transportStreamTimestamp'){offset+=44;// smelling even better ! we found the right descriptor
// skip null character (string end) + 3 first bytes
offset+=4;// timestamp is 33 bit expressed as a big-endian eight-octet number, with the upper 31 bits set to zero.
var pts33Bit=data[offset++]&0x1;this._hasTimeStamp=true;timestamp=((data[offset++]<<23)+(data[offset++]<<15)+(data[offset++]<<7)+data[offset++])/45;if(pts33Bit){timestamp+=47721858.84;// 2^32 / 90
}timestamp=Math.round(timestamp);_logger.logger.trace('ID3 timestamp found: '+timestamp);this._timeStamp=timestamp;}break;default:break;}}}},{key:'hasTimeStamp',get:function get(){return this._hasTimeStamp;}},{key:'timeStamp',get:function get(){return this._timeStamp;}},{key:'length',get:function get(){return this._length;}},{key:'payload',get:function get(){return this._payload;}}]);return ID3;}();exports.default=ID3;},{"53":53}],28:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP3 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */var _id=_dereq_(27);var _id2=_interopRequireDefault(_id);var _mpegaudio=_dereq_(30);var _mpegaudio2=_interopRequireDefault(_mpegaudio);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var MP3Demuxer=function(){function MP3Demuxer(observer,remuxer,config){_classCallCheck(this,MP3Demuxer);this.observer=observer;this.config=config;this.remuxer=remuxer;}_createClass(MP3Demuxer,[{key:'resetInitSegment',value:function resetInitSegment(initSegment,audioCodec,videoCodec,duration){this._audioTrack={container:'audio/mpeg',type:'audio',id:-1,sequenceNumber:0,isAAC:false,samples:[],len:0,manifestCodec:audioCodec,duration:duration,inputTimeScale:90000};}},{key:'resetTimeStamp',value:function resetTimeStamp(){}},{key:'append',// feed incoming data to the front of the parsing pipeline
value:function append(data,timeOffset,contiguous,accurateTimeOffset){var id3=new _id2.default(data);var pts=90*id3.timeStamp;var afterID3=id3.length;var offset,length;// Look for MPEG header
for(offset=afterID3,length=data.length;offset<length-1;offset++){if(data[offset]===0xff&&(data[offset+1]&0xe0)===0xe0&&(data[offset+1]&0x06)!==0x00){break;}}_mpegaudio2.default.parse(this._audioTrack,data,id3.length,pts);this.remuxer.remux(this._audioTrack,{samples:[]},{samples:[{pts:pts,dts:pts,data:id3.payload}],inputTimeScale:90000},{samples:[]},timeOffset,contiguous,accurateTimeOffset);}},{key:'destroy',value:function destroy(){}}],[{key:'probe',value:function probe(data){// check if data contains ID3 timestamp and MPEG sync word
var id3=new _id2.default(data),offset,length;if(id3.hasTimeStamp){// Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
// Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
// More info http://www.mp3-tech.org/programmer/frame_header.html
for(offset=id3.length,length=Math.min(data.length-1,offset+100);offset<length;offset++){if(data[offset]===0xff&&(data[offset+1]&0xe0)===0xe0&&(data[offset+1]&0x06)!==0x00){//logger.log('MPEG sync word found !');
return true;}}}return false;}}]);return MP3Demuxer;}();exports.default=MP3Demuxer;},{"27":27,"30":30}],29:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * MP4 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *///import {logger} from '../utils/logger';
var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var MP4Demuxer=function(){function MP4Demuxer(observer,remuxer){_classCallCheck(this,MP4Demuxer);this.observer=observer;this.remuxer=remuxer;}_createClass(MP4Demuxer,[{key:'resetTimeStamp',value:function resetTimeStamp(){}},{key:'resetInitSegment',value:function resetInitSegment(initSegment,audioCodec,videoCodec,duration){//jshint unused:false
var initData=this.initData=MP4Demuxer.parseInitSegment(initSegment);var tracks={};if(initData.audio){tracks.audio={container:'audio/mp4',codec:audioCodec,initSegment:initSegment};}if(initData.video){tracks.video={container:'video/mp4',codec:videoCodec,initSegment:initSegment};}this.observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT,{tracks:tracks});}},{key:'append',// feed incoming data to the front of the parsing pipeline
value:function append(data,timeOffset,contiguous,accurateTimeOffset){var initData=this.initData;var startDTS=MP4Demuxer.startDTS(initData,data);this.remuxer.remux(initData.audio,initData.video,null,null,startDTS,contiguous,accurateTimeOffset,data);}},{key:'destroy',value:function destroy(){}}],[{key:'probe',value:function probe(data){if(data.length>=8){var dataType=MP4Demuxer.bin2str(data.subarray(4,8));return['moof','ftyp','styp'].indexOf(dataType)>=0;}return false;}},{key:'bin2str',value:function bin2str(buffer){return String.fromCharCode.apply(null,buffer);}},{key:'readUint32',value:function readUint32(buffer,offset){var val=buffer[offset]<<24|buffer[offset+1]<<16|buffer[offset+2]<<8|buffer[offset+3];return val<0?4294967296+val:val;}// Find the data for a box specified by its path
},{key:'findBox',value:function findBox(data,path){var results=[],i,size,type,end,subresults;if(!path.length){// short-circuit the search for empty paths
return null;}for(i=0;i<data.byteLength;){size=MP4Demuxer.readUint32(data,i);type=MP4Demuxer.bin2str(data.subarray(i+4,i+8));end=size>1?i+size:data.byteLength;if(type===path[0]){if(path.length===1){// this is the end of the path and we've found the box we were
// looking for
results.push(data.subarray(i+8,end));}else{// recursively search for the next box along the path
subresults=MP4Demuxer.findBox(data.subarray(i+8,end),path.slice(1));if(subresults.length){results=results.concat(subresults);}}}i=end;}// we've finished searching all of data
return results;}/**
     * Parses an MP4 initialization segment and extracts stream type and
     * timescale values for any declared tracks. Timescale values indicate the
     * number of clock ticks per second to assume for time-based values
     * elsewhere in the MP4.
     *
     * To determine the start time of an MP4, you need two pieces of
     * information: the timescale unit and the earliest base media decode
     * time. Multiple timescales can be specified within an MP4 but the
     * base media decode time is always expressed in the timescale from
     * the media header box for the track:
     * ```
     * moov > trak > mdia > mdhd.timescale
     * moov > trak > mdia > hdlr
     * ```
     * @param init {Uint8Array} the bytes of the init segment
     * @return {object} a hash of track type to timescale values or null if
     * the init segment is malformed.
     */},{key:'parseInitSegment',value:function parseInitSegment(initSegment){var result=[];var traks=MP4Demuxer.findBox(initSegment,['moov','trak']);traks.forEach(function(trak){var tkhd=MP4Demuxer.findBox(trak,['tkhd'])[0];if(tkhd){var version=tkhd[0];var index=version===0?12:20;var trackId=MP4Demuxer.readUint32(tkhd,index);var mdhd=MP4Demuxer.findBox(trak,['mdia','mdhd'])[0];if(mdhd){version=mdhd[0];index=version===0?12:20;var timescale=MP4Demuxer.readUint32(mdhd,index);var hdlr=MP4Demuxer.findBox(trak,['mdia','hdlr'])[0];if(hdlr){var hdlrType=MP4Demuxer.bin2str(hdlr.subarray(8,12));var type={'soun':'audio','vide':'video'}[hdlrType];if(type){result[trackId]={timescale:timescale,type:type};result[type]={timescale:timescale,id:trackId};}}}}});return result;}/**
     * Determine the base media decode start time, in seconds, for an MP4
     * fragment. If multiple fragments are specified, the earliest time is
     * returned.
     *
     * The base media decode time can be parsed from track fragment
     * metadata:
     * ```
     * moof > traf > tfdt.baseMediaDecodeTime
     * ```
     * It requires the timescale value from the mdhd to interpret.
     *
     * @param timescale {object} a hash of track ids to timescale values.
     * @return {number} the earliest base media decode start time for the
     * fragment, in seconds
     */},{key:'startDTS',value:function startDTS(initData,fragment){var trafs,baseTimes,result;// we need info from two childrend of each track fragment box
trafs=MP4Demuxer.findBox(fragment,['moof','traf']);// determine the start times for each track
baseTimes=[].concat.apply([],trafs.map(function(traf){return MP4Demuxer.findBox(traf,['tfhd']).map(function(tfhd){var id,scale,baseTime;// get the track id from the tfhd
id=MP4Demuxer.readUint32(tfhd,4);// assume a 90kHz clock if no timescale was specified
scale=initData[id].timescale||90e3;// get the base media decode time from the tfdt
baseTime=MP4Demuxer.findBox(traf,['tfdt']).map(function(tfdt){var version,result;version=tfdt[0];result=MP4Demuxer.readUint32(tfdt,4);if(version===1){result*=Math.pow(2,32);result+=MP4Demuxer.readUint32(tfdt,8);}return result;})[0];baseTime=baseTime||Infinity;// convert base time to seconds
return baseTime/scale;});}));// return the minimum
result=Math.min.apply(null,baseTimes);return isFinite(result)?result:0;}}]);return MP4Demuxer;}();exports.default=MP4Demuxer;},{"35":35}],30:[function(_dereq_,module,exports){'use strict';var _logger=_dereq_(53);var MpegAudio={onFrame:function onFrame(track,data,bitRate,sampleRate,channelCount,frameIndex,pts){var frameDuration=1152*90000/sampleRate;var stamp=pts+frameIndex*frameDuration;track.config=[];track.channelCount=channelCount;track.samplerate=sampleRate;track.samples.push({unit:data,pts:stamp,dts:stamp});track.len+=data.length;},onNoise:function onNoise(data){_logger.logger.warn('mpeg audio has noise: '+data.length+' bytes');},parseFrames:function parseFrames(track,data,start,end,frameIndex,pts){var BitratesMap=[32,64,96,128,160,192,224,256,288,320,352,384,416,448,32,48,56,64,80,96,112,128,160,192,224,256,320,384,32,40,48,56,64,80,96,112,128,160,192,224,256,320,32,48,56,64,80,96,112,128,144,160,176,192,224,256,8,16,24,32,40,48,56,64,80,96,112,128,144,160];var SamplingRateMap=[44100,48000,32000,22050,24000,16000,11025,12000,8000];if(start+2>end){return-1;// we need at least 2 bytes to detect sync pattern
}if(data[start]===0xFF||(data[start+1]&0xE0)===0xE0){// Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
if(start+24>end){return-1;}var headerB=data[start+1]>>3&3;var headerC=data[start+1]>>1&3;var headerE=data[start+2]>>4&15;var headerF=data[start+2]>>2&3;var headerG=!!(data[start+2]&2);if(headerB!==1&&headerE!==0&&headerE!==15&&headerF!==3){var columnInBitrates=headerB===3?3-headerC:headerC===3?3:4;var bitRate=BitratesMap[columnInBitrates*14+headerE-1]*1000;var columnInSampleRates=headerB===3?0:headerB===2?1:2;var sampleRate=SamplingRateMap[columnInSampleRates*3+headerF];var padding=headerG?1:0;var channelCount=data[start+3]>>6===3?1:2;// If bits of channel mode are `11` then it is a single channel (Mono)
var frameLength=headerC===3?(headerB===3?12:6)*bitRate/sampleRate+padding<<2:(headerB===3?144:72)*bitRate/sampleRate+padding|0;if(start+frameLength>end){return-1;}this.onFrame(track,data.subarray(start,start+frameLength),bitRate,sampleRate,channelCount,frameIndex,pts);return frameLength;}}// noise or ID3, trying to skip
var offset=start+2;while(offset<end){if(data[offset-1]===0xFF&&(data[offset]&0xE0)===0xE0){// sync pattern is found
this.onNoise(data.subarray(start,offset-1));return offset-start-1;}offset++;}return-1;},parse:function parse(track,data,offset,pts){var length=data.length;var frameIndex=0;var parsed;while(offset<length&&(parsed=this.parseFrames(track,data,offset,length,frameIndex++,pts))>0){offset+=parsed;}}};/**
    *  MPEG parser helper
    */module.exports=MpegAudio;},{"53":53}],31:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * SAMPLE-AES decrypter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */var _decrypter=_dereq_(19);var _decrypter2=_interopRequireDefault(_decrypter);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var SampleAesDecrypter=function(){function SampleAesDecrypter(observer,config,decryptdata,discardEPB){_classCallCheck(this,SampleAesDecrypter);this.decryptdata=decryptdata;this.discardEPB=discardEPB;this.decrypter=new _decrypter2.default(observer,config);}_createClass(SampleAesDecrypter,[{key:'decryptBuffer',value:function decryptBuffer(encryptedData,callback){this.decrypter.decrypt(encryptedData,this.decryptdata.key.buffer,this.decryptdata.iv.buffer,callback);}// AAC - encrypt all full 16 bytes blocks starting from offset 16
},{key:'decryptAacSample',value:function decryptAacSample(samples,sampleIndex,callback,sync){var curUnit=samples[sampleIndex].unit;var encryptedData=curUnit.subarray(16,curUnit.length-curUnit.length%16);var encryptedBuffer=encryptedData.buffer.slice(encryptedData.byteOffset,encryptedData.byteOffset+encryptedData.length);var localthis=this;this.decryptBuffer(encryptedBuffer,function(decryptedData){decryptedData=new Uint8Array(decryptedData);curUnit.set(decryptedData,16);if(!sync){localthis.decryptAacSamples(samples,sampleIndex+1,callback);}});}},{key:'decryptAacSamples',value:function decryptAacSamples(samples,sampleIndex,callback){for(;;sampleIndex++){if(sampleIndex>=samples.length){callback();return;}if(samples[sampleIndex].unit.length<32){continue;}var sync=this.decrypter.isSync();this.decryptAacSample(samples,sampleIndex,callback,sync);if(!sync){return;}}}// AVC - encrypt one 16 bytes block out of ten, starting from offset 32
},{key:'getAvcEncryptedData',value:function getAvcEncryptedData(decodedData){var encryptedDataLen=Math.floor((decodedData.length-48)/160)*16+16;var encryptedData=new Int8Array(encryptedDataLen);var outputPos=0;for(var inputPos=32;inputPos<=decodedData.length-16;inputPos+=160,outputPos+=16){encryptedData.set(decodedData.subarray(inputPos,inputPos+16),outputPos);}return encryptedData;}},{key:'getAvcDecryptedUnit',value:function getAvcDecryptedUnit(decodedData,decryptedData){decryptedData=new Uint8Array(decryptedData);var inputPos=0;for(var outputPos=32;outputPos<=decodedData.length-16;outputPos+=160,inputPos+=16){decodedData.set(decryptedData.subarray(inputPos,inputPos+16),outputPos);}return decodedData;}},{key:'decryptAvcSample',value:function decryptAvcSample(samples,sampleIndex,unitIndex,callback,curUnit,sync){var decodedData=this.discardEPB(curUnit.data);var encryptedData=this.getAvcEncryptedData(decodedData);var localthis=this;this.decryptBuffer(encryptedData.buffer,function(decryptedData){curUnit.data=localthis.getAvcDecryptedUnit(decodedData,decryptedData);if(!sync){localthis.decryptAvcSamples(samples,sampleIndex,unitIndex+1,callback);}});}},{key:'decryptAvcSamples',value:function decryptAvcSamples(samples,sampleIndex,unitIndex,callback){for(;;sampleIndex++,unitIndex=0){if(sampleIndex>=samples.length){callback();return;}var curUnits=samples[sampleIndex].units;for(;;unitIndex++){if(unitIndex>=curUnits.length){break;}var curUnit=curUnits[unitIndex];if(curUnit.length<=48||curUnit.type!==1&&curUnit.type!==5){continue;}var sync=this.decrypter.isSync();this.decryptAvcSample(samples,sampleIndex,unitIndex,callback,curUnit,sync);if(!sync){return;}}}}}]);return SampleAesDecrypter;}();exports.default=SampleAesDecrypter;},{"19":19}],32:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */// import Hex from '../utils/hex';
var _adts=_dereq_(22);var _adts2=_interopRequireDefault(_adts);var _mpegaudio=_dereq_(30);var _mpegaudio2=_interopRequireDefault(_mpegaudio);var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _expGolomb=_dereq_(26);var _expGolomb2=_interopRequireDefault(_expGolomb);var _sampleAes=_dereq_(31);var _sampleAes2=_interopRequireDefault(_sampleAes);var _logger=_dereq_(53);var _errors=_dereq_(33);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var TSDemuxer=function(){function TSDemuxer(observer,remuxer,config,typeSupported){_classCallCheck(this,TSDemuxer);this.observer=observer;this.config=config;this.typeSupported=typeSupported;this.remuxer=remuxer;this.sampleAes=null;}_createClass(TSDemuxer,[{key:'setDecryptData',value:function setDecryptData(decryptdata){if(decryptdata!=null&&decryptdata.key!=null&&decryptdata.method==='SAMPLE-AES'){this.sampleAes=new _sampleAes2.default(this.observer,this.config,decryptdata,this.discardEPB);}else{this.sampleAes=null;}}},{key:'resetInitSegment',value:function resetInitSegment(initSegment,audioCodec,videoCodec,duration){this.pmtParsed=false;this._pmtId=-1;this._avcTrack={container:'video/mp2t',type:'video',id:-1,inputTimeScale:90000,sequenceNumber:0,samples:[],len:0,dropped:0};this._audioTrack={container:'video/mp2t',type:'audio',id:-1,inputTimeScale:90000,duration:duration,sequenceNumber:0,samples:[],len:0,isAAC:true};this._id3Track={type:'id3',id:-1,inputTimeScale:90000,sequenceNumber:0,samples:[],len:0};this._txtTrack={type:'text',id:-1,inputTimeScale:90000,sequenceNumber:0,samples:[],len:0};// flush any partial content
this.aacOverFlow=null;this.aacLastPTS=null;this.avcSample=null;this.audioCodec=audioCodec;this.videoCodec=videoCodec;this._duration=duration;}},{key:'resetTimeStamp',value:function resetTimeStamp(){}// feed incoming data to the front of the parsing pipeline
},{key:'append',value:function append(data,timeOffset,contiguous,accurateTimeOffset){var start,len=data.length,stt,pid,atf,offset,pes,unknownPIDs=false;this.contiguous=contiguous;var pmtParsed=this.pmtParsed,avcTrack=this._avcTrack,audioTrack=this._audioTrack,id3Track=this._id3Track,avcId=avcTrack.id,audioId=audioTrack.id,id3Id=id3Track.id,pmtId=this._pmtId,avcData=avcTrack.pesData,audioData=audioTrack.pesData,id3Data=id3Track.pesData,parsePAT=this._parsePAT,parsePMT=this._parsePMT,parsePES=this._parsePES,parseAVCPES=this._parseAVCPES.bind(this),parseAACPES=this._parseAACPES.bind(this),parseMPEGPES=this._parseMPEGPES.bind(this),parseID3PES=this._parseID3PES.bind(this);// don't parse last TS packet if incomplete
len-=len%188;// loop through TS packets
for(start=0;start<len;start+=188){if(data[start]===0x47){stt=!!(data[start+1]&0x40);// pid is a 13-bit field starting at the last bit of TS[1]
pid=((data[start+1]&0x1f)<<8)+data[start+2];atf=(data[start+3]&0x30)>>4;// if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
if(atf>1){offset=start+5+data[start+4];// continue if there is only adaptation field
if(offset===start+188){continue;}}else{offset=start+4;}switch(pid){case avcId:if(stt){if(avcData&&(pes=parsePES(avcData))){parseAVCPES(pes,false);}avcData={data:[],size:0};}if(avcData){avcData.data.push(data.subarray(offset,start+188));avcData.size+=start+188-offset;}break;case audioId:if(stt){if(audioData&&(pes=parsePES(audioData))){if(audioTrack.isAAC){parseAACPES(pes);}else{parseMPEGPES(pes);}}audioData={data:[],size:0};}if(audioData){audioData.data.push(data.subarray(offset,start+188));audioData.size+=start+188-offset;}break;case id3Id:if(stt){if(id3Data&&(pes=parsePES(id3Data))){parseID3PES(pes);}id3Data={data:[],size:0};}if(id3Data){id3Data.data.push(data.subarray(offset,start+188));id3Data.size+=start+188-offset;}break;case 0:if(stt){offset+=data[offset]+1;}pmtId=this._pmtId=parsePAT(data,offset);break;case pmtId:if(stt){offset+=data[offset]+1;}var parsedPIDs=parsePMT(data,offset,this.typeSupported.mpeg===true||this.typeSupported.mp3===true,this.sampleAes!=null);// only update track id if track PID found while parsing PMT
// this is to avoid resetting the PID to -1 in case
// track PID transiently disappears from the stream
// this could happen in case of transient missing audio samples for example
avcId=parsedPIDs.avc;if(avcId>0){avcTrack.id=avcId;}audioId=parsedPIDs.audio;if(audioId>0){audioTrack.id=audioId;audioTrack.isAAC=parsedPIDs.isAAC;}id3Id=parsedPIDs.id3;if(id3Id>0){id3Track.id=id3Id;}if(unknownPIDs&&!pmtParsed){_logger.logger.log('reparse from beginning');unknownPIDs=false;// we set it to -188, the += 188 in the for loop will reset start to 0
start=-188;}pmtParsed=this.pmtParsed=true;break;case 17:case 0x1fff:break;default:unknownPIDs=true;break;}}else{this.observer.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.FRAG_PARSING_ERROR,fatal:false,reason:'TS packet did not start with 0x47'});}}// try to parse last PES packets
if(avcData&&(pes=parsePES(avcData))){parseAVCPES(pes,true);avcTrack.pesData=null;}else{// either avcData null or PES truncated, keep it for next frag parsing
avcTrack.pesData=avcData;}if(audioData&&(pes=parsePES(audioData))){if(audioTrack.isAAC){parseAACPES(pes);}else{parseMPEGPES(pes);}audioTrack.pesData=null;}else{if(audioData&&audioData.size){_logger.logger.log('last AAC PES packet truncated,might overlap between fragments');}// either audioData null or PES truncated, keep it for next frag parsing
audioTrack.pesData=audioData;}if(id3Data&&(pes=parsePES(id3Data))){parseID3PES(pes);id3Track.pesData=null;}else{// either id3Data null or PES truncated, keep it for next frag parsing
id3Track.pesData=id3Data;}if(this.sampleAes==null){this.remuxer.remux(audioTrack,avcTrack,id3Track,this._txtTrack,timeOffset,contiguous,accurateTimeOffset);}else{this.decryptAndRemux(audioTrack,avcTrack,id3Track,this._txtTrack,timeOffset,contiguous,accurateTimeOffset);}}},{key:'decryptAndRemux',value:function decryptAndRemux(audioTrack,videoTrack,id3Track,textTrack,timeOffset,contiguous,accurateTimeOffset){if(audioTrack.samples&&audioTrack.isAAC){var localthis=this;this.sampleAes.decryptAacSamples(audioTrack.samples,0,function(){localthis.decryptAndRemuxAvc(audioTrack,videoTrack,id3Track,textTrack,timeOffset,contiguous,accurateTimeOffset);});}else{this.decryptAndRemuxAvc(audioTrack,videoTrack,id3Track,textTrack,timeOffset,contiguous,accurateTimeOffset);}}},{key:'decryptAndRemuxAvc',value:function decryptAndRemuxAvc(audioTrack,videoTrack,id3Track,textTrack,timeOffset,contiguous,accurateTimeOffset){if(videoTrack.samples){var localthis=this;this.sampleAes.decryptAvcSamples(videoTrack.samples,0,0,function(){localthis.remuxer.remux(audioTrack,videoTrack,id3Track,textTrack,timeOffset,contiguous,accurateTimeOffset);});}else{this.remuxer.remux(audioTrack,videoTrack,id3Track,textTrack,timeOffset,contiguous,accurateTimeOffset);}}},{key:'destroy',value:function destroy(){this._initPTS=this._initDTS=undefined;this._duration=0;}},{key:'_parsePAT',value:function _parsePAT(data,offset){// skip the PSI header and parse the first PMT entry
return(data[offset+10]&0x1F)<<8|data[offset+11];//logger.log('PMT PID:'  + this._pmtId);
}},{key:'_parsePMT',value:function _parsePMT(data,offset,mpegSupported,isSampleAes){var sectionLength,tableEnd,programInfoLength,pid,result={audio:-1,avc:-1,id3:-1,isAAC:true};sectionLength=(data[offset+1]&0x0f)<<8|data[offset+2];tableEnd=offset+3+sectionLength-4;// to determine where the table is, we have to figure out how
// long the program info descriptors are
programInfoLength=(data[offset+10]&0x0f)<<8|data[offset+11];// advance the offset to the first entry in the mapping table
offset+=12+programInfoLength;while(offset<tableEnd){pid=(data[offset+1]&0x1F)<<8|data[offset+2];switch(data[offset]){case 0xcf:// SAMPLE-AES AAC
if(!isSampleAes){_logger.logger.log('unkown stream type:'+data[offset]);break;}/* falls through */// ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
case 0x0f://logger.log('AAC PID:'  + pid);
if(result.audio===-1){result.audio=pid;}break;// Packetized metadata (ID3)
case 0x15://logger.log('ID3 PID:'  + pid);
if(result.id3===-1){result.id3=pid;}break;case 0xdb:// SAMPLE-AES AVC
if(!isSampleAes){_logger.logger.log('unkown stream type:'+data[offset]);break;}/* falls through */// ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
case 0x1b://logger.log('AVC PID:'  + pid);
if(result.avc===-1){result.avc=pid;}break;// ISO/IEC 11172-3 (MPEG-1 audio)
// or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
case 0x03:case 0x04://logger.log('MPEG PID:'  + pid);
if(!mpegSupported){_logger.logger.log('MPEG audio found, not supported in this browser for now');}else if(result.audio===-1){result.audio=pid;result.isAAC=false;}break;case 0x24:_logger.logger.warn('HEVC stream type found, not supported for now');break;default:_logger.logger.log('unkown stream type:'+data[offset]);break;}// move to the next table entry
// skip past the elementary stream descriptors, if present
offset+=((data[offset+3]&0x0F)<<8|data[offset+4])+5;}return result;}},{key:'_parsePES',value:function _parsePES(stream){var i=0,frag,pesFlags,pesPrefix,pesLen,pesHdrLen,pesData,pesPts,pesDts,payloadStartOffset,data=stream.data;// safety check
if(!stream||stream.size===0){return null;}// we might need up to 19 bytes to read PES header
// if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
// usually only one merge is needed (and this is rare ...)
while(data[0].length<19&&data.length>1){var newData=new Uint8Array(data[0].length+data[1].length);newData.set(data[0]);newData.set(data[1],data[0].length);data[0]=newData;data.splice(1,1);}//retrieve PTS/DTS from first fragment
frag=data[0];pesPrefix=(frag[0]<<16)+(frag[1]<<8)+frag[2];if(pesPrefix===1){pesLen=(frag[4]<<8)+frag[5];// if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
// minus 6 : PES header size
if(pesLen&&pesLen>stream.size-6){return null;}pesFlags=frag[7];if(pesFlags&0xC0){/* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
              as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
              as Bitwise operators treat their operands as a sequence of 32 bits */pesPts=(frag[9]&0x0E)*536870912+// 1 << 29
(frag[10]&0xFF)*4194304+// 1 << 22
(frag[11]&0xFE)*16384+// 1 << 14
(frag[12]&0xFF)*128+// 1 << 7
(frag[13]&0xFE)/2;// check if greater than 2^32 -1
if(pesPts>4294967295){// decrement 2^33
pesPts-=8589934592;}if(pesFlags&0x40){pesDts=(frag[14]&0x0E)*536870912+// 1 << 29
(frag[15]&0xFF)*4194304+// 1 << 22
(frag[16]&0xFE)*16384+// 1 << 14
(frag[17]&0xFF)*128+// 1 << 7
(frag[18]&0xFE)/2;// check if greater than 2^32 -1
if(pesDts>4294967295){// decrement 2^33
pesDts-=8589934592;}if(pesPts-pesDts>60*90000){_logger.logger.warn(Math.round((pesPts-pesDts)/90000)+'s delta between PTS and DTS, align them');pesPts=pesDts;}}else{pesDts=pesPts;}}pesHdrLen=frag[8];// 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
payloadStartOffset=pesHdrLen+9;stream.size-=payloadStartOffset;//reassemble PES packet
pesData=new Uint8Array(stream.size);for(var j=0,dataLen=data.length;j<dataLen;j++){frag=data[j];var len=frag.byteLength;if(payloadStartOffset){if(payloadStartOffset>len){// trim full frag if PES header bigger than frag
payloadStartOffset-=len;continue;}else{// trim partial frag if PES header smaller than frag
frag=frag.subarray(payloadStartOffset);len-=payloadStartOffset;payloadStartOffset=0;}}pesData.set(frag,i);i+=len;}if(pesLen){// payload size : remove PES header + PES extension
pesLen-=pesHdrLen+3;}return{data:pesData,pts:pesPts,dts:pesDts,len:pesLen};}else{return null;}}},{key:'pushAccesUnit',value:function pushAccesUnit(avcSample,avcTrack){if(avcSample.units.length&&avcSample.frame){var samples=avcTrack.samples;var nbSamples=samples.length;// only push AVC sample if starting with a keyframe is not mandatory OR
//    if keyframe already found in this fragment OR
//       keyframe found in last fragment (track.sps) AND
//          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
if(!this.config.forceKeyFrameOnDiscontinuity||avcSample.key===true||avcTrack.sps&&(nbSamples||this.contiguous)){avcSample.id=nbSamples;samples.push(avcSample);}else{// dropped samples, track it
avcTrack.dropped++;}}if(avcSample.debug.length){_logger.logger.log(avcSample.pts+'/'+avcSample.dts+':'+avcSample.debug);}}},{key:'_parseAVCPES',value:function _parseAVCPES(pes,last){var _this=this;//logger.log('parse new PES');
var track=this._avcTrack,units=this._parseAVCNALu(pes.data),debug=false,expGolombDecoder,avcSample=this.avcSample,push,i;//free pes.data to save up some memory
pes.data=null;units.forEach(function(unit){switch(unit.type){//NDR
case 1:push=true;if(debug&&avcSample){avcSample.debug+='NDR ';}avcSample.frame=true;// retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
var data=unit.data;if(data.length>4){var sliceType=new _expGolomb2.default(data).readSliceType();// 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
// SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
// An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
// I slice: A slice that is not an SI slice that is decoded using intra prediction only.
//if (sliceType === 2 || sliceType === 7) {
if(sliceType===2||sliceType===4||sliceType===7||sliceType===9){avcSample.key=true;}}break;//IDR
case 5:push=true;// handle PES not starting with AUD
if(!avcSample){avcSample=_this.avcSample=_this._createAVCSample(true,pes.pts,pes.dts,'');}if(debug){avcSample.debug+='IDR ';}avcSample.key=true;avcSample.frame=true;break;//SEI
case 6:push=true;if(debug&&avcSample){avcSample.debug+='SEI ';}expGolombDecoder=new _expGolomb2.default(_this.discardEPB(unit.data));// skip frameType
expGolombDecoder.readUByte();var payloadType=0;var payloadSize=0;var endOfCaptions=false;var b=0;while(!endOfCaptions&&expGolombDecoder.bytesAvailable>1){payloadType=0;do{b=expGolombDecoder.readUByte();payloadType+=b;}while(b===0xFF);// Parse payload size.
payloadSize=0;do{b=expGolombDecoder.readUByte();payloadSize+=b;}while(b===0xFF);// TODO: there can be more than one payload in an SEI packet...
// TODO: need to read type and size in a while loop to get them all
if(payloadType===4&&expGolombDecoder.bytesAvailable!==0){endOfCaptions=true;var countryCode=expGolombDecoder.readUByte();if(countryCode===181){var providerCode=expGolombDecoder.readUShort();if(providerCode===49){var userStructure=expGolombDecoder.readUInt();if(userStructure===0x47413934){var userDataType=expGolombDecoder.readUByte();// Raw CEA-608 bytes wrapped in CEA-708 packet
if(userDataType===3){var firstByte=expGolombDecoder.readUByte();var secondByte=expGolombDecoder.readUByte();var totalCCs=31&firstByte;var byteArray=[firstByte,secondByte];for(i=0;i<totalCCs;i++){// 3 bytes per CC
byteArray.push(expGolombDecoder.readUByte());byteArray.push(expGolombDecoder.readUByte());byteArray.push(expGolombDecoder.readUByte());}_this._insertSampleInOrder(_this._txtTrack.samples,{type:3,pts:pes.pts,bytes:byteArray});}}}}}else if(payloadSize<expGolombDecoder.bytesAvailable){for(i=0;i<payloadSize;i++){expGolombDecoder.readUByte();}}}break;//SPS
case 7:push=true;if(debug&&avcSample){avcSample.debug+='SPS ';}if(!track.sps){expGolombDecoder=new _expGolomb2.default(unit.data);var config=expGolombDecoder.readSPS();track.width=config.width;track.height=config.height;track.pixelRatio=config.pixelRatio;track.sps=[unit.data];track.duration=_this._duration;var codecarray=unit.data.subarray(1,4);var codecstring='avc1.';for(i=0;i<3;i++){var h=codecarray[i].toString(16);if(h.length<2){h='0'+h;}codecstring+=h;}track.codec=codecstring;}break;//PPS
case 8:push=true;if(debug&&avcSample){avcSample.debug+='PPS ';}if(!track.pps){track.pps=[unit.data];}break;// AUD
case 9:push=false;if(avcSample){_this.pushAccesUnit(avcSample,track);}avcSample=_this.avcSample=_this._createAVCSample(false,pes.pts,pes.dts,debug?'AUD ':'');break;// Filler Data
case 12:push=false;break;default:push=false;if(avcSample){avcSample.debug+='unknown NAL '+unit.type+' ';}break;}if(avcSample&&push){var _units=avcSample.units;_units.push(unit);}});// if last PES packet, push samples
if(last&&avcSample){this.pushAccesUnit(avcSample,track);this.avcSample=null;}}},{key:'_createAVCSample',value:function _createAVCSample(key,pts,dts,debug){return{key:key,pts:pts,dts:dts,units:[],debug:debug};}},{key:'_insertSampleInOrder',value:function _insertSampleInOrder(arr,data){var len=arr.length;if(len>0){if(data.pts>=arr[len-1].pts){arr.push(data);}else{for(var pos=len-1;pos>=0;pos--){if(data.pts<arr[pos].pts){arr.splice(pos,0,data);break;}}}}else{arr.push(data);}}},{key:'_getLastNalUnit',value:function _getLastNalUnit(){var avcSample=this.avcSample,lastUnit=void 0;// try to fallback to previous sample if current one is empty
if(!avcSample||avcSample.units.length===0){var track=this._avcTrack,samples=track.samples;avcSample=samples[samples.length-1];}if(avcSample){var units=avcSample.units;lastUnit=units[units.length-1];}return lastUnit;}},{key:'_parseAVCNALu',value:function _parseAVCNALu(array){var i=0,len=array.byteLength,value,overflow,track=this._avcTrack,state=track.naluState||0,lastState=state;var units=[],unit,unitType,lastUnitStart=-1,lastUnitType;//logger.log('PES:' + Hex.hexDump(array));
if(state===-1){// special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
lastUnitStart=0;// NALu type is value read from offset 0
lastUnitType=array[0]&0x1f;state=0;i=1;}while(i<len){value=array[i++];// optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
if(!state){state=value?0:1;continue;}if(state===1){state=value?0:2;continue;}// here we have state either equal to 2 or 3
if(!value){state=3;}else if(value===1){if(lastUnitStart>=0){unit={data:array.subarray(lastUnitStart,i-state-1),type:lastUnitType};//logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
units.push(unit);}else{// lastUnitStart is undefined => this is the first start code found in this PES packet
// first check if start code delimiter is overlapping between 2 PES packets,
// ie it started in last packet (lastState not zero)
// and ended at the beginning of this PES packet (i <= 4 - lastState)
var lastUnit=this._getLastNalUnit();if(lastUnit){if(lastState&&i<=4-lastState){// start delimiter overlapping between PES packets
// strip start delimiter bytes from the end of last NAL unit
// check if lastUnit had a state different from zero
if(lastUnit.state){// strip last bytes
lastUnit.data=lastUnit.data.subarray(0,lastUnit.data.byteLength-lastState);}}// If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
overflow=i-state-1;if(overflow>0){//logger.log('first NALU found with overflow:' + overflow);
var tmp=new Uint8Array(lastUnit.data.byteLength+overflow);tmp.set(lastUnit.data,0);tmp.set(array.subarray(0,overflow),lastUnit.data.byteLength);lastUnit.data=tmp;}}}// check if we can read unit type
if(i<len){unitType=array[i]&0x1f;//logger.log('find NALU @ offset:' + i + ',type:' + unitType);
lastUnitStart=i;lastUnitType=unitType;state=0;}else{// not enough byte to read unit type. let's read it on next PES parsing
state=-1;}}else{state=0;}}if(lastUnitStart>=0&&state>=0){unit={data:array.subarray(lastUnitStart,len),type:lastUnitType,state:state};units.push(unit);//logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
}// no NALu found
if(units.length===0){// append pes.data to previous NAL unit
var _lastUnit=this._getLastNalUnit();if(_lastUnit){var _tmp=new Uint8Array(_lastUnit.data.byteLength+array.byteLength);_tmp.set(_lastUnit.data,0);_tmp.set(array,_lastUnit.data.byteLength);_lastUnit.data=_tmp;}}track.naluState=state;return units;}/**
     * remove Emulation Prevention bytes from a RBSP
     */},{key:'discardEPB',value:function discardEPB(data){var length=data.byteLength,EPBPositions=[],i=1,newLength,newData;// Find all `Emulation Prevention Bytes`
while(i<length-2){if(data[i]===0&&data[i+1]===0&&data[i+2]===0x03){EPBPositions.push(i+2);i+=2;}else{i++;}}// If no Emulation Prevention Bytes were found just return the original
// array
if(EPBPositions.length===0){return data;}// Create a new array to hold the NAL unit data
newLength=length-EPBPositions.length;newData=new Uint8Array(newLength);var sourceIndex=0;for(i=0;i<newLength;sourceIndex++,i++){if(sourceIndex===EPBPositions[0]){// Skip this byte
sourceIndex++;// Remove this position index
EPBPositions.shift();}newData[i]=data[sourceIndex];}return newData;}},{key:'_parseAACPES',value:function _parseAACPES(pes){var track=this._audioTrack,data=pes.data,pts=pes.pts,startOffset=0,aacOverFlow=this.aacOverFlow,aacLastPTS=this.aacLastPTS,config,frameLength,frameDuration,frameIndex,offset,headerLength,stamp,len,aacSample;if(aacOverFlow){var tmp=new Uint8Array(aacOverFlow.byteLength+data.byteLength);tmp.set(aacOverFlow,0);tmp.set(data,aacOverFlow.byteLength);//logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
data=tmp;}// look for ADTS header (0xFFFx)
for(offset=startOffset,len=data.length;offset<len-1;offset++){if(data[offset]===0xff&&(data[offset+1]&0xf0)===0xf0){break;}}// if ADTS header does not start straight from the beginning of the PES payload, raise an error
if(offset){var reason,fatal;if(offset<len-1){reason='AAC PES did not start with ADTS header,offset:'+offset;fatal=false;}else{reason='no ADTS header found in AAC PES';fatal=true;}_logger.logger.warn('parsing error:'+reason);this.observer.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.FRAG_PARSING_ERROR,fatal:fatal,reason:reason});if(fatal){return;}}if(!track.samplerate){var audioCodec=this.audioCodec;config=_adts2.default.getAudioConfig(this.observer,data,offset,audioCodec);track.config=config.config;track.samplerate=config.samplerate;track.channelCount=config.channelCount;track.codec=config.codec;track.manifestCodec=config.manifestCodec;_logger.logger.log('parsed codec:'+track.codec+',rate:'+config.samplerate+',nb channel:'+config.channelCount);}frameIndex=0;frameDuration=1024*90000/track.samplerate;// if last AAC frame is overflowing, we should ensure timestamps are contiguous:
// first sample PTS should be equal to last sample PTS + frameDuration
if(aacOverFlow&&aacLastPTS){var newPTS=aacLastPTS+frameDuration;if(Math.abs(newPTS-pts)>1){_logger.logger.log('AAC: align PTS for overlapping frames by '+Math.round((newPTS-pts)/90));pts=newPTS;}}while(offset+5<len){// The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
headerLength=!!(data[offset+1]&0x01)?7:9;// retrieve frame size
frameLength=(data[offset+3]&0x03)<<11|data[offset+4]<<3|(data[offset+5]&0xE0)>>>5;frameLength-=headerLength;//stamp = pes.pts;
if(frameLength>0&&offset+headerLength+frameLength<=len){stamp=pts+frameIndex*frameDuration;//logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
aacSample={unit:data.subarray(offset+headerLength,offset+headerLength+frameLength),pts:stamp,dts:stamp};track.samples.push(aacSample);track.len+=frameLength;offset+=frameLength+headerLength;frameIndex++;// look for ADTS header (0xFFFx)
for(;offset<len-1;offset++){if(data[offset]===0xff&&(data[offset+1]&0xf0)===0xf0){break;}}}else{break;}}if(offset<len){aacOverFlow=data.subarray(offset,len);//logger.log(`AAC: overflow detected:${len-offset}`);
}else{aacOverFlow=null;}this.aacOverFlow=aacOverFlow;this.aacLastPTS=stamp;}},{key:'_parseMPEGPES',value:function _parseMPEGPES(pes){_mpegaudio2.default.parse(this._audioTrack,pes.data,0,pes.pts);}},{key:'_parseID3PES',value:function _parseID3PES(pes){this._id3Track.samples.push(pes);}}],[{key:'probe',value:function probe(data){// a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
if(data.length>=3*188&&data[0]===0x47&&data[188]===0x47&&data[2*188]===0x47){return true;}else{return false;}}}]);return TSDemuxer;}();exports.default=TSDemuxer;},{"22":22,"26":26,"30":30,"31":31,"33":33,"35":35,"53":53}],33:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var ErrorTypes=exports.ErrorTypes={// Identifier for a network error (loading error / timeout ...)
NETWORK_ERROR:'networkError',// Identifier for a media Error (video/parsing/mediasource error)
MEDIA_ERROR:'mediaError',// Identifier for a mux Error (demuxing/remuxing)
MUX_ERROR:'muxError',// Identifier for all other errors
OTHER_ERROR:'otherError'};var ErrorDetails=exports.ErrorDetails={// Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
MANIFEST_LOAD_ERROR:'manifestLoadError',// Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
MANIFEST_LOAD_TIMEOUT:'manifestLoadTimeOut',// Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
MANIFEST_PARSING_ERROR:'manifestParsingError',// Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
MANIFEST_INCOMPATIBLE_CODECS_ERROR:'manifestIncompatibleCodecsError',// Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
LEVEL_LOAD_ERROR:'levelLoadError',// Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
LEVEL_LOAD_TIMEOUT:'levelLoadTimeOut',// Identifier for a level switch error - data: { level : faulty level Id, event : error description}
LEVEL_SWITCH_ERROR:'levelSwitchError',// Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
AUDIO_TRACK_LOAD_ERROR:'audioTrackLoadError',// Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
AUDIO_TRACK_LOAD_TIMEOUT:'audioTrackLoadTimeOut',// Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
FRAG_LOAD_ERROR:'fragLoadError',// Identifier for fragment loop loading error - data: { frag : fragment object}
FRAG_LOOP_LOADING_ERROR:'fragLoopLoadingError',// Identifier for fragment load timeout error - data: { frag : fragment object}
FRAG_LOAD_TIMEOUT:'fragLoadTimeOut',// Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
FRAG_DECRYPT_ERROR:'fragDecryptError',// Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
// will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
FRAG_PARSING_ERROR:'fragParsingError',// Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
REMUX_ALLOC_ERROR:'remuxAllocError',// Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
KEY_LOAD_ERROR:'keyLoadError',// Identifier for decrypt key load timeout error - data: { frag : fragment object}
KEY_LOAD_TIMEOUT:'keyLoadTimeOut',// Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
BUFFER_ADD_CODEC_ERROR:'bufferAddCodecError',// Identifier for a buffer append error - data: append error description
BUFFER_APPEND_ERROR:'bufferAppendError',// Identifier for a buffer appending error event - data: appending error description
BUFFER_APPENDING_ERROR:'bufferAppendingError',// Identifier for a buffer stalled error event
BUFFER_STALLED_ERROR:'bufferStalledError',// Identifier for a buffer full event
BUFFER_FULL_ERROR:'bufferFullError',// Identifier for a buffer seek over hole event
BUFFER_SEEK_OVER_HOLE:'bufferSeekOverHole',// Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
BUFFER_NUDGE_ON_STALL:'bufferNudgeOnStall',// Identifier for an internal exception happening inside hls.js while handling an event
INTERNAL_EXCEPTION:'internalException',// Malformed WebVTT contents
WEBVTT_EXCEPTION:'webVTTException'};},{}],34:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */var _logger=_dereq_(53);var _errors=_dereq_(33);var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var EventHandler=function(){function EventHandler(hls){_classCallCheck(this,EventHandler);this.hls=hls;this.onEvent=this.onEvent.bind(this);for(var _len=arguments.length,events=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){events[_key-1]=arguments[_key];}this.handledEvents=events;this.useGenericHandler=true;this.registerListeners();}_createClass(EventHandler,[{key:'destroy',value:function destroy(){this.unregisterListeners();}},{key:'isEventHandler',value:function isEventHandler(){return _typeof(this.handledEvents)==='object'&&this.handledEvents.length&&typeof this.onEvent==='function';}},{key:'registerListeners',value:function registerListeners(){if(this.isEventHandler()){this.handledEvents.forEach(function(event){if(event==='hlsEventGeneric'){throw new Error('Forbidden event name: '+event);}this.hls.on(event,this.onEvent);}.bind(this));}}},{key:'unregisterListeners',value:function unregisterListeners(){if(this.isEventHandler()){this.handledEvents.forEach(function(event){this.hls.off(event,this.onEvent);}.bind(this));}}/**
     * arguments: event (string), data (any)
     */},{key:'onEvent',value:function onEvent(event,data){this.onEventGeneric(event,data);}},{key:'onEventGeneric',value:function onEventGeneric(event,data){var eventToFunction=function eventToFunction(event,data){var funcName='on'+event.replace('hls','');if(typeof this[funcName]!=='function'){throw new Error('Event '+event+' has no generic handler in this '+this.constructor.name+' class (tried '+funcName+')');}return this[funcName].bind(this,data);};try{eventToFunction.call(this,event,data).call();}catch(err){_logger.logger.error('internal error happened while processing '+event+':'+err.message);this.hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.OTHER_ERROR,details:_errors.ErrorDetails.INTERNAL_EXCEPTION,fatal:false,event:event,err:err});}}}]);return EventHandler;}();exports.default=EventHandler;},{"33":33,"35":35,"53":53}],35:[function(_dereq_,module,exports){'use strict';module.exports={// fired before MediaSource is attaching to media element - data: { media }
MEDIA_ATTACHING:'hlsMediaAttaching',// fired when MediaSource has been succesfully attached to media element - data: { }
MEDIA_ATTACHED:'hlsMediaAttached',// fired before detaching MediaSource from media element - data: { }
MEDIA_DETACHING:'hlsMediaDetaching',// fired when MediaSource has been detached from media element - data: { }
MEDIA_DETACHED:'hlsMediaDetached',// fired when we buffer is going to be reset - data: { }
BUFFER_RESET:'hlsBufferReset',// fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
BUFFER_CODECS:'hlsBufferCodecs',// fired when sourcebuffers have been created - data: { tracks : tracks }
BUFFER_CREATED:'hlsBufferCreated',// fired when we append a segment to the buffer - data: { segment: segment object }
BUFFER_APPENDING:'hlsBufferAppending',// fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
BUFFER_APPENDED:'hlsBufferAppended',// fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
BUFFER_EOS:'hlsBufferEos',// fired when the media buffer should be flushed - data { startOffset, endOffset }
BUFFER_FLUSHING:'hlsBufferFlushing',// fired when the media buffer has been flushed - data: { }
BUFFER_FLUSHED:'hlsBufferFlushed',// fired to signal that a manifest loading starts - data: { url : manifestURL}
MANIFEST_LOADING:'hlsManifestLoading',// fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
MANIFEST_LOADED:'hlsManifestLoaded',// fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
MANIFEST_PARSED:'hlsManifestParsed',// fired when a level switch is requested - data: { level : id of new level } // deprecated in favor LEVEL_SWITCHING
LEVEL_SWITCH:'hlsLevelSwitch',// fired when a level switch is requested - data: { level : id of new level }
LEVEL_SWITCHING:'hlsLevelSwitching',// fired when a level switch is effective - data: { level : id of new level }
LEVEL_SWITCHED:'hlsLevelSwitched',// fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
LEVEL_LOADING:'hlsLevelLoading',// fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
LEVEL_LOADED:'hlsLevelLoaded',// fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
LEVEL_UPDATED:'hlsLevelUpdated',// fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
LEVEL_PTS_UPDATED:'hlsLevelPtsUpdated',// fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
AUDIO_TRACKS_UPDATED:'hlsAudioTracksUpdated',// fired when an audio track switch occurs - data: { id : audio track id } // deprecated in favor AUDIO_TRACK_SWITCHING
AUDIO_TRACK_SWITCH:'hlsAudioTrackSwitch',// fired when an audio track switching is requested - data: { id : audio track id }
AUDIO_TRACK_SWITCHING:'hlsAudioTrackSwitching',// fired when an audio track switch actually occurs - data: { id : audio track id }
AUDIO_TRACK_SWITCHED:'hlsAudioTrackSwitched',// fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
AUDIO_TRACK_LOADING:'hlsAudioTrackLoading',// fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
AUDIO_TRACK_LOADED:'hlsAudioTrackLoaded',// fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
SUBTITLE_TRACKS_UPDATED:'hlsSubtitleTracksUpdated',// fired when an subtitle track switch occurs - data: { id : subtitle track id }
SUBTITLE_TRACK_SWITCH:'hlsSubtitleTrackSwitch',// fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
SUBTITLE_TRACK_LOADING:'hlsSubtitleTrackLoading',// fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
SUBTITLE_TRACK_LOADED:'hlsSubtitleTrackLoaded',// fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
SUBTITLE_FRAG_PROCESSED:'hlsSubtitleFragProcessed',// fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
INIT_PTS_FOUND:'hlsInitPtsFound',// fired when a fragment loading starts - data: { frag : fragment object }
FRAG_LOADING:'hlsFragLoading',// fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
FRAG_LOAD_PROGRESS:'hlsFragLoadProgress',// Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
FRAG_LOAD_EMERGENCY_ABORTED:'hlsFragLoadEmergencyAborted',// fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
FRAG_LOADED:'hlsFragLoaded',// fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, stats : { tstart, tdecrypt } }
FRAG_DECRYPTED:'hlsFragDecrypted',// fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
FRAG_PARSING_INIT_SEGMENT:'hlsFragParsingInitSegment',// fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
FRAG_PARSING_USERDATA:'hlsFragParsingUserdata',// fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
FRAG_PARSING_METADATA:'hlsFragParsingMetadata',// fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
FRAG_PARSING_DATA:'hlsFragParsingData',// fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
FRAG_PARSED:'hlsFragParsed',// fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
FRAG_BUFFERED:'hlsFragBuffered',// fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
FRAG_CHANGED:'hlsFragChanged',// Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
FPS_DROP:'hlsFpsDrop',//triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
FPS_DROP_LEVEL_CAPPING:'hlsFpsDropLevelCapping',// Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
ERROR:'hlsError',// fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
DESTROYING:'hlsDestroying',// fired when a decrypt key loading starts - data: { frag : fragment object }
KEY_LOADING:'hlsKeyLoading',// fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
KEY_LOADED:'hlsKeyLoaded',// fired upon stream controller state transitions - data: { previousState, nextState }
STREAM_STATE_TRANSITION:'hlsStreamStateTransition'};},{}],36:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}/**
 *  AAC helper
 */var AAC=function(){function AAC(){_classCallCheck(this,AAC);}_createClass(AAC,null,[{key:'getSilentFrame',value:function getSilentFrame(codec,channelCount){switch(codec){case'mp4a.40.2':if(channelCount===1){return new Uint8Array([0x00,0xc8,0x00,0x80,0x23,0x80]);}else if(channelCount===2){return new Uint8Array([0x21,0x00,0x49,0x90,0x02,0x19,0x00,0x23,0x80]);}else if(channelCount===3){return new Uint8Array([0x00,0xc8,0x00,0x80,0x20,0x84,0x01,0x26,0x40,0x08,0x64,0x00,0x8e]);}else if(channelCount===4){return new Uint8Array([0x00,0xc8,0x00,0x80,0x20,0x84,0x01,0x26,0x40,0x08,0x64,0x00,0x80,0x2c,0x80,0x08,0x02,0x38]);}else if(channelCount===5){return new Uint8Array([0x00,0xc8,0x00,0x80,0x20,0x84,0x01,0x26,0x40,0x08,0x64,0x00,0x82,0x30,0x04,0x99,0x00,0x21,0x90,0x02,0x38]);}else if(channelCount===6){return new Uint8Array([0x00,0xc8,0x00,0x80,0x20,0x84,0x01,0x26,0x40,0x08,0x64,0x00,0x82,0x30,0x04,0x99,0x00,0x21,0x90,0x02,0x00,0xb2,0x00,0x20,0x08,0xe0]);}break;// handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
default:if(channelCount===1){// ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
return new Uint8Array([0x1,0x40,0x22,0x80,0xa3,0x4e,0xe6,0x80,0xba,0x8,0x0,0x0,0x0,0x1c,0x6,0xf1,0xc1,0xa,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5e]);}else if(channelCount===2){// ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
return new Uint8Array([0x1,0x40,0x22,0x80,0xa3,0x5e,0xe6,0x80,0xba,0x8,0x0,0x0,0x0,0x0,0x95,0x0,0x6,0xf1,0xa1,0xa,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5e]);}else if(channelCount===3){// ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
return new Uint8Array([0x1,0x40,0x22,0x80,0xa3,0x5e,0xe6,0x80,0xba,0x8,0x0,0x0,0x0,0x0,0x95,0x0,0x6,0xf1,0xa1,0xa,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5e]);}break;}return null;}}]);return AAC;}();exports.default=AAC;},{}],37:[function(_dereq_,module,exports){"use strict";/**
 * Buffer Helper utils, providing methods dealing buffer length retrieval
*/var BufferHelper={isBuffered:function isBuffered(media,position){if(media){var buffered=media.buffered;for(var i=0;i<buffered.length;i++){if(position>=buffered.start(i)&&position<=buffered.end(i)){return true;}}}return false;},bufferInfo:function bufferInfo(media,pos,maxHoleDuration){if(media){var vbuffered=media.buffered,buffered=[],i;for(i=0;i<vbuffered.length;i++){buffered.push({start:vbuffered.start(i),end:vbuffered.end(i)});}return this.bufferedInfo(buffered,pos,maxHoleDuration);}else{return{len:0,start:pos,end:pos,nextStart:undefined};}},bufferedInfo:function bufferedInfo(buffered,pos,maxHoleDuration){var buffered2=[],// bufferStart and bufferEnd are buffer boundaries around current video position
bufferLen,bufferStart,bufferEnd,bufferStartNext,i;// sort on buffer.start/smaller end (IE does not always return sorted buffered range)
buffered.sort(function(a,b){var diff=a.start-b.start;if(diff){return diff;}else{return b.end-a.end;}});// there might be some small holes between buffer time range
// consider that holes smaller than maxHoleDuration are irrelevant and build another
// buffer time range representations that discards those holes
for(i=0;i<buffered.length;i++){var buf2len=buffered2.length;if(buf2len){var buf2end=buffered2[buf2len-1].end;// if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
if(buffered[i].start-buf2end<maxHoleDuration){// merge overlapping time ranges
// update lastRange.end only if smaller than item.end
// e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
// whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
if(buffered[i].end>buf2end){buffered2[buf2len-1].end=buffered[i].end;}}else{// big hole
buffered2.push(buffered[i]);}}else{// first value
buffered2.push(buffered[i]);}}for(i=0,bufferLen=0,bufferStart=bufferEnd=pos;i<buffered2.length;i++){var start=buffered2[i].start,end=buffered2[i].end;//logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
if(pos+maxHoleDuration>=start&&pos<end){// play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
bufferStart=start;bufferEnd=end;bufferLen=bufferEnd-pos;}else if(pos+maxHoleDuration<start){bufferStartNext=start;break;}}return{len:bufferLen,start:bufferStart,end:bufferEnd,nextStart:bufferStartNext};}};module.exports=BufferHelper;},{}],38:[function(_dereq_,module,exports){'use strict';var _logger=_dereq_(53);var LevelHelper={mergeDetails:function mergeDetails(oldDetails,newDetails){var start=Math.max(oldDetails.startSN,newDetails.startSN)-newDetails.startSN,end=Math.min(oldDetails.endSN,newDetails.endSN)-newDetails.startSN,delta=newDetails.startSN-oldDetails.startSN,oldfragments=oldDetails.fragments,newfragments=newDetails.fragments,ccOffset=0,PTSFrag;// check if old/new playlists have fragments in common
if(end<start){newDetails.PTSKnown=false;return;}// loop through overlapping SN and update startPTS , cc, and duration if any found
for(var i=start;i<=end;i++){var oldFrag=oldfragments[delta+i],newFrag=newfragments[i];if(newFrag&&oldFrag){ccOffset=oldFrag.cc-newFrag.cc;if(!isNaN(oldFrag.startPTS)){newFrag.start=newFrag.startPTS=oldFrag.startPTS;newFrag.endPTS=oldFrag.endPTS;newFrag.duration=oldFrag.duration;newFrag.backtracked=oldFrag.backtracked;newFrag.dropped=oldFrag.dropped;PTSFrag=newFrag;}}}if(ccOffset){_logger.logger.log('discontinuity sliding from playlist, take drift into account');for(i=0;i<newfragments.length;i++){newfragments[i].cc+=ccOffset;}}// if at least one fragment contains PTS info, recompute PTS information for all fragments
if(PTSFrag){LevelHelper.updateFragPTSDTS(newDetails,PTSFrag,PTSFrag.startPTS,PTSFrag.endPTS,PTSFrag.startDTS,PTSFrag.endDTS);}else{// ensure that delta is within oldfragments range
// also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
// in that case we also need to adjust start offset of all fragments
if(delta>=0&&delta<oldfragments.length){// adjust start by sliding offset
var sliding=oldfragments[delta].start;for(i=0;i<newfragments.length;i++){newfragments[i].start+=sliding;}}}// if we are here, it means we have fragments overlapping between
// old and new level. reliable PTS info is thus relying on old level
newDetails.PTSKnown=oldDetails.PTSKnown;return;},updateFragPTSDTS:function updateFragPTSDTS(details,frag,startPTS,endPTS,startDTS,endDTS){// update frag PTS/DTS
if(!isNaN(frag.startPTS)){// delta PTS between audio and video
var deltaPTS=Math.abs(frag.startPTS-startPTS);if(isNaN(frag.deltaPTS)){frag.deltaPTS=deltaPTS;}else{frag.deltaPTS=Math.max(deltaPTS,frag.deltaPTS);}startPTS=Math.min(startPTS,frag.startPTS);endPTS=Math.max(endPTS,frag.endPTS);startDTS=Math.min(startDTS,frag.startDTS);endDTS=Math.max(endDTS,frag.endDTS);}var drift=startPTS-frag.start;frag.start=frag.startPTS=startPTS;frag.endPTS=endPTS;frag.startDTS=startDTS;frag.endDTS=endDTS;frag.duration=endPTS-startPTS;var sn=frag.sn;// exit if sn out of range
if(!details||sn<details.startSN||sn>details.endSN){return 0;}var fragIdx,fragments,i;fragIdx=sn-details.startSN;fragments=details.fragments;frag=fragments[fragIdx];// adjust fragment PTS/duration from seqnum-1 to frag 0
for(i=fragIdx;i>0;i--){LevelHelper.updatePTS(fragments,i,i-1);}// adjust fragment PTS/duration from seqnum to last frag
for(i=fragIdx;i<fragments.length-1;i++){LevelHelper.updatePTS(fragments,i,i+1);}details.PTSKnown=true;//logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);
return drift;},updatePTS:function updatePTS(fragments,fromIdx,toIdx){var fragFrom=fragments[fromIdx],fragTo=fragments[toIdx],fragToPTS=fragTo.startPTS;// if we know startPTS[toIdx]
if(!isNaN(fragToPTS)){// update fragment duration.
// it helps to fix drifts between playlist reported duration and fragment real duration
if(toIdx>fromIdx){fragFrom.duration=fragToPTS-fragFrom.start;if(fragFrom.duration<0){_logger.logger.warn('negative duration computed for frag '+fragFrom.sn+',level '+fragFrom.level+', there should be some duration drift between playlist and fragment!');}}else{fragTo.duration=fragFrom.start-fragToPTS;if(fragTo.duration<0){_logger.logger.warn('negative duration computed for frag '+fragTo.sn+',level '+fragTo.level+', there should be some duration drift between playlist and fragment!');}}}else{// we dont know startPTS[toIdx]
if(toIdx>fromIdx){fragTo.start=fragFrom.start+fragFrom.duration;}else{fragTo.start=Math.max(fragFrom.start-fragTo.duration,0);}}}};/**
    * Level Helper class, providing methods dealing with playlist sliding and drift
   */module.exports=LevelHelper;},{"53":53}],39:[function(_dereq_,module,exports){/**
 * HLS interface
 */'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _urlToolkit=_dereq_(2);var _urlToolkit2=_interopRequireDefault(_urlToolkit);var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _errors=_dereq_(33);var _playlistLoader=_dereq_(43);var _playlistLoader2=_interopRequireDefault(_playlistLoader);var _fragmentLoader=_dereq_(41);var _fragmentLoader2=_interopRequireDefault(_fragmentLoader);var _keyLoader=_dereq_(42);var _keyLoader2=_interopRequireDefault(_keyLoader);var _streamController=_dereq_(13);var _streamController2=_interopRequireDefault(_streamController);var _levelController=_dereq_(12);var _levelController2=_interopRequireDefault(_levelController);var _id3TrackController=_dereq_(11);var _id3TrackController2=_interopRequireDefault(_id3TrackController);var _logger=_dereq_(53);var _events3=_dereq_(1);var _events4=_interopRequireDefault(_events3);var _config=_dereq_(4);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Hls=function(){_createClass(Hls,null,[{key:'isSupported',value:function isSupported(){var mediaSource=window.MediaSource=window.MediaSource||window.WebKitMediaSource;var sourceBuffer=window.SourceBuffer=window.SourceBuffer||window.WebKitSourceBuffer;var isTypeSupported=mediaSource&&typeof mediaSource.isTypeSupported==='function'&&mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');// if SourceBuffer is exposed ensure its API is valid
// safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible
var sourceBufferValidAPI=!sourceBuffer||sourceBuffer.prototype&&typeof sourceBuffer.prototype.appendBuffer==='function'&&typeof sourceBuffer.prototype.remove==='function';return isTypeSupported&&sourceBufferValidAPI;}},{key:'version',get:function get(){// replaced with browserify-versionify transform
return'0.7.9';}},{key:'Events',get:function get(){return _events2.default;}},{key:'ErrorTypes',get:function get(){return _errors.ErrorTypes;}},{key:'ErrorDetails',get:function get(){return _errors.ErrorDetails;}},{key:'DefaultConfig',get:function get(){if(!Hls.defaultConfig){return _config.hlsDefaultConfig;}return Hls.defaultConfig;},set:function set(defaultConfig){Hls.defaultConfig=defaultConfig;}}]);function Hls(){var _this=this;var config=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_classCallCheck(this,Hls);var defaultConfig=Hls.DefaultConfig;if((config.liveSyncDurationCount||config.liveMaxLatencyDurationCount)&&(config.liveSyncDuration||config.liveMaxLatencyDuration)){throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');}for(var prop in defaultConfig){if(prop in config){continue;}config[prop]=defaultConfig[prop];}if(config.liveMaxLatencyDurationCount!==undefined&&config.liveMaxLatencyDurationCount<=config.liveSyncDurationCount){throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');}if(config.liveMaxLatencyDuration!==undefined&&(config.liveMaxLatencyDuration<=config.liveSyncDuration||config.liveSyncDuration===undefined)){throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');}(0,_logger.enableLogs)(config.debug);this.config=config;this._autoLevelCapping=-1;// observer setup
var observer=this.observer=new _events4.default();observer.trigger=function trigger(event){for(var _len=arguments.length,data=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){data[_key-1]=arguments[_key];}observer.emit.apply(observer,[event,event].concat(data));};observer.off=function off(event){for(var _len2=arguments.length,data=Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){data[_key2-1]=arguments[_key2];}observer.removeListener.apply(observer,[event].concat(data));};this.on=observer.on.bind(observer);this.off=observer.off.bind(observer);this.trigger=observer.trigger.bind(observer);// core controllers and network loaders
var abrController=this.abrController=new config.abrController(this);var bufferController=new config.bufferController(this);var capLevelController=new config.capLevelController(this);var fpsController=new config.fpsController(this);var playListLoader=new _playlistLoader2.default(this);var fragmentLoader=new _fragmentLoader2.default(this);var keyLoader=new _keyLoader2.default(this);var id3TrackController=new _id3TrackController2.default(this);// network controllers
var levelController=this.levelController=new _levelController2.default(this);var streamController=this.streamController=new _streamController2.default(this);var networkControllers=[levelController,streamController];// optional audio stream controller
var Controller=config.audioStreamController;if(Controller){networkControllers.push(new Controller(this));}this.networkControllers=networkControllers;var coreComponents=[playListLoader,fragmentLoader,keyLoader,abrController,bufferController,capLevelController,fpsController,id3TrackController];// optional audio track and subtitle controller
Controller=config.audioTrackController;if(Controller){var audioTrackController=new Controller(this);this.audioTrackController=audioTrackController;coreComponents.push(audioTrackController);}Controller=config.subtitleTrackController;if(Controller){var subtitleTrackController=new Controller(this);this.subtitleTrackController=subtitleTrackController;coreComponents.push(subtitleTrackController);}// optional subtitle controller
[config.subtitleStreamController,config.timelineController].forEach(function(Controller){if(Controller){coreComponents.push(new Controller(_this));}});this.coreComponents=coreComponents;}_createClass(Hls,[{key:'destroy',value:function destroy(){_logger.logger.log('destroy');this.trigger(_events2.default.DESTROYING);this.detachMedia();this.coreComponents.concat(this.networkControllers).forEach(function(component){component.destroy();});this.url=null;this.observer.removeAllListeners();this._autoLevelCapping=-1;}},{key:'attachMedia',value:function attachMedia(media){_logger.logger.log('attachMedia');this.media=media;this.trigger(_events2.default.MEDIA_ATTACHING,{media:media});}},{key:'detachMedia',value:function detachMedia(){_logger.logger.log('detachMedia');this.trigger(_events2.default.MEDIA_DETACHING);this.media=null;}},{key:'loadSource',value:function loadSource(url){url=_urlToolkit2.default.buildAbsoluteURL(window.location.href,url,{alwaysNormalize:true});_logger.logger.log('loadSource:'+url);this.url=url;// when attaching to a source URL, trigger a playlist load
this.trigger(_events2.default.MANIFEST_LOADING,{url:url});}},{key:'startLoad',value:function startLoad(){var startPosition=arguments.length>0&&arguments[0]!==undefined?arguments[0]:-1;_logger.logger.log('startLoad('+startPosition+')');this.networkControllers.forEach(function(controller){controller.startLoad(startPosition);});}},{key:'stopLoad',value:function stopLoad(){_logger.logger.log('stopLoad');this.networkControllers.forEach(function(controller){controller.stopLoad();});}},{key:'swapAudioCodec',value:function swapAudioCodec(){_logger.logger.log('swapAudioCodec');this.streamController.swapAudioCodec();}},{key:'recoverMediaError',value:function recoverMediaError(){_logger.logger.log('recoverMediaError');var media=this.media;this.detachMedia();this.attachMedia(media);}/** Return all quality levels **/},{key:'levels',get:function get(){return this.levelController.levels;}/** Return current playback quality level **/},{key:'currentLevel',get:function get(){return this.streamController.currentLevel;}/* set quality level immediately (-1 for automatic level selection) */,set:function set(newLevel){_logger.logger.log('set currentLevel:'+newLevel);this.loadLevel=newLevel;this.streamController.immediateLevelSwitch();}/** Return next playback quality level (quality level of next fragment) **/},{key:'nextLevel',get:function get(){return this.streamController.nextLevel;}/* set quality level for next fragment (-1 for automatic level selection) */,set:function set(newLevel){_logger.logger.log('set nextLevel:'+newLevel);this.levelController.manualLevel=newLevel;this.streamController.nextLevelSwitch();}/** Return the quality level of current/last loaded fragment **/},{key:'loadLevel',get:function get(){return this.levelController.level;}/* set quality level for current/next loaded fragment (-1 for automatic level selection) */,set:function set(newLevel){_logger.logger.log('set loadLevel:'+newLevel);this.levelController.manualLevel=newLevel;}/** Return the quality level of next loaded fragment **/},{key:'nextLoadLevel',get:function get(){return this.levelController.nextLoadLevel;}/** set quality level of next loaded fragment **/,set:function set(level){this.levelController.nextLoadLevel=level;}/** Return first level (index of first level referenced in manifest)
    **/},{key:'firstLevel',get:function get(){return Math.max(this.levelController.firstLevel,this.minAutoLevel);}/** set first level (index of first level referenced in manifest)
    **/,set:function set(newLevel){_logger.logger.log('set firstLevel:'+newLevel);this.levelController.firstLevel=newLevel;}/** Return start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/},{key:'startLevel',get:function get(){return this.levelController.startLevel;}/** set  start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/,set:function set(newLevel){_logger.logger.log('set startLevel:'+newLevel);var hls=this;// if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
if(newLevel!==-1){newLevel=Math.max(newLevel,hls.minAutoLevel);}hls.levelController.startLevel=newLevel;}/** Return the capping/max level value that could be used by automatic level selection algorithm **/},{key:'autoLevelCapping',get:function get(){return this._autoLevelCapping;}/** set the capping/max level value that could be used by automatic level selection algorithm **/,set:function set(newLevel){_logger.logger.log('set autoLevelCapping:'+newLevel);this._autoLevelCapping=newLevel;}/* check if we are in automatic level selection mode */},{key:'autoLevelEnabled',get:function get(){return this.levelController.manualLevel===-1;}/* return manual level */},{key:'manualLevel',get:function get(){return this.levelController.manualLevel;}/* return min level selectable in auto mode according to config.minAutoBitrate */},{key:'minAutoLevel',get:function get(){var hls=this,levels=hls.levels,minAutoBitrate=hls.config.minAutoBitrate,len=levels?levels.length:0;for(var i=0;i<len;i++){var levelNextBitrate=levels[i].realBitrate?Math.max(levels[i].realBitrate,levels[i].bitrate):levels[i].bitrate;if(levelNextBitrate>minAutoBitrate){return i;}}return 0;}/* return max level selectable in auto mode according to autoLevelCapping */},{key:'maxAutoLevel',get:function get(){var hls=this;var levels=hls.levels;var autoLevelCapping=hls.autoLevelCapping;var maxAutoLevel=void 0;if(autoLevelCapping===-1&&levels&&levels.length){maxAutoLevel=levels.length-1;}else{maxAutoLevel=autoLevelCapping;}return maxAutoLevel;}// return next auto level
},{key:'nextAutoLevel',get:function get(){var hls=this;// ensure next auto level is between  min and max auto level
return Math.min(Math.max(hls.abrController.nextAutoLevel,hls.minAutoLevel),hls.maxAutoLevel);}// this setter is used to force next auto level
// this is useful to force a switch down in auto mode : in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
// forced value is valid for one fragment. upon succesful frag loading at forced level, this value will be resetted to -1 by ABR controller
,set:function set(nextLevel){var hls=this;hls.abrController.nextAutoLevel=Math.max(hls.minAutoLevel,nextLevel);}/** get alternate audio tracks list from playlist **/},{key:'audioTracks',get:function get(){var audioTrackController=this.audioTrackController;return audioTrackController?audioTrackController.audioTracks:[];}/** get index of the selected audio track (index in audio track lists) **/},{key:'audioTrack',get:function get(){var audioTrackController=this.audioTrackController;return audioTrackController?audioTrackController.audioTrack:-1;}/** select an audio track, based on its index in audio track lists**/,set:function set(audioTrackId){var audioTrackController=this.audioTrackController;if(audioTrackController){audioTrackController.audioTrack=audioTrackId;}}},{key:'liveSyncPosition',get:function get(){return this.streamController.liveSyncPosition;}/** get alternate subtitle tracks list from playlist **/},{key:'subtitleTracks',get:function get(){var subtitleTrackController=this.subtitleTrackController;return subtitleTrackController?subtitleTrackController.subtitleTracks:[];}/** get index of the selected subtitle track (index in subtitle track lists) **/},{key:'subtitleTrack',get:function get(){var subtitleTrackController=this.subtitleTrackController;return subtitleTrackController?subtitleTrackController.subtitleTrack:-1;}/** select an subtitle track, based on its index in subtitle track lists**/,set:function set(subtitleTrackId){var subtitleTrackController=this.subtitleTrackController;if(subtitleTrackController){subtitleTrackController.subtitleTrack=subtitleTrackId;}}}]);return Hls;}();exports.default=Hls;},{"1":1,"11":11,"12":12,"13":13,"2":2,"33":33,"35":35,"4":4,"41":41,"42":42,"43":43,"53":53}],40:[function(_dereq_,module,exports){'use strict';// This is mostly for support of the es6 module export
// syntax with the babel compiler, it looks like it doesnt support
// function exports like we are used to in node/commonjs
module.exports=_dereq_(39).default;},{"39":39}],41:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _errors=_dereq_(33);var _logger=_dereq_(53);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */var FragmentLoader=function(_EventHandler){_inherits(FragmentLoader,_EventHandler);function FragmentLoader(hls){_classCallCheck(this,FragmentLoader);var _this=_possibleConstructorReturn(this,(FragmentLoader.__proto__||Object.getPrototypeOf(FragmentLoader)).call(this,hls,_events2.default.FRAG_LOADING));_this.loaders={};return _this;}_createClass(FragmentLoader,[{key:'destroy',value:function destroy(){var loaders=this.loaders;for(var loaderName in loaders){var loader=loaders[loaderName];if(loader){loader.destroy();}}this.loaders={};_eventHandler2.default.prototype.destroy.call(this);}},{key:'onFragLoading',value:function onFragLoading(data){var frag=data.frag,type=frag.type,loader=this.loaders[type],config=this.hls.config;frag.loaded=0;if(loader){_logger.logger.warn('abort previous fragment loader for type:'+type);loader.abort();}loader=this.loaders[type]=frag.loader=typeof config.fLoader!=='undefined'?new config.fLoader(config):new config.loader(config);var loaderContext=void 0,loaderConfig=void 0,loaderCallbacks=void 0;loaderContext={url:frag.url,frag:frag,responseType:'arraybuffer',progressData:false};var start=frag.byteRangeStartOffset,end=frag.byteRangeEndOffset;if(!isNaN(start)&&!isNaN(end)){loaderContext.rangeStart=start;loaderContext.rangeEnd=end;}loaderConfig={timeout:config.fragLoadingTimeOut,maxRetry:0,retryDelay:0,maxRetryDelay:config.fragLoadingMaxRetryTimeout};loaderCallbacks={onSuccess:this.loadsuccess.bind(this),onError:this.loaderror.bind(this),onTimeout:this.loadtimeout.bind(this),onProgress:this.loadprogress.bind(this)};loader.load(loaderContext,loaderConfig,loaderCallbacks);}},{key:'loadsuccess',value:function loadsuccess(response,stats,context){var payload=response.data,frag=context.frag;// detach fragment loader on load success
frag.loader=undefined;this.loaders[frag.type]=undefined;this.hls.trigger(_events2.default.FRAG_LOADED,{payload:payload,frag:frag,stats:stats});}},{key:'loaderror',value:function loaderror(response,context){var loader=context.loader;if(loader){loader.abort();}this.loaders[context.type]=undefined;this.hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.NETWORK_ERROR,details:_errors.ErrorDetails.FRAG_LOAD_ERROR,fatal:false,frag:context.frag,response:response});}},{key:'loadtimeout',value:function loadtimeout(stats,context){var loader=context.loader;if(loader){loader.abort();}this.loaders[context.type]=undefined;this.hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.NETWORK_ERROR,details:_errors.ErrorDetails.FRAG_LOAD_TIMEOUT,fatal:false,frag:context.frag});}// data will be used for progressive parsing
},{key:'loadprogress',value:function loadprogress(stats,context,data){// jshint ignore:line
var frag=context.frag;frag.loaded=stats.loaded;this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS,{frag:frag,stats:stats});}}]);return FragmentLoader;}(_eventHandler2.default);exports.default=FragmentLoader;},{"33":33,"34":34,"35":35,"53":53}],42:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _errors=_dereq_(33);var _logger=_dereq_(53);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */var KeyLoader=function(_EventHandler){_inherits(KeyLoader,_EventHandler);function KeyLoader(hls){_classCallCheck(this,KeyLoader);var _this=_possibleConstructorReturn(this,(KeyLoader.__proto__||Object.getPrototypeOf(KeyLoader)).call(this,hls,_events2.default.KEY_LOADING));_this.loaders={};_this.decryptkey=null;_this.decrypturl=null;return _this;}_createClass(KeyLoader,[{key:'destroy',value:function destroy(){for(var loaderName in this.loaders){var loader=this.loaders[loaderName];if(loader){loader.destroy();}}this.loaders={};_eventHandler2.default.prototype.destroy.call(this);}},{key:'onKeyLoading',value:function onKeyLoading(data){var frag=data.frag,type=frag.type,loader=this.loaders[type],decryptdata=frag.decryptdata,uri=decryptdata.uri;// if uri is different from previous one or if decrypt key not retrieved yet
if(uri!==this.decrypturl||this.decryptkey===null){var config=this.hls.config;if(loader){_logger.logger.warn('abort previous key loader for type:'+type);loader.abort();}frag.loader=this.loaders[type]=new config.loader(config);this.decrypturl=uri;this.decryptkey=null;var loaderContext=void 0,loaderConfig=void 0,loaderCallbacks=void 0;loaderContext={url:uri,frag:frag,responseType:'arraybuffer'};loaderConfig={timeout:config.fragLoadingTimeOut,maxRetry:config.fragLoadingMaxRetry,retryDelay:config.fragLoadingRetryDelay,maxRetryDelay:config.fragLoadingMaxRetryTimeout};loaderCallbacks={onSuccess:this.loadsuccess.bind(this),onError:this.loaderror.bind(this),onTimeout:this.loadtimeout.bind(this)};frag.loader.load(loaderContext,loaderConfig,loaderCallbacks);}else if(this.decryptkey){// we already loaded this key, return it
decryptdata.key=this.decryptkey;this.hls.trigger(_events2.default.KEY_LOADED,{frag:frag});}}},{key:'loadsuccess',value:function loadsuccess(response,stats,context){var frag=context.frag;this.decryptkey=frag.decryptdata.key=new Uint8Array(response.data);// detach fragment loader on load success
frag.loader=undefined;this.loaders[frag.type]=undefined;this.hls.trigger(_events2.default.KEY_LOADED,{frag:frag});}},{key:'loaderror',value:function loaderror(response,context){var frag=context.frag,loader=frag.loader;if(loader){loader.abort();}this.loaders[context.type]=undefined;this.hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.NETWORK_ERROR,details:_errors.ErrorDetails.KEY_LOAD_ERROR,fatal:false,frag:frag,response:response});}},{key:'loadtimeout',value:function loadtimeout(stats,context){var frag=context.frag,loader=frag.loader;if(loader){loader.abort();}this.loaders[context.type]=undefined;this.hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.NETWORK_ERROR,details:_errors.ErrorDetails.KEY_LOAD_TIMEOUT,fatal:false,frag:frag});}}]);return KeyLoader;}(_eventHandler2.default);exports.default=KeyLoader;},{"33":33,"34":34,"35":35,"53":53}],43:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Playlist Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */var _urlToolkit=_dereq_(2);var _urlToolkit2=_interopRequireDefault(_urlToolkit);var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _eventHandler=_dereq_(34);var _eventHandler2=_interopRequireDefault(_eventHandler);var _errors=_dereq_(33);var _attrList=_dereq_(47);var _attrList2=_interopRequireDefault(_attrList);var _logger=_dereq_(53);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX=/#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;var MASTER_PLAYLIST_MEDIA_REGEX=/#EXT-X-MEDIA:(.*)/g;var LEVEL_PLAYLIST_REGEX_FAST=/#EXTINF:(\d*(?:\.\d+)?)(?:,(.*))?|(?!#)(\S.+)|#EXT-X-BYTERANGE: *(.+)|#EXT-X-PROGRAM-DATE-TIME:(.+)|#.*/g;var LEVEL_PLAYLIST_REGEX_SLOW=/(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;var LevelKey=function(){function LevelKey(){_classCallCheck(this,LevelKey);this.method=null;this.key=null;this.iv=null;this._uri=null;}_createClass(LevelKey,[{key:'uri',get:function get(){if(!this._uri&&this.reluri){this._uri=_urlToolkit2.default.buildAbsoluteURL(this.baseuri,this.reluri,{alwaysNormalize:true});}return this._uri;}}]);return LevelKey;}();var Fragment=function(){function Fragment(){_classCallCheck(this,Fragment);this._url=null;this._byteRange=null;this._decryptdata=null;this.tagList=[];}_createClass(Fragment,[{key:'createInitializationVector',/**
     * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
     * @returns {Uint8Array}
     */value:function createInitializationVector(segmentNumber){var uint8View=new Uint8Array(16);for(var i=12;i<16;i++){uint8View[i]=segmentNumber>>8*(15-i)&0xff;}return uint8View;}/**
     * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
     * @param levelkey - a playlist's encryption info
     * @param segmentNumber - the fragment's segment number
     * @returns {*} - an object to be applied as a fragment's decryptdata
     */},{key:'fragmentDecryptdataFromLevelkey',value:function fragmentDecryptdataFromLevelkey(levelkey,segmentNumber){var decryptdata=levelkey;if(levelkey&&levelkey.method&&levelkey.uri&&!levelkey.iv){decryptdata=new LevelKey();decryptdata.method=levelkey.method;decryptdata.baseuri=levelkey.baseuri;decryptdata.reluri=levelkey.reluri;decryptdata.iv=this.createInitializationVector(segmentNumber);}return decryptdata;}},{key:'cloneObj',value:function cloneObj(obj){return JSON.parse(JSON.stringify(obj));}},{key:'url',get:function get(){if(!this._url&&this.relurl){this._url=_urlToolkit2.default.buildAbsoluteURL(this.baseurl,this.relurl,{alwaysNormalize:true});}return this._url;},set:function set(value){this._url=value;}},{key:'programDateTime',get:function get(){if(!this._programDateTime&&this.rawProgramDateTime){this._programDateTime=new Date(Date.parse(this.rawProgramDateTime));}return this._programDateTime;}},{key:'byteRange',get:function get(){if(!this._byteRange){var byteRange=this._byteRange=[];if(this.rawByteRange){var params=this.rawByteRange.split('@',2);if(params.length===1){var lastByteRangeEndOffset=this.lastByteRangeEndOffset;byteRange[0]=lastByteRangeEndOffset?lastByteRangeEndOffset:0;}else{byteRange[0]=parseInt(params[1]);}byteRange[1]=parseInt(params[0])+byteRange[0];}}return this._byteRange;}},{key:'byteRangeStartOffset',get:function get(){return this.byteRange[0];}},{key:'byteRangeEndOffset',get:function get(){return this.byteRange[1];}},{key:'decryptdata',get:function get(){if(!this._decryptdata){this._decryptdata=this.fragmentDecryptdataFromLevelkey(this.levelkey,this.sn);}return this._decryptdata;}}]);return Fragment;}();var PlaylistLoader=function(_EventHandler){_inherits(PlaylistLoader,_EventHandler);function PlaylistLoader(hls){_classCallCheck(this,PlaylistLoader);var _this=_possibleConstructorReturn(this,(PlaylistLoader.__proto__||Object.getPrototypeOf(PlaylistLoader)).call(this,hls,_events2.default.MANIFEST_LOADING,_events2.default.LEVEL_LOADING,_events2.default.AUDIO_TRACK_LOADING,_events2.default.SUBTITLE_TRACK_LOADING));_this.loaders={};return _this;}_createClass(PlaylistLoader,[{key:'destroy',value:function destroy(){for(var loaderName in this.loaders){var loader=this.loaders[loaderName];if(loader){loader.destroy();}}this.loaders={};_eventHandler2.default.prototype.destroy.call(this);}},{key:'onManifestLoading',value:function onManifestLoading(data){this.load(data.url,{type:'manifest'});}},{key:'onLevelLoading',value:function onLevelLoading(data){this.load(data.url,{type:'level',level:data.level,id:data.id});}},{key:'onAudioTrackLoading',value:function onAudioTrackLoading(data){this.load(data.url,{type:'audioTrack',id:data.id});}},{key:'onSubtitleTrackLoading',value:function onSubtitleTrackLoading(data){this.load(data.url,{type:'subtitleTrack',id:data.id});}},{key:'load',value:function load(url,context){var loader=this.loaders[context.type];if(loader){var loaderContext=loader.context;if(loaderContext&&loaderContext.url===url){_logger.logger.trace('playlist request ongoing');return;}else{_logger.logger.warn('abort previous loader for type:'+context.type);loader.abort();}}var config=this.hls.config,retry=void 0,timeout=void 0,retryDelay=void 0,maxRetryDelay=void 0;if(context.type==='manifest'){retry=config.manifestLoadingMaxRetry;timeout=config.manifestLoadingTimeOut;retryDelay=config.manifestLoadingRetryDelay;maxRetryDelay=config.manifestLoadingMaxRetryTimeout;}else{retry=config.levelLoadingMaxRetry;timeout=config.levelLoadingTimeOut;retryDelay=config.levelLoadingRetryDelay;maxRetryDelay=config.levelLoadingMaxRetryTimeout;_logger.logger.log('loading playlist for '+context.type+' '+(context.level||context.id));}loader=this.loaders[context.type]=context.loader=typeof config.pLoader!=='undefined'?new config.pLoader(config):new config.loader(config);context.url=url;context.responseType='';var loaderConfig=void 0,loaderCallbacks=void 0;loaderConfig={timeout:timeout,maxRetry:retry,retryDelay:retryDelay,maxRetryDelay:maxRetryDelay};loaderCallbacks={onSuccess:this.loadsuccess.bind(this),onError:this.loaderror.bind(this),onTimeout:this.loadtimeout.bind(this)};loader.load(context,loaderConfig,loaderCallbacks);}},{key:'resolve',value:function resolve(url,baseUrl){return _urlToolkit2.default.buildAbsoluteURL(baseUrl,url,{alwaysNormalize:true});}},{key:'parseMasterPlaylist',value:function parseMasterPlaylist(string,baseurl){var levels=[],result=void 0;MASTER_PLAYLIST_REGEX.lastIndex=0;while((result=MASTER_PLAYLIST_REGEX.exec(string))!=null){var level={};var attrs=level.attrs=new _attrList2.default(result[1]);level.url=this.resolve(result[2],baseurl);var resolution=attrs.decimalResolution('RESOLUTION');if(resolution){level.width=resolution.width;level.height=resolution.height;}level.bitrate=attrs.decimalInteger('AVERAGE-BANDWIDTH')||attrs.decimalInteger('BANDWIDTH');level.name=attrs.NAME;var codecs=attrs.CODECS;if(codecs){codecs=codecs.split(/[ ,]+/);for(var i=0;i<codecs.length;i++){var codec=codecs[i];if(codec.indexOf('avc1')!==-1){level.videoCodec=this.avc1toavcoti(codec);}else{level.audioCodec=codec;}}}levels.push(level);}return levels;}},{key:'parseMasterPlaylistMedia',value:function parseMasterPlaylistMedia(string,baseurl,type){var result=void 0,medias=[],id=0;MASTER_PLAYLIST_MEDIA_REGEX.lastIndex=0;while((result=MASTER_PLAYLIST_MEDIA_REGEX.exec(string))!=null){var media={};var attrs=new _attrList2.default(result[1]);if(attrs.TYPE===type){media.groupId=attrs['GROUP-ID'];media.name=attrs.NAME;media.type=type;media.default=attrs.DEFAULT==='YES';media.autoselect=attrs.AUTOSELECT==='YES';media.forced=attrs.FORCED==='YES';if(attrs.URI){media.url=this.resolve(attrs.URI,baseurl);}media.lang=attrs.LANGUAGE;if(!media.name){media.name=media.lang;}media.id=id++;medias.push(media);}}return medias;}},{key:'avc1toavcoti',value:function avc1toavcoti(codec){var result,avcdata=codec.split('.');if(avcdata.length>2){result=avcdata.shift()+'.';result+=parseInt(avcdata.shift()).toString(16);result+=('000'+parseInt(avcdata.shift()).toString(16)).substr(-4);}else{result=codec;}return result;}},{key:'parseLevelPlaylist',value:function parseLevelPlaylist(string,baseurl,id,type){var currentSN=0,totalduration=0,level={type:null,version:null,url:baseurl,fragments:[],live:true,startSN:0},levelkey=new LevelKey(),cc=0,prevFrag=null,frag=new Fragment(),result,i;LEVEL_PLAYLIST_REGEX_FAST.lastIndex=0;while((result=LEVEL_PLAYLIST_REGEX_FAST.exec(string))!==null){var duration=result[1];if(duration){// INF
frag.duration=parseFloat(duration);// avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
var title=(' '+result[2]).slice(1);frag.title=title?title:null;frag.tagList.push(title?['INF',duration,title]:['INF',duration]);}else if(result[3]){// url
if(!isNaN(frag.duration)){var sn=currentSN++;frag.type=type;frag.start=totalduration;frag.levelkey=levelkey;frag.sn=sn;frag.level=id;frag.cc=cc;frag.baseurl=baseurl;// avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
frag.relurl=(' '+result[3]).slice(1);level.fragments.push(frag);prevFrag=frag;totalduration+=frag.duration;frag=new Fragment();}}else if(result[4]){// X-BYTERANGE
frag.rawByteRange=(' '+result[4]).slice(1);if(prevFrag){var lastByteRangeEndOffset=prevFrag.byteRangeEndOffset;if(lastByteRangeEndOffset){frag.lastByteRangeEndOffset=lastByteRangeEndOffset;}}}else if(result[5]){// PROGRAM-DATE-TIME
// avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
frag.rawProgramDateTime=(' '+result[5]).slice(1);frag.tagList.push(['PROGRAM-DATE-TIME',frag.rawProgramDateTime]);}else{result=result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);for(i=1;i<result.length;i++){if(result[i]!==undefined){break;}}// avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
var value1=(' '+result[i+1]).slice(1);var value2=(' '+result[i+2]).slice(1);switch(result[i]){case'#':frag.tagList.push(value2?[value1,value2]:[value1]);break;case'PLAYLIST-TYPE':level.type=value1.toUpperCase();break;case'MEDIA-SEQUENCE':currentSN=level.startSN=parseInt(value1);break;case'TARGETDURATION':level.targetduration=parseFloat(value1);break;case'VERSION':level.version=parseInt(value1);break;case'EXTM3U':break;case'ENDLIST':level.live=false;break;case'DIS':cc++;frag.tagList.push(['DIS']);break;case'DISCONTINUITY-SEQ':cc=parseInt(value1);break;case'KEY':// https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
var decryptparams=value1;var keyAttrs=new _attrList2.default(decryptparams);var decryptmethod=keyAttrs.enumeratedString('METHOD'),decrypturi=keyAttrs.URI,decryptiv=keyAttrs.hexadecimalInteger('IV');if(decryptmethod){levelkey=new LevelKey();if(decrypturi&&['AES-128','SAMPLE-AES'].indexOf(decryptmethod)>=0){levelkey.method=decryptmethod;// URI to get the key
levelkey.baseuri=baseurl;levelkey.reluri=decrypturi;levelkey.key=null;// Initialization Vector (IV)
levelkey.iv=decryptiv;}}break;case'START':var startParams=value1;var startAttrs=new _attrList2.default(startParams);var startTimeOffset=startAttrs.decimalFloatingPoint('TIME-OFFSET');//TIME-OFFSET can be 0
if(!isNaN(startTimeOffset)){level.startTimeOffset=startTimeOffset;}break;case'MAP':var mapAttrs=new _attrList2.default(value1);frag.relurl=mapAttrs.URI;frag.rawByteRange=mapAttrs.BYTERANGE;frag.baseurl=baseurl;frag.level=id;frag.type=type;frag.sn='initSegment';level.initSegment=frag;frag=new Fragment();break;default:_logger.logger.warn('line parsed but not handled: '+result);break;}}}frag=prevFrag;//logger.log('found ' + level.fragments.length + ' fragments');
if(frag&&!frag.relurl){level.fragments.pop();totalduration-=frag.duration;}level.totalduration=totalduration;level.averagetargetduration=totalduration/level.fragments.length;level.endSN=currentSN-1;return level;}},{key:'loadsuccess',value:function loadsuccess(response,stats,context){var string=response.data,url=response.url,type=context.type,id=context.id,level=context.level,hls=this.hls;this.loaders[type]=undefined;// responseURL not supported on some browsers (it is used to detect URL redirection)
// data-uri mode also not supported (but no need to detect redirection)
if(url===undefined||url.indexOf('data:')===0){// fallback to initial URL
url=context.url;}stats.tload=performance.now();//stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
if(string.indexOf('#EXTM3U')===0){if(string.indexOf('#EXTINF:')>0){var isLevel=type!=='audioTrack'&&type!=='subtitleTrack',levelId=!isNaN(level)?level:!isNaN(id)?id:0,levelDetails=this.parseLevelPlaylist(string,url,levelId,type==='audioTrack'?'audio':type==='subtitleTrack'?'subtitle':'main');levelDetails.tload=stats.tload;if(type==='manifest'){// first request, stream manifest (no master playlist), fire manifest loaded event with level details
hls.trigger(_events2.default.MANIFEST_LOADED,{levels:[{url:url,details:levelDetails}],audioTracks:[],url:url,stats:stats});}stats.tparsed=performance.now();if(levelDetails.targetduration){if(isLevel){hls.trigger(_events2.default.LEVEL_LOADED,{details:levelDetails,level:level||0,id:id||0,stats:stats});}else{if(type==='audioTrack'){hls.trigger(_events2.default.AUDIO_TRACK_LOADED,{details:levelDetails,id:id,stats:stats});}else if(type==='subtitleTrack'){hls.trigger(_events2.default.SUBTITLE_TRACK_LOADED,{details:levelDetails,id:id,stats:stats});}}}else{hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.NETWORK_ERROR,details:_errors.ErrorDetails.MANIFEST_PARSING_ERROR,fatal:true,url:url,reason:'invalid targetduration'});}}else{var levels=this.parseMasterPlaylist(string,url);// multi level playlist, parse level info
if(levels.length){var audioTracks=this.parseMasterPlaylistMedia(string,url,'AUDIO');var subtitles=this.parseMasterPlaylistMedia(string,url,'SUBTITLES');if(audioTracks.length){// check if we have found an audio track embedded in main playlist (audio track without URI attribute)
var embeddedAudioFound=false;audioTracks.forEach(function(audioTrack){if(!audioTrack.url){embeddedAudioFound=true;}});// if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track
// this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled
if(embeddedAudioFound===false&&levels[0].audioCodec&&!levels[0].attrs.AUDIO){_logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');audioTracks.unshift({type:'main',name:'main'});}}hls.trigger(_events2.default.MANIFEST_LOADED,{levels:levels,audioTracks:audioTracks,subtitles:subtitles,url:url,stats:stats});}else{hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.NETWORK_ERROR,details:_errors.ErrorDetails.MANIFEST_PARSING_ERROR,fatal:true,url:url,reason:'no level found in manifest'});}}}else{hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.NETWORK_ERROR,details:_errors.ErrorDetails.MANIFEST_PARSING_ERROR,fatal:true,url:url,reason:'no EXTM3U delimiter'});}}},{key:'loaderror',value:function loaderror(response,context){var details,fatal,loader=context.loader;switch(context.type){case'manifest':details=_errors.ErrorDetails.MANIFEST_LOAD_ERROR;fatal=true;break;case'level':details=_errors.ErrorDetails.LEVEL_LOAD_ERROR;fatal=false;break;case'audioTrack':details=_errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;fatal=false;break;}if(loader){loader.abort();this.loaders[context.type]=undefined;}this.hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.NETWORK_ERROR,details:details,fatal:fatal,url:loader.url,loader:loader,response:response,context:context});}},{key:'loadtimeout',value:function loadtimeout(stats,context){var details,fatal,loader=context.loader;switch(context.type){case'manifest':details=_errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT;fatal=true;break;case'level':details=_errors.ErrorDetails.LEVEL_LOAD_TIMEOUT;fatal=false;break;case'audioTrack':details=_errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT;fatal=false;break;}if(loader){loader.abort();this.loaders[context.type]=undefined;}this.hls.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.NETWORK_ERROR,details:details,fatal:fatal,url:loader.url,loader:loader,context:context});}}]);return PlaylistLoader;}(_eventHandler2.default);exports.default=PlaylistLoader;},{"2":2,"33":33,"34":34,"35":35,"47":47,"53":53}],44:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}/**
 * Generate MP4 Box
*///import Hex from '../utils/hex';
var UINT32_MAX=Math.pow(2,32)-1;var MP4=function(){function MP4(){_classCallCheck(this,MP4);}_createClass(MP4,null,[{key:'init',value:function init(){MP4.types={avc1:[],// codingname
avcC:[],btrt:[],dinf:[],dref:[],esds:[],ftyp:[],hdlr:[],mdat:[],mdhd:[],mdia:[],mfhd:[],minf:[],moof:[],moov:[],mp4a:[],'.mp3':[],mvex:[],mvhd:[],pasp:[],sdtp:[],stbl:[],stco:[],stsc:[],stsd:[],stsz:[],stts:[],tfdt:[],tfhd:[],traf:[],trak:[],trun:[],trex:[],tkhd:[],vmhd:[],smhd:[]};var i;for(i in MP4.types){if(MP4.types.hasOwnProperty(i)){MP4.types[i]=[i.charCodeAt(0),i.charCodeAt(1),i.charCodeAt(2),i.charCodeAt(3)];}}var videoHdlr=new Uint8Array([0x00,// version 0
0x00,0x00,0x00,// flags
0x00,0x00,0x00,0x00,// pre_defined
0x76,0x69,0x64,0x65,// handler_type: 'vide'
0x00,0x00,0x00,0x00,// reserved
0x00,0x00,0x00,0x00,// reserved
0x00,0x00,0x00,0x00,// reserved
0x56,0x69,0x64,0x65,0x6f,0x48,0x61,0x6e,0x64,0x6c,0x65,0x72,0x00// name: 'VideoHandler'
]);var audioHdlr=new Uint8Array([0x00,// version 0
0x00,0x00,0x00,// flags
0x00,0x00,0x00,0x00,// pre_defined
0x73,0x6f,0x75,0x6e,// handler_type: 'soun'
0x00,0x00,0x00,0x00,// reserved
0x00,0x00,0x00,0x00,// reserved
0x00,0x00,0x00,0x00,// reserved
0x53,0x6f,0x75,0x6e,0x64,0x48,0x61,0x6e,0x64,0x6c,0x65,0x72,0x00// name: 'SoundHandler'
]);MP4.HDLR_TYPES={'video':videoHdlr,'audio':audioHdlr};var dref=new Uint8Array([0x00,// version 0
0x00,0x00,0x00,// flags
0x00,0x00,0x00,0x01,// entry_count
0x00,0x00,0x00,0x0c,// entry_size
0x75,0x72,0x6c,0x20,// 'url' type
0x00,// version 0
0x00,0x00,0x01// entry_flags
]);var stco=new Uint8Array([0x00,// version
0x00,0x00,0x00,// flags
0x00,0x00,0x00,0x00// entry_count
]);MP4.STTS=MP4.STSC=MP4.STCO=stco;MP4.STSZ=new Uint8Array([0x00,// version
0x00,0x00,0x00,// flags
0x00,0x00,0x00,0x00,// sample_size
0x00,0x00,0x00,0x00]);MP4.VMHD=new Uint8Array([0x00,// version
0x00,0x00,0x01,// flags
0x00,0x00,// graphicsmode
0x00,0x00,0x00,0x00,0x00,0x00// opcolor
]);MP4.SMHD=new Uint8Array([0x00,// version
0x00,0x00,0x00,// flags
0x00,0x00,// balance
0x00,0x00// reserved
]);MP4.STSD=new Uint8Array([0x00,// version 0
0x00,0x00,0x00,// flags
0x00,0x00,0x00,0x01]);// entry_count
var majorBrand=new Uint8Array([105,115,111,109]);// isom
var avc1Brand=new Uint8Array([97,118,99,49]);// avc1
var minorVersion=new Uint8Array([0,0,0,1]);MP4.FTYP=MP4.box(MP4.types.ftyp,majorBrand,minorVersion,majorBrand,avc1Brand);MP4.DINF=MP4.box(MP4.types.dinf,MP4.box(MP4.types.dref,dref));}},{key:'box',value:function box(type){var payload=Array.prototype.slice.call(arguments,1),size=8,i=payload.length,len=i,result;// calculate the total size we need to allocate
while(i--){size+=payload[i].byteLength;}result=new Uint8Array(size);result[0]=size>>24&0xff;result[1]=size>>16&0xff;result[2]=size>>8&0xff;result[3]=size&0xff;result.set(type,4);// copy the payload into the result
for(i=0,size=8;i<len;i++){// copy payload[i] array @ offset size
result.set(payload[i],size);size+=payload[i].byteLength;}return result;}},{key:'hdlr',value:function hdlr(type){return MP4.box(MP4.types.hdlr,MP4.HDLR_TYPES[type]);}},{key:'mdat',value:function mdat(data){return MP4.box(MP4.types.mdat,data);}},{key:'mdhd',value:function mdhd(timescale,duration){duration*=timescale;var upperWordDuration=Math.floor(duration/(UINT32_MAX+1));var lowerWordDuration=Math.floor(duration%(UINT32_MAX+1));return MP4.box(MP4.types.mdhd,new Uint8Array([0x01,// version 1
0x00,0x00,0x00,// flags
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,// creation_time
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,// modification_time
timescale>>24&0xFF,timescale>>16&0xFF,timescale>>8&0xFF,timescale&0xFF,// timescale
upperWordDuration>>24,upperWordDuration>>16&0xFF,upperWordDuration>>8&0xFF,upperWordDuration&0xFF,lowerWordDuration>>24,lowerWordDuration>>16&0xFF,lowerWordDuration>>8&0xFF,lowerWordDuration&0xFF,0x55,0xc4,// 'und' language (undetermined)
0x00,0x00]));}},{key:'mdia',value:function mdia(track){return MP4.box(MP4.types.mdia,MP4.mdhd(track.timescale,track.duration),MP4.hdlr(track.type),MP4.minf(track));}},{key:'mfhd',value:function mfhd(sequenceNumber){return MP4.box(MP4.types.mfhd,new Uint8Array([0x00,0x00,0x00,0x00,// flags
sequenceNumber>>24,sequenceNumber>>16&0xFF,sequenceNumber>>8&0xFF,sequenceNumber&0xFF]));}},{key:'minf',value:function minf(track){if(track.type==='audio'){return MP4.box(MP4.types.minf,MP4.box(MP4.types.smhd,MP4.SMHD),MP4.DINF,MP4.stbl(track));}else{return MP4.box(MP4.types.minf,MP4.box(MP4.types.vmhd,MP4.VMHD),MP4.DINF,MP4.stbl(track));}}},{key:'moof',value:function moof(sn,baseMediaDecodeTime,track){return MP4.box(MP4.types.moof,MP4.mfhd(sn),MP4.traf(track,baseMediaDecodeTime));}/**
     * @param tracks... (optional) {array} the tracks associated with this movie
     */},{key:'moov',value:function moov(tracks){var i=tracks.length,boxes=[];while(i--){boxes[i]=MP4.trak(tracks[i]);}return MP4.box.apply(null,[MP4.types.moov,MP4.mvhd(tracks[0].timescale,tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));}},{key:'mvex',value:function mvex(tracks){var i=tracks.length,boxes=[];while(i--){boxes[i]=MP4.trex(tracks[i]);}return MP4.box.apply(null,[MP4.types.mvex].concat(boxes));}},{key:'mvhd',value:function mvhd(timescale,duration){duration*=timescale;var upperWordDuration=Math.floor(duration/(UINT32_MAX+1));var lowerWordDuration=Math.floor(duration%(UINT32_MAX+1));var bytes=new Uint8Array([0x01,// version 1
0x00,0x00,0x00,// flags
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,// creation_time
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,// modification_time
timescale>>24&0xFF,timescale>>16&0xFF,timescale>>8&0xFF,timescale&0xFF,// timescale
upperWordDuration>>24,upperWordDuration>>16&0xFF,upperWordDuration>>8&0xFF,upperWordDuration&0xFF,lowerWordDuration>>24,lowerWordDuration>>16&0xFF,lowerWordDuration>>8&0xFF,lowerWordDuration&0xFF,0x00,0x01,0x00,0x00,// 1.0 rate
0x01,0x00,// 1.0 volume
0x00,0x00,// reserved
0x00,0x00,0x00,0x00,// reserved
0x00,0x00,0x00,0x00,// reserved
0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,// transformation: unity matrix
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// pre_defined
0xff,0xff,0xff,0xff// next_track_ID
]);return MP4.box(MP4.types.mvhd,bytes);}},{key:'sdtp',value:function sdtp(track){var samples=track.samples||[],bytes=new Uint8Array(4+samples.length),flags,i;// leave the full box header (4 bytes) all zero
// write the sample table
for(i=0;i<samples.length;i++){flags=samples[i].flags;bytes[i+4]=flags.dependsOn<<4|flags.isDependedOn<<2|flags.hasRedundancy;}return MP4.box(MP4.types.sdtp,bytes);}},{key:'stbl',value:function stbl(track){return MP4.box(MP4.types.stbl,MP4.stsd(track),MP4.box(MP4.types.stts,MP4.STTS),MP4.box(MP4.types.stsc,MP4.STSC),MP4.box(MP4.types.stsz,MP4.STSZ),MP4.box(MP4.types.stco,MP4.STCO));}},{key:'avc1',value:function avc1(track){var sps=[],pps=[],i,data,len;// assemble the SPSs
for(i=0;i<track.sps.length;i++){data=track.sps[i];len=data.byteLength;sps.push(len>>>8&0xFF);sps.push(len&0xFF);sps=sps.concat(Array.prototype.slice.call(data));// SPS
}// assemble the PPSs
for(i=0;i<track.pps.length;i++){data=track.pps[i];len=data.byteLength;pps.push(len>>>8&0xFF);pps.push(len&0xFF);pps=pps.concat(Array.prototype.slice.call(data));}var avcc=MP4.box(MP4.types.avcC,new Uint8Array([0x01,// version
sps[3],// profile
sps[4],// profile compat
sps[5],// level
0xfc|3,// lengthSizeMinusOne, hard-coded to 4 bytes
0xE0|track.sps.length// 3bit reserved (111) + numOfSequenceParameterSets
].concat(sps).concat([track.pps.length// numOfPictureParameterSets
]).concat(pps))),// "PPS"
width=track.width,height=track.height,hSpacing=track.pixelRatio[0],vSpacing=track.pixelRatio[1];//console.log('avcc:' + Hex.hexDump(avcc));
return MP4.box(MP4.types.avc1,new Uint8Array([0x00,0x00,0x00,// reserved
0x00,0x00,0x00,// reserved
0x00,0x01,// data_reference_index
0x00,0x00,// pre_defined
0x00,0x00,// reserved
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// pre_defined
width>>8&0xFF,width&0xff,// width
height>>8&0xFF,height&0xff,// height
0x00,0x48,0x00,0x00,// horizresolution
0x00,0x48,0x00,0x00,// vertresolution
0x00,0x00,0x00,0x00,// reserved
0x00,0x01,// frame_count
0x12,0x64,0x61,0x69,0x6C,//dailymotion/hls.js
0x79,0x6D,0x6F,0x74,0x69,0x6F,0x6E,0x2F,0x68,0x6C,0x73,0x2E,0x6A,0x73,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// compressorname
0x00,0x18,// depth = 24
0x11,0x11]),// pre_defined = -1
avcc,MP4.box(MP4.types.btrt,new Uint8Array([0x00,0x1c,0x9c,0x80,// bufferSizeDB
0x00,0x2d,0xc6,0xc0,// maxBitrate
0x00,0x2d,0xc6,0xc0])),// avgBitrate
MP4.box(MP4.types.pasp,new Uint8Array([hSpacing>>24,// hSpacing
hSpacing>>16&0xFF,hSpacing>>8&0xFF,hSpacing&0xFF,vSpacing>>24,// vSpacing
vSpacing>>16&0xFF,vSpacing>>8&0xFF,vSpacing&0xFF])));}},{key:'esds',value:function esds(track){var configlen=track.config.length;return new Uint8Array([0x00,// version 0
0x00,0x00,0x00,// flags
0x03,// descriptor_type
0x17+configlen,// length
0x00,0x01,//es_id
0x00,// stream_priority
0x04,// descriptor_type
0x0f+configlen,// length
0x40,//codec : mpeg4_audio
0x15,// stream_type
0x00,0x00,0x00,// buffer_size
0x00,0x00,0x00,0x00,// maxBitrate
0x00,0x00,0x00,0x00,// avgBitrate
0x05// descriptor_type
].concat([configlen]).concat(track.config).concat([0x06,0x01,0x02]));// GASpecificConfig)); // length + audio config descriptor
}},{key:'mp4a',value:function mp4a(track){var samplerate=track.samplerate;return MP4.box(MP4.types.mp4a,new Uint8Array([0x00,0x00,0x00,// reserved
0x00,0x00,0x00,// reserved
0x00,0x01,// data_reference_index
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// reserved
0x00,track.channelCount,// channelcount
0x00,0x10,// sampleSize:16bits
0x00,0x00,0x00,0x00,// reserved2
samplerate>>8&0xFF,samplerate&0xff,//
0x00,0x00]),MP4.box(MP4.types.esds,MP4.esds(track)));}},{key:'mp3',value:function mp3(track){var samplerate=track.samplerate;return MP4.box(MP4.types['.mp3'],new Uint8Array([0x00,0x00,0x00,// reserved
0x00,0x00,0x00,// reserved
0x00,0x01,// data_reference_index
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// reserved
0x00,track.channelCount,// channelcount
0x00,0x10,// sampleSize:16bits
0x00,0x00,0x00,0x00,// reserved2
samplerate>>8&0xFF,samplerate&0xff,//
0x00,0x00]));}},{key:'stsd',value:function stsd(track){if(track.type==='audio'){if(!track.isAAC&&track.codec==='mp3'){return MP4.box(MP4.types.stsd,MP4.STSD,MP4.mp3(track));}return MP4.box(MP4.types.stsd,MP4.STSD,MP4.mp4a(track));}else{return MP4.box(MP4.types.stsd,MP4.STSD,MP4.avc1(track));}}},{key:'tkhd',value:function tkhd(track){var id=track.id,duration=track.duration*track.timescale,width=track.width,height=track.height,upperWordDuration=Math.floor(duration/(UINT32_MAX+1)),lowerWordDuration=Math.floor(duration%(UINT32_MAX+1));return MP4.box(MP4.types.tkhd,new Uint8Array([0x01,// version 1
0x00,0x00,0x07,// flags
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,// creation_time
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,// modification_time
id>>24&0xFF,id>>16&0xFF,id>>8&0xFF,id&0xFF,// track_ID
0x00,0x00,0x00,0x00,// reserved
upperWordDuration>>24,upperWordDuration>>16&0xFF,upperWordDuration>>8&0xFF,upperWordDuration&0xFF,lowerWordDuration>>24,lowerWordDuration>>16&0xFF,lowerWordDuration>>8&0xFF,lowerWordDuration&0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// reserved
0x00,0x00,// layer
0x00,0x00,// alternate_group
0x00,0x00,// non-audio track volume
0x00,0x00,// reserved
0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,// transformation: unity matrix
width>>8&0xFF,width&0xFF,0x00,0x00,// width
height>>8&0xFF,height&0xFF,0x00,0x00// height
]));}},{key:'traf',value:function traf(track,baseMediaDecodeTime){var sampleDependencyTable=MP4.sdtp(track),id=track.id,upperWordBaseMediaDecodeTime=Math.floor(baseMediaDecodeTime/(UINT32_MAX+1)),lowerWordBaseMediaDecodeTime=Math.floor(baseMediaDecodeTime%(UINT32_MAX+1));return MP4.box(MP4.types.traf,MP4.box(MP4.types.tfhd,new Uint8Array([0x00,// version 0
0x00,0x00,0x00,// flags
id>>24,id>>16&0XFF,id>>8&0XFF,id&0xFF])),MP4.box(MP4.types.tfdt,new Uint8Array([0x01,// version 1
0x00,0x00,0x00,// flags
upperWordBaseMediaDecodeTime>>24,upperWordBaseMediaDecodeTime>>16&0XFF,upperWordBaseMediaDecodeTime>>8&0XFF,upperWordBaseMediaDecodeTime&0xFF,lowerWordBaseMediaDecodeTime>>24,lowerWordBaseMediaDecodeTime>>16&0XFF,lowerWordBaseMediaDecodeTime>>8&0XFF,lowerWordBaseMediaDecodeTime&0xFF])),MP4.trun(track,sampleDependencyTable.length+16+// tfhd
20+// tfdt
8+// traf header
16+// mfhd
8+// moof header
8),// mdat header
sampleDependencyTable);}/**
     * Generate a track box.
     * @param track {object} a track definition
     * @return {Uint8Array} the track box
     */},{key:'trak',value:function trak(track){track.duration=track.duration||0xffffffff;return MP4.box(MP4.types.trak,MP4.tkhd(track),MP4.mdia(track));}},{key:'trex',value:function trex(track){var id=track.id;return MP4.box(MP4.types.trex,new Uint8Array([0x00,// version 0
0x00,0x00,0x00,// flags
id>>24,id>>16&0XFF,id>>8&0XFF,id&0xFF,// track_ID
0x00,0x00,0x00,0x01,// default_sample_description_index
0x00,0x00,0x00,0x00,// default_sample_duration
0x00,0x00,0x00,0x00,// default_sample_size
0x00,0x01,0x00,0x01// default_sample_flags
]));}},{key:'trun',value:function trun(track,offset){var samples=track.samples||[],len=samples.length,arraylen=12+16*len,array=new Uint8Array(arraylen),i,sample,duration,size,flags,cts;offset+=8+arraylen;array.set([0x00,// version 0
0x00,0x0f,0x01,// flags
len>>>24&0xFF,len>>>16&0xFF,len>>>8&0xFF,len&0xFF,// sample_count
offset>>>24&0xFF,offset>>>16&0xFF,offset>>>8&0xFF,offset&0xFF// data_offset
],0);for(i=0;i<len;i++){sample=samples[i];duration=sample.duration;size=sample.size;flags=sample.flags;cts=sample.cts;array.set([duration>>>24&0xFF,duration>>>16&0xFF,duration>>>8&0xFF,duration&0xFF,// sample_duration
size>>>24&0xFF,size>>>16&0xFF,size>>>8&0xFF,size&0xFF,// sample_size
flags.isLeading<<2|flags.dependsOn,flags.isDependedOn<<6|flags.hasRedundancy<<4|flags.paddingValue<<1|flags.isNonSync,flags.degradPrio&0xF0<<8,flags.degradPrio&0x0F,// sample_flags
cts>>>24&0xFF,cts>>>16&0xFF,cts>>>8&0xFF,cts&0xFF// sample_composition_time_offset
],12+16*i);}return MP4.box(MP4.types.trun,array);}},{key:'initSegment',value:function initSegment(tracks){if(!MP4.types){MP4.init();}var movie=MP4.moov(tracks),result;result=new Uint8Array(MP4.FTYP.byteLength+movie.byteLength);result.set(MP4.FTYP);result.set(movie,MP4.FTYP.byteLength);return result;}}]);return MP4;}();exports.default=MP4;},{}],45:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */var _aac=_dereq_(36);var _aac2=_interopRequireDefault(_aac);var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);var _logger=_dereq_(53);var _mp4Generator=_dereq_(44);var _mp4Generator2=_interopRequireDefault(_mp4Generator);var _errors=_dereq_(33);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}// 10 seconds
var MAX_SILENT_FRAME_DURATION=10*1000;var MP4Remuxer=function(){function MP4Remuxer(observer,config,typeSupported,vendor){_classCallCheck(this,MP4Remuxer);this.observer=observer;this.config=config;this.typeSupported=typeSupported;var userAgent=navigator.userAgent;this.isSafari=vendor&&vendor.indexOf('Apple')>-1&&userAgent&&!userAgent.match('CriOS');this.ISGenerated=false;}_createClass(MP4Remuxer,[{key:'destroy',value:function destroy(){}},{key:'resetTimeStamp',value:function resetTimeStamp(defaultTimeStamp){this._initPTS=this._initDTS=defaultTimeStamp;}},{key:'resetInitSegment',value:function resetInitSegment(){this.ISGenerated=false;}},{key:'remux',value:function remux(audioTrack,videoTrack,id3Track,textTrack,timeOffset,contiguous,accurateTimeOffset){// generate Init Segment if needed
if(!this.ISGenerated){this.generateIS(audioTrack,videoTrack,timeOffset);}if(this.ISGenerated){// Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
// calculated in remuxAudio.
//logger.log('nb AAC samples:' + audioTrack.samples.length);
if(audioTrack.samples.length){// if initSegment was generated without video samples, regenerate it again
if(!audioTrack.timescale){_logger.logger.warn('regenerate InitSegment as audio detected');this.generateIS(audioTrack,videoTrack,timeOffset);}var audioData=this.remuxAudio(audioTrack,timeOffset,contiguous,accurateTimeOffset);//logger.log('nb AVC samples:' + videoTrack.samples.length);
if(videoTrack.samples.length){var audioTrackLength=void 0;if(audioData){audioTrackLength=audioData.endPTS-audioData.startPTS;}// if initSegment was generated without video samples, regenerate it again
if(!videoTrack.timescale){_logger.logger.warn('regenerate InitSegment as video detected');this.generateIS(audioTrack,videoTrack,timeOffset);}this.remuxVideo(videoTrack,timeOffset,contiguous,audioTrackLength,accurateTimeOffset);}}else{var videoData=void 0;//logger.log('nb AVC samples:' + videoTrack.samples.length);
if(videoTrack.samples.length){videoData=this.remuxVideo(videoTrack,timeOffset,contiguous,accurateTimeOffset);}if(videoData&&audioTrack.codec){this.remuxEmptyAudio(audioTrack,timeOffset,contiguous,videoData);}}}//logger.log('nb ID3 samples:' + audioTrack.samples.length);
if(id3Track.samples.length){this.remuxID3(id3Track,timeOffset);}//logger.log('nb ID3 samples:' + audioTrack.samples.length);
if(textTrack.samples.length){this.remuxText(textTrack,timeOffset);}//notify end of parsing
this.observer.trigger(_events2.default.FRAG_PARSED);}},{key:'generateIS',value:function generateIS(audioTrack,videoTrack,timeOffset){var observer=this.observer,audioSamples=audioTrack.samples,videoSamples=videoTrack.samples,typeSupported=this.typeSupported,container='audio/mp4',tracks={},data={tracks:tracks},computePTSDTS=this._initPTS===undefined,initPTS,initDTS;if(computePTSDTS){initPTS=initDTS=Infinity;}if(audioTrack.config&&audioSamples.length){// let's use audio sampling rate as MP4 time scale.
// rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
// using audio sampling rate here helps having an integer MP4 frame duration
// this avoids potential rounding issue and AV sync issue
audioTrack.timescale=audioTrack.samplerate;_logger.logger.log('audio sampling rate : '+audioTrack.samplerate);if(!audioTrack.isAAC){if(typeSupported.mpeg){// Chrome and Safari
container='audio/mpeg';audioTrack.codec='';}else if(typeSupported.mp3){// Firefox
audioTrack.codec='mp3';}}tracks.audio={container:container,codec:audioTrack.codec,initSegment:!audioTrack.isAAC&&typeSupported.mpeg?new Uint8Array():_mp4Generator2.default.initSegment([audioTrack]),metadata:{channelCount:audioTrack.channelCount}};if(computePTSDTS){// remember first PTS of this demuxing context. for audio, PTS = DTS
initPTS=initDTS=audioSamples[0].pts-audioTrack.inputTimeScale*timeOffset;}}if(videoTrack.sps&&videoTrack.pps&&videoSamples.length){// let's use input time scale as MP4 video timescale
// we use input time scale straight away to avoid rounding issues on frame duration / cts computation
var inputTimeScale=videoTrack.inputTimeScale;videoTrack.timescale=inputTimeScale;tracks.video={container:'video/mp4',codec:videoTrack.codec,initSegment:_mp4Generator2.default.initSegment([videoTrack]),metadata:{width:videoTrack.width,height:videoTrack.height}};if(computePTSDTS){initPTS=Math.min(initPTS,videoSamples[0].pts-inputTimeScale*timeOffset);initDTS=Math.min(initDTS,videoSamples[0].dts-inputTimeScale*timeOffset);this.observer.trigger(_events2.default.INIT_PTS_FOUND,{initPTS:initPTS});}}if(Object.keys(tracks).length){observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT,data);this.ISGenerated=true;if(computePTSDTS){this._initPTS=initPTS;this._initDTS=initDTS;}}else{observer.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MEDIA_ERROR,details:_errors.ErrorDetails.FRAG_PARSING_ERROR,fatal:false,reason:'no audio/video samples found'});}}},{key:'remuxVideo',value:function remuxVideo(track,timeOffset,contiguous,audioTrackLength,accurateTimeOffset){var offset=8,timeScale=track.timescale,mp4SampleDuration,mdat,moof,firstPTS,firstDTS,nextDTS,lastPTS,lastDTS,inputSamples=track.samples,outputSamples=[],nbSamples=inputSamples.length,ptsNormalize=this._PTSNormalize,initDTS=this._initDTS;// for (let i = 0; i < track.samples.length; i++) {
//   let avcSample = track.samples[i];
//   let units = avcSample.units;
//   let unitsString = '';
//   for (let j = 0; j < units.length ; j++) {
//     unitsString += units[j].type + ',';
//     if (units[j].data.length < 500) {
//       unitsString += Hex.hexDump(units[j].data);
//     }
//   }
//   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);
// }
// if parsed fragment is contiguous with last one, let's use last DTS value as reference
var nextAvcDts=this.nextAvcDts;var isSafari=this.isSafari;// Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive
if(isSafari){// also consider consecutive fragments as being contiguous (even if a level switch occurs),
// for sake of clarity:
// consecutive fragments are frags with
//  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
//  - less than 200 ms PTS gaps (timeScale/5)
contiguous|=inputSamples.length&&nextAvcDts&&(accurateTimeOffset&&Math.abs(timeOffset-nextAvcDts/timeScale)<0.1||Math.abs(inputSamples[0].pts-nextAvcDts-initDTS)<timeScale/5);}if(!contiguous){// if not contiguous, let's use target timeOffset
nextAvcDts=timeOffset*timeScale;}// PTS is coded on 33bits, and can loop from -2^32 to 2^32
// ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
inputSamples.forEach(function(sample){sample.pts=ptsNormalize(sample.pts-initDTS,nextAvcDts);sample.dts=ptsNormalize(sample.dts-initDTS,nextAvcDts);});// sort video samples by DTS then PTS then demux id order
inputSamples.sort(function(a,b){var deltadts=a.dts-b.dts;var deltapts=a.pts-b.pts;return deltadts?deltadts:deltapts?deltapts:a.id-b.id;});// handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
var PTSDTSshift=inputSamples.reduce(function(prev,curr){return Math.max(Math.min(prev,curr.pts-curr.dts),-18000);},0);if(PTSDTSshift<0){_logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by '+Math.round(PTSDTSshift/90)+' ms to overcome this issue');for(var i=0;i<inputSamples.length;i++){inputSamples[i].dts+=PTSDTSshift;}}// compute first DTS and last DTS, normalize them against reference value
var sample=inputSamples[0];firstDTS=Math.max(sample.dts,0);firstPTS=Math.max(sample.pts,0);// check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
var delta=Math.round((firstDTS-nextAvcDts)/90);// if fragment are contiguous, detect hole/overlapping between fragments
if(contiguous){if(delta){if(delta>1){_logger.logger.log('AVC:'+delta+' ms hole between fragments detected,filling it');}else if(delta<-1){_logger.logger.log('AVC:'+-delta+' ms overlapping between fragments detected');}// remove hole/gap : set DTS to next expected DTS
firstDTS=nextAvcDts;inputSamples[0].dts=firstDTS;// offset PTS as well, ensure that PTS is smaller or equal than new DTS
firstPTS=Math.max(firstPTS-delta,nextAvcDts);inputSamples[0].pts=firstPTS;_logger.logger.log('Video/PTS/DTS adjusted: '+Math.round(firstPTS/90)+'/'+Math.round(firstDTS/90)+',delta:'+delta+' ms');}}nextDTS=firstDTS;// compute lastPTS/lastDTS
sample=inputSamples[inputSamples.length-1];lastDTS=Math.max(sample.dts,0);lastPTS=Math.max(sample.pts,0,lastDTS);// on Safari let's signal the same sample duration for all samples
// sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
// set this constant duration as being the avg delta between consecutive DTS.
if(isSafari){mp4SampleDuration=Math.round((lastDTS-firstDTS)/(inputSamples.length-1));}var nbNalu=0,naluLen=0;for(var _i=0;_i<nbSamples;_i++){// compute total/avc sample length and nb of NAL units
var _sample=inputSamples[_i],units=_sample.units,nbUnits=units.length,sampleLen=0;for(var j=0;j<nbUnits;j++){sampleLen+=units[j].data.length;}naluLen+=sampleLen;nbNalu+=nbUnits;_sample.length=sampleLen;// normalize PTS/DTS
if(isSafari){// sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
_sample.dts=firstDTS+_i*mp4SampleDuration;}else{// ensure sample monotonic DTS
_sample.dts=Math.max(_sample.dts,firstDTS);}// ensure that computed value is greater or equal than sample DTS
_sample.pts=Math.max(_sample.pts,_sample.dts);}/* concatenate the video data and construct the mdat in place
        (need 8 more bytes to fill length and mpdat type) */var mdatSize=naluLen+4*nbNalu+8;try{mdat=new Uint8Array(mdatSize);}catch(err){this.observer.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MUX_ERROR,details:_errors.ErrorDetails.REMUX_ALLOC_ERROR,fatal:false,bytes:mdatSize,reason:'fail allocating video mdat '+mdatSize});return;}var view=new DataView(mdat.buffer);view.setUint32(0,mdatSize);mdat.set(_mp4Generator2.default.types.mdat,4);for(var _i2=0;_i2<nbSamples;_i2++){var avcSample=inputSamples[_i2],avcSampleUnits=avcSample.units,mp4SampleLength=0,compositionTimeOffset=void 0;// convert NALU bitstream to MP4 format (prepend NALU with size field)
for(var _j=0,_nbUnits=avcSampleUnits.length;_j<_nbUnits;_j++){var unit=avcSampleUnits[_j],unitData=unit.data,unitDataLen=unit.data.byteLength;view.setUint32(offset,unitDataLen);offset+=4;mdat.set(unitData,offset);offset+=unitDataLen;mp4SampleLength+=4+unitDataLen;}if(!isSafari){// expected sample duration is the Decoding Timestamp diff of consecutive samples
if(_i2<nbSamples-1){mp4SampleDuration=inputSamples[_i2+1].dts-avcSample.dts;}else{var config=this.config,lastFrameDuration=avcSample.dts-inputSamples[_i2>0?_i2-1:_i2].dts;if(config.stretchShortVideoTrack){// In some cases, a segment's audio track duration may exceed the video track duration.
// Since we've already remuxed audio, and we know how long the audio track is, we look to
// see if the delta to the next segment is longer than the minimum of maxBufferHole and
// maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate
// the duration of the last frame to minimize any potential gap between segments.
var maxBufferHole=config.maxBufferHole,maxSeekHole=config.maxSeekHole,gapTolerance=Math.floor(Math.min(maxBufferHole,maxSeekHole)*timeScale),deltaToFrameEnd=(audioTrackLength?firstPTS+audioTrackLength*timeScale:this.nextAudioPts)-avcSample.pts;if(deltaToFrameEnd>gapTolerance){// We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
// frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.
mp4SampleDuration=deltaToFrameEnd-lastFrameDuration;if(mp4SampleDuration<0){mp4SampleDuration=lastFrameDuration;}_logger.logger.log('It is approximately '+deltaToFrameEnd/90+' ms to the next segment; using duration '+mp4SampleDuration/90+' ms for the last video frame.');}else{mp4SampleDuration=lastFrameDuration;}}else{mp4SampleDuration=lastFrameDuration;}}compositionTimeOffset=Math.round(avcSample.pts-avcSample.dts);}else{compositionTimeOffset=Math.max(0,mp4SampleDuration*Math.round((avcSample.pts-avcSample.dts)/mp4SampleDuration));}//console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
outputSamples.push({size:mp4SampleLength,// constant duration
duration:mp4SampleDuration,cts:compositionTimeOffset,flags:{isLeading:0,isDependedOn:0,hasRedundancy:0,degradPrio:0,dependsOn:avcSample.key?2:1,isNonSync:avcSample.key?0:1}});}// next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
this.nextAvcDts=lastDTS+mp4SampleDuration;var dropped=track.dropped;track.len=0;track.nbNalu=0;track.dropped=0;if(outputSamples.length&&navigator.userAgent.toLowerCase().indexOf('chrome')>-1){var flags=outputSamples[0].flags;// chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
// https://code.google.com/p/chromium/issues/detail?id=229412
flags.dependsOn=2;flags.isNonSync=0;}track.samples=outputSamples;moof=_mp4Generator2.default.moof(track.sequenceNumber++,firstDTS,track);track.samples=[];var data={data1:moof,data2:mdat,startPTS:firstPTS/timeScale,endPTS:(lastPTS+mp4SampleDuration)/timeScale,startDTS:firstDTS/timeScale,endDTS:this.nextAvcDts/timeScale,type:'video',nb:outputSamples.length,dropped:dropped};this.observer.trigger(_events2.default.FRAG_PARSING_DATA,data);return data;}},{key:'remuxAudio',value:function remuxAudio(track,timeOffset,contiguous,accurateTimeOffset){var inputTimeScale=track.inputTimeScale,mp4timeScale=track.timescale,scaleFactor=inputTimeScale/mp4timeScale,mp4SampleDuration=track.isAAC?1024:1152,inputSampleDuration=mp4SampleDuration*scaleFactor,ptsNormalize=this._PTSNormalize,initDTS=this._initDTS,rawMPEG=!track.isAAC&&this.typeSupported.mpeg;var offset,mp4Sample,fillFrame,mdat,moof,firstPTS,lastPTS,inputSamples=track.samples,outputSamples=[],nextAudioPts=this.nextAudioPts;// for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
// for sake of clarity:
// consecutive fragments are frags with
//  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
//  - less than 20 audio frames distance
// contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
// this helps ensuring audio continuity
// and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame
contiguous|=inputSamples.length&&nextAudioPts&&(accurateTimeOffset&&Math.abs(timeOffset-nextAudioPts/inputTimeScale)<0.1||Math.abs(inputSamples[0].pts-nextAudioPts-initDTS)<20*inputSampleDuration);if(!contiguous){// if fragments are not contiguous, let's use timeOffset to compute next Audio PTS
nextAudioPts=timeOffset*inputTimeScale;}// compute normalized PTS
inputSamples.forEach(function(sample){sample.pts=sample.dts=ptsNormalize(sample.pts-initDTS,nextAudioPts);});// sort based on normalized PTS (this is to avoid sorting issues in case timestamp
// reloop in the middle of our samples array)
inputSamples.sort(function(a,b){return a.pts-b.pts;});// If the audio track is missing samples, the frames seem to get "left-shifted" within the
// resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
// In an effort to prevent this from happening, we inject frames here where there are gaps.
// When possible, we inject a silent frame; when that's not possible, we duplicate the last
// frame.
// only inject/drop audio frames in case time offset is accurate
if(accurateTimeOffset&&track.isAAC){for(var i=0,nextPts=nextAudioPts;i<inputSamples.length;){// First, let's see how far off this frame is from where we expect it to be
var sample=inputSamples[i],delta;var pts=sample.pts;delta=pts-nextPts;var duration=Math.abs(1000*delta/inputTimeScale);// If we're overlapping by more than a duration, drop this sample
if(delta<=-inputSampleDuration){_logger.logger.warn('Dropping 1 audio frame @ '+(nextPts/inputTimeScale).toFixed(3)+'s due to '+duration+' ms overlap.');inputSamples.splice(i,1);track.len-=sample.unit.length;// Don't touch nextPtsNorm or i
}// Insert missing frames if:
// 1: We're more than one frame away
// 2: Not more than MAX_SILENT_FRAME_DURATION away
// 3: currentTime (aka nextPtsNorm) is not 0
else if(delta>=inputSampleDuration&&duration<MAX_SILENT_FRAME_DURATION&&nextPts){var missing=Math.round(delta/inputSampleDuration);_logger.logger.warn('Injecting '+missing+' audio frame @ '+(nextPts/inputTimeScale).toFixed(3)+'s due to '+Math.round(1000*delta/inputTimeScale)+' ms gap.');for(var j=0;j<missing;j++){var newStamp=Math.max(nextPts,0);fillFrame=_aac2.default.getSilentFrame(track.manifestCodec||track.codec,track.channelCount);if(!fillFrame){_logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');fillFrame=sample.unit.subarray();}inputSamples.splice(i,0,{unit:fillFrame,pts:newStamp,dts:newStamp});track.len+=fillFrame.length;nextPts+=inputSampleDuration;i++;}// Adjust sample to next expected pts
sample.pts=sample.dts=nextPts;nextPts+=inputSampleDuration;i++;}else{// Otherwise, just adjust pts
if(Math.abs(delta)>0.1*inputSampleDuration){//logger.log(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);
}sample.pts=sample.dts=nextPts;nextPts+=inputSampleDuration;i++;}}}for(var _j2=0,_nbSamples=inputSamples.length;_j2<_nbSamples;_j2++){var audioSample=inputSamples[_j2];var unit=audioSample.unit;var _pts=audioSample.pts;//logger.log(`Audio/PTS:${Math.round(pts/90)}`);
// if not first sample
if(lastPTS!==undefined){mp4Sample.duration=Math.round((_pts-lastPTS)/scaleFactor);}else{var _delta=Math.round(1000*(_pts-nextAudioPts)/inputTimeScale),numMissingFrames=0;// if fragment are contiguous, detect hole/overlapping between fragments
// contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
if(contiguous&&track.isAAC){// log delta
if(_delta){if(_delta>0&&_delta<MAX_SILENT_FRAME_DURATION){numMissingFrames=Math.round((_pts-nextAudioPts)/inputSampleDuration);_logger.logger.log(_delta+' ms hole between AAC samples detected,filling it');if(numMissingFrames>0){fillFrame=_aac2.default.getSilentFrame(track.manifestCodec||track.codec,track.channelCount);if(!fillFrame){fillFrame=unit.subarray();}track.len+=numMissingFrames*fillFrame.length;}// if we have frame overlap, overlapping for more than half a frame duraion
}else if(_delta<-12){// drop overlapping audio frames... browser will deal with it
_logger.logger.log('drop overlapping AAC sample, expected/parsed/delta:'+(nextAudioPts/inputTimeScale).toFixed(3)+'s/'+(_pts/inputTimeScale).toFixed(3)+'s/'+-_delta+'ms');track.len-=unit.byteLength;continue;}// set PTS/DTS to expected PTS/DTS
_pts=nextAudioPts;}}// remember first PTS of our audioSamples, ensure value is positive
firstPTS=Math.max(0,_pts);if(track.len>0){/* concatenate the audio data and construct the mdat in place
              (need 8 more bytes to fill length and mdat type) */var mdatSize=rawMPEG?track.len:track.len+8;offset=rawMPEG?0:8;try{mdat=new Uint8Array(mdatSize);}catch(err){this.observer.trigger(_events2.default.ERROR,{type:_errors.ErrorTypes.MUX_ERROR,details:_errors.ErrorDetails.REMUX_ALLOC_ERROR,fatal:false,bytes:mdatSize,reason:'fail allocating audio mdat '+mdatSize});return;}if(!rawMPEG){var view=new DataView(mdat.buffer);view.setUint32(0,mdatSize);mdat.set(_mp4Generator2.default.types.mdat,4);}}else{// no audio samples
return;}for(var _i3=0;_i3<numMissingFrames;_i3++){fillFrame=_aac2.default.getSilentFrame(track.manifestCodec||track.codec,track.channelCount);if(!fillFrame){_logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');fillFrame=unit.subarray();}mdat.set(fillFrame,offset);offset+=fillFrame.byteLength;mp4Sample={size:fillFrame.byteLength,cts:0,duration:1024,flags:{isLeading:0,isDependedOn:0,hasRedundancy:0,degradPrio:0,dependsOn:1}};outputSamples.push(mp4Sample);}}mdat.set(unit,offset);var unitLen=unit.byteLength;offset+=unitLen;//console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
mp4Sample={size:unitLen,cts:0,duration:0,flags:{isLeading:0,isDependedOn:0,hasRedundancy:0,degradPrio:0,dependsOn:1}};outputSamples.push(mp4Sample);lastPTS=_pts;}var lastSampleDuration=0;var nbSamples=outputSamples.length;//set last sample duration as being identical to previous sample
if(nbSamples>=2){lastSampleDuration=outputSamples[nbSamples-2].duration;mp4Sample.duration=lastSampleDuration;}if(nbSamples){// next audio sample PTS should be equal to last sample PTS + duration
this.nextAudioPts=nextAudioPts=lastPTS+scaleFactor*lastSampleDuration;//logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
track.len=0;track.samples=outputSamples;if(rawMPEG){moof=new Uint8Array();}else{moof=_mp4Generator2.default.moof(track.sequenceNumber++,firstPTS/scaleFactor,track);}track.samples=[];var start=firstPTS/inputTimeScale;var end=nextAudioPts/inputTimeScale;var audioData={data1:moof,data2:mdat,startPTS:start,endPTS:end,startDTS:start,endDTS:end,type:'audio',nb:nbSamples};this.observer.trigger(_events2.default.FRAG_PARSING_DATA,audioData);return audioData;}return null;}},{key:'remuxEmptyAudio',value:function remuxEmptyAudio(track,timeOffset,contiguous,videoData){var inputTimeScale=track.inputTimeScale,mp4timeScale=track.samplerate?track.samplerate:inputTimeScale,scaleFactor=inputTimeScale/mp4timeScale,nextAudioPts=this.nextAudioPts,// sync with video's timestamp
startDTS=(nextAudioPts!==undefined?nextAudioPts:videoData.startDTS*inputTimeScale)+this._initDTS,endDTS=videoData.endDTS*inputTimeScale+this._initDTS,// one sample's duration value
sampleDuration=1024,frameDuration=scaleFactor*sampleDuration,// samples count of this segment's duration
nbSamples=Math.ceil((endDTS-startDTS)/frameDuration),// silent frame
silentFrame=_aac2.default.getSilentFrame(track.manifestCodec||track.codec,track.channelCount);_logger.logger.warn('remux empty Audio');// Can't remux if we can't generate a silent frame...
if(!silentFrame){_logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');return;}var samples=[];for(var i=0;i<nbSamples;i++){var stamp=startDTS+i*frameDuration;samples.push({unit:silentFrame,pts:stamp,dts:stamp});track.len+=silentFrame.length;}track.samples=samples;this.remuxAudio(track,timeOffset,contiguous);}},{key:'remuxID3',value:function remuxID3(track,timeOffset){var length=track.samples.length,sample;var inputTimeScale=track.inputTimeScale;var initPTS=this._initPTS;var initDTS=this._initDTS;// consume samples
if(length){for(var index=0;index<length;index++){sample=track.samples[index];// setting id3 pts, dts to relative time
// using this._initPTS and this._initDTS to calculate relative time
sample.pts=(sample.pts-initPTS)/inputTimeScale;sample.dts=(sample.dts-initDTS)/inputTimeScale;}this.observer.trigger(_events2.default.FRAG_PARSING_METADATA,{samples:track.samples});}track.samples=[];timeOffset=timeOffset;}},{key:'remuxText',value:function remuxText(track,timeOffset){track.samples.sort(function(a,b){return a.pts-b.pts;});var length=track.samples.length,sample;var inputTimeScale=track.inputTimeScale;var initPTS=this._initPTS;// consume samples
if(length){for(var index=0;index<length;index++){sample=track.samples[index];// setting text pts, dts to relative time
// using this._initPTS and this._initDTS to calculate relative time
sample.pts=(sample.pts-initPTS)/inputTimeScale;}this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA,{samples:track.samples});}track.samples=[];timeOffset=timeOffset;}},{key:'_PTSNormalize',value:function _PTSNormalize(value,reference){var offset;if(reference===undefined){return value;}if(reference<value){// - 2^33
offset=-8589934592;}else{// + 2^33
offset=8589934592;}/* PTS is 33bit (from 0 to 2^33 -1)
        if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
        PTS looping occured. fill the gap */while(Math.abs(value-reference)>4294967296){value+=offset;}return value;}}]);return MP4Remuxer;}();exports.default=MP4Remuxer;},{"33":33,"35":35,"36":36,"44":44,"53":53}],46:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */var _events=_dereq_(35);var _events2=_interopRequireDefault(_events);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var PassThroughRemuxer=function(){function PassThroughRemuxer(observer){_classCallCheck(this,PassThroughRemuxer);this.observer=observer;}_createClass(PassThroughRemuxer,[{key:'destroy',value:function destroy(){}},{key:'resetTimeStamp',value:function resetTimeStamp(){}},{key:'resetInitSegment',value:function resetInitSegment(){}},{key:'remux',value:function remux(audioTrack,videoTrack,id3Track,textTrack,timeOffset,contiguous,accurateTimeOffset,rawData){var observer=this.observer;var streamType='';if(audioTrack){streamType+='audio';}if(videoTrack){streamType+='video';}observer.trigger(_events2.default.FRAG_PARSING_DATA,{data1:rawData,startPTS:timeOffset,startDTS:timeOffset,type:streamType,nb:1,dropped:0});//notify end of parsing
observer.trigger(_events2.default.FRAG_PARSED);}}]);return PassThroughRemuxer;}();exports.default=PassThroughRemuxer;},{"35":35}],47:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var DECIMAL_RESOLUTION_REGEX=/^(\d+)x(\d+)$/;var ATTR_LIST_REGEX=/\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js
var AttrList=function(){function AttrList(attrs){_classCallCheck(this,AttrList);if(typeof attrs==='string'){attrs=AttrList.parseAttrList(attrs);}for(var attr in attrs){if(attrs.hasOwnProperty(attr)){this[attr]=attrs[attr];}}}_createClass(AttrList,[{key:'decimalInteger',value:function decimalInteger(attrName){var intValue=parseInt(this[attrName],10);if(intValue>Number.MAX_SAFE_INTEGER){return Infinity;}return intValue;}},{key:'hexadecimalInteger',value:function hexadecimalInteger(attrName){if(this[attrName]){var stringValue=(this[attrName]||'0x').slice(2);stringValue=(stringValue.length&1?'0':'')+stringValue;var value=new Uint8Array(stringValue.length/2);for(var i=0;i<stringValue.length/2;i++){value[i]=parseInt(stringValue.slice(i*2,i*2+2),16);}return value;}else{return null;}}},{key:'hexadecimalIntegerAsNumber',value:function hexadecimalIntegerAsNumber(attrName){var intValue=parseInt(this[attrName],16);if(intValue>Number.MAX_SAFE_INTEGER){return Infinity;}return intValue;}},{key:'decimalFloatingPoint',value:function decimalFloatingPoint(attrName){return parseFloat(this[attrName]);}},{key:'enumeratedString',value:function enumeratedString(attrName){return this[attrName];}},{key:'decimalResolution',value:function decimalResolution(attrName){var res=DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);if(res===null){return undefined;}return{width:parseInt(res[1],10),height:parseInt(res[2],10)};}}],[{key:'parseAttrList',value:function parseAttrList(input){var match,attrs={};ATTR_LIST_REGEX.lastIndex=0;while((match=ATTR_LIST_REGEX.exec(input))!==null){var value=match[2],quote='"';if(value.indexOf(quote)===0&&value.lastIndexOf(quote)===value.length-1){value=value.slice(1,-1);}attrs[match[1]]=value;}return attrs;}}]);return AttrList;}();exports.default=AttrList;},{}],48:[function(_dereq_,module,exports){"use strict";var BinarySearch={/**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */search:function search(list,comparisonFunction){var minIndex=0;var maxIndex=list.length-1;var currentIndex=null;var currentElement=null;while(minIndex<=maxIndex){currentIndex=(minIndex+maxIndex)/2|0;currentElement=list[currentIndex];var comparisonResult=comparisonFunction(currentElement);if(comparisonResult>0){minIndex=currentIndex+1;}else if(comparisonResult<0){maxIndex=currentIndex-1;}else{return currentElement;}}return null;}};module.exports=BinarySearch;},{}],49:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *//**
 *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
 */var specialCea608CharsCodes={0x2a:0xe1,// lowercase a, acute accent
0x5c:0xe9,// lowercase e, acute accent
0x5e:0xed,// lowercase i, acute accent
0x5f:0xf3,// lowercase o, acute accent
0x60:0xfa,// lowercase u, acute accent
0x7b:0xe7,// lowercase c with cedilla
0x7c:0xf7,// division symbol
0x7d:0xd1,// uppercase N tilde
0x7e:0xf1,// lowercase n tilde
0x7f:0x2588,// Full block
// THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
// THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
// THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
0x80:0xae,// Registered symbol (R)
0x81:0xb0,// degree sign
0x82:0xbd,// 1/2 symbol
0x83:0xbf,// Inverted (open) question mark
0x84:0x2122,// Trademark symbol (TM)
0x85:0xa2,// Cents symbol
0x86:0xa3,// Pounds sterling
0x87:0x266a,// Music 8'th note
0x88:0xe0,// lowercase a, grave accent
0x89:0x20,// transparent space (regular)
0x8a:0xe8,// lowercase e, grave accent
0x8b:0xe2,// lowercase a, circumflex accent
0x8c:0xea,// lowercase e, circumflex accent
0x8d:0xee,// lowercase i, circumflex accent
0x8e:0xf4,// lowercase o, circumflex accent
0x8f:0xfb,// lowercase u, circumflex accent
// THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
// THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
0x90:0xc1,// capital letter A with acute
0x91:0xc9,// capital letter E with acute
0x92:0xd3,// capital letter O with acute
0x93:0xda,// capital letter U with acute
0x94:0xdc,// capital letter U with diaresis
0x95:0xfc,// lowercase letter U with diaeresis
0x96:0x2018,// opening single quote
0x97:0xa1,// inverted exclamation mark
0x98:0x2a,// asterisk
0x99:0x2019,// closing single quote
0x9a:0x2501,// box drawings heavy horizontal
0x9b:0xa9,// copyright sign
0x9c:0x2120,// Service mark
0x9d:0x2022,// (round) bullet
0x9e:0x201c,// Left double quotation mark
0x9f:0x201d,// Right double quotation mark
0xa0:0xc0,// uppercase A, grave accent
0xa1:0xc2,// uppercase A, circumflex
0xa2:0xc7,// uppercase C with cedilla
0xa3:0xc8,// uppercase E, grave accent
0xa4:0xca,// uppercase E, circumflex
0xa5:0xcb,// capital letter E with diaresis
0xa6:0xeb,// lowercase letter e with diaresis
0xa7:0xce,// uppercase I, circumflex
0xa8:0xcf,// uppercase I, with diaresis
0xa9:0xef,// lowercase i, with diaresis
0xaa:0xd4,// uppercase O, circumflex
0xab:0xd9,// uppercase U, grave accent
0xac:0xf9,// lowercase u, grave accent
0xad:0xdb,// uppercase U, circumflex
0xae:0xab,// left-pointing double angle quotation mark
0xaf:0xbb,// right-pointing double angle quotation mark
// THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
// THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
0xb0:0xc3,// Uppercase A, tilde
0xb1:0xe3,// Lowercase a, tilde
0xb2:0xcd,// Uppercase I, acute accent
0xb3:0xcc,// Uppercase I, grave accent
0xb4:0xec,// Lowercase i, grave accent
0xb5:0xd2,// Uppercase O, grave accent
0xb6:0xf2,// Lowercase o, grave accent
0xb7:0xd5,// Uppercase O, tilde
0xb8:0xf5,// Lowercase o, tilde
0xb9:0x7b,// Open curly brace
0xba:0x7d,// Closing curly brace
0xbb:0x5c,// Backslash
0xbc:0x5e,// Caret
0xbd:0x5f,// Underscore
0xbe:0x7c,// Pipe (vertical line)
0xbf:0x223c,// Tilde operator
0xc0:0xc4,// Uppercase A, umlaut
0xc1:0xe4,// Lowercase A, umlaut
0xc2:0xd6,// Uppercase O, umlaut
0xc3:0xf6,// Lowercase o, umlaut
0xc4:0xdf,// Esszett (sharp S)
0xc5:0xa5,// Yen symbol
0xc6:0xa4,// Generic currency sign
0xc7:0x2503,// Box drawings heavy vertical
0xc8:0xc5,// Uppercase A, ring
0xc9:0xe5,// Lowercase A, ring
0xca:0xd8,// Uppercase O, stroke
0xcb:0xf8,// Lowercase o, strok
0xcc:0x250f,// Box drawings heavy down and right
0xcd:0x2513,// Box drawings heavy down and left
0xce:0x2517,// Box drawings heavy up and right
0xcf:0x251b// Box drawings heavy up and left
};/**
 * Utils
 */var getCharForByte=function getCharForByte(byte){var charCode=byte;if(specialCea608CharsCodes.hasOwnProperty(byte)){charCode=specialCea608CharsCodes[byte];}return String.fromCharCode(charCode);};var NR_ROWS=15,NR_COLS=100;// Tables to look up row from PAC data
var rowsLowCh1={0x11:1,0x12:3,0x15:5,0x16:7,0x17:9,0x10:11,0x13:12,0x14:14};var rowsHighCh1={0x11:2,0x12:4,0x15:6,0x16:8,0x17:10,0x13:13,0x14:15};var rowsLowCh2={0x19:1,0x1A:3,0x1D:5,0x1E:7,0x1F:9,0x18:11,0x1B:12,0x1C:14};var rowsHighCh2={0x19:2,0x1A:4,0x1D:6,0x1E:8,0x1F:10,0x1B:13,0x1C:15};var backgroundColors=['white','green','blue','cyan','red','yellow','magenta','black','transparent'];/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */var logger={verboseFilter:{'DATA':3,'DEBUG':3,'INFO':2,'WARNING':2,'TEXT':1,'ERROR':0},time:null,verboseLevel:0,// Only write errors
setTime:function setTime(newTime){this.time=newTime;},log:function log(severity,msg){var minLevel=this.verboseFilter[severity];if(this.verboseLevel>=minLevel){console.log(this.time+' ['+severity+'] '+msg);}}};var numArrayToHexArray=function numArrayToHexArray(numArray){var hexArray=[];for(var j=0;j<numArray.length;j++){hexArray.push(numArray[j].toString(16));}return hexArray;};var PenState=function(){function PenState(foreground,underline,italics,background,flash){_classCallCheck(this,PenState);this.foreground=foreground||'white';this.underline=underline||false;this.italics=italics||false;this.background=background||'black';this.flash=flash||false;}_createClass(PenState,[{key:'reset',value:function reset(){this.foreground='white';this.underline=false;this.italics=false;this.background='black';this.flash=false;}},{key:'setStyles',value:function setStyles(styles){var attribs=['foreground','underline','italics','background','flash'];for(var i=0;i<attribs.length;i++){var style=attribs[i];if(styles.hasOwnProperty(style)){this[style]=styles[style];}}}},{key:'isDefault',value:function isDefault(){return this.foreground==='white'&&!this.underline&&!this.italics&&this.background==='black'&&!this.flash;}},{key:'equals',value:function equals(other){return this.foreground===other.foreground&&this.underline===other.underline&&this.italics===other.italics&&this.background===other.background&&this.flash===other.flash;}},{key:'copy',value:function copy(newPenState){this.foreground=newPenState.foreground;this.underline=newPenState.underline;this.italics=newPenState.italics;this.background=newPenState.background;this.flash=newPenState.flash;}},{key:'toString',value:function toString(){return'color='+this.foreground+', underline='+this.underline+', italics='+this.italics+', background='+this.background+', flash='+this.flash;}}]);return PenState;}();/**
 * Unicode character with styling and background.
 * @constructor
 */var StyledUnicodeChar=function(){function StyledUnicodeChar(uchar,foreground,underline,italics,background,flash){_classCallCheck(this,StyledUnicodeChar);this.uchar=uchar||' ';// unicode character
this.penState=new PenState(foreground,underline,italics,background,flash);}_createClass(StyledUnicodeChar,[{key:'reset',value:function reset(){this.uchar=' ';this.penState.reset();}},{key:'setChar',value:function setChar(uchar,newPenState){this.uchar=uchar;this.penState.copy(newPenState);}},{key:'setPenState',value:function setPenState(newPenState){this.penState.copy(newPenState);}},{key:'equals',value:function equals(other){return this.uchar===other.uchar&&this.penState.equals(other.penState);}},{key:'copy',value:function copy(newChar){this.uchar=newChar.uchar;this.penState.copy(newChar.penState);}},{key:'isEmpty',value:function isEmpty(){return this.uchar===' '&&this.penState.isDefault();}}]);return StyledUnicodeChar;}();/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */var Row=function(){function Row(){_classCallCheck(this,Row);this.chars=[];for(var i=0;i<NR_COLS;i++){this.chars.push(new StyledUnicodeChar());}this.pos=0;this.currPenState=new PenState();}_createClass(Row,[{key:'equals',value:function equals(other){var equal=true;for(var i=0;i<NR_COLS;i++){if(!this.chars[i].equals(other.chars[i])){equal=false;break;}}return equal;}},{key:'copy',value:function copy(other){for(var i=0;i<NR_COLS;i++){this.chars[i].copy(other.chars[i]);}}},{key:'isEmpty',value:function isEmpty(){var empty=true;for(var i=0;i<NR_COLS;i++){if(!this.chars[i].isEmpty()){empty=false;break;}}return empty;}/**
         *  Set the cursor to a valid column.
         */},{key:'setCursor',value:function setCursor(absPos){if(this.pos!==absPos){this.pos=absPos;}if(this.pos<0){logger.log('ERROR','Negative cursor position '+this.pos);this.pos=0;}else if(this.pos>NR_COLS){logger.log('ERROR','Too large cursor position '+this.pos);this.pos=NR_COLS;}}/**
         * Move the cursor relative to current position.
         */},{key:'moveCursor',value:function moveCursor(relPos){var newPos=this.pos+relPos;if(relPos>1){for(var i=this.pos+1;i<newPos+1;i++){this.chars[i].setPenState(this.currPenState);}}this.setCursor(newPos);}/**
         * Backspace, move one step back and clear character.
         */},{key:'backSpace',value:function backSpace(){this.moveCursor(-1);this.chars[this.pos].setChar(' ',this.currPenState);}},{key:'insertChar',value:function insertChar(byte){if(byte>=0x90){//Extended char
this.backSpace();}var char=getCharForByte(byte);if(this.pos>=NR_COLS){logger.log('ERROR','Cannot insert '+byte.toString(16)+' ('+char+') at position '+this.pos+'. Skipping it!');return;}this.chars[this.pos].setChar(char,this.currPenState);this.moveCursor(1);}},{key:'clearFromPos',value:function clearFromPos(startPos){var i;for(i=startPos;i<NR_COLS;i++){this.chars[i].reset();}}},{key:'clear',value:function clear(){this.clearFromPos(0);this.pos=0;this.currPenState.reset();}},{key:'clearToEndOfRow',value:function clearToEndOfRow(){this.clearFromPos(this.pos);}},{key:'getTextString',value:function getTextString(){var chars=[];var empty=true;for(var i=0;i<NR_COLS;i++){var char=this.chars[i].uchar;if(char!==' '){empty=false;}chars.push(char);}if(empty){return'';}else{return chars.join('');}}},{key:'setPenStyles',value:function setPenStyles(styles){this.currPenState.setStyles(styles);var currChar=this.chars[this.pos];currChar.setPenState(this.currPenState);}}]);return Row;}();/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/var CaptionScreen=function(){function CaptionScreen(){_classCallCheck(this,CaptionScreen);this.rows=[];for(var i=0;i<NR_ROWS;i++){this.rows.push(new Row());// Note that we use zero-based numbering (0-14)
}this.currRow=NR_ROWS-1;this.nrRollUpRows=null;this.reset();}_createClass(CaptionScreen,[{key:'reset',value:function reset(){for(var i=0;i<NR_ROWS;i++){this.rows[i].clear();}this.currRow=NR_ROWS-1;}},{key:'equals',value:function equals(other){var equal=true;for(var i=0;i<NR_ROWS;i++){if(!this.rows[i].equals(other.rows[i])){equal=false;break;}}return equal;}},{key:'copy',value:function copy(other){for(var i=0;i<NR_ROWS;i++){this.rows[i].copy(other.rows[i]);}}},{key:'isEmpty',value:function isEmpty(){var empty=true;for(var i=0;i<NR_ROWS;i++){if(!this.rows[i].isEmpty()){empty=false;break;}}return empty;}},{key:'backSpace',value:function backSpace(){var row=this.rows[this.currRow];row.backSpace();}},{key:'clearToEndOfRow',value:function clearToEndOfRow(){var row=this.rows[this.currRow];row.clearToEndOfRow();}/**
         * Insert a character (without styling) in the current row.
         */},{key:'insertChar',value:function insertChar(char){var row=this.rows[this.currRow];row.insertChar(char);}},{key:'setPen',value:function setPen(styles){var row=this.rows[this.currRow];row.setPenStyles(styles);}},{key:'moveCursor',value:function moveCursor(relPos){var row=this.rows[this.currRow];row.moveCursor(relPos);}},{key:'setCursor',value:function setCursor(absPos){logger.log('INFO','setCursor: '+absPos);var row=this.rows[this.currRow];row.setCursor(absPos);}},{key:'setPAC',value:function setPAC(pacData){logger.log('INFO','pacData = '+JSON.stringify(pacData));var newRow=pacData.row-1;if(this.nrRollUpRows&&newRow<this.nrRollUpRows-1){newRow=this.nrRollUpRows-1;}//Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
if(this.nrRollUpRows&&this.currRow!==newRow){//clear all rows first
for(var i=0;i<NR_ROWS;i++){this.rows[i].clear();}//Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
//topRowIndex - the start of rows to copy (inclusive index)
var topRowIndex=this.currRow+1-this.nrRollUpRows;//We only copy if the last position was already shown.
//We use the cueStartTime value to check this.
var lastOutputScreen=this.lastOutputScreen;if(lastOutputScreen){var prevLineTime=lastOutputScreen.rows[topRowIndex].cueStartTime;if(prevLineTime&&prevLineTime<logger.time){for(var _i=0;_i<this.nrRollUpRows;_i++){this.rows[newRow-this.nrRollUpRows+_i+1].copy(lastOutputScreen.rows[topRowIndex+_i]);}}}}this.currRow=newRow;var row=this.rows[this.currRow];if(pacData.indent!==null){var indent=pacData.indent;var prevPos=Math.max(indent-1,0);row.setCursor(pacData.indent);pacData.color=row.chars[prevPos].penState.foreground;}var styles={foreground:pacData.color,underline:pacData.underline,italics:pacData.italics,background:'black',flash:false};this.setPen(styles);}/**
         * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
         */},{key:'setBkgData',value:function setBkgData(bkgData){logger.log('INFO','bkgData = '+JSON.stringify(bkgData));this.backSpace();this.setPen(bkgData);this.insertChar(0x20);//Space
}},{key:'setRollUpRows',value:function setRollUpRows(nrRows){this.nrRollUpRows=nrRows;}},{key:'rollUp',value:function rollUp(){if(this.nrRollUpRows===null){logger.log('DEBUG','roll_up but nrRollUpRows not set yet');return;//Not properly setup
}logger.log('TEXT',this.getDisplayText());var topRowIndex=this.currRow+1-this.nrRollUpRows;var topRow=this.rows.splice(topRowIndex,1)[0];topRow.clear();this.rows.splice(this.currRow,0,topRow);logger.log('INFO','Rolling up');//logger.log('TEXT', this.get_display_text())
}/**
         * Get all non-empty rows with as unicode text.
         */},{key:'getDisplayText',value:function getDisplayText(asOneRow){asOneRow=asOneRow||false;var displayText=[];var text='';var rowNr=-1;for(var i=0;i<NR_ROWS;i++){var rowText=this.rows[i].getTextString();if(rowText){rowNr=i+1;if(asOneRow){displayText.push('Row '+rowNr+': \''+rowText+'\'');}else{displayText.push(rowText.trim());}}}if(displayText.length>0){if(asOneRow){text='['+displayText.join(' | ')+']';}else{text=displayText.join('\n');}}return text;}},{key:'getTextAndFormat',value:function getTextAndFormat(){return this.rows;}}]);return CaptionScreen;}();//var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];
var Cea608Channel=function(){function Cea608Channel(channelNumber,outputFilter){_classCallCheck(this,Cea608Channel);this.chNr=channelNumber;this.outputFilter=outputFilter;this.mode=null;this.verbose=0;this.displayedMemory=new CaptionScreen();this.nonDisplayedMemory=new CaptionScreen();this.lastOutputScreen=new CaptionScreen();this.currRollUpRow=this.displayedMemory.rows[NR_ROWS-1];this.writeScreen=this.displayedMemory;this.mode=null;this.cueStartTime=null;// Keeps track of where a cue started.
}_createClass(Cea608Channel,[{key:'reset',value:function reset(){this.mode=null;this.displayedMemory.reset();this.nonDisplayedMemory.reset();this.lastOutputScreen.reset();this.currRollUpRow=this.displayedMemory.rows[NR_ROWS-1];this.writeScreen=this.displayedMemory;this.mode=null;this.cueStartTime=null;this.lastCueEndTime=null;}},{key:'getHandler',value:function getHandler(){return this.outputFilter;}},{key:'setHandler',value:function setHandler(newHandler){this.outputFilter=newHandler;}},{key:'setPAC',value:function setPAC(pacData){this.writeScreen.setPAC(pacData);}},{key:'setBkgData',value:function setBkgData(bkgData){this.writeScreen.setBkgData(bkgData);}},{key:'setMode',value:function setMode(newMode){if(newMode===this.mode){return;}this.mode=newMode;logger.log('INFO','MODE='+newMode);if(this.mode==='MODE_POP-ON'){this.writeScreen=this.nonDisplayedMemory;}else{this.writeScreen=this.displayedMemory;this.writeScreen.reset();}if(this.mode!=='MODE_ROLL-UP'){this.displayedMemory.nrRollUpRows=null;this.nonDisplayedMemory.nrRollUpRows=null;}this.mode=newMode;}},{key:'insertChars',value:function insertChars(chars){for(var i=0;i<chars.length;i++){this.writeScreen.insertChar(chars[i]);}var screen=this.writeScreen===this.displayedMemory?'DISP':'NON_DISP';logger.log('INFO',screen+': '+this.writeScreen.getDisplayText(true));if(this.mode==='MODE_PAINT-ON'||this.mode==='MODE_ROLL-UP'){logger.log('TEXT','DISPLAYED: '+this.displayedMemory.getDisplayText(true));this.outputDataUpdate();}}},{key:'ccRCL',value:function ccRCL(){// Resume Caption Loading (switch mode to Pop On)
logger.log('INFO','RCL - Resume Caption Loading');this.setMode('MODE_POP-ON');}},{key:'ccBS',value:function ccBS(){// BackSpace
logger.log('INFO','BS - BackSpace');if(this.mode==='MODE_TEXT'){return;}this.writeScreen.backSpace();if(this.writeScreen===this.displayedMemory){this.outputDataUpdate();}}},{key:'ccAOF',value:function ccAOF(){// Reserved (formerly Alarm Off)
return;}},{key:'ccAON',value:function ccAON(){// Reserved (formerly Alarm On)
return;}},{key:'ccDER',value:function ccDER(){// Delete to End of Row
logger.log('INFO','DER- Delete to End of Row');this.writeScreen.clearToEndOfRow();this.outputDataUpdate();}},{key:'ccRU',value:function ccRU(nrRows){//Roll-Up Captions-2,3,or 4 Rows
logger.log('INFO','RU('+nrRows+') - Roll Up');this.writeScreen=this.displayedMemory;this.setMode('MODE_ROLL-UP');this.writeScreen.setRollUpRows(nrRows);}},{key:'ccFON',value:function ccFON(){//Flash On
logger.log('INFO','FON - Flash On');this.writeScreen.setPen({flash:true});}},{key:'ccRDC',value:function ccRDC(){// Resume Direct Captioning (switch mode to PaintOn)
logger.log('INFO','RDC - Resume Direct Captioning');this.setMode('MODE_PAINT-ON');}},{key:'ccTR',value:function ccTR(){// Text Restart in text mode (not supported, however)
logger.log('INFO','TR');this.setMode('MODE_TEXT');}},{key:'ccRTD',value:function ccRTD(){// Resume Text Display in Text mode (not supported, however)
logger.log('INFO','RTD');this.setMode('MODE_TEXT');}},{key:'ccEDM',value:function ccEDM(){// Erase Displayed Memory
logger.log('INFO','EDM - Erase Displayed Memory');this.displayedMemory.reset();this.outputDataUpdate();}},{key:'ccCR',value:function ccCR(){// Carriage Return
logger.log('CR - Carriage Return');this.writeScreen.rollUp();this.outputDataUpdate();}},{key:'ccENM',value:function ccENM(){//Erase Non-Displayed Memory
logger.log('INFO','ENM - Erase Non-displayed Memory');this.nonDisplayedMemory.reset();}},{key:'ccEOC',value:function ccEOC(){//End of Caption (Flip Memories)
logger.log('INFO','EOC - End Of Caption');if(this.mode==='MODE_POP-ON'){var tmp=this.displayedMemory;this.displayedMemory=this.nonDisplayedMemory;this.nonDisplayedMemory=tmp;this.writeScreen=this.nonDisplayedMemory;logger.log('TEXT','DISP: '+this.displayedMemory.getDisplayText());}this.outputDataUpdate();}},{key:'ccTO',value:function ccTO(nrCols){// Tab Offset 1,2, or 3 columns
logger.log('INFO','TO('+nrCols+') - Tab Offset');this.writeScreen.moveCursor(nrCols);}},{key:'ccMIDROW',value:function ccMIDROW(secondByte){// Parse MIDROW command
var styles={flash:false};styles.underline=secondByte%2===1;styles.italics=secondByte>=0x2e;if(!styles.italics){var colorIndex=Math.floor(secondByte/2)-0x10;var colors=['white','green','blue','cyan','red','yellow','magenta'];styles.foreground=colors[colorIndex];}else{styles.foreground='white';}logger.log('INFO','MIDROW: '+JSON.stringify(styles));this.writeScreen.setPen(styles);}},{key:'outputDataUpdate',value:function outputDataUpdate(){var t=logger.time;if(t===null){return;}if(this.outputFilter){if(this.outputFilter.updateData){this.outputFilter.updateData(t,this.displayedMemory);}if(this.cueStartTime===null&&!this.displayedMemory.isEmpty()){// Start of a new cue
this.cueStartTime=t;}else{if(!this.displayedMemory.equals(this.lastOutputScreen)){if(this.outputFilter.newCue){this.outputFilter.newCue(this.cueStartTime,t,this.lastOutputScreen);}this.cueStartTime=this.displayedMemory.isEmpty()?null:t;}}this.lastOutputScreen.copy(this.displayedMemory);}}},{key:'cueSplitAtTime',value:function cueSplitAtTime(t){if(this.outputFilter){if(!this.displayedMemory.isEmpty()){if(this.outputFilter.newCue){this.outputFilter.newCue(this.cueStartTime,t,this.displayedMemory);}this.cueStartTime=t;}}}}]);return Cea608Channel;}();var Cea608Parser=function(){function Cea608Parser(field,out1,out2){_classCallCheck(this,Cea608Parser);this.field=field||1;this.outputs=[out1,out2];this.channels=[new Cea608Channel(1,out1),new Cea608Channel(2,out2)];this.currChNr=-1;// Will be 1 or 2
this.lastCmdA=null;// First byte of last command
this.lastCmdB=null;// Second byte of last command
this.bufferedData=[];this.startTime=null;this.lastTime=null;this.dataCounters={'padding':0,'char':0,'cmd':0,'other':0};}_createClass(Cea608Parser,[{key:'getHandler',value:function getHandler(index){return this.channels[index].getHandler();}},{key:'setHandler',value:function setHandler(index,newHandler){this.channels[index].setHandler(newHandler);}/**
         * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
         */},{key:'addData',value:function addData(t,byteList){var cmdFound,a,b,charsFound=false;this.lastTime=t;logger.setTime(t);for(var i=0;i<byteList.length;i+=2){a=byteList[i]&0x7f;b=byteList[i+1]&0x7f;if(a===0&&b===0){this.dataCounters.padding+=2;continue;}else{logger.log('DATA','['+numArrayToHexArray([byteList[i],byteList[i+1]])+'] -> ('+numArrayToHexArray([a,b])+')');}cmdFound=this.parseCmd(a,b);if(!cmdFound){cmdFound=this.parseMidrow(a,b);}if(!cmdFound){cmdFound=this.parsePAC(a,b);}if(!cmdFound){cmdFound=this.parseBackgroundAttributes(a,b);}if(!cmdFound){charsFound=this.parseChars(a,b);if(charsFound){if(this.currChNr&&this.currChNr>=0){var channel=this.channels[this.currChNr-1];channel.insertChars(charsFound);}else{logger.log('WARNING','No channel found yet. TEXT-MODE?');}}}if(cmdFound){this.dataCounters.cmd+=2;}else if(charsFound){this.dataCounters.char+=2;}else{this.dataCounters.other+=2;logger.log('WARNING','Couldn\'t parse cleaned data '+numArrayToHexArray([a,b])+' orig: '+numArrayToHexArray([byteList[i],byteList[i+1]]));}}}/**
         * Parse Command.
         * @returns {Boolean} Tells if a command was found
         */},{key:'parseCmd',value:function parseCmd(a,b){var chNr=null;var cond1=(a===0x14||a===0x1C)&&0x20<=b&&b<=0x2F;var cond2=(a===0x17||a===0x1F)&&0x21<=b&&b<=0x23;if(!(cond1||cond2)){return false;}if(a===this.lastCmdA&&b===this.lastCmdB){this.lastCmdA=null;this.lastCmdB=null;// Repeated commands are dropped (once)
logger.log('DEBUG','Repeated command ('+numArrayToHexArray([a,b])+') is dropped');return true;}if(a===0x14||a===0x17){chNr=1;}else{chNr=2;// (a === 0x1C || a=== 0x1f)
}var channel=this.channels[chNr-1];if(a===0x14||a===0x1C){if(b===0x20){channel.ccRCL();}else if(b===0x21){channel.ccBS();}else if(b===0x22){channel.ccAOF();}else if(b===0x23){channel.ccAON();}else if(b===0x24){channel.ccDER();}else if(b===0x25){channel.ccRU(2);}else if(b===0x26){channel.ccRU(3);}else if(b===0x27){channel.ccRU(4);}else if(b===0x28){channel.ccFON();}else if(b===0x29){channel.ccRDC();}else if(b===0x2A){channel.ccTR();}else if(b===0x2B){channel.ccRTD();}else if(b===0x2C){channel.ccEDM();}else if(b===0x2D){channel.ccCR();}else if(b===0x2E){channel.ccENM();}else if(b===0x2F){channel.ccEOC();}}else{//a == 0x17 || a == 0x1F
channel.ccTO(b-0x20);}this.lastCmdA=a;this.lastCmdB=b;this.currChNr=chNr;return true;}/**
         * Parse midrow styling command
         * @returns {Boolean}
         */},{key:'parseMidrow',value:function parseMidrow(a,b){var chNr=null;if((a===0x11||a===0x19)&&0x20<=b&&b<=0x2f){if(a===0x11){chNr=1;}else{chNr=2;}if(chNr!==this.currChNr){logger.log('ERROR','Mismatch channel in midrow parsing');return false;}var channel=this.channels[chNr-1];channel.ccMIDROW(b);logger.log('DEBUG','MIDROW ('+numArrayToHexArray([a,b])+')');return true;}return false;}/**
         * Parse Preable Access Codes (Table 53).
         * @returns {Boolean} Tells if PAC found
         */},{key:'parsePAC',value:function parsePAC(a,b){var chNr=null;var row=null;var case1=(0x11<=a&&a<=0x17||0x19<=a&&a<=0x1F)&&0x40<=b&&b<=0x7F;var case2=(a===0x10||a===0x18)&&0x40<=b&&b<=0x5F;if(!(case1||case2)){return false;}if(a===this.lastCmdA&&b===this.lastCmdB){this.lastCmdA=null;this.lastCmdB=null;return true;// Repeated commands are dropped (once)
}chNr=a<=0x17?1:2;if(0x40<=b&&b<=0x5F){row=chNr===1?rowsLowCh1[a]:rowsLowCh2[a];}else{// 0x60 <= b <= 0x7F
row=chNr===1?rowsHighCh1[a]:rowsHighCh2[a];}var pacData=this.interpretPAC(row,b);var channel=this.channels[chNr-1];channel.setPAC(pacData);this.lastCmdA=a;this.lastCmdB=b;this.currChNr=chNr;return true;}/**
         * Interpret the second byte of the pac, and return the information.
         * @returns {Object} pacData with style parameters.
         */},{key:'interpretPAC',value:function interpretPAC(row,byte){var pacIndex=byte;var pacData={color:null,italics:false,indent:null,underline:false,row:row};if(byte>0x5F){pacIndex=byte-0x60;}else{pacIndex=byte-0x40;}pacData.underline=(pacIndex&1)===1;if(pacIndex<=0xd){pacData.color=['white','green','blue','cyan','red','yellow','magenta','white'][Math.floor(pacIndex/2)];}else if(pacIndex<=0xf){pacData.italics=true;pacData.color='white';}else{pacData.indent=Math.floor((pacIndex-0x10)/2)*4;}return pacData;// Note that row has zero offset. The spec uses 1.
}/**
         * Parse characters.
         * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
         */},{key:'parseChars',value:function parseChars(a,b){var channelNr=null,charCodes=null,charCode1=null;if(a>=0x19){channelNr=2;charCode1=a-8;}else{channelNr=1;charCode1=a;}if(0x11<=charCode1&&charCode1<=0x13){// Special character
var oneCode=b;if(charCode1===0x11){oneCode=b+0x50;}else if(charCode1===0x12){oneCode=b+0x70;}else{oneCode=b+0x90;}logger.log('INFO','Special char \''+getCharForByte(oneCode)+'\' in channel '+channelNr);charCodes=[oneCode];}else if(0x20<=a&&a<=0x7f){charCodes=b===0?[a]:[a,b];}if(charCodes){var hexCodes=numArrayToHexArray(charCodes);logger.log('DEBUG','Char codes =  '+hexCodes.join(','));this.lastCmdA=null;this.lastCmdB=null;}return charCodes;}/**
        * Parse extended background attributes as well as new foreground color black.
        * @returns{Boolean} Tells if background attributes are found
        */},{key:'parseBackgroundAttributes',value:function parseBackgroundAttributes(a,b){var bkgData,index,chNr,channel;var case1=(a===0x10||a===0x18)&&0x20<=b&&b<=0x2f;var case2=(a===0x17||a===0x1f)&&0x2d<=b&&b<=0x2f;if(!(case1||case2)){return false;}bkgData={};if(a===0x10||a===0x18){index=Math.floor((b-0x20)/2);bkgData.background=backgroundColors[index];if(b%2===1){bkgData.background=bkgData.background+'_semi';}}else if(b===0x2d){bkgData.background='transparent';}else{bkgData.foreground='black';if(b===0x2f){bkgData.underline=true;}}chNr=a<0x18?1:2;channel=this.channels[chNr-1];channel.setBkgData(bkgData);this.lastCmdA=null;this.lastCmdB=null;return true;}/**
         * Reset state of parser and its channels.
         */},{key:'reset',value:function reset(){for(var i=0;i<this.channels.length;i++){if(this.channels[i]){this.channels[i].reset();}}this.lastCmdA=null;this.lastCmdB=null;}/**
         * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
         */},{key:'cueSplitAtTime',value:function cueSplitAtTime(t){for(var i=0;i<this.channels.length;i++){if(this.channels[i]){this.channels[i].cueSplitAtTime(t);}}}}]);return Cea608Parser;}();exports.default=Cea608Parser;},{}],50:[function(_dereq_,module,exports){'use strict';var _vttparser=_dereq_(56);var Cues={newCue:function newCue(track,startTime,endTime,captionScreen){var row;var cue;var indenting;var indent;var text;var VTTCue=window.VTTCue||window.TextTrackCue;for(var r=0;r<captionScreen.rows.length;r++){row=captionScreen.rows[r];indenting=true;indent=0;text='';if(!row.isEmpty()){for(var c=0;c<row.chars.length;c++){if(row.chars[c].uchar.match(/\s/)&&indenting){indent++;}else{text+=row.chars[c].uchar;indenting=false;}}//To be used for cleaning-up orphaned roll-up captions
row.cueStartTime=startTime;// Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
if(startTime===endTime){endTime+=0.0001;}cue=new VTTCue(startTime,endTime,(0,_vttparser.fixLineBreaks)(text.trim()));if(indent>=16){indent--;}else{indent++;}// VTTCue.line get's flakey when using controls, so let's now include line 13&14
// also, drop line 1 since it's to close to the top
if(navigator.userAgent.match(/Firefox\//)){cue.line=r+1;}else{cue.line=r>7?r-2:r+1;}cue.align='left';// Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
cue.position=Math.max(0,Math.min(100,100*(indent/32)+(navigator.userAgent.match(/Firefox\//)?50:0)));track.addCue(cue);}}}};module.exports=Cues;},{"56":56}],51:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */var _ewma=_dereq_(52);var _ewma2=_interopRequireDefault(_ewma);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var EwmaBandWidthEstimator=function(){function EwmaBandWidthEstimator(hls,slow,fast,defaultEstimate){_classCallCheck(this,EwmaBandWidthEstimator);this.hls=hls;this.defaultEstimate_=defaultEstimate;this.minWeight_=0.001;this.minDelayMs_=50;this.slow_=new _ewma2.default(slow);this.fast_=new _ewma2.default(fast);}_createClass(EwmaBandWidthEstimator,[{key:'sample',value:function sample(durationMs,numBytes){durationMs=Math.max(durationMs,this.minDelayMs_);var bandwidth=8000*numBytes/durationMs,//console.log('instant bw:'+ Math.round(bandwidth));
// we weight sample using loading duration....
weight=durationMs/1000;this.fast_.sample(weight,bandwidth);this.slow_.sample(weight,bandwidth);}},{key:'canEstimate',value:function canEstimate(){var fast=this.fast_;return fast&&fast.getTotalWeight()>=this.minWeight_;}},{key:'getEstimate',value:function getEstimate(){if(this.canEstimate()){//console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
//console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
// Take the minimum of these two estimates.  This should have the effect of
// adapting down quickly, but up more slowly.
return Math.min(this.fast_.getEstimate(),this.slow_.getEstimate());}else{return this.defaultEstimate_;}}},{key:'destroy',value:function destroy(){}}]);return EwmaBandWidthEstimator;}();exports.default=EwmaBandWidthEstimator;},{"52":52}],52:[function(_dereq_,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */var EWMA=function(){//  About half of the estimated value will be from the last |halfLife| samples by weight.
function EWMA(halfLife){_classCallCheck(this,EWMA);// Larger values of alpha expire historical data more slowly.
this.alpha_=halfLife?Math.exp(Math.log(0.5)/halfLife):0;this.estimate_=0;this.totalWeight_=0;}_createClass(EWMA,[{key:"sample",value:function sample(weight,value){var adjAlpha=Math.pow(this.alpha_,weight);this.estimate_=value*(1-adjAlpha)+adjAlpha*this.estimate_;this.totalWeight_+=weight;}},{key:"getTotalWeight",value:function getTotalWeight(){return this.totalWeight_;}},{key:"getEstimate",value:function getEstimate(){if(this.alpha_){var zeroFactor=1-Math.pow(this.alpha_,this.totalWeight_);return this.estimate_/zeroFactor;}else{return this.estimate_;}}}]);return EWMA;}();exports.default=EWMA;},{}],53:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};function noop(){}var fakeLogger={trace:noop,debug:noop,log:noop,warn:noop,info:noop,error:noop};var exportedLogger=fakeLogger;/*globals self: false *///let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }
function formatMsg(type,msg){msg='['+type+'] > '+msg;return msg;}function consolePrintFn(type){var func=self.console[type];if(func){return function(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}if(args[0]){args[0]=formatMsg(type,args[0]);}func.apply(self.console,args);};}return noop;}function exportLoggerFunctions(debugConfig){for(var _len2=arguments.length,functions=Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){functions[_key2-1]=arguments[_key2];}functions.forEach(function(type){exportedLogger[type]=debugConfig[type]?debugConfig[type].bind(debugConfig):consolePrintFn(type);});}var enableLogs=exports.enableLogs=function enableLogs(debugConfig){if(debugConfig===true||(typeof debugConfig==='undefined'?'undefined':_typeof(debugConfig))==='object'){exportLoggerFunctions(debugConfig,// Remove out from list here to hard-disable a log-level
//'trace',
'debug','log','info','warn','error');// Some browsers don't allow to use bind on console object anyway
// fallback to default if needed
try{exportedLogger.log();}catch(e){exportedLogger=fakeLogger;}}else{exportedLogger=fakeLogger;}};var logger=exports.logger=exportedLogger;},{}],54:[function(_dereq_,module,exports){'use strict';/**
 *  TimeRanges to string helper
 */var TimeRanges={toString:function toString(r){var log='',len=r.length;for(var i=0;i<len;i++){log+='['+r.start(i).toFixed(3)+','+r.end(i).toFixed(3)+']';}return log;}};module.exports=TimeRanges;},{}],55:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */exports.default=function(){if(typeof window!=='undefined'&&window.VTTCue){return window.VTTCue;}var autoKeyword='auto';var directionSetting={'':true,lr:true,rl:true};var alignSetting={start:true,middle:true,end:true,left:true,right:true};function findDirectionSetting(value){if(typeof value!=='string'){return false;}var dir=directionSetting[value.toLowerCase()];return dir?value.toLowerCase():false;}function findAlignSetting(value){if(typeof value!=='string'){return false;}var align=alignSetting[value.toLowerCase()];return align?value.toLowerCase():false;}function extend(obj){var i=1;for(;i<arguments.length;i++){var cobj=arguments[i];for(var p in cobj){obj[p]=cobj[p];}}return obj;}function VTTCue(startTime,endTime,text){var cue=this;var isIE8=function(){if(typeof navigator==='undefined'){return;}return /MSIE\s8\.0/.test(navigator.userAgent);}();var baseObj={};if(isIE8){cue=document.createElement('custom');}else{baseObj.enumerable=true;}/**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */// Lets us know when the VTTCue's data has changed in such a way that we need
// to recompute its display state. This lets us compute its display state
// lazily.
cue.hasBeenReset=false;/**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */var _id='';var _pauseOnExit=false;var _startTime=startTime;var _endTime=endTime;var _text=text;var _region=null;var _vertical='';var _snapToLines=true;var _line='auto';var _lineAlign='start';var _position=50;var _positionAlign='middle';var _size=50;var _align='middle';Object.defineProperty(cue,'id',extend({},baseObj,{get:function get(){return _id;},set:function set(value){_id=''+value;}}));Object.defineProperty(cue,'pauseOnExit',extend({},baseObj,{get:function get(){return _pauseOnExit;},set:function set(value){_pauseOnExit=!!value;}}));Object.defineProperty(cue,'startTime',extend({},baseObj,{get:function get(){return _startTime;},set:function set(value){if(typeof value!=='number'){throw new TypeError('Start time must be set to a number.');}_startTime=value;this.hasBeenReset=true;}}));Object.defineProperty(cue,'endTime',extend({},baseObj,{get:function get(){return _endTime;},set:function set(value){if(typeof value!=='number'){throw new TypeError('End time must be set to a number.');}_endTime=value;this.hasBeenReset=true;}}));Object.defineProperty(cue,'text',extend({},baseObj,{get:function get(){return _text;},set:function set(value){_text=''+value;this.hasBeenReset=true;}}));Object.defineProperty(cue,'region',extend({},baseObj,{get:function get(){return _region;},set:function set(value){_region=value;this.hasBeenReset=true;}}));Object.defineProperty(cue,'vertical',extend({},baseObj,{get:function get(){return _vertical;},set:function set(value){var setting=findDirectionSetting(value);// Have to check for false because the setting an be an empty string.
if(setting===false){throw new SyntaxError('An invalid or illegal string was specified.');}_vertical=setting;this.hasBeenReset=true;}}));Object.defineProperty(cue,'snapToLines',extend({},baseObj,{get:function get(){return _snapToLines;},set:function set(value){_snapToLines=!!value;this.hasBeenReset=true;}}));Object.defineProperty(cue,'line',extend({},baseObj,{get:function get(){return _line;},set:function set(value){if(typeof value!=='number'&&value!==autoKeyword){throw new SyntaxError('An invalid number or illegal string was specified.');}_line=value;this.hasBeenReset=true;}}));Object.defineProperty(cue,'lineAlign',extend({},baseObj,{get:function get(){return _lineAlign;},set:function set(value){var setting=findAlignSetting(value);if(!setting){throw new SyntaxError('An invalid or illegal string was specified.');}_lineAlign=setting;this.hasBeenReset=true;}}));Object.defineProperty(cue,'position',extend({},baseObj,{get:function get(){return _position;},set:function set(value){if(value<0||value>100){throw new Error('Position must be between 0 and 100.');}_position=value;this.hasBeenReset=true;}}));Object.defineProperty(cue,'positionAlign',extend({},baseObj,{get:function get(){return _positionAlign;},set:function set(value){var setting=findAlignSetting(value);if(!setting){throw new SyntaxError('An invalid or illegal string was specified.');}_positionAlign=setting;this.hasBeenReset=true;}}));Object.defineProperty(cue,'size',extend({},baseObj,{get:function get(){return _size;},set:function set(value){if(value<0||value>100){throw new Error('Size must be between 0 and 100.');}_size=value;this.hasBeenReset=true;}}));Object.defineProperty(cue,'align',extend({},baseObj,{get:function get(){return _align;},set:function set(value){var setting=findAlignSetting(value);if(!setting){throw new SyntaxError('An invalid or illegal string was specified.');}_align=setting;this.hasBeenReset=true;}}));/**
     * Other <track> spec defined properties
     */// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
cue.displayState=undefined;if(isIE8){return cue;}}/**
   * VTTCue methods
   */VTTCue.prototype.getCueAsHTML=function(){// Assume WebVTT.convertCueToDOMTree is on the global.
var WebVTT=window.WebVTT;return WebVTT.convertCueToDOMTree(window,this.text);};return VTTCue;}();},{}],56:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});exports.fixLineBreaks=undefined;var _vttcue=_dereq_(55);var _vttcue2=_interopRequireDefault(_vttcue);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var StringDecoder=function StringDecoder(){return{decode:function decode(data){if(!data){return'';}if(typeof data!=='string'){throw new Error('Error - expected string data.');}return decodeURIComponent(encodeURIComponent(data));}};};/*
    * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
    */function VTTParser(){this.window=window;this.state='INITIAL';this.buffer='';this.decoder=new StringDecoder();this.regionList=[];}// Try to parse input as a time stamp.
function parseTimeStamp(input){function computeSeconds(h,m,s,f){return(h|0)*3600+(m|0)*60+(s|0)+(f|0)/1000;}var m=input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);if(!m){return null;}if(m[3]){// Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
return computeSeconds(m[1],m[2],m[3].replace(':',''),m[4]);}else if(m[1]>59){// Timestamp takes the form of [hours]:[minutes].[milliseconds]
// First position is hours as it's over 59.
return computeSeconds(m[1],m[2],0,m[4]);}else{// Timestamp takes the form of [minutes]:[seconds].[milliseconds]
return computeSeconds(0,m[1],m[2],m[4]);}}// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings(){this.values=Object.create(null);}Settings.prototype={// Only accept the first assignment to any key.
set:function set(k,v){if(!this.get(k)&&v!==''){this.values[k]=v;}},// Return the value for a key, or a default value.
// If 'defaultKey' is passed then 'dflt' is assumed to be an object with
// a number of possible default values as properties where 'defaultKey' is
// the key of the property that will be chosen; otherwise it's assumed to be
// a single value.
get:function get(k,dflt,defaultKey){if(defaultKey){return this.has(k)?this.values[k]:dflt[defaultKey];}return this.has(k)?this.values[k]:dflt;},// Check whether we have a value for a key.
has:function has(k){return k in this.values;},// Accept a setting if its one of the given alternatives.
alt:function alt(k,v,a){for(var n=0;n<a.length;++n){if(v===a[n]){this.set(k,v);break;}}},// Accept a setting if its a valid (signed) integer.
integer:function integer(k,v){if(/^-?\d+$/.test(v)){// integer
this.set(k,parseInt(v,10));}},// Accept a setting if its a valid percentage.
percent:function percent(k,v){var m;if(m=v.match(/^([\d]{1,3})(\.[\d]*)?%$/)){v=parseFloat(v);if(v>=0&&v<=100){this.set(k,v);return true;}}return false;}};// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input,callback,keyValueDelim,groupDelim){var groups=groupDelim?input.split(groupDelim):[input];for(var i in groups){if(typeof groups[i]!=='string'){continue;}var kv=groups[i].split(keyValueDelim);if(kv.length!==2){continue;}var k=kv[0];var v=kv[1];callback(k,v);}}var defaults=new _vttcue2.default(0,0,0);// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
// Chrome and Safari don't yet support this change, but FF does
var center=defaults.align==='middle'?'middle':'center';function parseCue(input,cue,regionList){// Remember the original input if we need to throw an error.
var oInput=input;// 4.1 WebVTT timestamp
function consumeTimeStamp(){var ts=parseTimeStamp(input);if(ts===null){throw new Error('Malformed timestamp: '+oInput);}// Remove time stamp from input.
input=input.replace(/^[^\sa-zA-Z-]+/,'');return ts;}// 4.4.2 WebVTT cue settings
function consumeCueSettings(input,cue){var settings=new Settings();parseOptions(input,function(k,v){switch(k){case'region':// Find the last region we parsed with the same region id.
for(var i=regionList.length-1;i>=0;i--){if(regionList[i].id===v){settings.set(k,regionList[i].region);break;}}break;case'vertical':settings.alt(k,v,['rl','lr']);break;case'line':var vals=v.split(','),vals0=vals[0];settings.integer(k,vals0);if(settings.percent(k,vals0)){settings.set('snapToLines',false);}settings.alt(k,vals0,['auto']);if(vals.length===2){settings.alt('lineAlign',vals[1],['start',center,'end']);}break;case'position':vals=v.split(',');settings.percent(k,vals[0]);if(vals.length===2){settings.alt('positionAlign',vals[1],['start',center,'end','line-left','line-right','auto']);}break;case'size':settings.percent(k,v);break;case'align':settings.alt(k,v,['start',center,'end','left','right']);break;}},/:/,/\s/);// Apply default values for any missing fields.
cue.region=settings.get('region',null);cue.vertical=settings.get('vertical','');var line=settings.get('line','auto');if(line==='auto'&&defaults.line===-1){// set numeric line number for Safari
line=-1;}cue.line=line;cue.lineAlign=settings.get('lineAlign','start');cue.snapToLines=settings.get('snapToLines',true);cue.size=settings.get('size',100);cue.align=settings.get('align',center);var position=settings.get('position','auto');if(position==='auto'&&defaults.position===50){// set numeric position for Safari
position=cue.align==='start'||cue.align==='left'?0:cue.align==='end'||cue.align==='right'?100:50;}cue.position=position;}function skipWhitespace(){input=input.replace(/^\s+/,'');}// 4.1 WebVTT cue timings.
skipWhitespace();cue.startTime=consumeTimeStamp();// (1) collect cue start time
skipWhitespace();if(input.substr(0,3)!=='-->'){// (3) next characters must match '-->'
throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): '+oInput);}input=input.substr(3);skipWhitespace();cue.endTime=consumeTimeStamp();// (5) collect cue end time
// 4.1 WebVTT cue settings list.
skipWhitespace();consumeCueSettings(input,cue);}function fixLineBreaks(input){return input.replace(/<br(?: \/)?>/gi,'\n');}VTTParser.prototype={parse:function parse(data){var self=this;// If there is no data then we won't decode it, but will just try to parse
// whatever is in buffer already. This may occur in circumstances, for
// example when flush() is called.
if(data){// Try to decode the data that we received.
self.buffer+=self.decoder.decode(data,{stream:true});}function collectNextLine(){var buffer=self.buffer;var pos=0;buffer=fixLineBreaks(buffer);while(pos<buffer.length&&buffer[pos]!=='\r'&&buffer[pos]!=='\n'){++pos;}var line=buffer.substr(0,pos);// Advance the buffer early in case we fail below.
if(buffer[pos]==='\r'){++pos;}if(buffer[pos]==='\n'){++pos;}self.buffer=buffer.substr(pos);return line;}// 3.2 WebVTT metadata header syntax
function parseHeader(input){parseOptions(input,function(k,v){switch(k){case'Region':// 3.3 WebVTT region metadata header syntax
console.log('parse region',v);//parseRegion(v);
break;}},/:/);}// 5.1 WebVTT file parsing.
try{var line;if(self.state==='INITIAL'){// We can't start parsing until we have the first line.
if(!/\r\n|\n/.test(self.buffer)){return this;}line=collectNextLine();var m=line.match(/^WEBVTT([ \t].*)?$/);if(!m||!m[0]){throw new Error('Malformed WebVTT signature.');}self.state='HEADER';}var alreadyCollectedLine=false;while(self.buffer){// We can't parse a line until we have the full line.
if(!/\r\n|\n/.test(self.buffer)){return this;}if(!alreadyCollectedLine){line=collectNextLine();}else{alreadyCollectedLine=false;}switch(self.state){case'HEADER':// 13-18 - Allow a header (metadata) under the WEBVTT line.
if(/:/.test(line)){parseHeader(line);}else if(!line){// An empty line terminates the header and starts the body (cues).
self.state='ID';}continue;case'NOTE':// Ignore NOTE blocks.
if(!line){self.state='ID';}continue;case'ID':// Check for the start of NOTE blocks.
if(/^NOTE($|[ \t])/.test(line)){self.state='NOTE';break;}// 19-29 - Allow any number of line terminators, then initialize new cue values.
if(!line){continue;}self.cue=new _vttcue2.default(0,0,'');self.state='CUE';// 30-39 - Check if self line contains an optional identifier or timing data.
if(line.indexOf('-->')===-1){self.cue.id=line;continue;}// Process line as start of a cue.
/*falls through*/case'CUE':// 40 - Collect cue timings and settings.
try{parseCue(line,self.cue,self.regionList);}catch(e){// In case of an error ignore rest of the cue.
self.cue=null;self.state='BADCUE';continue;}self.state='CUETEXT';continue;case'CUETEXT':var hasSubstring=line.indexOf('-->')!==-1;// 34 - If we have an empty line then report the cue.
// 35 - If we have the special substring '-->' then report the cue,
// but do not collect the line as we need to process the current
// one as a new cue.
if(!line||hasSubstring&&(alreadyCollectedLine=true)){// We are done parsing self cue.
if(self.oncue){self.oncue(self.cue);}self.cue=null;self.state='ID';continue;}if(self.cue.text){self.cue.text+='\n';}self.cue.text+=line;continue;case'BADCUE':// BADCUE
// 54-62 - Collect and discard the remaining cue.
if(!line){self.state='ID';}continue;}}}catch(e){// If we are currently parsing a cue, report what we have.
if(self.state==='CUETEXT'&&self.cue&&self.oncue){self.oncue(self.cue);}self.cue=null;// Enter BADWEBVTT state if header was not parsed correctly otherwise
// another exception occurred so enter BADCUE state.
self.state=self.state==='INITIAL'?'BADWEBVTT':'BADCUE';}return this;},flush:function flush(){var self=this;try{// Finish decoding the stream.
self.buffer+=self.decoder.decode();// Synthesize the end of the current cue or region.
if(self.cue||self.state==='HEADER'){self.buffer+='\n\n';self.parse();}// If we've flushed, parsed, and we're still on the INITIAL state then
// that means we don't have enough of the stream to parse the first
// line.
if(self.state==='INITIAL'){throw new Error('Malformed WebVTT signature.');}}catch(e){throw e;}if(self.onflush){self.onflush();}return this;}};exports.fixLineBreaks=fixLineBreaks;exports.default=VTTParser;},{"55":55}],57:[function(_dereq_,module,exports){'use strict';var _vttparser=_dereq_(56);var _vttparser2=_interopRequireDefault(_vttparser);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// String.prototype.startsWith is not supported in IE11
var startsWith=function startsWith(inputString,searchString,position){return inputString.substr(position||0,searchString.length)===searchString;};var cueString2millis=function cueString2millis(timeString){var ts=parseInt(timeString.substr(-3));var secs=parseInt(timeString.substr(-6,2));var mins=parseInt(timeString.substr(-9,2));var hours=timeString.length>9?parseInt(timeString.substr(0,timeString.indexOf(':'))):0;if(isNaN(ts)||isNaN(secs)||isNaN(mins)||isNaN(hours)){return-1;}ts+=1000*secs;ts+=60*1000*mins;ts+=60*60*1000*hours;return ts;};// From https://github.com/darkskyapp/string-hash
var hash=function hash(text){var hash=5381;var i=text.length;while(i){hash=hash*33^text.charCodeAt(--i);}return(hash>>>0).toString();};var calculateOffset=function calculateOffset(vttCCs,cc,presentationTime){var currCC=vttCCs[cc];var prevCC=vttCCs[currCC.prevCC];// This is the first discontinuity or cues have been processed since the last discontinuity
// Offset = current discontinuity time
if(!prevCC||!prevCC.new&&currCC.new){vttCCs.ccOffset=vttCCs.presentationOffset=currCC.start;currCC.new=false;return;}// There have been discontinuities since cues were last parsed.
// Offset = time elapsed
while(prevCC&&prevCC.new){vttCCs.ccOffset+=currCC.start-prevCC.start;currCC.new=false;currCC=prevCC;prevCC=vttCCs[currCC.prevCC];}vttCCs.presentationOffset=presentationTime;};var WebVTTParser={parse:function parse(vttByteArray,syncPTS,vttCCs,cc,callBack,errorCallBack){// Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
var re=/\r\n|\n\r|\n|\r/g;var vttLines=String.fromCharCode.apply(null,new Uint8Array(vttByteArray)).trim().replace(re,'\n').split('\n');var cueTime='00:00.000';var mpegTs=0;var localTime=0;var presentationTime=0;var cues=[];var parsingError=void 0;var inHeader=true;// let VTTCue = VTTCue || window.TextTrackCue;
// Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
var parser=new _vttparser2.default();parser.oncue=function(cue){// Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
var currCC=vttCCs[cc];var cueOffset=vttCCs.ccOffset;// Update offsets for new discontinuities
if(currCC&&currCC.new){if(localTime!==undefined){// When local time is provided, offset = discontinuity start time - local time
cueOffset=vttCCs.ccOffset=currCC.start;}else{calculateOffset(vttCCs,cc,presentationTime);}}if(presentationTime){// If we have MPEGTS, offset = presentation time + discontinuity offset
cueOffset=presentationTime+vttCCs.ccOffset-vttCCs.presentationOffset;}cue.startTime+=cueOffset-localTime;cue.endTime+=cueOffset-localTime;// Create a unique hash id for a cue based on start/end times and text.
// This helps timeline-controller to avoid showing repeated captions.
cue.id=hash(cue.startTime)+hash(cue.endTime)+hash(cue.text);// Fix encoding of special characters. TODO: Test with all sorts of weird characters.
cue.text=decodeURIComponent(escape(cue.text));if(cue.endTime>0){cues.push(cue);}};parser.onparsingerror=function(e){parsingError=e;};parser.onflush=function(){if(parsingError&&errorCallBack){errorCallBack(parsingError);return;}callBack(cues);};// Go through contents line by line.
vttLines.forEach(function(line){if(inHeader){// Look for X-TIMESTAMP-MAP in header.
if(startsWith(line,'X-TIMESTAMP-MAP=')){// Once found, no more are allowed anyway, so stop searching.
inHeader=false;// Extract LOCAL and MPEGTS.
line.substr(16).split(',').forEach(function(timestamp){if(startsWith(timestamp,'LOCAL:')){cueTime=timestamp.substr(6);}else if(startsWith(timestamp,'MPEGTS:')){mpegTs=parseInt(timestamp.substr(7));}});try{// Calculate subtitle offset in milliseconds.
// If sync PTS is less than zero, we have a 33-bit wraparound, which is fixed by adding 2^33 = 8589934592.
syncPTS=syncPTS<0?syncPTS+8589934592:syncPTS;// Adjust MPEGTS by sync PTS.
mpegTs-=syncPTS;// Convert cue time to seconds
localTime=cueString2millis(cueTime)/1000;// Convert MPEGTS to seconds from 90kHz.
presentationTime=mpegTs/90000;if(localTime===-1){parsingError=new Error('Malformed X-TIMESTAMP-MAP: '+line);}}catch(e){parsingError=new Error('Malformed X-TIMESTAMP-MAP: '+line);}// Return without parsing X-TIMESTAMP-MAP line.
return;}else if(line===''){inHeader=false;}}// Parse line by default.
parser.parse(line+'\n');});parser.flush();}};module.exports=WebVTTParser;},{"56":56}],58:[function(_dereq_,module,exports){'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();/**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */var _logger=_dereq_(53);function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var XhrLoader=function(){function XhrLoader(config){_classCallCheck(this,XhrLoader);if(config&&config.xhrSetup){this.xhrSetup=config.xhrSetup;}}_createClass(XhrLoader,[{key:'destroy',value:function destroy(){this.abort();this.loader=null;}},{key:'abort',value:function abort(){var loader=this.loader;if(loader&&loader.readyState!==4){this.stats.aborted=true;loader.abort();}window.clearTimeout(this.requestTimeout);this.requestTimeout=null;window.clearTimeout(this.retryTimeout);this.retryTimeout=null;}},{key:'load',value:function load(context,config,callbacks){this.context=context;this.config=config;this.callbacks=callbacks;this.stats={trequest:performance.now(),retry:0};this.retryDelay=config.retryDelay;this.loadInternal();}},{key:'loadInternal',value:function loadInternal(){var xhr,context=this.context;if(typeof XDomainRequest!=='undefined'){xhr=this.loader=new XDomainRequest();}else{xhr=this.loader=new XMLHttpRequest();}var stats=this.stats;stats.tfirst=0;stats.loaded=0;var xhrSetup=this.xhrSetup;try{if(xhrSetup){try{xhrSetup(xhr,context.url);}catch(e){// fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
// not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
xhr.open('GET',context.url,true);xhrSetup(xhr,context.url);}}if(!xhr.readyState){xhr.open('GET',context.url,true);}}catch(e){// IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
this.callbacks.onError({code:xhr.status,text:e.message},context);return;}if(context.rangeEnd){xhr.setRequestHeader('Range','bytes='+context.rangeStart+'-'+(context.rangeEnd-1));}xhr.onreadystatechange=this.readystatechange.bind(this);xhr.onprogress=this.loadprogress.bind(this);xhr.responseType=context.responseType;// setup timeout before we perform request
this.requestTimeout=window.setTimeout(this.loadtimeout.bind(this),this.config.timeout);xhr.send();}},{key:'readystatechange',value:function readystatechange(event){var xhr=event.currentTarget,readyState=xhr.readyState,stats=this.stats,context=this.context,config=this.config;// don't proceed if xhr has been aborted
if(stats.aborted){return;}// >= HEADERS_RECEIVED
if(readyState>=2){// clear xhr timeout and rearm it if readyState less than 4
window.clearTimeout(this.requestTimeout);if(stats.tfirst===0){stats.tfirst=Math.max(performance.now(),stats.trequest);}if(readyState===4){var status=xhr.status;// http status between 200 to 299 are all successful
if(status>=200&&status<300){stats.tload=Math.max(stats.tfirst,performance.now());var data=void 0,len=void 0;if(context.responseType==='arraybuffer'){data=xhr.response;len=data.byteLength;}else{data=xhr.responseText;len=data.length;}stats.loaded=stats.total=len;var response={url:xhr.responseURL,data:data};this.callbacks.onSuccess(response,stats,context);}else{// if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
if(stats.retry>=config.maxRetry||status>=400&&status<499){_logger.logger.error(status+' while loading '+context.url);this.callbacks.onError({code:status,text:xhr.statusText},context);}else{// retry
_logger.logger.warn(status+' while loading '+context.url+', retrying in '+this.retryDelay+'...');// aborts and resets internal state
this.destroy();// schedule retry
this.retryTimeout=window.setTimeout(this.loadInternal.bind(this),this.retryDelay);// set exponential backoff
this.retryDelay=Math.min(2*this.retryDelay,config.maxRetryDelay);stats.retry++;}}}else{// readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
this.requestTimeout=window.setTimeout(this.loadtimeout.bind(this),config.timeout);}}}},{key:'loadtimeout',value:function loadtimeout(){_logger.logger.warn('timeout while loading '+this.context.url);this.callbacks.onTimeout(this.stats,this.context);}},{key:'loadprogress',value:function loadprogress(event){var stats=this.stats;stats.loaded=event.loaded;if(event.lengthComputable){stats.total=event.total;}var onProgress=this.callbacks.onProgress;if(onProgress){// last args is to provide on progress data
onProgress(stats,this.context,null);}}}]);return XhrLoader;}();exports.default=XhrLoader;},{"53":53}]},{},[40])(40);});//# sourceMappingURL=hls.js.map
/***/},/* 174 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _style=__webpack_require__(175);var _style2=_interopRequireDefault(_style);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var HTMLImg=function(_Playback){(0,_inherits3.default)(HTMLImg,_Playback);HTMLImg.prototype.getPlaybackType=function getPlaybackType(){return _playback2.default.NO_OP;};(0,_createClass3.default)(HTMLImg,[{key:'name',get:function get(){return'html_img';}},{key:'tagName',get:function get(){return'img';}},{key:'attributes',get:function get(){return{'data-html-img':''};}},{key:'events',get:function get(){return{'load':'_onLoad','abort':'_onError','error':'_onError'};}}]);function HTMLImg(params){(0,_classCallCheck3.default)(this,HTMLImg);var _this=(0,_possibleConstructorReturn3.default)(this,_Playback.call(this,params));_this.el.src=params.src;return _this;}HTMLImg.prototype.render=function render(){var style=_styler2.default.getStyleFor(_style2.default);this.$el.append(style);this.trigger(_events2.default.PLAYBACK_READY,this.name);return this;};HTMLImg.prototype._onLoad=function _onLoad(){this.trigger(_events2.default.PLAYBACK_ENDED,this.name);};HTMLImg.prototype._onError=function _onError(evt){var m=evt.type==='error'?'load error':'loading aborted';this.trigger(_events2.default.PLAYBACK_ERROR,{message:m},this.name);};return HTMLImg;}(_playback2.default);exports.default=HTMLImg;HTMLImg.canPlay=function(resource){return /\.(png|jpg|jpeg|gif|bmp|tiff|pgm|pnm|webp)(|\?.*)$/i.test(resource);};module.exports=exports['default'];/***/},/* 175 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,"[data-html-img] {\n  max-width: 100%;\n  max-height: 100%; }\n",""]);// exports
/***/},/* 176 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _utils=__webpack_require__(5);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _style=__webpack_require__(177);var _style2=_interopRequireDefault(_style);var _error=__webpack_require__(178);var _error2=_interopRequireDefault(_error);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var NoOp=function(_Playback){(0,_inherits3.default)(NoOp,_Playback);(0,_createClass3.default)(NoOp,[{key:'name',get:function get(){return'no_op';}},{key:'template',get:function get(){return(0,_template2.default)(_error2.default);}},{key:'attributes',get:function get(){return{'data-no-op':''};}}]);function NoOp(){(0,_classCallCheck3.default)(this,NoOp);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var _this=(0,_possibleConstructorReturn3.default)(this,_Playback.call.apply(_Playback,[this].concat(args)));_this._noiseFrameNum=-1;_this._started=false;return _this;}NoOp.prototype.render=function render(){var style=_styler2.default.getStyleFor(_style2.default);var playbackNotSupported=this.options.playbackNotSupportedMessage||this.i18n.t('playback_not_supported');this.$el.html(this.template({message:playbackNotSupported}));this.$el.append(style);this.trigger(_events2.default.PLAYBACK_READY,this.name);var showForNoOp=!!(this.options.poster&&this.options.poster.showForNoOp);if(this.options.autoPlay||!showForNoOp){this.play();}return this;};NoOp.prototype.play=function play(){if(!this._started){this._started=true;this.trigger(_events2.default.PLAYBACK_PLAY);this._animate();}};NoOp.prototype._noise=function _noise(){this._noiseFrameNum=(this._noiseFrameNum+1)%5;if(this._noiseFrameNum){// only update noise every 5 frames to save cpu
return;}var idata=this.context.createImageData(this.context.canvas.width,this.context.canvas.height);var buffer32=void 0;try{buffer32=new Uint32Array(idata.data.buffer);}catch(err){buffer32=new Uint32Array(this.context.canvas.width*this.context.canvas.height*4);var data=idata.data;for(var i=0;i<data.length;i++){buffer32[i]=data[i];}}var len=buffer32.length,m=Math.random()*6+4;var run=0,color=0;for(var _i=0;_i<len;){if(run<0){run=m*Math.random();var p=Math.pow(Math.random(),0.4);color=255*p<<24;}run-=1;buffer32[_i++]=color;}this.context.putImageData(idata,0,0);};NoOp.prototype._loop=function _loop(){var _this2=this;if(this._stop){return;}this._noise();this._animationHandle=(0,_utils.requestAnimationFrame)(function(){return _this2._loop();});};NoOp.prototype.destroy=function destroy(){if(this._animationHandle){(0,_utils.cancelAnimationFrame)(this._animationHandle);this._stop=true;}};NoOp.prototype._animate=function _animate(){this.canvas=this.$el.find('canvas[data-no-op-canvas]')[0];this.context=this.canvas.getContext('2d');this._loop();};return NoOp;}(_playback2.default);exports.default=NoOp;NoOp.canPlay=function(source){// eslint-disable-line no-unused-vars
return true;};module.exports=exports['default'];/***/},/* 177 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,"[data-no-op] {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  text-align: center; }\n\n[data-no-op] p[data-no-op-msg] {\n  position: absolute;\n  text-align: center;\n  font-size: 25px;\n  left: 0;\n  right: 0;\n  color: white;\n  padding: 10px;\n  /* center vertically */\n  top: 50%;\n  -webkit-transform: translateY(-50%);\n  -moz-transform: translateY(-50%);\n  -ms-transform: translateY(-50%);\n  -o-transform: translateY(-50%);\n  transform: translateY(-50%);\n  max-height: 100%;\n  overflow: auto; }\n\n[data-no-op] canvas[data-no-op-canvas] {\n  background-color: #777;\n  height: 100%;\n  width: 100%; }\n",""]);// exports
/***/},/* 178 *//***/function(module,exports){module.exports="<canvas data-no-op-canvas></canvas>\n<p data-no-op-msg><%=message%><p>\n";/***/},/* 179 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _spinner_three_bounce=__webpack_require__(180);var _spinner_three_bounce2=_interopRequireDefault(_spinner_three_bounce);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_spinner_three_bounce2.default;module.exports=exports['default'];/***/},/* 180 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _ui_container_plugin=__webpack_require__(36);var _ui_container_plugin2=_interopRequireDefault(_ui_container_plugin);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _spinner=__webpack_require__(181);var _spinner2=_interopRequireDefault(_spinner);var _spinner3=__webpack_require__(182);var _spinner4=_interopRequireDefault(_spinner3);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var SpinnerThreeBouncePlugin=function(_UIContainerPlugin){(0,_inherits3.default)(SpinnerThreeBouncePlugin,_UIContainerPlugin);(0,_createClass3.default)(SpinnerThreeBouncePlugin,[{key:'name',get:function get(){return'spinner';}},{key:'attributes',get:function get(){return{'data-spinner':'','class':'spinner-three-bounce'};}}]);function SpinnerThreeBouncePlugin(container){(0,_classCallCheck3.default)(this,SpinnerThreeBouncePlugin);var _this=(0,_possibleConstructorReturn3.default)(this,_UIContainerPlugin.call(this,container));_this.template=(0,_template2.default)(_spinner2.default);_this.showTimeout=null;_this.listenTo(_this.container,_events2.default.CONTAINER_STATE_BUFFERING,_this.onBuffering);_this.listenTo(_this.container,_events2.default.CONTAINER_STATE_BUFFERFULL,_this.onBufferFull);_this.listenTo(_this.container,_events2.default.CONTAINER_STOP,_this.onStop);_this.listenTo(_this.container,_events2.default.CONTAINER_ENDED,_this.onStop);_this.listenTo(_this.container,_events2.default.CONTAINER_ERROR,_this.onStop);_this.render();return _this;}SpinnerThreeBouncePlugin.prototype.onBuffering=function onBuffering(){this.show();};SpinnerThreeBouncePlugin.prototype.onBufferFull=function onBufferFull(){this.hide();};SpinnerThreeBouncePlugin.prototype.onStop=function onStop(){this.hide();};SpinnerThreeBouncePlugin.prototype.show=function show(){var _this2=this;if(this.showTimeout===null){this.showTimeout=setTimeout(function(){return _this2.$el.show();},300);}};SpinnerThreeBouncePlugin.prototype.hide=function hide(){if(this.showTimeout!==null){clearTimeout(this.showTimeout);this.showTimeout=null;}this.$el.hide();};SpinnerThreeBouncePlugin.prototype.render=function render(){this.$el.html(this.template());var style=_styler2.default.getStyleFor(_spinner4.default);this.container.$el.append(style);this.container.$el.append(this.$el);this.$el.hide();if(this.container.buffering){this.onBuffering();}return this;};return SpinnerThreeBouncePlugin;}(_ui_container_plugin2.default);exports.default=SpinnerThreeBouncePlugin;module.exports=exports['default'];/***/},/* 181 *//***/function(module,exports){module.exports="<div data-bounce1></div><div data-bounce2></div><div data-bounce3></div>\n";/***/},/* 182 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,".spinner-three-bounce[data-spinner] {\n  position: absolute;\n  margin: 0 auto;\n  width: 70px;\n  text-align: center;\n  z-index: 999;\n  left: 0;\n  right: 0;\n  margin-left: auto;\n  margin-right: auto;\n  /* center vertically */\n  top: 50%;\n  -webkit-transform: translateY(-50%);\n  -moz-transform: translateY(-50%);\n  -ms-transform: translateY(-50%);\n  -o-transform: translateY(-50%);\n  transform: translateY(-50%); }\n  .spinner-three-bounce[data-spinner] > div {\n    width: 18px;\n    height: 18px;\n    background-color: #FFFFFF;\n    border-radius: 100%;\n    display: inline-block;\n    -webkit-animation: bouncedelay 1.4s infinite ease-in-out;\n    -moz-animation: bouncedelay 1.4s infinite ease-in-out;\n    animation: bouncedelay 1.4s infinite ease-in-out;\n    /* Prevent first frame from flickering when animation starts */\n    -webkit-animation-fill-mode: both;\n    -moz-animation-fill-mode: both;\n    animation-fill-mode: both; }\n  .spinner-three-bounce[data-spinner] [data-bounce1] {\n    -webkit-animation-delay: -0.32s;\n    -moz-animation-delay: -0.32s;\n    animation-delay: -0.32s; }\n  .spinner-three-bounce[data-spinner] [data-bounce2] {\n    -webkit-animation-delay: -0.16s;\n    -moz-animation-delay: -0.16s;\n    animation-delay: -0.16s; }\n\n@-webkit-keyframes bouncedelay {\n  0%, 80%, 100% {\n    -webkit-transform: scale(0); }\n  40% {\n    -webkit-transform: scale(1); } }\n\n@-moz-keyframes bouncedelay {\n  0%, 80%, 100% {\n    -moz-transform: scale(0); }\n  40% {\n    -moz-transform: scale(1); } }\n\n@keyframes bouncedelay {\n  0%, 80%, 100% {\n    -webkit-transform: scale(0);\n    -moz-transform: scale(0);\n    -ms-transform: scale(0);\n    -o-transform: scale(0);\n    transform: scale(0); }\n  40% {\n    -webkit-transform: scale(1);\n    -moz-transform: scale(1);\n    -ms-transform: scale(1);\n    -o-transform: scale(1);\n    transform: scale(1); } }\n",""]);// exports
/***/},/* 183 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _stats=__webpack_require__(184);var _stats2=_interopRequireDefault(_stats);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_stats2.default;module.exports=exports['default'];/***/},/* 184 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _container_plugin=__webpack_require__(37);var _container_plugin2=_interopRequireDefault(_container_plugin);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var StatsPlugin=function(_ContainerPlugin){(0,_inherits3.default)(StatsPlugin,_ContainerPlugin);(0,_createClass3.default)(StatsPlugin,[{key:'name',get:function get(){return'stats';}}]);function StatsPlugin(container){(0,_classCallCheck3.default)(this,StatsPlugin);var _this=(0,_possibleConstructorReturn3.default)(this,_ContainerPlugin.call(this,container));_this.setInitialAttrs();_this.reportInterval=_this.options.reportInterval||5000;_this.state='IDLE';return _this;}StatsPlugin.prototype.bindEvents=function bindEvents(){this.listenTo(this.container.playback,_events2.default.PLAYBACK_PLAY,this.onPlay);this.listenTo(this.container,_events2.default.CONTAINER_STOP,this.onStop);this.listenTo(this.container,_events2.default.CONTAINER_ENDED,this.onStop);this.listenTo(this.container,_events2.default.CONTAINER_DESTROYED,this.onStop);this.listenTo(this.container,_events2.default.CONTAINER_STATE_BUFFERING,this.onBuffering);this.listenTo(this.container,_events2.default.CONTAINER_STATE_BUFFERFULL,this.onBufferFull);this.listenTo(this.container,_events2.default.CONTAINER_STATS_ADD,this.onStatsAdd);this.listenTo(this.container,_events2.default.CONTAINER_BITRATE,this.onStatsAdd);this.listenTo(this.container.playback,_events2.default.PLAYBACK_STATS_ADD,this.onStatsAdd);};StatsPlugin.prototype.setInitialAttrs=function setInitialAttrs(){this.firstPlay=true;this.startupTime=0;this.rebufferingTime=0;this.watchingTime=0;this.rebuffers=0;this.externalMetrics={};};StatsPlugin.prototype.onPlay=function onPlay(){this.state='PLAYING';this.watchingTimeInit=Date.now();if(!this.intervalId){this.intervalId=setInterval(this.report.bind(this),this.reportInterval);}};StatsPlugin.prototype.onStop=function onStop(){clearInterval(this.intervalId);this.report();this.intervalId=undefined;this.state='STOPPED';};StatsPlugin.prototype.onBuffering=function onBuffering(){if(this.firstPlay){this.startupTimeInit=Date.now();}else{this.rebufferingTimeInit=Date.now();}this.state='BUFFERING';this.rebuffers++;};StatsPlugin.prototype.onBufferFull=function onBufferFull(){if(this.firstPlay&&this.startupTimeInit){this.firstPlay=false;this.startupTime=Date.now()-this.startupTimeInit;this.watchingTimeInit=Date.now();}else if(this.rebufferingTimeInit){this.rebufferingTime+=this.getRebufferingTime();}this.rebufferingTimeInit=undefined;this.state='PLAYING';};StatsPlugin.prototype.getRebufferingTime=function getRebufferingTime(){return Date.now()-this.rebufferingTimeInit;};StatsPlugin.prototype.getWatchingTime=function getWatchingTime(){var totalTime=Date.now()-this.watchingTimeInit;return totalTime-this.rebufferingTime;};StatsPlugin.prototype.isRebuffering=function isRebuffering(){return!!this.rebufferingTimeInit;};StatsPlugin.prototype.onStatsAdd=function onStatsAdd(metric){_clapprZepto2.default.extend(this.externalMetrics,metric);};StatsPlugin.prototype.getStats=function getStats(){var metrics={startupTime:this.startupTime,rebuffers:this.rebuffers,rebufferingTime:this.isRebuffering()?this.rebufferingTime+this.getRebufferingTime():this.rebufferingTime,watchingTime:this.isRebuffering()?this.getWatchingTime()-this.getRebufferingTime():this.getWatchingTime()};_clapprZepto2.default.extend(metrics,this.externalMetrics);return metrics;};StatsPlugin.prototype.report=function report(){this.container.statsReport(this.getStats());};return StatsPlugin;}(_container_plugin2.default);// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
exports.default=StatsPlugin;module.exports=exports['default'];/***/},/* 185 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _watermark=__webpack_require__(186);var _watermark2=_interopRequireDefault(_watermark);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_watermark2.default;module.exports=exports['default'];/***/},/* 186 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _ui_container_plugin=__webpack_require__(36);var _ui_container_plugin2=_interopRequireDefault(_ui_container_plugin);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _watermark=__webpack_require__(187);var _watermark2=_interopRequireDefault(_watermark);var _watermark3=__webpack_require__(188);var _watermark4=_interopRequireDefault(_watermark3);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var WaterMarkPlugin=function(_UIContainerPlugin){(0,_inherits3.default)(WaterMarkPlugin,_UIContainerPlugin);(0,_createClass3.default)(WaterMarkPlugin,[{key:'name',get:function get(){return'watermark';}},{key:'template',get:function get(){return(0,_template2.default)(_watermark4.default);}}]);function WaterMarkPlugin(container){(0,_classCallCheck3.default)(this,WaterMarkPlugin);var _this=(0,_possibleConstructorReturn3.default)(this,_UIContainerPlugin.call(this,container));_this.configure();return _this;}WaterMarkPlugin.prototype.bindEvents=function bindEvents(){this.listenTo(this.container,_events2.default.CONTAINER_PLAY,this.onPlay);this.listenTo(this.container,_events2.default.CONTAINER_STOP,this.onStop);this.listenTo(this.container,_events2.default.CONTAINER_OPTIONS_CHANGE,this.configure);};WaterMarkPlugin.prototype.configure=function configure(){this.position=this.options.position||'bottom-right';if(this.options.watermark){this.imageUrl=this.options.watermark;this.imageLink=this.options.watermarkLink;this.render();}else{this.$el.remove();}};WaterMarkPlugin.prototype.onPlay=function onPlay(){if(!this.hidden)this.$el.show();};WaterMarkPlugin.prototype.onStop=function onStop(){this.$el.hide();};WaterMarkPlugin.prototype.render=function render(){this.$el.hide();var templateOptions={position:this.position,imageUrl:this.imageUrl,imageLink:this.imageLink};this.$el.html(this.template(templateOptions));var style=_styler2.default.getStyleFor(_watermark2.default);this.container.$el.append(style);this.container.$el.append(this.$el);return this;};return WaterMarkPlugin;}(_ui_container_plugin2.default);exports.default=WaterMarkPlugin;module.exports=exports['default'];/***/},/* 187 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,"[data-watermark] {\n  position: absolute;\n  min-width: 70px;\n  max-width: 200px;\n  width: 12%;\n  text-align: center;\n  z-index: 10; }\n\n[data-watermark] a {\n  outline: none;\n  cursor: pointer; }\n\n[data-watermark] img {\n  max-width: 100%; }\n\n[data-watermark-bottom-left] {\n  bottom: 10px;\n  left: 10px; }\n\n[data-watermark-bottom-right] {\n  bottom: 10px;\n  right: 42px; }\n\n[data-watermark-top-left] {\n  top: 10px;\n  left: 10px; }\n\n[data-watermark-top-right] {\n  top: 10px;\n  right: 37px; }\n",""]);// exports
/***/},/* 188 *//***/function(module,exports){module.exports="<div data-watermark data-watermark-<%=position %>>\n<% if(typeof imageLink !== 'undefined') { %>\n<a target=_blank href=\"<%= imageLink %>\">\n<% } %>\n<img src=\"<%= imageUrl %>\">\n<% if(typeof imageLink !== 'undefined') { %>\n</a>\n<% } %>\n</div>\n";/***/},/* 189 *//***/function(module,exports,__webpack_require__){"use strict";/* WEBPACK VAR INJECTION */(function(process){Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _ui_container_plugin=__webpack_require__(36);var _ui_container_plugin2=_interopRequireDefault(_ui_container_plugin);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _poster=__webpack_require__(190);var _poster2=_interopRequireDefault(_poster);var _poster3=__webpack_require__(191);var _poster4=_interopRequireDefault(_poster3);var _play=__webpack_require__(58);var _play2=_interopRequireDefault(_play);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}//Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var PosterPlugin=function(_UIContainerPlugin){(0,_inherits3.default)(PosterPlugin,_UIContainerPlugin);(0,_createClass3.default)(PosterPlugin,[{key:'name',get:function get(){return'poster';}},{key:'template',get:function get(){return(0,_template2.default)(_poster4.default);}},{key:'shouldRender',get:function get(){var showForNoOp=!!(this.options.poster&&this.options.poster.showForNoOp);return this.container.playback.name!=='html_img'&&(this.container.playback.getPlaybackType()!==_playback2.default.NO_OP||showForNoOp);}},{key:'attributes',get:function get(){return{'class':'player-poster','data-poster':''};}},{key:'events',get:function get(){return{'click':'clicked'};}},{key:'showOnVideoEnd',get:function get(){return!this.options.poster||this.options.poster.showOnVideoEnd||this.options.poster.showOnVideoEnd===undefined;}}]);function PosterPlugin(container){(0,_classCallCheck3.default)(this,PosterPlugin);var _this=(0,_possibleConstructorReturn3.default)(this,_UIContainerPlugin.call(this,container));_this.hasStartedPlaying=false;_this.playRequested=false;_this.render();process.nextTick(function(){return _this.update();});return _this;}PosterPlugin.prototype.bindEvents=function bindEvents(){this.listenTo(this.container,_events2.default.CONTAINER_STOP,this.onStop);this.listenTo(this.container,_events2.default.CONTAINER_PLAY,this.onPlay);this.listenTo(this.container,_events2.default.CONTAINER_STATE_BUFFERING,this.update);this.listenTo(this.container,_events2.default.CONTAINER_STATE_BUFFERFULL,this.update);this.listenTo(this.container,_events2.default.CONTAINER_OPTIONS_CHANGE,this.render);this.showOnVideoEnd&&this.listenTo(this.container,_events2.default.CONTAINER_ENDED,this.onStop);};PosterPlugin.prototype.stopListening=function stopListening(){_UIContainerPlugin.prototype.stopListening.call(this);};PosterPlugin.prototype.onPlay=function onPlay(){this.hasStartedPlaying=true;this.update();};PosterPlugin.prototype.onStop=function onStop(){this.hasStartedPlaying=false;this.playRequested=false;this.update();};PosterPlugin.prototype.showPlayButton=function showPlayButton(show){if(show&&(!this.options.chromeless||this.options.allowUserInteraction)){this.$playButton.show();this.$el.addClass('clickable');}else{this.$playButton.hide();this.$el.removeClass('clickable');}};PosterPlugin.prototype.clicked=function clicked(){if(!this.options.chromeless||this.options.allowUserInteraction){this.playRequested=true;this.update();this.container.play();}return false;};PosterPlugin.prototype.shouldHideOnPlay=function shouldHideOnPlay(){// Audio broadcasts should keep the poster up; video should hide poster while playing.
return!this.container.playback.isAudioOnly;};PosterPlugin.prototype.update=function update(){if(!this.shouldRender){return;}var showPlayButton=!this.playRequested&&!this.hasStartedPlaying&&!this.container.buffering;this.showPlayButton(showPlayButton);if(!this.hasStartedPlaying){this.container.disableMediaControl();this.$el.show();}else{this.container.enableMediaControl();if(this.shouldHideOnPlay()){this.$el.hide();}}};PosterPlugin.prototype.render=function render(){if(!this.shouldRender){return;}var style=_styler2.default.getStyleFor(_poster2.default,{baseUrl:this.options.baseUrl});this.$el.html(this.template());this.$el.append(style);var isRegularPoster=this.options.poster&&this.options.poster.custom==undefined;if(isRegularPoster){var posterUrl=this.options.poster.url||this.options.poster;this.$el.css({'background-image':'url('+posterUrl+')'});}else if(this.options.poster){this.$el.css({'background':this.options.poster.custom});}this.container.$el.append(this.el);this.$playWrapper=this.$el.find('.play-wrapper');this.$playWrapper.append(_play2.default);this.$playButton=this.$playWrapper.find('svg');this.$playButton.addClass('poster-icon');this.$playButton.attr('data-poster','');var buttonsColor=this.options.mediacontrol&&this.options.mediacontrol.buttons;if(buttonsColor){this.$el.find('svg path').css('fill',buttonsColor);}if(this.options.mediacontrol&&this.options.mediacontrol.buttons){buttonsColor=this.options.mediacontrol.buttons;this.$playButton.css('color',buttonsColor);}this.update();return this;};return PosterPlugin;}(_ui_container_plugin2.default);exports.default=PosterPlugin;module.exports=exports['default'];/* WEBPACK VAR INJECTION */}).call(exports,__webpack_require__(57));/***/},/* 190 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,".player-poster[data-poster] {\n  display: -webkit-box;\n  display: -moz-box;\n  display: box;\n  display: -webkit-flex;\n  display: -moz-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: center;\n  -moz-box-pack: center;\n  box-pack: center;\n  -webkit-justify-content: center;\n  -moz-justify-content: center;\n  -ms-justify-content: center;\n  -o-justify-content: center;\n  justify-content: center;\n  -ms-flex-pack: center;\n  -webkit-box-align: center;\n  -moz-box-align: center;\n  box-align: center;\n  -webkit-align-items: center;\n  -moz-align-items: center;\n  -ms-align-items: center;\n  -o-align-items: center;\n  align-items: center;\n  -ms-flex-align: center;\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  z-index: 998;\n  top: 0;\n  left: 0;\n  background-color: #000;\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-position: 50% 50%; }\n  .player-poster[data-poster].clickable {\n    cursor: pointer; }\n  .player-poster[data-poster]:hover .play-wrapper[data-poster] {\n    opacity: 1; }\n  .player-poster[data-poster] .play-wrapper[data-poster] {\n    width: 100%;\n    height: 25%;\n    margin: 0 auto;\n    opacity: 0.75;\n    -webkit-transition: opacity 0.1s ease;\n    -moz-transition: opacity 0.1s ease;\n    transition: opacity 0.1s ease; }\n    .player-poster[data-poster] .play-wrapper[data-poster] svg {\n      height: 100%; }\n      .player-poster[data-poster] .play-wrapper[data-poster] svg path {\n        fill: #fff; }\n",""]);// exports
/***/},/* 191 *//***/function(module,exports){module.exports="<div class=\"play-wrapper\" data-poster></div>\n";/***/},/* 192 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _google_analytics=__webpack_require__(193);var _google_analytics2=_interopRequireDefault(_google_analytics);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_google_analytics2.default;module.exports=exports['default'];/***/},/* 193 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _container_plugin=__webpack_require__(37);var _container_plugin2=_interopRequireDefault(_container_plugin);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var GoogleAnalytics=function(_ContainerPlugin){(0,_inherits3.default)(GoogleAnalytics,_ContainerPlugin);(0,_createClass3.default)(GoogleAnalytics,[{key:'name',get:function get(){return'google_analytics';}}]);function GoogleAnalytics(container){(0,_classCallCheck3.default)(this,GoogleAnalytics);var _this=(0,_possibleConstructorReturn3.default)(this,_ContainerPlugin.call(this,container));if(_this.container.options.gaAccount){_this.account=_this.container.options.gaAccount;_this.trackerName=_this.container.options.gaTrackerName?_this.container.options.gaTrackerName+'.':'Clappr.';_this.domainName=_this.container.options.gaDomainName;_this.currentHDState=undefined;_this.embedScript();}return _this;}GoogleAnalytics.prototype.embedScript=function embedScript(){var _this2=this;if(!window._gat){var script=document.createElement('script');script.setAttribute('type','text/javascript');script.setAttribute('async','async');script.setAttribute('src','//www.google-analytics.com/ga.js');script.onload=function(){return _this2.addEventListeners();};document.body.appendChild(script);}else{this.addEventListeners();}};GoogleAnalytics.prototype.addEventListeners=function addEventListeners(){var _this3=this;if(this.container){this.listenTo(this.container,_events2.default.CONTAINER_READY,this.onReady);this.listenTo(this.container,_events2.default.CONTAINER_PLAY,this.onPlay);this.listenTo(this.container,_events2.default.CONTAINER_STOP,this.onStop);this.listenTo(this.container,_events2.default.CONTAINER_PAUSE,this.onPause);this.listenTo(this.container,_events2.default.CONTAINER_ENDED,this.onEnded);this.listenTo(this.container,_events2.default.CONTAINER_STATE_BUFFERING,this.onBuffering);this.listenTo(this.container,_events2.default.CONTAINER_STATE_BUFFERFULL,this.onBufferFull);this.listenTo(this.container,_events2.default.CONTAINER_ERROR,this.onError);this.listenTo(this.container,_events2.default.CONTAINER_PLAYBACKSTATE,this.onPlaybackChanged);this.listenTo(this.container,_events2.default.CONTAINER_VOLUME,function(event){return _this3.onVolumeChanged(event);});this.listenTo(this.container,_events2.default.CONTAINER_SEEK,function(event){return _this3.onSeek(event);});this.listenTo(this.container,_events2.default.CONTAINER_FULL_SCREEN,this.onFullscreen);this.listenTo(this.container,_events2.default.CONTAINER_HIGHDEFINITIONUPDATE,this.onHD);this.listenTo(this.container,_events2.default.CONTAINER_PLAYBACKDVRSTATECHANGED,this.onDVR);}_gaq.push([this.trackerName+'_setAccount',this.account]);if(this.domainName)_gaq.push([this.trackerName+'_setDomainName',this.domainName]);};GoogleAnalytics.prototype.onReady=function onReady(){this.push(['Video','Playback',this.container.playback.name]);};GoogleAnalytics.prototype.onPlay=function onPlay(){this.push(['Video','Play',this.container.playback.src]);};GoogleAnalytics.prototype.onStop=function onStop(){this.push(['Video','Stop',this.container.playback.src]);};GoogleAnalytics.prototype.onEnded=function onEnded(){this.push(['Video','Ended',this.container.playback.src]);};GoogleAnalytics.prototype.onBuffering=function onBuffering(){this.push(['Video','Buffering',this.container.playback.src]);};GoogleAnalytics.prototype.onBufferFull=function onBufferFull(){this.push(['Video','Bufferfull',this.container.playback.src]);};GoogleAnalytics.prototype.onError=function onError(){this.push(['Video','Error',this.container.playback.src]);};GoogleAnalytics.prototype.onHD=function onHD(isHD){var status=isHD?'ON':'OFF';if(status!==this.currentHDState){this.currentHDState=status;this.push(['Video','HD - '+status,this.container.playback.src]);}};GoogleAnalytics.prototype.onPlaybackChanged=function onPlaybackChanged(playbackState){if(playbackState.type!==null){this.push(['Video','Playback Type - '+playbackState.type,this.container.playback.src]);}};GoogleAnalytics.prototype.onDVR=function onDVR(dvrInUse){var status=dvrInUse?'ON':'OFF';this.push(['Interaction','DVR - '+status,this.container.playback.src]);};GoogleAnalytics.prototype.onPause=function onPause(){this.push(['Video','Pause',this.container.playback.src]);};GoogleAnalytics.prototype.onSeek=function onSeek(){this.push(['Video','Seek',this.container.playback.src]);};GoogleAnalytics.prototype.onVolumeChanged=function onVolumeChanged(){this.push(['Interaction','Volume',this.container.playback.src]);};GoogleAnalytics.prototype.onFullscreen=function onFullscreen(){this.push(['Interaction','Fullscreen',this.container.playback.src]);};GoogleAnalytics.prototype.push=function push(array){var res=[this.trackerName+'_trackEvent'].concat(array);_gaq.push(res);};return GoogleAnalytics;}(_container_plugin2.default);exports.default=GoogleAnalytics;module.exports=exports['default'];/***/},/* 194 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _click_to_pause=__webpack_require__(195);var _click_to_pause2=_interopRequireDefault(_click_to_pause);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_click_to_pause2.default;module.exports=exports['default'];/***/},/* 195 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _container_plugin=__webpack_require__(37);var _container_plugin2=_interopRequireDefault(_container_plugin);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var ClickToPausePlugin=function(_ContainerPlugin){(0,_inherits3.default)(ClickToPausePlugin,_ContainerPlugin);(0,_createClass3.default)(ClickToPausePlugin,[{key:'name',get:function get(){return'click_to_pause';}}]);function ClickToPausePlugin(container){(0,_classCallCheck3.default)(this,ClickToPausePlugin);return(0,_possibleConstructorReturn3.default)(this,_ContainerPlugin.call(this,container));}ClickToPausePlugin.prototype.bindEvents=function bindEvents(){this.listenTo(this.container,_events2.default.CONTAINER_CLICK,this.click);this.listenTo(this.container,_events2.default.CONTAINER_SETTINGSUPDATE,this.settingsUpdate);};ClickToPausePlugin.prototype.click=function click(){if(this.container.getPlaybackType()!==_playback2.default.LIVE||this.container.isDvrEnabled()){if(this.container.isPlaying()){this.container.pause();}else{this.container.play();}}};ClickToPausePlugin.prototype.settingsUpdate=function settingsUpdate(){this.container.$el.removeClass('pointer-enabled');if(this.container.getPlaybackType()!==_playback2.default.LIVE||this.container.isDvrEnabled()){this.container.$el.addClass('pointer-enabled');}};return ClickToPausePlugin;}(_container_plugin2.default);//Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
exports.default=ClickToPausePlugin;module.exports=exports['default'];/***/},/* 196 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _dvr_controls=__webpack_require__(197);var _dvr_controls2=_interopRequireDefault(_dvr_controls);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_dvr_controls2.default;module.exports=exports['default'];/***/},/* 197 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _ui_core_plugin=__webpack_require__(38);var _ui_core_plugin2=_interopRequireDefault(_ui_core_plugin);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _dvr_controls=__webpack_require__(198);var _dvr_controls2=_interopRequireDefault(_dvr_controls);var _index=__webpack_require__(199);var _index2=_interopRequireDefault(_index);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var DVRControls=function(_UICorePlugin){(0,_inherits3.default)(DVRControls,_UICorePlugin);(0,_createClass3.default)(DVRControls,[{key:'template',get:function get(){return(0,_template2.default)(_index2.default);}},{key:'name',get:function get(){return'dvr_controls';}},{key:'events',get:function get(){return{'click .live-button':'click'};}},{key:'attributes',get:function get(){return{'class':'dvr-controls','data-dvr-controls':''};}}]);function DVRControls(core){(0,_classCallCheck3.default)(this,DVRControls);var _this=(0,_possibleConstructorReturn3.default)(this,_UICorePlugin.call(this,core));_this.settingsUpdate();return _this;}DVRControls.prototype.bindEvents=function bindEvents(){this.listenTo(this.core.mediaControl,_events2.default.MEDIACONTROL_CONTAINERCHANGED,this.containerChanged);this.listenTo(this.core.mediaControl,_events2.default.MEDIACONTROL_RENDERED,this.settingsUpdate);this.listenTo(this.core,_events2.default.CORE_OPTIONS_CHANGE,this.render);if(this.core.getCurrentContainer()){this.listenToOnce(this.core.getCurrentContainer(),_events2.default.CONTAINER_TIMEUPDATE,this.render);this.listenTo(this.core.getCurrentContainer(),_events2.default.CONTAINER_PLAYBACKDVRSTATECHANGED,this.dvrChanged);}};DVRControls.prototype.containerChanged=function containerChanged(){this.stopListening();this.bindEvents();};DVRControls.prototype.dvrChanged=function dvrChanged(dvrEnabled){this.settingsUpdate();this.core.mediaControl.$el.addClass('live');if(dvrEnabled){this.core.mediaControl.$el.addClass('dvr');this.core.mediaControl.$el.find('.media-control-indicator[data-position], .media-control-indicator[data-duration]').hide();}else{this.core.mediaControl.$el.removeClass('dvr');}};DVRControls.prototype.click=function click(){var mediaControl=this.core.mediaControl;var container=mediaControl.container;if(!container.isPlaying()){container.play();}if(mediaControl.$el.hasClass('dvr')){container.seek(container.getDuration());}};DVRControls.prototype.settingsUpdate=function settingsUpdate(){var _this2=this;this.stopListening();if(this.shouldRender()){this.render();this.$el.click(function(){return _this2.click();});}this.bindEvents();};DVRControls.prototype.shouldRender=function shouldRender(){var useDvrControls=this.core.options.useDvrControls===undefined||!!this.core.options.useDvrControls;return useDvrControls&&this.core.getPlaybackType()===_playback2.default.LIVE;};DVRControls.prototype.render=function render(){this.style=this.style||_styler2.default.getStyleFor(_dvr_controls2.default,{baseUrl:this.core.options.baseUrl});this.$el.html(this.template({live:this.core.i18n.t('live'),backToLive:this.core.i18n.t('back_to_live')}));this.$el.append(this.style);if(this.shouldRender()){this.core.mediaControl.$el.addClass('live');this.core.mediaControl.$('.media-control-left-panel[data-media-control]').append(this.$el);}return this;};return DVRControls;}(_ui_core_plugin2.default);exports.default=DVRControls;module.exports=exports['default'];/***/},/* 198 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,".dvr-controls[data-dvr-controls] {\n  display: inline-block;\n  float: left;\n  color: #fff;\n  line-height: 32px;\n  font-size: 10px;\n  font-weight: bold;\n  margin-left: 6px; }\n  .dvr-controls[data-dvr-controls] .live-info {\n    cursor: default;\n    font-family: \"Roboto\", \"Open Sans\", Arial, sans-serif;\n    text-transform: uppercase; }\n    .dvr-controls[data-dvr-controls] .live-info:before {\n      content: \"\";\n      display: inline-block;\n      position: relative;\n      width: 7px;\n      height: 7px;\n      border-radius: 3.5px;\n      margin-right: 3.5px;\n      background-color: #ff0101; }\n    .dvr-controls[data-dvr-controls] .live-info.disabled {\n      opacity: 0.3; }\n      .dvr-controls[data-dvr-controls] .live-info.disabled:before {\n        background-color: #fff; }\n  .dvr-controls[data-dvr-controls] .live-button {\n    cursor: pointer;\n    outline: none;\n    display: none;\n    border: 0;\n    color: #fff;\n    background-color: transparent;\n    height: 32px;\n    padding: 0;\n    opacity: 0.7;\n    font-family: \"Roboto\", \"Open Sans\", Arial, sans-serif;\n    text-transform: uppercase;\n    -webkit-transition: all 0.1s ease;\n    -moz-transition: all 0.1s ease;\n    transition: all 0.1s ease; }\n    .dvr-controls[data-dvr-controls] .live-button:before {\n      content: \"\";\n      display: inline-block;\n      position: relative;\n      width: 7px;\n      height: 7px;\n      border-radius: 3.5px;\n      margin-right: 3.5px;\n      background-color: #fff; }\n    .dvr-controls[data-dvr-controls] .live-button:hover {\n      opacity: 1;\n      text-shadow: rgba(255, 255, 255, 0.75) 0 0 5px; }\n\n.dvr .dvr-controls[data-dvr-controls] .live-info {\n  display: none; }\n\n.dvr .dvr-controls[data-dvr-controls] .live-button {\n  display: block; }\n\n.dvr.media-control.live[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-2[data-seekbar] {\n  background-color: #005aff; }\n\n.media-control.live[data-media-control] .media-control-layer[data-controls] .bar-container[data-seekbar] .bar-background[data-seekbar] .bar-fill-2[data-seekbar] {\n  background-color: #ff0101; }\n",""]);// exports
/***/},/* 199 *//***/function(module,exports){module.exports="<div class=\"live-info\"><%= live %></div>\n<button type=\"button\" class=\"live-button\" aria-label=\"<%= backToLive %>\"><%= backToLive %></button>\n";/***/},/* 200 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _closed_captions=__webpack_require__(201);var _closed_captions2=_interopRequireDefault(_closed_captions);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_closed_captions2.default;module.exports=exports['default'];/***/},/* 201 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _ui_core_plugin=__webpack_require__(38);var _ui_core_plugin2=_interopRequireDefault(_ui_core_plugin);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _cc=__webpack_require__(202);var _cc2=_interopRequireDefault(_cc);var _closed_captions=__webpack_require__(203);var _closed_captions2=_interopRequireDefault(_closed_captions);var _closed_captions3=__webpack_require__(204);var _closed_captions4=_interopRequireDefault(_closed_captions3);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var ClosedCaptions=function(_UICorePlugin){(0,_inherits3.default)(ClosedCaptions,_UICorePlugin);(0,_createClass3.default)(ClosedCaptions,[{key:'name',get:function get(){return'closed_captions';}},{key:'template',get:function get(){return(0,_template2.default)(_closed_captions4.default);}},{key:'events',get:function get(){return{'click [data-cc-button]':'toggleContextMenu','click [data-cc-select]':'onTrackSelect'};}},{key:'attributes',get:function get(){return{'class':'cc-controls','data-cc-controls':''};}}]);function ClosedCaptions(core){(0,_classCallCheck3.default)(this,ClosedCaptions);var _this=(0,_possibleConstructorReturn3.default)(this,_UICorePlugin.call(this,core));var config=core.options.closedCaptionsConfig;_this._title=config&&config.title?config.title:null;_this._ariaLabel=config&&config.ariaLabel?config.ariaLabel:'cc-button';_this._labelCb=config&&config.labelCallback&&typeof config.labelCallback==='function'?config.labelCallback:function(track){return track.name;};return _this;}ClosedCaptions.prototype.bindEvents=function bindEvents(){this.listenTo(this.core.mediaControl,_events2.default.MEDIACONTROL_CONTAINERCHANGED,this.containerChanged);this.listenTo(this.core.mediaControl,_events2.default.MEDIACONTROL_RENDERED,this.render);this.listenTo(this.core.mediaControl,_events2.default.MEDIACONTROL_HIDE,this.hideContextMenu);this.container=this.core.getCurrentContainer();if(this.container){this.listenTo(this.container,_events2.default.CONTAINER_SUBTITLE_AVAILABLE,this.onSubtitleAvailable);this.listenTo(this.container,_events2.default.CONTAINER_SUBTITLE_CHANGED,this.onSubtitleChanged);this.listenTo(this.container,_events2.default.CONTAINER_STOP,this.onContainerStop);}};ClosedCaptions.prototype.onContainerStop=function onContainerStop(){this.ccAvailable(false);};ClosedCaptions.prototype.containerChanged=function containerChanged(){this.ccAvailable(false);this.stopListening();this.bindEvents();};ClosedCaptions.prototype.onSubtitleAvailable=function onSubtitleAvailable(){this.renderCcButton();this.ccAvailable(true);};ClosedCaptions.prototype.onSubtitleChanged=function onSubtitleChanged(track){this.setCurrentContextMenuElement(track.id);};ClosedCaptions.prototype.onTrackSelect=function onTrackSelect(event){var trackId=parseInt(event.target.dataset.ccSelect,10);this.container.closedCaptionsTrackId=trackId;this.hideContextMenu();event.stopPropagation();return false;};ClosedCaptions.prototype.ccAvailable=function ccAvailable(hasCC){var method=hasCC?'addClass':'removeClass';this.$el[method]('available');};ClosedCaptions.prototype.toggleContextMenu=function toggleContextMenu(){this.$el.find('ul').toggle();};ClosedCaptions.prototype.hideContextMenu=function hideContextMenu(){this.$el.find('ul').hide();};ClosedCaptions.prototype.contextMenuElement=function contextMenuElement(id){return this.$el.find('ul a'+(!isNaN(id)?'[data-cc-select="'+id+'"]':'')).parent();};ClosedCaptions.prototype.setCurrentContextMenuElement=function setCurrentContextMenuElement(trackId){if(this._trackId!==trackId){this.contextMenuElement().removeClass('current');this.contextMenuElement(trackId).addClass('current');var method=trackId>-1?'addClass':'removeClass';this.$ccButton[method]('enabled');this._trackId=trackId;}};ClosedCaptions.prototype.renderCcButton=function renderCcButton(){var tracks=this.container?this.container.closedCaptionsTracks:[];for(var i=0;i<tracks.length;i++){tracks[i].label=this._labelCb(tracks[i]);}this.$el.html(this.template({ariaLabel:this._ariaLabel,disabledLabel:this.core.i18n.t('disabled'),title:this._title,tracks:tracks}));this.$ccButton=this.$el.find('button.cc-button[data-cc-button]');this.$ccButton.append(_cc2.default);this.$el.append(this.style);};ClosedCaptions.prototype.render=function render(){if(!this.style){this.style=_styler2.default.getStyleFor(_closed_captions2.default,{baseUrl:this.core.options.baseUrl});}this.renderCcButton();var $fullscreen=this.core.mediaControl.$el.find('button[data-fullscreen]');if($fullscreen[0]){this.$el.insertAfter($fullscreen);}else{this.core.mediaControl.$el.find('.media-control-right-panel[data-media-control]').prepend(this.$el);}return this;};return ClosedCaptions;}(_ui_core_plugin2.default);exports.default=ClosedCaptions;module.exports=exports['default'];/***/},/* 202 *//***/function(module,exports){module.exports="<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 49 41.8\" style=\"enable-background:new 0 0 49 41.8;\" xml:space=\"preserve\"><path d=\"M47.1,0H3.2C1.6,0,0,1.2,0,2.8v31.5C0,35.9,1.6,37,3.2,37h11.9l3.2,1.9l4.7,2.7c0.9,0.5,2-0.1,2-1.1V37h22.1 c1.6,0,1.9-1.1,1.9-2.7V2.8C49,1.2,48.7,0,47.1,0z M7.2,18.6c0-4.8,3.5-9.3,9.9-9.3c4.8,0,7.1,2.7,7.1,2.7l-2.5,4 c0,0-1.7-1.7-4.2-1.7c-2.8,0-4.3,2.1-4.3,4.3c0,2.1,1.5,4.4,4.5,4.4c2.5,0,4.9-2.1,4.9-2.1l2.2,4.2c0,0-2.7,2.9-7.6,2.9 C10.8,27.9,7.2,23.5,7.2,18.6z M36.9,27.9c-6.4,0-9.9-4.4-9.9-9.3c0-4.8,3.5-9.3,9.9-9.3C41.7,9.3,44,12,44,12l-2.5,4 c0,0-1.7-1.7-4.2-1.7c-2.8,0-4.3,2.1-4.3,4.3c0,2.1,1.5,4.4,4.5,4.4c2.5,0,4.9-2.1,4.9-2.1l2.2,4.2C44.5,25,41.9,27.9,36.9,27.9z\"></path></svg>";/***/},/* 203 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,".cc-controls[data-cc-controls] {\n  float: right;\n  position: relative;\n  display: none; }\n  .cc-controls[data-cc-controls].available {\n    display: block; }\n  .cc-controls[data-cc-controls] .cc-button {\n    padding: 6px !important; }\n    .cc-controls[data-cc-controls] .cc-button.enabled {\n      display: block;\n      opacity: 1.0; }\n      .cc-controls[data-cc-controls] .cc-button.enabled:hover {\n        opacity: 1.0;\n        text-shadow: none; }\n  .cc-controls[data-cc-controls] > ul {\n    list-style-type: none;\n    position: absolute;\n    bottom: 25px;\n    border: 1px solid black;\n    display: none;\n    background-color: #e6e6e6; }\n  .cc-controls[data-cc-controls] li {\n    font-size: 10px; }\n    .cc-controls[data-cc-controls] li[data-title] {\n      background-color: #c3c2c2;\n      padding: 5px; }\n    .cc-controls[data-cc-controls] li a {\n      color: #444;\n      padding: 2px 10px;\n      display: block;\n      text-decoration: none; }\n      .cc-controls[data-cc-controls] li a:hover {\n        background-color: #555;\n        color: white; }\n        .cc-controls[data-cc-controls] li a:hover a {\n          color: white;\n          text-decoration: none; }\n    .cc-controls[data-cc-controls] li.current a {\n      color: #f00; }\n",""]);// exports
/***/},/* 204 *//***/function(module,exports){module.exports="<button type=\"button\" class=\"cc-button media-control-button media-control-icon\" data-cc-button aria-label=\"<%= ariaLabel %>\"></button>\n<ul>\n  <% if (title) { %>\n  <li data-title><%= title %></li>\n  <% }; %>\n  <li><a href=\"#\" data-cc-select=\"-1\"><%= disabledLabel %></a></li>\n  <% for (var i = 0; i < tracks.length; i++) { %>\n    <li><a href=\"#\" data-cc-select=\"<%= tracks[i].id %>\"><%= tracks[i].label %></a></li>\n  <% }; %>\n</ul>\n";/***/},/* 205 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _favicon=__webpack_require__(206);var _favicon2=_interopRequireDefault(_favicon);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_favicon2.default;module.exports=exports['default'];/***/},/* 206 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _core_plugin=__webpack_require__(30);var _core_plugin2=_interopRequireDefault(_core_plugin);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);var _play=__webpack_require__(58);var _play2=_interopRequireDefault(_play);var _pause=__webpack_require__(76);var _pause2=_interopRequireDefault(_pause);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var oldIcon=(0,_clapprZepto2.default)('link[rel="shortcut icon"]');var Favicon=function(_CorePlugin){(0,_inherits3.default)(Favicon,_CorePlugin);(0,_createClass3.default)(Favicon,[{key:'name',get:function get(){return'favicon';}},{key:'oldIcon',get:function get(){return oldIcon;}}]);function Favicon(core){(0,_classCallCheck3.default)(this,Favicon);var _this=(0,_possibleConstructorReturn3.default)(this,_CorePlugin.call(this,core));_this._container=null;_this.configure();return _this;}Favicon.prototype.configure=function configure(){if(this.core.options.changeFavicon){if(!this.enabled){this.stopListening(this.core,_events2.default.CORE_OPTIONS_CHANGE);this.enable();}}else if(this.enabled){this.disable();this.listenTo(this.core,_events2.default.CORE_OPTIONS_CHANGE,this.configure);}};Favicon.prototype.bindEvents=function bindEvents(){this.listenTo(this.core,_events2.default.CORE_OPTIONS_CHANGE,this.configure);this.listenTo(this.core.mediaControl,_events2.default.MEDIACONTROL_CONTAINERCHANGED,this.containerChanged);if(this.core.mediaControl.container){this.containerChanged();}};Favicon.prototype.containerChanged=function containerChanged(){this._container&&this.stopListening(this._container);this._container=this.core.mediaControl.container;this.listenTo(this._container,_events2.default.CONTAINER_PLAY,this.setPlayIcon);this.listenTo(this._container,_events2.default.CONTAINER_PAUSE,this.setPauseIcon);this.listenTo(this._container,_events2.default.CONTAINER_STOP,this.resetIcon);this.listenTo(this._container,_events2.default.CONTAINER_ENDED,this.resetIcon);this.listenTo(this._container,_events2.default.CONTAINER_ERROR,this.resetIcon);this.resetIcon();};Favicon.prototype.disable=function disable(){_CorePlugin.prototype.disable.call(this);this.resetIcon();};Favicon.prototype.destroy=function destroy(){_CorePlugin.prototype.destroy.call(this);this.resetIcon();};Favicon.prototype.createIcon=function createIcon(svg){var canvas=(0,_clapprZepto2.default)('<canvas/>');canvas[0].width=16;canvas[0].height=16;var ctx=canvas[0].getContext('2d');ctx.fillStyle='#000';var d=(0,_clapprZepto2.default)(svg).find('path').attr('d');var path=new Path2D(d);ctx.fill(path);var icon=(0,_clapprZepto2.default)('<link rel="shortcut icon" type="image/png"/>');icon.attr('href',canvas[0].toDataURL('image/png'));return icon;};Favicon.prototype.setPlayIcon=function setPlayIcon(){if(!this.playIcon){this.playIcon=this.createIcon(_play2.default);}this.changeIcon(this.playIcon);};Favicon.prototype.setPauseIcon=function setPauseIcon(){if(!this.pauseIcon){this.pauseIcon=this.createIcon(_pause2.default);}this.changeIcon(this.pauseIcon);};Favicon.prototype.resetIcon=function resetIcon(){(0,_clapprZepto2.default)('link[rel="shortcut icon"]').remove();(0,_clapprZepto2.default)('head').append(this.oldIcon);};Favicon.prototype.changeIcon=function changeIcon(icon){if(icon){(0,_clapprZepto2.default)('link[rel="shortcut icon"]').remove();(0,_clapprZepto2.default)('head').append(icon);}};return Favicon;}(_core_plugin2.default);exports.default=Favicon;module.exports=exports['default'];/***/},/* 207 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _seek_time=__webpack_require__(208);var _seek_time2=_interopRequireDefault(_seek_time);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}exports.default=_seek_time2.default;module.exports=exports['default'];/***/},/* 208 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _utils=__webpack_require__(5);var _ui_core_plugin=__webpack_require__(38);var _ui_core_plugin2=_interopRequireDefault(_ui_core_plugin);var _styler=__webpack_require__(7);var _styler2=_interopRequireDefault(_styler);var _template=__webpack_require__(8);var _template2=_interopRequireDefault(_template);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _playback=__webpack_require__(9);var _playback2=_interopRequireDefault(_playback);var _seek_time=__webpack_require__(209);var _seek_time2=_interopRequireDefault(_seek_time);var _seek_time3=__webpack_require__(210);var _seek_time4=_interopRequireDefault(_seek_time3);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Copyright 2014 Globo.com Player authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
var SeekTime=function(_UICorePlugin){(0,_inherits3.default)(SeekTime,_UICorePlugin);(0,_createClass3.default)(SeekTime,[{key:'name',get:function get(){return'seek_time';}},{key:'template',get:function get(){return(0,_template2.default)(_seek_time4.default);}},{key:'attributes',get:function get(){return{'class':'seek-time','data-seek-time':''};}},{key:'mediaControl',get:function get(){return this.core.mediaControl;}},{key:'mediaControlContainer',get:function get(){return this.mediaControl.container;}},{key:'isLiveStreamWithDvr',get:function get(){return this.mediaControlContainer&&this.mediaControlContainer.getPlaybackType()===_playback2.default.LIVE&&this.mediaControlContainer.isDvrEnabled();}},{key:'durationShown',get:function get(){return this.isLiveStreamWithDvr&&!this.useActualLiveTime;}},{key:'useActualLiveTime',get:function get(){return this.actualLiveTime&&this.isLiveStreamWithDvr;}}]);function SeekTime(core){(0,_classCallCheck3.default)(this,SeekTime);var _this=(0,_possibleConstructorReturn3.default)(this,_UICorePlugin.call(this,core));_this.hoveringOverSeekBar=false;_this.hoverPosition=null;_this.duration=null;_this.actualLiveTime=!!_this.mediaControl.options.actualLiveTime;if(_this.actualLiveTime){if(_this.mediaControl.options.actualLiveServerTime){_this.actualLiveServerTimeDiff=new Date().getTime()-new Date(_this.mediaControl.options.actualLiveServerTime).getTime();}else{_this.actualLiveServerTimeDiff=0;}}return _this;}SeekTime.prototype.bindEvents=function bindEvents(){this.listenTo(this.mediaControl,_events2.default.MEDIACONTROL_RENDERED,this.render);this.listenTo(this.mediaControl,_events2.default.MEDIACONTROL_MOUSEMOVE_SEEKBAR,this.showTime);this.listenTo(this.mediaControl,_events2.default.MEDIACONTROL_MOUSELEAVE_SEEKBAR,this.hideTime);this.listenTo(this.mediaControl,_events2.default.MEDIACONTROL_CONTAINERCHANGED,this.onContainerChanged);if(this.mediaControlContainer){this.listenTo(this.mediaControlContainer,_events2.default.CONTAINER_PLAYBACKDVRSTATECHANGED,this.update);this.listenTo(this.mediaControlContainer,_events2.default.CONTAINER_TIMEUPDATE,this.updateDuration);}};SeekTime.prototype.onContainerChanged=function onContainerChanged(){this.stopListening();this.bindEvents();};SeekTime.prototype.updateDuration=function updateDuration(timeProgress){this.duration=timeProgress.total;this.update();};SeekTime.prototype.showTime=function showTime(event){this.hoveringOverSeekBar=true;this.calculateHoverPosition(event);this.update();};SeekTime.prototype.hideTime=function hideTime(){this.hoveringOverSeekBar=false;this.update();};SeekTime.prototype.calculateHoverPosition=function calculateHoverPosition(event){var offset=event.pageX-this.mediaControl.$seekBarContainer.offset().left;// proportion into the seek bar that the mouse is hovered over 0-1
this.hoverPosition=Math.min(1,Math.max(offset/this.mediaControl.$seekBarContainer.width(),0));};SeekTime.prototype.getSeekTime=function getSeekTime(){var seekTime=void 0,secondsSinceMidnight=void 0;if(this.useActualLiveTime){var d=new Date(new Date().getTime()-this.actualLiveServerTimeDiff),e=new Date(d);secondsSinceMidnight=(e-d.setHours(0,0,0,0))/1000;seekTime=secondsSinceMidnight-this.duration+this.hoverPosition*this.duration;if(seekTime<0){seekTime+=86400;}}else{seekTime=this.hoverPosition*this.duration;}return{seekTime:seekTime,secondsSinceMidnight:secondsSinceMidnight};};SeekTime.prototype.update=function update(){if(!this.rendered){// update() is always called after a render
return;}if(!this.shouldBeVisible()){this.$el.hide();this.$el.css('left','-100%');}else{var seekTime=this.getSeekTime();var currentSeekTime=(0,_utils.formatTime)(seekTime.seekTime,this.useActualLiveTime);// only update dom if necessary, ie time actually changed
if(currentSeekTime!==this.displayedSeekTime){this.$seekTimeEl.text(currentSeekTime);this.displayedSeekTime=currentSeekTime;}if(this.durationShown){this.$durationEl.show();var currentDuration=(0,_utils.formatTime)(this.actualLiveTime?seekTime.secondsSinceMidnight:this.duration,this.actualLiveTime);if(currentDuration!==this.displayedDuration){this.$durationEl.text(currentDuration);this.displayedDuration=currentDuration;}}else{this.$durationEl.hide();}// the element must be unhidden before its width is requested, otherwise it's width will be reported as 0
this.$el.show();var containerWidth=this.mediaControl.$seekBarContainer.width();var elWidth=this.$el.width();var elLeftPos=this.hoverPosition*containerWidth;elLeftPos-=elWidth/2;elLeftPos=Math.max(0,Math.min(elLeftPos,containerWidth-elWidth));this.$el.css('left',elLeftPos);}};SeekTime.prototype.shouldBeVisible=function shouldBeVisible(){return this.mediaControlContainer&&this.mediaControlContainer.settings.seekEnabled&&this.hoveringOverSeekBar&&this.hoverPosition!==null&&this.duration!==null;};SeekTime.prototype.render=function render(){this.rendered=true;this.displayedDuration=null;this.displayedSeekTime=null;var style=_styler2.default.getStyleFor(_seek_time2.default);this.$el.html(this.template());this.$el.append(style);this.$el.hide();this.mediaControl.$el.append(this.el);this.$seekTimeEl=this.$el.find('[data-seek-time]');this.$durationEl=this.$el.find('[data-duration]');this.$durationEl.hide();this.update();};return SeekTime;}(_ui_core_plugin2.default);exports.default=SeekTime;module.exports=exports['default'];/***/},/* 209 *//***/function(module,exports,__webpack_require__){exports=module.exports=__webpack_require__(10)(undefined);// imports
// module
exports.push([module.i,".seek-time[data-seek-time] {\n  position: absolute;\n  white-space: nowrap;\n  height: 20px;\n  line-height: 20px;\n  font-size: 0;\n  left: -100%;\n  bottom: 55px;\n  background-color: rgba(2, 2, 2, 0.5);\n  z-index: 9999;\n  -webkit-transition: opacity 0.1s ease;\n  -moz-transition: opacity 0.1s ease;\n  transition: opacity 0.1s ease; }\n  .seek-time[data-seek-time].hidden[data-seek-time] {\n    opacity: 0; }\n  .seek-time[data-seek-time] [data-seek-time] {\n    display: inline-block;\n    color: white;\n    font-size: 10px;\n    padding-left: 7px;\n    padding-right: 7px;\n    vertical-align: top; }\n  .seek-time[data-seek-time] [data-duration] {\n    display: inline-block;\n    color: rgba(255, 255, 255, 0.5);\n    font-size: 10px;\n    padding-right: 7px;\n    vertical-align: top; }\n    .seek-time[data-seek-time] [data-duration]:before {\n      content: \"|\";\n      margin-right: 7px; }\n",""]);// exports
/***/},/* 210 *//***/function(module,exports){module.exports="<span data-seek-time></span>\n<span data-duration></span>\n";/***/},/* 211 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _core_plugin=__webpack_require__(30);var _core_plugin2=_interopRequireDefault(_core_plugin);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var SourcesPlugin=function(_CorePlugin){(0,_inherits3.default)(SourcesPlugin,_CorePlugin);function SourcesPlugin(){(0,_classCallCheck3.default)(this,SourcesPlugin);return(0,_possibleConstructorReturn3.default)(this,_CorePlugin.apply(this,arguments));}SourcesPlugin.prototype.bindEvents=function bindEvents(){this.listenTo(this.core,_events2.default.CORE_CONTAINERS_CREATED,this.onContainersCreated);};SourcesPlugin.prototype.onContainersCreated=function onContainersCreated(){var firstValidSource=this.core.containers.filter(function(container){return container.playback.name!=='no_op';})[0]||this.core.containers[0];if(firstValidSource){this.core.containers.forEach(function(container){if(container!==firstValidSource){container.destroy();}});}};(0,_createClass3.default)(SourcesPlugin,[{key:'name',get:function get(){return'sources';}}]);return SourcesPlugin;}(_core_plugin2.default);exports.default=SourcesPlugin;module.exports=exports['default'];/***/},/* 212 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _events=__webpack_require__(4);var _events2=_interopRequireDefault(_events);var _core_plugin=__webpack_require__(30);var _core_plugin2=_interopRequireDefault(_core_plugin);var _utils=__webpack_require__(5);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var EndVideo=function(_CorePlugin){(0,_inherits3.default)(EndVideo,_CorePlugin);function EndVideo(){(0,_classCallCheck3.default)(this,EndVideo);return(0,_possibleConstructorReturn3.default)(this,_CorePlugin.apply(this,arguments));}EndVideo.prototype.bindEvents=function bindEvents(){this.listenTo(this.core.mediaControl,_events2.default.MEDIACONTROL_CONTAINERCHANGED,this.containerChanged);var container=this.core.getCurrentContainer();if(container){this.listenTo(container,_events2.default.CONTAINER_ENDED,this.ended);this.listenTo(container,_events2.default.CONTAINER_STOP,this.ended);}};EndVideo.prototype.containerChanged=function containerChanged(){this.stopListening();this.bindEvents();};EndVideo.prototype.ended=function ended(){var exitOnEnd=typeof this.core.options.exitFullscreenOnEnd==='undefined'||this.core.options.exitFullscreenOnEnd;if(exitOnEnd&&_utils.Fullscreen.isFullscreen()){this.core.toggleFullscreen();}};(0,_createClass3.default)(EndVideo,[{key:'name',get:function get(){return'end_video';}}]);return EndVideo;}(_core_plugin2.default);exports.default=EndVideo;module.exports=exports['default'];/***/},/* 213 *//***/function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:true});var _keys=__webpack_require__(31);var _keys2=_interopRequireDefault(_keys);var _classCallCheck2=__webpack_require__(0);var _classCallCheck3=_interopRequireDefault(_classCallCheck2);var _possibleConstructorReturn2=__webpack_require__(1);var _possibleConstructorReturn3=_interopRequireDefault(_possibleConstructorReturn2);var _createClass2=__webpack_require__(3);var _createClass3=_interopRequireDefault(_createClass2);var _inherits2=__webpack_require__(2);var _inherits3=_interopRequireDefault(_inherits2);var _utils=__webpack_require__(5);var _clapprZepto=__webpack_require__(6);var _clapprZepto2=_interopRequireDefault(_clapprZepto);var _core_plugin=__webpack_require__(30);var _core_plugin2=_interopRequireDefault(_core_plugin);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/**
 * The internationalization (i18n) plugin
 * @class Strings
 * @constructor
 * @extends CorePlugin
 * @module plugins
 */var Strings=function(_CorePlugin){(0,_inherits3.default)(Strings,_CorePlugin);(0,_createClass3.default)(Strings,[{key:'name',get:function get(){return'strings';}}]);function Strings(core){(0,_classCallCheck3.default)(this,Strings);var _this=(0,_possibleConstructorReturn3.default)(this,_CorePlugin.call(this,core));_this._initializeMessages();return _this;}/**
   * Gets a translated string for the given key.
   * @method t
   * @param {String} key the key to all messages
   * @return {String} translated label
   */Strings.prototype.t=function t(key){var lang=this._language();var i18n=lang&&this._messages[lang]||this._messages['en'];return i18n[key]||key;};Strings.prototype._language=function _language(){return this.core.options.language||(0,_utils.getBrowserLanguage)();};Strings.prototype._initializeMessages=function _initializeMessages(){var defaultMessages={'en':{'live':'live','back_to_live':'back to live','disabled':'Disabled','playback_not_supported':'Your browser does not support the playback of this video. Please try using a different browser.'},'pt':{'live':'ao vivo','back_to_live':'voltar para o ao vivo','disabled':'Desativado','playback_not_supported':'Seu navegador no supporta a reproduo deste video. Por favor, tente usar um navegador diferente.'},'es':{'live':'vivo','back_to_live':'volver en vivo','disabled':'Discapacitado','playback_not_supported':'Su navegador no soporta la reproduccin de un video. Por favor, trate de usar un navegador diferente.'},'ru':{'live':' ','back_to_live':'  ','disabled':'','playback_not_supported':'      . ,   .'},'fr':{'live':'en direct','disabled':'Dsactiv','back_to_live':'retour au direct','playback_not_supported':'Votre navigateur ne supporte pas la lecture de cette vido. Merci de tenter sur un autre navigateur.'},'tr':{'live':'canl','back_to_live':'canl yayna dn','disabled':'Engelli','playback_not_supported':'Taraycnz bu videoyu oynatma desteine sahip deil. Ltfen farkl bir tarayc ile deneyin.'}};var strings=this.core.options.strings||{};this._messages=(0,_keys2.default)(defaultMessages).reduce(function(messages,lang){messages[lang]=_clapprZepto2.default.extend({},defaultMessages[lang],strings[lang]);return messages;},{});this._messages['pt-BR']=this._messages['pt'];this._messages['en-US']=this._messages['en'];this._messages['es-419']=this._messages['es'];this._messages['fr-FR']=this._messages['fr'];this._messages['tr-TR']=this._messages['tr'];};return Strings;}(_core_plugin2.default);exports.default=Strings;module.exports=exports['default'];/***/}]/******/));});

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

(function () {
  'use strict';

  let CSS_URL_RX = /(url\()([^)]*)(\))/g;
  let ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
  let workingURL;
  let resolveDoc;
  /**
   * Resolves the given URL against the provided `baseUri'.
   * 
   * Note that this function performs no resolution for URLs that start
   * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
   * URL resolution, use `window.URL`.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} url Input URL to resolve
   * @param {?string=} baseURI Base URI to resolve the URL against
   * @return {string} resolved URL
   */
  function resolveUrl(url, baseURI) {
    if (url && ABS_URL.test(url)) {
      return url;
    }
    // Lazy feature detection.
    if (workingURL === undefined) {
      workingURL = false;
      try {
        const u = new URL('b', 'http://a');
        u.pathname = 'c%20d';
        workingURL = u.href === 'http://a/c%20d';
      } catch (e) {
        // silently fail
      }
    }
    if (!baseURI) {
      baseURI = document.baseURI || window.location.href;
    }
    if (workingURL) {
      return new URL(url, baseURI).href;
    }
    // Fallback to creating an anchor into a disconnected document.
    if (!resolveDoc) {
      resolveDoc = document.implementation.createHTMLDocument('temp');
      resolveDoc.base = resolveDoc.createElement('base');
      resolveDoc.head.appendChild(resolveDoc.base);
      resolveDoc.anchor = resolveDoc.createElement('a');
      resolveDoc.body.appendChild(resolveDoc.anchor);
    }
    resolveDoc.base.href = baseURI;
    resolveDoc.anchor.href = url;
    return resolveDoc.anchor.href || url;
  }

  /**
   * Resolves any relative URL's in the given CSS text against the provided
   * `ownerDocument`'s `baseURI`.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} cssText CSS text to process
   * @param {string} baseURI Base URI to resolve the URL against
   * @return {string} Processed CSS text with resolved URL's
   */
  function resolveCss(cssText, baseURI) {
    return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
      return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
    });
  }

  /**
   * Returns a path from a given `url`. The path includes the trailing
   * `/` from the url.
   *
   * @memberof Polymer.ResolveUrl
   * @param {string} url Input URL to transform
   * @return {string} resolved path
   */
  function pathFromUrl(url) {
    return url.substring(0, url.lastIndexOf('/') + 1);
  }

  /**
   * Module with utilities for resolving relative URL's.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for resolving relative URL's.
   */
  Polymer.ResolveUrl = {
    resolveCss: resolveCss,
    resolveUrl: resolveUrl,
    pathFromUrl: pathFromUrl
  };
})();

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

(function () {

  'use strict';

  // Microtask implemented using Mutation Observer

  let microtaskCurrHandle = 0;
  let microtaskLastHandle = 0;
  let microtaskCallbacks = [];
  let microtaskNodeContent = 0;
  let microtaskNode = document.createTextNode('');
  new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });

  function microtaskFlush() {
    const len = microtaskCallbacks.length;
    for (let i = 0; i < len; i++) {
      let cb = microtaskCallbacks[i];
      if (cb) {
        try {
          cb();
        } catch (e) {
          setTimeout(() => {
            throw e;
          });
        }
      }
    }
    microtaskCallbacks.splice(0, len);
    microtaskLastHandle += len;
  }

  /**
   * Module that provides a number of strategies for enqueuing asynchronous
   * tasks.  Each sub-module provides a standard `run(fn)` interface that returns a
   * handle, and a `cancel(handle)` interface for canceling async tasks before
   * they run.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides a number of strategies for enqueuing asynchronous
   * tasks.
   */
  Polymer.Async = {

    /**
     * Async interface wrapper around `setTimeout`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `setTimeout`.
     */
    timeOut: {
      /**
       * Returns a sub-module with the async interface providing the provided
       * delay.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number=} delay Time to wait before calling callbacks in ms
       * @return {!AsyncInterface} An async timeout interface
       */
      after(delay) {
        return {
          run(fn) {
            return window.setTimeout(fn, delay);
          },
          cancel(handle) {
            window.clearTimeout(handle);
          }
        };
      },
      /**
       * Enqueues a function called in the next task.
       *
       * @memberof Polymer.Async.timeOut
       * @param {!Function} fn Callback to run
       * @param {number=} delay Delay in milliseconds
       * @return {number} Handle used for canceling task
       */
      run(fn, delay) {
        return window.setTimeout(fn, delay);
      },
      /**
       * Cancels a previously enqueued `timeOut` callback.
       *
       * @memberof Polymer.Async.timeOut
       * @param {number} handle Handle returned from `run` of callback to cancel
       * @return {void}
       */
      cancel(handle) {
        window.clearTimeout(handle);
      }
    },

    /**
     * Async interface wrapper around `requestAnimationFrame`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `requestAnimationFrame`.
     */
    animationFrame: {
      /**
       * Enqueues a function called at `requestAnimationFrame` timing.
       *
       * @memberof Polymer.Async.animationFrame
       * @param {function(number):void} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run(fn) {
        return window.requestAnimationFrame(fn);
      },
      /**
       * Cancels a previously enqueued `animationFrame` callback.
       *
       * @memberof Polymer.Async.animationFrame
       * @param {number} handle Handle returned from `run` of callback to cancel
       * @return {void}
       */
      cancel(handle) {
        window.cancelAnimationFrame(handle);
      }
    },

    /**
     * Async interface wrapper around `requestIdleCallback`.  Falls back to
     * `setTimeout` on browsers that do not support `requestIdleCallback`.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface wrapper around `requestIdleCallback`.
     */
    idlePeriod: {
      /**
       * Enqueues a function called at `requestIdleCallback` timing.
       *
       * @memberof Polymer.Async.idlePeriod
       * @param {function(!IdleDeadline):void} fn Callback to run
       * @return {number} Handle used for canceling task
       */
      run(fn) {
        return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
      },
      /**
       * Cancels a previously enqueued `idlePeriod` callback.
       *
       * @memberof Polymer.Async.idlePeriod
       * @param {number} handle Handle returned from `run` of callback to cancel
       * @return {void}
       */
      cancel(handle) {
        window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
      }
    },

    /**
     * Async interface for enqueuing callbacks that run at microtask timing.
     *
     * Note that microtask timing is achieved via a single `MutationObserver`,
     * and thus callbacks enqueued with this API will all run in a single
     * batch, and not interleaved with other microtasks such as promises.
     * Promises are avoided as an implementation choice for the time being
     * due to Safari bugs that cause Promises to lack microtask guarantees.
     *
     * @namespace
     * @memberof Polymer.Async
     * @summary Async interface for enqueuing callbacks that run at microtask
     *   timing.
     */
    microTask: {

      /**
       * Enqueues a function called at microtask timing.
       *
       * @memberof Polymer.Async.microTask
       * @param {!Function=} callback Callback to run
       * @return {number} Handle used for canceling task
       */
      run(callback) {
        microtaskNode.textContent = microtaskNodeContent++;
        microtaskCallbacks.push(callback);
        return microtaskCurrHandle++;
      },

      /**
       * Cancels a previously enqueued `microTask` callback.
       *
       * @memberof Polymer.Async.microTask
       * @param {number} handle Handle returned from `run` of callback to cancel
       * @return {void}
       */
      cancel(handle) {
        const idx = handle - microtaskLastHandle;
        if (idx >= 0) {
          if (!microtaskCallbacks[idx]) {
            throw new Error('invalid async handle: ' + handle);
          }
          microtaskCallbacks[idx] = null;
        }
      }

    }
  };
})();

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(1);

(function () {
  'use strict';

  // Common implementation for mixin & behavior

  function mutablePropertyChange(inst, property, value, old, mutableData) {
    let isObject;
    if (mutableData) {
      isObject = typeof value === 'object' && value !== null;
      // Pull `old` for Objects from temp cache, but treat `null` as a primitive
      if (isObject) {
        old = inst.__dataTemp[property];
      }
    }
    // Strict equality check, but return false for NaN===NaN
    let shouldChange = old !== value && (old === old || value === value);
    // Objects are stored in temporary cache (cleared at end of
    // turn), which is used for dirty-checking
    if (isObject && shouldChange) {
      inst.__dataTemp[property] = value;
    }
    return shouldChange;
  }

  /**
   * Element class mixin to skip strict dirty-checking for objects and arrays
   * (always consider them to be "dirty"), for use on elements utilizing
   * `Polymer.PropertyEffects`
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   * Specifically, any elements in the binding tree between the source of a
   * mutation and the consumption of it must apply this mixin or enable the
   * `Polymer.OptionalMutableData` mixin.
   *
   * In order to make the dirty check strategy configurable, see
   * `Polymer.OptionalMutableData`.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse as opposed to using strict dirty checking with immutable
   * patterns or Polymer's path notification API.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin to skip strict dirty-checking for objects
   *   and arrays
   */
  Polymer.MutableData = Polymer.dedupingMixin(superClass => {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_MutableData}
     */
    class MutableData extends superClass {
      /**
       * Overrides `Polymer.PropertyEffects` to provide option for skipping
       * strict equality checking for Objects and Arrays.
       *
       * This method pulls the value to dirty check against from the `__dataTemp`
       * cache (rather than the normal `__data` cache) for Objects.  Since the temp
       * cache is cleared at the end of a turn, this implementation allows
       * side-effects of deep object changes to be processed by re-setting the
       * same object (using the temp cache as an in-turn backstop to prevent
       * cycles due to 2-way notification).
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       * @protected
       */
      _shouldPropertyChange(property, value, old) {
        return mutablePropertyChange(this, property, value, old, true);
      }

    }
    /** @type {boolean} */
    MutableData.prototype.mutableData = false;

    return MutableData;
  });

  /**
   * Element class mixin to add the optional ability to skip strict
   * dirty-checking for objects and arrays (always consider them to be
   * "dirty") by setting a `mutable-data` attribute on an element instance.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will allow Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   * Specifically, any elements in the binding tree between the source of a
   * mutation and the consumption of it must enable this mixin or apply the
   * `Polymer.MutableData` mixin.
   *
   * While this mixin adds the ability to forgo Object/Array dirty checking,
   * the `mutableData` flag defaults to false and must be set on the instance.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse by relying on `mutableData: true` as opposed to using
   * strict dirty checking with immutable patterns or Polymer's path notification
   * API.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin to optionally skip strict dirty-checking
   *   for objects and arrays
   */
  Polymer.OptionalMutableData = Polymer.dedupingMixin(superClass => {

    /**
     * @mixinClass
     * @polymer
     * @implements {Polymer_OptionalMutableData}
     */
    class OptionalMutableData extends superClass {

      static get properties() {
        return {
          /**
           * Instance-level flag for configuring the dirty-checking strategy
           * for this element.  When true, Objects and Arrays will skip dirty
           * checking, otherwise strict equality checking will be used.
           */
          mutableData: Boolean
        };
      }

      /**
       * Overrides `Polymer.PropertyEffects` to provide option for skipping
       * strict equality checking for Objects and Arrays.
       *
       * When `this.mutableData` is true on this instance, this method
       * pulls the value to dirty check against from the `__dataTemp` cache
       * (rather than the normal `__data` cache) for Objects.  Since the temp
       * cache is cleared at the end of a turn, this implementation allows
       * side-effects of deep object changes to be processed by re-setting the
       * same object (using the temp cache as an in-turn backstop to prevent
       * cycles due to 2-way notification).
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       * @protected
       */
      _shouldPropertyChange(property, value, old) {
        return mutablePropertyChange(this, property, value, old, this.mutableData);
      }
    }

    return OptionalMutableData;
  });

  // Export for use by legacy behavior
  Polymer.MutableData._mutablePropertyChange = mutablePropertyChange;
})();

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OzoneAPIRequest; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript__);
/// <amd-module name="ozone-api-request"/>
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * OzoneAPIRequest is a light wrapper over XMLHttpRequest to manager AJAX request to Ozone.
 *
 * ### Events
 *
 * * *ozone-api-request-success* Fired when connection to ozone succeeds.
 * Event detail contains the XMLHttpRequest.
 *
 * * *ozone-api-request-error* Fired when connection to ozone fails.
 * Event detail contains the XMLHttpRequest.
 *

 * * *ozone-api-request-timeout* Fired when connection timeout.
 * Event detail contains the XMLHttpRequest.
 *
 * * *ozone-api-request-unauthorized* Fired when server return 403 unauthorized.
 * Event detail contains the XMLHttpRequest.
 *
 *
 * ### Usage
 *
 * * Basic usage with promise
 * ```typeScript
 * const OzoneAPIRequest = new OzoneAPIRequest();
 * OzoneAPIRequest.url = url;
 * OzoneAPIRequest.method = 'GET';
 * OzoneAPIRequest.sendRequest()
 *    .then((res:XMLHttpRequest) => {
 *        // Do something with XMLHttpRequest
 *        console.log(res.response)
 *    })
 *    .catch((failRequest)=>{
 *        // Do something with XMLHttpRequest to handel the error.
 *        console.error(failRequest.statusText)
 *    })
 * ```
 *
 *
 * * Usage with Event handler
 * ```typeScript
 * this.addEventListener('ozone-api-request-success', (event: Event) => {
 *        // Do something with XMLHttpRequest
 *        console.log(event.detail.response)
 *    })
 * this.addEventListener('ozone-api-request-error', (event: Event) => {
 *        // Do something with XMLHttpRequest to handel the error.
 *        console.error(event.detail.statusText)
 *    })
 * const OzoneAPIRequest = new OzoneAPIRequest();
 * OzoneAPIRequest.setEventTarget(this)
 * OzoneAPIRequest.url = url;
 * OzoneAPIRequest.method = 'GET';
 * OzoneAPIRequest.sendRequest();
 * ```
 *
 * * Modify request before send
 * ```typeScript
 * const OzoneAPIRequest = new OzoneAPIRequest();
 * OzoneAPIRequest.url = url;
 * OzoneAPIRequest.method = 'GET';
 * const request = OzoneAPIRequest.createXMLHttpRequest();
 * // Modify default request
 * request.setRequestHeader('Cache-Control', 'only-if-cached');
 *
 * OzoneAPIRequest.sendRequest(request);
 * // Handel response
 * ```
 *
 */
let OzoneAPIRequest = class OzoneAPIRequest {
    /**
     * OzoneAPIRequest is a light wrapper over XMLHttpRequest to manager AJAX request to Ozone.
     *
     * ### Events
     *
     * * *ozone-api-request-success* Fired when connection to ozone succeeds.
     * Event detail contains the XMLHttpRequest.
     *
     * * *ozone-api-request-error* Fired when connection to ozone fails.
     * Event detail contains the XMLHttpRequest.
     *
    
     * * *ozone-api-request-timeout* Fired when connection timeout.
     * Event detail contains the XMLHttpRequest.
     *
     * * *ozone-api-request-unauthorized* Fired when server return 403 unauthorized.
     * Event detail contains the XMLHttpRequest.
     *
     *
     * ### Usage
     *
     * * Basic usage with promise
     * ```typeScript
     * const OzoneAPIRequest = new OzoneAPIRequest();
     * OzoneAPIRequest.url = url;
     * OzoneAPIRequest.method = 'GET';
     * OzoneAPIRequest.sendRequest()
     *    .then((res:XMLHttpRequest) => {
     *        // Do something with XMLHttpRequest
     *        console.log(res.response)
     *    })
     *    .catch((failRequest)=>{
     *        // Do something with XMLHttpRequest to handel the error.
     *        console.error(failRequest.statusText)
     *    })
     * ```
     *
     *
     * * Usage with Event handler
     * ```typeScript
     * this.addEventListener('ozone-api-request-success', (event: Event) => {
     *        // Do something with XMLHttpRequest
     *        console.log(event.detail.response)
     *    })
     * this.addEventListener('ozone-api-request-error', (event: Event) => {
     *        // Do something with XMLHttpRequest to handel the error.
     *        console.error(event.detail.statusText)
     *    })
     * const OzoneAPIRequest = new OzoneAPIRequest();
     * OzoneAPIRequest.setEventTarget(this)
     * OzoneAPIRequest.url = url;
     * OzoneAPIRequest.method = 'GET';
     * OzoneAPIRequest.sendRequest();
     * ```
     *
     * * Modify request before send
     * ```typeScript
     * const OzoneAPIRequest = new OzoneAPIRequest();
     * OzoneAPIRequest.url = url;
     * OzoneAPIRequest.method = 'GET';
     * const request = OzoneAPIRequest.createXMLHttpRequest();
     * // Modify default request
     * request.setRequestHeader('Cache-Control', 'only-if-cached');
     *
     * OzoneAPIRequest.sendRequest(request);
     * // Handel response
     * ```
     *
     */
    constructor() {
        this._url = '';
        this._method = 'GET';
        this._body = '';
        this._responseType = 'json';
        /**
         * eventTarget to dispatch *ozone-api-request-success* and *ozone-api-request-error* events
         * Default value is document.
         * @type {EventTarget}
         */
        this.eventTarget = document;
    }
    set url(url) {
        this._url = url;
    }
    get url() {
        return this._url;
    }
    set body(body) {
        this._body = body;
    }
    get body() {
        return this._body;
    }
    set method(method) {
        this._method = method;
    }
    get method() {
        return this._method;
    }
    set responseType(responseType) {
        this._responseType = responseType;
    }
    get responseType() {
        return this._responseType;
    }
    /**
     * Create and open an XMLHttpRequest
     * @return {XMLHttpRequest}
     */
    createXMLHttpRequest() {
        const xmlhttp = new XMLHttpRequest();
        xmlhttp.withCredentials = true;
        xmlhttp.open(this.method, this.url, true);
        xmlhttp.responseType = this.responseType;
        xmlhttp.setRequestHeader("Content-Type", "application/json");
        xmlhttp.setRequestHeader('Accept', 'application/json');
        return xmlhttp;
    }
    setEventTarget(element) {
        this.eventTarget = element;
    }
    /**
     *
     * @param {XMLHttpRequest} request (optional) This parameters overwrite the default XmlHttpRequest.
     * @return {Promise<XMLHttpRequest>}
     */
    sendRequest(request) {
        const xmlhttp = request || this.createXMLHttpRequest();
        return new Promise((resolve, reject) => {
            const handleResponse = () => {
                switch (xmlhttp.status) {
                    case 200:
                        this.eventTarget.dispatchEvent(new CustomEvent('ozone-api-request-success', {
                            bubbles: true, detail: xmlhttp
                        }));
                        resolve(xmlhttp);
                        break;
                    case 403:
                        this.eventTarget.dispatchEvent(new CustomEvent('ozone-api-request-unauthorized', {
                            bubbles: true, detail: xmlhttp
                        }));
                        reject(xmlhttp);
                        break;
                    default:
                        this.eventTarget.dispatchEvent(new CustomEvent('ozone-api-request-error', {
                            bubbles: true, detail: xmlhttp
                        }));
                        reject(xmlhttp);
                }
            };
            xmlhttp.onload = handleResponse;
            xmlhttp.ontimeout = () => {
                this.eventTarget.dispatchEvent(new CustomEvent('ozone-api-request-timeout', {
                    bubbles: true, detail: xmlhttp
                }));
                reject(xmlhttp);
            };
            xmlhttp.onerror = handleResponse;
            xmlhttp.send(this.body);
        });
    }
};
OzoneAPIRequest = __decorate([Object(__WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript__["jsElement"])()], OzoneAPIRequest);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(1);

__webpack_require__(33);

__webpack_require__(19);

__webpack_require__(20);

__webpack_require__(34);

(function () {

  'use strict';

  /** @const {Object} */

  const CaseMap = Polymer.CaseMap;

  // Monotonically increasing unique ID used for de-duping effects triggered
  // from multiple properties in the same turn
  let dedupeId = 0;

  /**
   * Property effect types; effects are stored on the prototype using these keys
   * @enum {string}
   */
  const TYPES = {
    COMPUTE: '__computeEffects',
    REFLECT: '__reflectEffects',
    NOTIFY: '__notifyEffects',
    PROPAGATE: '__propagateEffects',
    OBSERVE: '__observeEffects',
    READ_ONLY: '__readOnly'
  };

  /**
   * @typedef {{
   * name: (string | undefined),
   * structured: (boolean | undefined),
   * wildcard: (boolean | undefined)
   * }}
   */
  let DataTrigger; //eslint-disable-line no-unused-vars

  /**
   * @typedef {{
   * info: ?,
   * trigger: (!DataTrigger | undefined),
   * fn: (!Function | undefined)
   * }}
   */
  let DataEffect; //eslint-disable-line no-unused-vars

  let PropertyEffectsType; //eslint-disable-line no-unused-vars

  /**
   * Ensures that the model has an own-property map of effects for the given type.
   * The model may be a prototype or an instance.
   *
   * Property effects are stored as arrays of effects by property in a map,
   * by named type on the model. e.g.
   *
   *   __computeEffects: {
   *     foo: [ ... ],
   *     bar: [ ... ]
   *   }
   *
   * If the model does not yet have an effect map for the type, one is created
   * and returned.  If it does, but it is not an own property (i.e. the
   * prototype had effects), the the map is deeply cloned and the copy is
   * set on the model and returned, ready for new effects to be added.
   *
   * @param {Object} model Prototype or instance
   * @param {string} type Property effect type
   * @return {Object} The own-property map of effects for the given type
   * @private
   */
  function ensureOwnEffectMap(model, type) {
    let effects = model[type];
    if (!effects) {
      effects = model[type] = {};
    } else if (!model.hasOwnProperty(type)) {
      effects = model[type] = Object.create(model[type]);
      for (let p in effects) {
        let protoFx = effects[p];
        let instFx = effects[p] = Array(protoFx.length);
        for (let i = 0; i < protoFx.length; i++) {
          instFx[i] = protoFx[i];
        }
      }
    }
    return effects;
  }

  // -- effects ----------------------------------------------

  /**
   * Runs all effects of a given type for the given set of property changes
   * on an instance.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} effects Object map of property-to-Array of effects
   * @param {Object} props Bag of current property changes
   * @param {Object=} oldProps Bag of previous values for changed properties
   * @param {boolean=} hasPaths True with `props` contains one or more paths
   * @param {*=} extraArgs Additional metadata to pass to effect function
   * @return {boolean} True if an effect ran for this property
   * @private
   */
  function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
    if (effects) {
      let ran = false;
      let id = dedupeId++;
      for (let prop in props) {
        if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
          ran = true;
        }
      }
      return ran;
    }
    return false;
  }

  /**
   * Runs a list of effects for a given property.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} effects Object map of property-to-Array of effects
   * @param {number} dedupeId Counter used for de-duping effects
   * @param {string} prop Name of changed property
   * @param {*} props Changed properties
   * @param {*} oldProps Old properties
   * @param {boolean=} hasPaths True with `props` contains one or more paths
   * @param {*=} extraArgs Additional metadata to pass to effect function
   * @return {boolean} True if an effect ran for this property
   * @private
   */
  function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
    let ran = false;
    let rootProperty = hasPaths ? Polymer.Path.root(prop) : prop;
    let fxs = effects[rootProperty];
    if (fxs) {
      for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
        if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
          if (fx.info) {
            fx.info.lastRun = dedupeId;
          }
          fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
          ran = true;
        }
      }
    }
    return ran;
  }

  /**
   * Determines whether a property/path that has changed matches the trigger
   * criteria for an effect.  A trigger is a descriptor with the following
   * structure, which matches the descriptors returned from `parseArg`.
   * e.g. for `foo.bar.*`:
   * ```
   * trigger: {
   *   name: 'a.b',
   *   structured: true,
   *   wildcard: true
   * }
   * ```
   * If no trigger is given, the path is deemed to match.
   *
   * @param {string} path Path or property that changed
   * @param {DataTrigger} trigger Descriptor
   * @return {boolean} Whether the path matched the trigger
   */
  function pathMatchesTrigger(path, trigger) {
    if (trigger) {
      let triggerPath = trigger.name;
      return triggerPath == path || trigger.structured && Polymer.Path.isAncestor(triggerPath, path) || trigger.wildcard && Polymer.Path.isDescendant(triggerPath, path);
    } else {
      return true;
    }
  }

  /**
   * Implements the "observer" effect.
   *
   * Calls the method with `info.methodName` on the instance, passing the
   * new and old values.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @return {void}
   * @private
   */
  function runObserverEffect(inst, property, props, oldProps, info) {
    let fn = typeof info.method === "string" ? inst[info.method] : info.method;
    let changedProp = info.property;
    if (fn) {
      fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
    } else if (!info.dynamicFn) {
      console.warn('observer method `' + info.method + '` not defined');
    }
  }

  /**
   * Runs "notify" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * will dispatch path notification events in the case that the property
   * changed was a path and the root property for that path didn't have a
   * "notify" effect.  This is to maintain 1.0 behavior that did not require
   * `notify: true` to ensure object sub-property notifications were
   * sent.
   *
   * @param {!PropertyEffectsType} inst The instance with effects to run
   * @param {Object} notifyProps Bag of properties to notify
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @return {void}
   * @private
   */
  function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
    // Notify
    let fxs = inst[TYPES.NOTIFY];
    let notified;
    let id = dedupeId++;
    // Try normal notify effects; if none, fall back to try path notification
    for (let prop in notifyProps) {
      if (notifyProps[prop]) {
        if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
          notified = true;
        } else if (hasPaths && notifyPath(inst, prop, props)) {
          notified = true;
        }
      }
    }
    // Flush host if we actually notified and host was batching
    // And the host has already initialized clients; this prevents
    // an issue with a host observing data changes before clients are ready.
    let host;
    if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
      host._invalidateProperties();
    }
  }

  /**
   * Dispatches {property}-changed events with path information in the detail
   * object to indicate a sub-path of the property was changed.
   *
   * @param {!PropertyEffectsType} inst The element from which to fire the event
   * @param {string} path The path that was changed
   * @param {Object} props Bag of current property changes
   * @return {boolean} Returns true if the path was notified
   * @private
   */
  function notifyPath(inst, path, props) {
    let rootProperty = Polymer.Path.root(path);
    if (rootProperty !== path) {
      let eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';
      dispatchNotifyEvent(inst, eventName, props[path], path);
      return true;
    }
    return false;
  }

  /**
   * Dispatches {property}-changed events to indicate a property (or path)
   * changed.
   *
   * @param {!PropertyEffectsType} inst The element from which to fire the event
   * @param {string} eventName The name of the event to send ('{property}-changed')
   * @param {*} value The value of the changed property
   * @param {string | null | undefined} path If a sub-path of this property changed, the path
   *   that changed (optional).
   * @return {void}
   * @private
   * @suppress {invalidCasts}
   */
  function dispatchNotifyEvent(inst, eventName, value, path) {
    let detail = {
      value: value,
      queueProperty: true
    };
    if (path) {
      detail.path = path;
    }
    /** @type {!HTMLElement} */inst.dispatchEvent(new CustomEvent(eventName, { detail }));
  }

  /**
   * Implements the "notify" effect.
   *
   * Dispatches a non-bubbling event named `info.eventName` on the instance
   * with a detail object containing the new `value`.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @return {void}
   * @private
   */
  function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
    let rootProperty = hasPaths ? Polymer.Path.root(property) : property;
    let path = rootProperty != property ? property : null;
    let value = path ? Polymer.Path.get(inst, path) : inst.__data[property];
    if (path && value === undefined) {
      value = props[property]; // specifically for .splices
    }
    dispatchNotifyEvent(inst, info.eventName, value, path);
  }

  /**
   * Handler function for 2-way notification events. Receives context
   * information captured in the `addNotifyListener` closure from the
   * `__notifyListeners` metadata.
   *
   * Sets the value of the notified property to the host property or path.  If
   * the event contained path information, translate that path to the host
   * scope's name for that path first.
   *
   * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
   * @param {!PropertyEffectsType} inst Host element instance handling the notification event
   * @param {string} fromProp Child element property that was bound
   * @param {string} toPath Host property/path that was bound
   * @param {boolean} negate Whether the binding was negated
   * @return {void}
   * @private
   */
  function handleNotification(event, inst, fromProp, toPath, negate) {
    let value;
    let detail = /** @type {Object} */event.detail;
    let fromPath = detail && detail.path;
    if (fromPath) {
      toPath = Polymer.Path.translate(fromProp, toPath, fromPath);
      value = detail && detail.value;
    } else {
      value = event.target[fromProp];
    }
    value = negate ? !value : value;
    if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
      if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
        inst._invalidateProperties();
      }
    }
  }

  /**
   * Implements the "reflect" effect.
   *
   * Sets the attribute named `info.attrName` to the given property value.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @return {void}
   * @private
   */
  function runReflectEffect(inst, property, props, oldProps, info) {
    let value = inst.__data[property];
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */inst);
    }
    inst._propertyToAttribute(property, info.attrName, value);
  }

  /**
   * Runs "computed" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * continues to run computed effects based on the output of each pass until
   * there are no more newly computed properties.  This ensures that all
   * properties that will be computed by the initial set of changes are
   * computed before other effects (binding propagation, observers, and notify)
   * run.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {!Object} changedProps Bag of changed properties
   * @param {!Object} oldProps Bag of previous values for changed properties
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @return {void}
   * @private
   */
  function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
    let computeEffects = inst[TYPES.COMPUTE];
    if (computeEffects) {
      let inputProps = changedProps;
      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
        Object.assign(oldProps, inst.__dataOld);
        Object.assign(changedProps, inst.__dataPending);
        inputProps = inst.__dataPending;
        inst.__dataPending = null;
      }
    }
  }

  /**
   * Implements the "computed property" effect by running the method with the
   * values of the arguments specified in the `info` object and setting the
   * return value to the computed property specified.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @return {void}
   * @private
   */
  function runComputedEffect(inst, property, props, oldProps, info) {
    let result = runMethodEffect(inst, property, props, oldProps, info);
    let computedProp = info.methodInfo;
    if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
      inst._setPendingProperty(computedProp, result, true);
    } else {
      inst[computedProp] = result;
    }
  }

  /**
   * Computes path changes based on path links set up using the `linkPaths`
   * API.
   *
   * @param {!PropertyEffectsType} inst The instance whose props are changing
   * @param {string | !Array<(string|number)>} path Path that has changed
   * @param {*} value Value of changed path
   * @return {void}
   * @private
   */
  function computeLinkedPaths(inst, path, value) {
    let links = inst.__dataLinkedPaths;
    if (links) {
      let link;
      for (let a in links) {
        let b = links[a];
        if (Polymer.Path.isDescendant(a, path)) {
          link = Polymer.Path.translate(a, b, path);
          inst._setPendingPropertyOrPath(link, value, true, true);
        } else if (Polymer.Path.isDescendant(b, path)) {
          link = Polymer.Path.translate(b, a, path);
          inst._setPendingPropertyOrPath(link, value, true, true);
        }
      }
    }
  }

  // -- bindings ----------------------------------------------

  /**
   * Adds binding metadata to the current `nodeInfo`, and binding effects
   * for all part dependencies to `templateInfo`.
   *
   * @param {Function} constructor Class that `_parseTemplate` is currently
   *   running on
   * @param {TemplateInfo} templateInfo Template metadata for current template
   * @param {NodeInfo} nodeInfo Node metadata for current template node
   * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
   * @param {string} target Target property name
   * @param {!Array<!BindingPart>} parts Array of binding part metadata
   * @param {string=} literal Literal text surrounding binding parts (specified
   *   only for 'property' bindings, since these must be initialized as part
   *   of boot-up)
   * @return {void}
   * @private
   */
  function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
    // Create binding metadata and add to nodeInfo
    nodeInfo.bindings = nodeInfo.bindings || [];
    let /** Binding */binding = { kind, target, parts, literal, isCompound: parts.length !== 1 };
    nodeInfo.bindings.push(binding);
    // Add listener info to binding metadata
    if (shouldAddListener(binding)) {
      let { event, negate } = binding.parts[0];
      binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';
      binding.listenerNegate = negate;
    }
    // Add "propagate" property effects to templateInfo
    let index = templateInfo.nodeInfoList.length;
    for (let i = 0; i < binding.parts.length; i++) {
      let part = binding.parts[i];
      part.compoundIndex = i;
      addEffectForBindingPart(constructor, templateInfo, binding, part, index);
    }
  }

  /**
   * Adds property effects to the given `templateInfo` for the given binding
   * part.
   *
   * @param {Function} constructor Class that `_parseTemplate` is currently
   *   running on
   * @param {TemplateInfo} templateInfo Template metadata for current template
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @param {number} index Index into `nodeInfoList` for this node
   * @return {void}
   */
  function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
    if (!part.literal) {
      if (binding.kind === 'attribute' && binding.target[0] === '-') {
        console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
      } else {
        let dependencies = part.dependencies;
        let info = { index, binding, part, evaluator: constructor };
        for (let j = 0; j < dependencies.length; j++) {
          let trigger = dependencies[j];
          if (typeof trigger == 'string') {
            trigger = parseArg(trigger);
            trigger.wildcard = true;
          }
          constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
            fn: runBindingEffect,
            info, trigger
          });
        }
      }
    }
  }

  /**
   * Implements the "binding" (property/path binding) effect.
   *
   * Note that binding syntax is overridable via `_parseBindings` and
   * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
   * non-literal parts returned from `_parseBindings`.  However,
   * there is no support for _path_ bindings via custom binding parts,
   * as this is specific to Polymer's path binding syntax.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} path Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @param {boolean} hasPaths True with `props` contains one or more paths
   * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
   *   metadata
   * @return {void}
   * @private
   */
  function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
    let node = nodeList[info.index];
    let binding = info.binding;
    let part = info.part;
    // Subpath notification: transform path and set to client
    // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
    if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
      let value = props[path];
      path = Polymer.Path.translate(part.source, binding.target, path);
      if (node._setPendingPropertyOrPath(path, value, false, true)) {
        inst._enqueueClient(node);
      }
    } else {
      let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
      // Propagate value to child
      applyBindingValue(inst, node, binding, part, value);
    }
  }

  /**
   * Sets the value for an "binding" (binding) effect to a node,
   * either as a property or attribute.
   *
   * @param {!PropertyEffectsType} inst The instance owning the binding effect
   * @param {Node} node Target node for binding
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @param {*} value Value to set
   * @return {void}
   * @private
   */
  function applyBindingValue(inst, node, binding, part, value) {
    value = computeBindingValue(node, value, binding, part);
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, binding.target, binding.kind, node);
    }
    if (binding.kind == 'attribute') {
      // Attribute binding
      inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);
    } else {
      // Property binding
      let prop = binding.target;
      if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
        if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
          if (node._setPendingProperty(prop, value)) {
            inst._enqueueClient(node);
          }
        }
      } else {
        inst._setUnmanagedPropertyToNode(node, prop, value);
      }
    }
  }

  /**
   * Transforms an "binding" effect value based on compound & negation
   * effect metadata, as well as handling for special-case properties
   *
   * @param {Node} node Node the value will be set to
   * @param {*} value Value to set
   * @param {!Binding} binding Binding metadata
   * @param {!BindingPart} part Binding part metadata
   * @return {*} Transformed value to set
   * @private
   */
  function computeBindingValue(node, value, binding, part) {
    if (binding.isCompound) {
      let storage = node.__dataCompoundStorage[binding.target];
      storage[part.compoundIndex] = value;
      value = storage.join('');
    }
    if (binding.kind !== 'attribute') {
      // Some browsers serialize `undefined` to `"undefined"`
      if (binding.target === 'textContent' || binding.target === 'value' && (node.localName === 'input' || node.localName === 'textarea')) {
        value = value == undefined ? '' : value;
      }
    }
    return value;
  }

  /**
   * Returns true if a binding's metadata meets all the requirements to allow
   * 2-way binding, and therefore a `<property>-changed` event listener should be
   * added:
   * - used curly braces
   * - is a property (not attribute) binding
   * - is not a textContent binding
   * - is not compound
   *
   * @param {!Binding} binding Binding metadata
   * @return {boolean} True if 2-way listener should be added
   * @private
   */
  function shouldAddListener(binding) {
    return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
  }

  /**
   * Setup compound binding storage structures, notify listeners, and dataHost
   * references onto the bound nodeList.
   *
   * @param {!PropertyEffectsType} inst Instance that bas been previously bound
   * @param {TemplateInfo} templateInfo Template metadata
   * @return {void}
   * @private
   */
  function setupBindings(inst, templateInfo) {
    // Setup compound storage, dataHost, and notify listeners
    let { nodeList, nodeInfoList } = templateInfo;
    if (nodeInfoList.length) {
      for (let i = 0; i < nodeInfoList.length; i++) {
        let info = nodeInfoList[i];
        let node = nodeList[i];
        let bindings = info.bindings;
        if (bindings) {
          for (let i = 0; i < bindings.length; i++) {
            let binding = bindings[i];
            setupCompoundStorage(node, binding);
            addNotifyListener(node, inst, binding);
          }
        }
        node.__dataHost = inst;
      }
    }
  }

  /**
   * Initializes `__dataCompoundStorage` local storage on a bound node with
   * initial literal data for compound bindings, and sets the joined
   * literal parts to the bound property.
   *
   * When changes to compound parts occur, they are first set into the compound
   * storage array for that property, and then the array is joined to result in
   * the final value set to the property/attribute.
   *
   * @param {Node} node Bound node to initialize
   * @param {Binding} binding Binding metadata
   * @return {void}
   * @private
   */
  function setupCompoundStorage(node, binding) {
    if (binding.isCompound) {
      // Create compound storage map
      let storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
      let parts = binding.parts;
      // Copy literals from parts into storage for this binding
      let literals = new Array(parts.length);
      for (let j = 0; j < parts.length; j++) {
        literals[j] = parts[j].literal;
      }
      let target = binding.target;
      storage[target] = literals;
      // Configure properties with their literal parts
      if (binding.literal && binding.kind == 'property') {
        node[target] = binding.literal;
      }
    }
  }

  /**
   * Adds a 2-way binding notification event listener to the node specified
   *
   * @param {Object} node Child element to add listener to
   * @param {!PropertyEffectsType} inst Host element instance to handle notification event
   * @param {Binding} binding Binding metadata
   * @return {void}
   * @private
   */
  function addNotifyListener(node, inst, binding) {
    if (binding.listenerEvent) {
      let part = binding.parts[0];
      node.addEventListener(binding.listenerEvent, function (e) {
        handleNotification(e, inst, binding.target, part.source, part.negate);
      });
    }
  }

  // -- for method-based effects (complexObserver & computed) --------------

  /**
   * Adds property effects for each argument in the method signature (and
   * optionally, for the method name if `dynamic` is true) that calls the
   * provided effect function.
   *
   * @param {Element | Object} model Prototype or instance
   * @param {!MethodSignature} sig Method signature metadata
   * @param {string} type Type of property effect to add
   * @param {Function} effectFn Function to run when arguments change
   * @param {*=} methodInfo Effect-specific information to be included in
   *   method effect metadata
   * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
   *   method names should be included as a dependency to the effect. Note,
   *   defaults to true if the signature is static (sig.static is true).
   * @return {void}
   * @private
   */
  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
    dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]);
    let info = {
      methodName: sig.methodName,
      args: sig.args,
      methodInfo,
      dynamicFn
    };
    for (let i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
      if (!arg.literal) {
        model._addPropertyEffect(arg.rootProperty, type, {
          fn: effectFn, info: info, trigger: arg
        });
      }
    }
    if (dynamicFn) {
      model._addPropertyEffect(sig.methodName, type, {
        fn: effectFn, info: info
      });
    }
  }

  /**
   * Calls a method with arguments marshaled from properties on the instance
   * based on the method signature contained in the effect metadata.
   *
   * Multi-property observers, computed properties, and inline computing
   * functions call this function to invoke the method, then use the return
   * value accordingly.
   *
   * @param {!PropertyEffectsType} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @param {?} info Effect metadata
   * @return {*} Returns the return value from the method invocation
   * @private
   */
  function runMethodEffect(inst, property, props, oldProps, info) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    let context = inst._methodHost || inst;
    let fn = context[info.methodName];
    if (fn) {
      let args = marshalArgs(inst.__data, info.args, property, props);
      return fn.apply(context, args);
    } else if (!info.dynamicFn) {
      console.warn('method `' + info.methodName + '` not defined');
    }
  }

  const emptyArray = [];

  // Regular expressions used for binding
  const IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
  const NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
  const SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
  const DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
  const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
  const ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
  const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
  const ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
  const BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
  const OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
  const CLOSE_BRACKET = '(?:]]|}})';
  const NEGATE = '(?:(!)\\s*)?'; // Group 2
  const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
  const bindingRegex = new RegExp(EXPRESSION, "g");

  /**
   * Create a string from binding parts of all the literal parts
   *
   * @param {!Array<BindingPart>} parts All parts to stringify
   * @return {string} String made from the literal parts
   */
  function literalFromParts(parts) {
    let s = '';
    for (let i = 0; i < parts.length; i++) {
      let literal = parts[i].literal;
      s += literal || '';
    }
    return s;
  }

  /**
   * Parses an expression string for a method signature, and returns a metadata
   * describing the method in terms of `methodName`, `static` (whether all the
   * arguments are literals), and an array of `args`
   *
   * @param {string} expression The expression to parse
   * @return {?MethodSignature} The method metadata object if a method expression was
   *   found, otherwise `undefined`
   * @private
   */
  function parseMethod(expression) {
    // tries to match valid javascript property names
    let m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
    if (m) {
      let methodName = m[1];
      let sig = { methodName, static: true, args: emptyArray };
      if (m[2].trim()) {
        // replace escaped commas with comma entity, split on un-escaped commas
        let args = m[2].replace(/\\,/g, '&comma;').split(',');
        return parseArgs(args, sig);
      } else {
        return sig;
      }
    }
    return null;
  }

  /**
   * Parses an array of arguments and sets the `args` property of the supplied
   * signature metadata object. Sets the `static` property to false if any
   * argument is a non-literal.
   *
   * @param {!Array<string>} argList Array of argument names
   * @param {!MethodSignature} sig Method signature metadata object
   * @return {!MethodSignature} The updated signature metadata object
   * @private
   */
  function parseArgs(argList, sig) {
    sig.args = argList.map(function (rawArg) {
      let arg = parseArg(rawArg);
      if (!arg.literal) {
        sig.static = false;
      }
      return arg;
    }, this);
    return sig;
  }

  /**
   * Parses an individual argument, and returns an argument metadata object
   * with the following fields:
   *
   *   {
   *     value: 'prop',        // property/path or literal value
   *     literal: false,       // whether argument is a literal
   *     structured: false,    // whether the property is a path
   *     rootProperty: 'prop', // the root property of the path
   *     wildcard: false       // whether the argument was a wildcard '.*' path
   *   }
   *
   * @param {string} rawArg The string value of the argument
   * @return {!MethodArg} Argument metadata object
   * @private
   */
  function parseArg(rawArg) {
    // clean up whitespace
    let arg = rawArg.trim()
    // replace comma entity with comma
    .replace(/&comma;/g, ',')
    // repair extra escape sequences; note only commas strictly need
    // escaping, but we allow any other char to be escaped since its
    // likely users will do this
    .replace(/\\(.)/g, '\$1');
    // basic argument descriptor
    let a = {
      name: arg,
      value: '',
      literal: false
    };
    // detect literal value (must be String or Number)
    let fc = arg[0];
    if (fc === '-') {
      fc = arg[1];
    }
    if (fc >= '0' && fc <= '9') {
      fc = '#';
    }
    switch (fc) {
      case "'":
      case '"':
        a.value = arg.slice(1, -1);
        a.literal = true;
        break;
      case '#':
        a.value = Number(arg);
        a.literal = true;
        break;
    }
    // if not literal, look for structured path
    if (!a.literal) {
      a.rootProperty = Polymer.Path.root(arg);
      // detect structured path (has dots)
      a.structured = Polymer.Path.isPath(arg);
      if (a.structured) {
        a.wildcard = arg.slice(-2) == '.*';
        if (a.wildcard) {
          a.name = arg.slice(0, -2);
        }
      }
    }
    return a;
  }

  /**
   * Gather the argument values for a method specified in the provided array
   * of argument metadata.
   *
   * The `path` and `value` arguments are used to fill in wildcard descriptor
   * when the method is being called as a result of a path notification.
   *
   * @param {Object} data Instance data storage object to read properties from
   * @param {!Array<!MethodArg>} args Array of argument metadata
   * @param {string} path Property/path name that triggered the method effect
   * @param {Object} props Bag of current property changes
   * @return {Array<*>} Array of argument values
   * @private
   */
  function marshalArgs(data, args, path, props) {
    let values = [];
    for (let i = 0, l = args.length; i < l; i++) {
      let arg = args[i];
      let name = arg.name;
      let v;
      if (arg.literal) {
        v = arg.value;
      } else {
        if (arg.structured) {
          v = Polymer.Path.get(data, name);
          // when data is not stored e.g. `splices`
          if (v === undefined) {
            v = props[name];
          }
        } else {
          v = data[name];
        }
      }
      if (arg.wildcard) {
        // Only send the actual path changed info if the change that
        // caused the observer to run matched the wildcard
        let baseChanged = name.indexOf(path + '.') === 0;
        let matches = path.indexOf(name) === 0 && !baseChanged;
        values[i] = {
          path: matches ? path : name,
          value: matches ? props[path] : v,
          base: v
        };
      } else {
        values[i] = v;
      }
    }
    return values;
  }

  // data api

  /**
   * Sends array splice notifications (`.splices` and `.length`)
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {!PropertyEffectsType} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {Array} splices Array of splice records
   * @return {void}
   * @private
   */
  function notifySplices(inst, array, path, splices) {
    let splicesPath = path + '.splices';
    inst.notifyPath(splicesPath, { indexSplices: splices });
    inst.notifyPath(path + '.length', array.length);
    // Null here to allow potentially large splice records to be GC'ed.
    inst.__data[splicesPath] = { indexSplices: null };
  }

  /**
   * Creates a splice record and sends an array splice notification for
   * the described mutation
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {!PropertyEffectsType} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {number} index Index at which the array mutation occurred
   * @param {number} addedCount Number of added items
   * @param {Array} removed Array of removed items
   * @return {void}
   * @private
   */
  function notifySplice(inst, array, path, index, addedCount, removed) {
    notifySplices(inst, array, path, [{
      index: index,
      addedCount: addedCount,
      removed: removed,
      object: array,
      type: 'splice'
    }]);
  }

  /**
   * Returns an upper-cased version of the string.
   *
   * @param {string} name String to uppercase
   * @return {string} Uppercased string
   * @private
   */
  function upper(name) {
    return name[0].toUpperCase() + name.substring(1);
  }

  /**
   * Element class mixin that provides meta-programming for Polymer's template
   * binding and data observation (collectively, "property effects") system.
   *
   * This mixin uses provides the following key static methods for adding
   * property effects to an element class:
   * - `addPropertyEffect`
   * - `createPropertyObserver`
   * - `createMethodObserver`
   * - `createNotifyingProperty`
   * - `createReadOnlyProperty`
   * - `createReflectedProperty`
   * - `createComputedProperty`
   * - `bindTemplate`
   *
   * Each method creates one or more property accessors, along with metadata
   * used by this mixin's implementation of `_propertiesChanged` to perform
   * the property effects.
   *
   * Underscored versions of the above methods also exist on the element
   * prototype for adding property effects on instances at runtime.
   *
   * Note that this mixin overrides several `PropertyAccessors` methods, in
   * many cases to maintain guarantees provided by the Polymer 1.x features;
   * notably it changes property accessors to be synchronous by default
   * whereas the default when using `PropertyAccessors` standalone is to be
   * async by default.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.TemplateStamp
   * @appliesMixin Polymer.PropertyAccessors
   * @memberof Polymer
   * @summary Element class mixin that provides meta-programming for Polymer's
   * template binding and data observation system.
   */
  Polymer.PropertyEffects = Polymer.dedupingMixin(superClass => {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_PropertyAccessors}
     * @implements {Polymer_TemplateStamp}
     * @unrestricted
     */
    const propertyEffectsBase = Polymer.TemplateStamp(Polymer.PropertyAccessors(superClass));

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyEffects}
     * @extends {propertyEffectsBase}
     * @unrestricted
     */
    class PropertyEffects extends propertyEffectsBase {

      constructor() {
        super();
        /** @type {number} */
        // NOTE: used to track re-entrant calls to `_flushProperties`
        // path changes dirty check against `__dataTemp` only during one "turn"
        // and are cleared when `__dataCounter` returns to 0.
        this.__dataCounter = 0;
        /** @type {boolean} */
        this.__dataClientsReady;
        /** @type {Array} */
        this.__dataPendingClients;
        /** @type {Object} */
        this.__dataToNotify;
        /** @type {Object} */
        this.__dataLinkedPaths;
        /** @type {boolean} */
        this.__dataHasPaths;
        /** @type {Object} */
        this.__dataCompoundStorage;
        /** @type {Polymer_PropertyEffects} */
        this.__dataHost;
        /** @type {!Object} */
        this.__dataTemp;
        /** @type {boolean} */
        this.__dataClientsInitialized;
        /** @type {!Object} */
        this.__data;
        /** @type {!Object} */
        this.__dataPending;
        /** @type {!Object} */
        this.__dataOld;
        /** @type {Object} */
        this.__computeEffects;
        /** @type {Object} */
        this.__reflectEffects;
        /** @type {Object} */
        this.__notifyEffects;
        /** @type {Object} */
        this.__propagateEffects;
        /** @type {Object} */
        this.__observeEffects;
        /** @type {Object} */
        this.__readOnly;
        /** @type {!TemplateInfo} */
        this.__templateInfo;
      }

      get PROPERTY_EFFECT_TYPES() {
        return TYPES;
      }

      /**
       * @return {void}
       */
      _initializeProperties() {
        super._initializeProperties();
        hostStack.registerHost(this);
        this.__dataClientsReady = false;
        this.__dataPendingClients = null;
        this.__dataToNotify = null;
        this.__dataLinkedPaths = null;
        this.__dataHasPaths = false;
        // May be set on instance prior to upgrade
        this.__dataCompoundStorage = this.__dataCompoundStorage || null;
        this.__dataHost = this.__dataHost || null;
        this.__dataTemp = {};
        this.__dataClientsInitialized = false;
      }

      /**
       * Overrides `Polymer.PropertyAccessors` implementation to provide a
       * more efficient implementation of initializing properties from
       * the prototype on the instance.
       *
       * @override
       * @param {Object} props Properties to initialize on the prototype
       * @return {void}
       */
      _initializeProtoProperties(props) {
        this.__data = Object.create(props);
        this.__dataPending = Object.create(props);
        this.__dataOld = {};
      }

      /**
       * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
       * `_setProperty`'s `shouldNotify: true`.
       *
       * @override
       * @param {Object} props Properties to initialize on the instance
       * @return {void}
       */
      _initializeInstanceProperties(props) {
        let readOnly = this[TYPES.READ_ONLY];
        for (let prop in props) {
          if (!readOnly || !readOnly[prop]) {
            this.__dataPending = this.__dataPending || {};
            this.__dataOld = this.__dataOld || {};
            this.__data[prop] = this.__dataPending[prop] = props[prop];
          }
        }
      }

      // Prototype setup ----------------------------------------

      /**
       * Equivalent to static `addPropertyEffect` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property that should trigger the effect
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object
       * @return {void}
       * @protected
       */
      _addPropertyEffect(property, type, effect) {
        this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
        // effects are accumulated into arrays per property based on type
        let effects = ensureOwnEffectMap(this, type)[property];
        if (!effects) {
          effects = this[type][property] = [];
        }
        effects.push(effect);
      }

      /**
       * Removes the given property effect.
       *
       * @param {string} property Property the effect was associated with
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object to remove
       * @return {void}
       */
      _removePropertyEffect(property, type, effect) {
        let effects = ensureOwnEffectMap(this, type)[property];
        let idx = effects.indexOf(effect);
        if (idx >= 0) {
          effects.splice(idx, 1);
        }
      }

      /**
       * Returns whether the current prototype/instance has a property effect
       * of a certain type.
       *
       * @param {string} property Property name
       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasPropertyEffect(property, type) {
        let effects = this[type];
        return Boolean(effects && effects[property]);
      }

      /**
       * Returns whether the current prototype/instance has a "read only"
       * accessor for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasReadOnlyEffect(property) {
        return this._hasPropertyEffect(property, TYPES.READ_ONLY);
      }

      /**
       * Returns whether the current prototype/instance has a "notify"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasNotifyEffect(property) {
        return this._hasPropertyEffect(property, TYPES.NOTIFY);
      }

      /**
       * Returns whether the current prototype/instance has a "reflect to attribute"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasReflectEffect(property) {
        return this._hasPropertyEffect(property, TYPES.REFLECT);
      }

      /**
       * Returns whether the current prototype/instance has a "computed"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasComputedEffect(property) {
        return this._hasPropertyEffect(property, TYPES.COMPUTE);
      }

      // Runtime ----------------------------------------

      /**
       * Sets a pending property or path.  If the root property of the path in
       * question had no accessor, the path is set, otherwise it is enqueued
       * via `_setPendingProperty`.
       *
       * This function isolates relatively expensive functionality necessary
       * for the public API (`set`, `setProperties`, `notifyPath`, and property
       * change listeners via {{...}} bindings), such that it is only done
       * when paths enter the system, and not at every propagation step.  It
       * also sets a `__dataHasPaths` flag on the instance which is used to
       * fast-path slower path-matching code in the property effects host paths.
       *
       * `path` can be a path string or array of path parts as accepted by the
       * public API.
       *
       * @param {string | !Array<number|string>} path Path to set
       * @param {*} value Value to set
       * @param {boolean=} shouldNotify Set to true if this change should
       *  cause a property notification event dispatch
       * @param {boolean=} isPathNotification If the path being set is a path
       *   notification of an already changed value, as opposed to a request
       *   to set and notify the change.  In the latter `false` case, a dirty
       *   check is performed and then the value is set to the path before
       *   enqueuing the pending property change.
       * @return {boolean} Returns true if the property/path was enqueued in
       *   the pending changes bag.
       * @protected
       */
      _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
        if (isPathNotification || Polymer.Path.root(Array.isArray(path) ? path[0] : path) !== path) {
          // Dirty check changes being set to a path against the actual object,
          // since this is the entry point for paths into the system; from here
          // the only dirty checks are against the `__dataTemp` cache to prevent
          // duplicate work in the same turn only. Note, if this was a notification
          // of a change already set to a path (isPathNotification: true),
          // we always let the change through and skip the `set` since it was
          // already dirty checked at the point of entry and the underlying
          // object has already been updated
          if (!isPathNotification) {
            let old = Polymer.Path.get(this, path);
            path = /** @type {string} */Polymer.Path.set(this, path, value);
            // Use property-accessor's simpler dirty check
            if (!path || !super._shouldPropertyChange(path, value, old)) {
              return false;
            }
          }
          this.__dataHasPaths = true;
          if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {
            computeLinkedPaths(this, path, value);
            return true;
          }
        } else {
          if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
            return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);
          } else {
            this[path] = value;
          }
        }
        return false;
      }

      /**
       * Applies a value to a non-Polymer element/node's property.
       *
       * The implementation makes a best-effort at binding interop:
       * Some native element properties have side-effects when
       * re-setting the same value (e.g. setting `<input>.value` resets the
       * cursor position), so we do a dirty-check before setting the value.
       * However, for better interop with non-Polymer custom elements that
       * accept objects, we explicitly re-set object changes coming from the
       * Polymer world (which may include deep object changes without the
       * top reference changing), erring on the side of providing more
       * information.
       *
       * Users may override this method to provide alternate approaches.
       *
       * @param {!Node} node The node to set a property on
       * @param {string} prop The property to set
       * @param {*} value The value to set
       * @return {void}
       * @protected
       */
      _setUnmanagedPropertyToNode(node, prop, value) {
        // It is a judgment call that resetting primitives is
        // "bad" and resettings objects is also "good"; alternatively we could
        // implement a whitelist of tag & property values that should never
        // be reset (e.g. <input>.value && <select>.value)
        if (value !== node[prop] || typeof value == 'object') {
          node[prop] = value;
        }
      }

      /**
       * Overrides the `PropertiesChanged` implementation to introduce special
       * dirty check logic depending on the property & value being set:
       *
       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
       * 2. Object set to simple property (e.g. 'prop': {...})
       *    Stored in `__dataTemp` and `__data`, dirty checked against
       *    `__dataTemp` by default implementation of `_shouldPropertyChange`
       * 3. Primitive value set to simple property (e.g. 'prop': 42)
       *    Stored in `__data`, dirty checked against `__data`
       *
       * The dirty-check is important to prevent cycles due to two-way
       * notification, but paths and objects are only dirty checked against any
       * previous value set during this turn via a "temporary cache" that is
       * cleared when the last `_propertiesChanged` exits. This is so:
       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
       *    due to array mutations like shift/unshift/splice; this is fine
       *    since path changes are dirty-checked at user entry points like `set`
       * b. dirty-checking for objects only lasts one turn to allow the user
       *    to mutate the object in-place and re-set it with the same identity
       *    and have all sub-properties re-propagated in a subsequent turn.
       *
       * The temp cache is not necessarily sufficient to prevent invalid array
       * paths, since a splice can happen during the same turn (with pathological
       * user code); we could introduce a "fixup" for temporarily cached array
       * paths if needed: https://github.com/Polymer/polymer/issues/4227
       *
       * @override
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @param {boolean=} shouldNotify True if property should fire notification
       *   event (applies only for `notify: true` properties)
       * @return {boolean} Returns true if the property changed
       */
      _setPendingProperty(property, value, shouldNotify) {
        let isPath = this.__dataHasPaths && Polymer.Path.isPath(property);
        let prevProps = isPath ? this.__dataTemp : this.__data;
        if (this._shouldPropertyChange(property, value, prevProps[property])) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          // Ensure old is captured from the last turn
          if (!(property in this.__dataOld)) {
            this.__dataOld[property] = this.__data[property];
          }
          // Paths are stored in temporary cache (cleared at end of turn),
          // which is used for dirty-checking, all others stored in __data
          if (isPath) {
            this.__dataTemp[property] = value;
          } else {
            this.__data[property] = value;
          }
          // All changes go into pending property bag, passed to _propertiesChanged
          this.__dataPending[property] = value;
          // Track properties that should notify separately
          if (isPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
            this.__dataToNotify = this.__dataToNotify || {};
            this.__dataToNotify[property] = shouldNotify;
          }
          return true;
        }
        return false;
      }

      /**
       * Overrides base implementation to ensure all accessors set `shouldNotify`
       * to true, for per-property notification tracking.
       *
       * @override
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @return {void}
       */
      _setProperty(property, value) {
        if (this._setPendingProperty(property, value, true)) {
          this._invalidateProperties();
        }
      }

      /**
       * Overrides `PropertyAccessor`'s default async queuing of
       * `_propertiesChanged`: if `__dataReady` is false (has not yet been
       * manually flushed), the function no-ops; otherwise flushes
       * `_propertiesChanged` synchronously.
       *
       * @override
       * @return {void}
       */
      _invalidateProperties() {
        if (this.__dataReady) {
          this._flushProperties();
        }
      }

      /**
       * Enqueues the given client on a list of pending clients, whose
       * pending property changes can later be flushed via a call to
       * `_flushClients`.
       *
       * @param {Object} client PropertyEffects client to enqueue
       * @return {void}
       * @protected
       */
      _enqueueClient(client) {
        this.__dataPendingClients = this.__dataPendingClients || [];
        if (client !== this) {
          this.__dataPendingClients.push(client);
        }
      }

      /**
       * Overrides superclass implementation.
       *
       * @return {void}
       * @protected
       */
      _flushProperties() {
        this.__dataCounter++;
        super._flushProperties();
        this.__dataCounter--;
      }

      /**
       * Flushes any clients previously enqueued via `_enqueueClient`, causing
       * their `_flushProperties` method to run.
       *
       * @return {void}
       * @protected
       */
      _flushClients() {
        if (!this.__dataClientsReady) {
          this.__dataClientsReady = true;
          this._readyClients();
          // Override point where accessors are turned on; importantly,
          // this is after clients have fully readied, providing a guarantee
          // that any property effects occur only after all clients are ready.
          this.__dataReady = true;
        } else {
          this.__enableOrFlushClients();
        }
      }

      // NOTE: We ensure clients either enable or flush as appropriate. This
      // handles two corner cases:
      // (1) clients flush properly when connected/enabled before the host
      // enables; e.g.
      //   (a) Templatize stamps with no properties and does not flush and
      //   (b) the instance is inserted into dom and
      //   (c) then the instance flushes.
      // (2) clients enable properly when not connected/enabled when the host
      // flushes; e.g.
      //   (a) a template is runtime stamped and not yet connected/enabled
      //   (b) a host sets a property, causing stamped dom to flush
      //   (c) the stamped dom enables.
      __enableOrFlushClients() {
        let clients = this.__dataPendingClients;
        if (clients) {
          this.__dataPendingClients = null;
          for (let i = 0; i < clients.length; i++) {
            let client = clients[i];
            if (!client.__dataEnabled) {
              client._enableProperties();
            } else if (client.__dataPending) {
              client._flushProperties();
            }
          }
        }
      }

      /**
       * Perform any initial setup on client dom. Called before the first
       * `_flushProperties` call on client dom and before any element
       * observers are called.
       *
       * @return {void}
       * @protected
       */
      _readyClients() {
        this.__enableOrFlushClients();
      }

      /**
       * Sets a bag of property changes to this instance, and
       * synchronously processes all effects of the properties as a batch.
       *
       * Property names must be simple properties, not paths.  Batched
       * path propagation is not supported.
       *
       * @param {Object} props Bag of one or more key-value pairs whose key is
       *   a property and value is the new value to set for that property.
       * @param {boolean=} setReadOnly When true, any private values set in
       *   `props` will be set. By default, `setProperties` will not set
       *   `readOnly: true` root properties.
       * @return {void}
       * @public
       */
      setProperties(props, setReadOnly) {
        for (let path in props) {
          if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
            //TODO(kschaaf): explicitly disallow paths in setProperty?
            // wildcard observers currently only pass the first changed path
            // in the `info` object, and you could do some odd things batching
            // paths, e.g. {'foo.bar': {...}, 'foo': null}
            this._setPendingPropertyOrPath(path, props[path], true);
          }
        }
        this._invalidateProperties();
      }

      /**
       * Overrides `PropertyAccessors` so that property accessor
       * side effects are not enabled until after client dom is fully ready.
       * Also calls `_flushClients` callback to ensure client dom is enabled
       * that was not enabled as a result of flushing properties.
       *
       * @override
       * @return {void}
       */
      ready() {
        // It is important that `super.ready()` is not called here as it
        // immediately turns on accessors. Instead, we wait until `readyClients`
        // to enable accessors to provide a guarantee that clients are ready
        // before processing any accessors side effects.
        this._flushProperties();
        // If no data was pending, `_flushProperties` will not `flushClients`
        // so ensure this is done.
        if (!this.__dataClientsReady) {
          this._flushClients();
        }
        // Before ready, client notifications do not trigger _flushProperties.
        // Therefore a flush is necessary here if data has been set.
        if (this.__dataPending) {
          this._flushProperties();
        }
      }

      /**
       * Implements `PropertyAccessors`'s properties changed callback.
       *
       * Runs each class of effects for the batch of changed properties in
       * a specific order (compute, propagate, reflect, observe, notify).
       *
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {!Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {!Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {void}
       */
      _propertiesChanged(currentProps, changedProps, oldProps) {
        // ----------------------------
        // let c = Object.getOwnPropertyNames(changedProps || {});
        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
        // if (window.debug) { debugger; }
        // ----------------------------
        let hasPaths = this.__dataHasPaths;
        this.__dataHasPaths = false;
        // Compute properties
        runComputedEffects(this, changedProps, oldProps, hasPaths);
        // Clear notify properties prior to possible reentry (propagate, observe),
        // but after computing effects have a chance to add to them
        let notifyProps = this.__dataToNotify;
        this.__dataToNotify = null;
        // Propagate properties to clients
        this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
        // Flush clients
        this._flushClients();
        // Reflect properties
        runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
        // Observe properties
        runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
        // Notify properties to host
        if (notifyProps) {
          runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
        }
        // Clear temporary cache at end of turn
        if (this.__dataCounter == 1) {
          this.__dataTemp = {};
        }
        // ----------------------------
        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
        // ----------------------------
      }

      /**
       * Called to propagate any property changes to stamped template nodes
       * managed by this element.
       *
       * @param {Object} changedProps Bag of changed properties
       * @param {Object} oldProps Bag of previous values for changed properties
       * @param {boolean} hasPaths True with `props` contains one or more paths
       * @return {void}
       * @protected
       */
      _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
        if (this[TYPES.PROPAGATE]) {
          runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
        }
        let templateInfo = this.__templateInfo;
        while (templateInfo) {
          runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
          templateInfo = templateInfo.nextTemplateInfo;
        }
      }

      /**
       * Aliases one data path as another, such that path notifications from one
       * are routed to the other.
       *
       * @param {string | !Array<string|number>} to Target path to link.
       * @param {string | !Array<string|number>} from Source path to link.
       * @return {void}
       * @public
       */
      linkPaths(to, from) {
        to = Polymer.Path.normalize(to);
        from = Polymer.Path.normalize(from);
        this.__dataLinkedPaths = this.__dataLinkedPaths || {};
        this.__dataLinkedPaths[to] = from;
      }

      /**
       * Removes a data path alias previously established with `_linkPaths`.
       *
       * Note, the path to unlink should be the target (`to`) used when
       * linking the paths.
       *
       * @param {string | !Array<string|number>} path Target path to unlink.
       * @return {void}
       * @public
       */
      unlinkPaths(path) {
        path = Polymer.Path.normalize(path);
        if (this.__dataLinkedPaths) {
          delete this.__dataLinkedPaths[path];
        }
      }

      /**
       * Notify that an array has changed.
       *
       * Example:
       *
       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
       *     ...
       *     this.items.splice(1, 1, {name: 'Sam'});
       *     this.items.push({name: 'Bob'});
       *     this.notifySplices('items', [
       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, object: this.items, type: 'splice' },
       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
       *     ]);
       *
       * @param {string} path Path that should be notified.
       * @param {Array} splices Array of splice records indicating ordered
       *   changes that occurred to the array. Each record should have the
       *   following fields:
       *    * index: index at which the change occurred
       *    * removed: array of items that were removed from this index
       *    * addedCount: number of new items added at this index
       *    * object: a reference to the array in question
       *    * type: the string literal 'splice'
       *
       *   Note that splice records _must_ be normalized such that they are
       *   reported in index order (raw results from `Object.observe` are not
       *   ordered and must be normalized/merged before notifying).
       * @return {void}
       * @public
      */
      notifySplices(path, splices) {
        let info = { path: '' };
        let array = /** @type {Array} */Polymer.Path.get(this, path, info);
        notifySplices(this, array, info.path, splices);
      }

      /**
       * Convenience method for reading a value from a path.
       *
       * Note, if any part in the path is undefined, this method returns
       * `undefined` (this method does not throw when dereferencing undefined
       * paths).
       *
       * @param {(string|!Array<(string|number)>)} path Path to the value
       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `users.12.name` or `['users', 12, 'name']`).
       * @param {Object=} root Root object from which the path is evaluated.
       * @return {*} Value at the path, or `undefined` if any part of the path
       *   is undefined.
       * @public
       */
      get(path, root) {
        return Polymer.Path.get(root || this, path);
      }

      /**
       * Convenience method for setting a value to a path and notifying any
       * elements bound to the same path.
       *
       * Note, if any part in the path except for the last is undefined,
       * this method does nothing (this method does not throw when
       * dereferencing undefined paths).
       *
       * @param {(string|!Array<(string|number)>)} path Path to the value
       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
       * @param {*} value Value to set at the specified path.
       * @param {Object=} root Root object from which the path is evaluated.
       *   When specified, no notification will occur.
       * @return {void}
       * @public
      */
      set(path, value, root) {
        if (root) {
          Polymer.Path.set(root, path, value);
        } else {
          if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */path]) {
            if (this._setPendingPropertyOrPath(path, value, true)) {
              this._invalidateProperties();
            }
          }
        }
      }

      /**
       * Adds items onto the end of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @param {...*} items Items to push onto array
       * @return {number} New length of the array.
       * @public
       */
      push(path, ...items) {
        let info = { path: '' };
        let array = /** @type {Array}*/Polymer.Path.get(this, path, info);
        let len = array.length;
        let ret = array.push(...items);
        if (items.length) {
          notifySplice(this, array, info.path, len, items.length, []);
        }
        return ret;
      }

      /**
       * Removes an item from the end of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @return {*} Item that was removed.
       * @public
       */
      pop(path) {
        let info = { path: '' };
        let array = /** @type {Array} */Polymer.Path.get(this, path, info);
        let hadLength = Boolean(array.length);
        let ret = array.pop();
        if (hadLength) {
          notifySplice(this, array, info.path, array.length, 0, [ret]);
        }
        return ret;
      }

      /**
       * Starting from the start index specified, removes 0 or more items
       * from the array and inserts 0 or more new items in their place.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.splice`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @param {number} start Index from which to start removing/inserting.
       * @param {number} deleteCount Number of items to remove.
       * @param {...*} items Items to insert into array.
       * @return {Array} Array of removed items.
       * @public
       */
      splice(path, start, deleteCount, ...items) {
        let info = { path: '' };
        let array = /** @type {Array} */Polymer.Path.get(this, path, info);
        // Normalize fancy native splice handling of crazy start values
        if (start < 0) {
          start = array.length - Math.floor(-start);
        } else if (start) {
          start = Math.floor(start);
        }
        // array.splice does different things based on the number of arguments
        // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)
        // do different things. In the former, the whole array is cleared. In the
        // latter, no items are removed.
        // This means that we need to detect whether 1. one of the arguments
        // is actually passed in and then 2. determine how many arguments
        // we should pass on to the native array.splice
        //
        let ret;
        // Omit any additional arguments if they were not passed in
        if (arguments.length === 2) {
          ret = array.splice(start);
          // Either start was undefined and the others were defined, but in this
          // case we can safely pass on all arguments
          //
          // Note: this includes the case where none of the arguments were passed in,
          // e.g. this.splice('array'). However, if both start and deleteCount
          // are undefined, array.splice will not modify the array (as expected)
        } else {
          ret = array.splice(start, deleteCount, ...items);
        }
        // At the end, check whether any items were passed in (e.g. insertions)
        // or if the return array contains items (e.g. deletions).
        // Only notify if items were added or deleted.
        if (items.length || ret.length) {
          notifySplice(this, array, info.path, start, items.length, ret);
        }
        return ret;
      }

      /**
       * Removes an item from the beginning of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @return {*} Item that was removed.
       * @public
       */
      shift(path) {
        let info = { path: '' };
        let array = /** @type {Array} */Polymer.Path.get(this, path, info);
        let hadLength = Boolean(array.length);
        let ret = array.shift();
        if (hadLength) {
          notifySplice(this, array, info.path, 0, 0, [ret]);
        }
        return ret;
      }

      /**
       * Adds items onto the beginning of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @param {string | !Array<string|number>} path Path to array.
       * @param {...*} items Items to insert info array
       * @return {number} New length of the array.
       * @public
       */
      unshift(path, ...items) {
        let info = { path: '' };
        let array = /** @type {Array} */Polymer.Path.get(this, path, info);
        let ret = array.unshift(...items);
        if (items.length) {
          notifySplice(this, array, info.path, 0, items.length, []);
        }
        return ret;
      }

      /**
       * Notify that a path has changed.
       *
       * Example:
       *
       *     this.item.user.name = 'Bob';
       *     this.notifyPath('item.user.name');
       *
       * @param {string} path Path that should be notified.
       * @param {*=} value Value at the path (optional).
       * @return {void}
       * @public
      */
      notifyPath(path, value) {
        /** @type {string} */
        let propPath;
        if (arguments.length == 1) {
          // Get value if not supplied
          let info = { path: '' };
          value = Polymer.Path.get(this, path, info);
          propPath = info.path;
        } else if (Array.isArray(path)) {
          // Normalize path if needed
          propPath = Polymer.Path.normalize(path);
        } else {
          propPath = /** @type{string} */path;
        }
        if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
          this._invalidateProperties();
        }
      }

      /**
       * Equivalent to static `createReadOnlyProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @param {boolean=} protectedSetter Creates a custom protected setter
       *   when `true`.
       * @return {void}
       * @protected
       */
      _createReadOnlyProperty(property, protectedSetter) {
        this._addPropertyEffect(property, TYPES.READ_ONLY);
        if (protectedSetter) {
          this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {
            this._setProperty(property, value);
          };
        }
      }

      /**
       * Equivalent to static `createPropertyObserver` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @param {string|function(*,*)} method Function or name of observer method to call
       * @param {boolean=} dynamicFn Whether the method name should be included as
       *   a dependency to the effect.
       * @return {void}
       * @protected
       */
      _createPropertyObserver(property, method, dynamicFn) {
        let info = { property, method, dynamicFn: Boolean(dynamicFn) };
        this._addPropertyEffect(property, TYPES.OBSERVE, {
          fn: runObserverEffect, info, trigger: { name: property }
        });
        if (dynamicFn) {
          this._addPropertyEffect( /** @type {string} */method, TYPES.OBSERVE, {
            fn: runObserverEffect, info, trigger: { name: method }
          });
        }
      }

      /**
       * Equivalent to static `createMethodObserver` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @return {void}
       * @protected
       */
      _createMethodObserver(expression, dynamicFn) {
        let sig = parseMethod(expression);
        if (!sig) {
          throw new Error("Malformed observer expression '" + expression + "'");
        }
        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
      }

      /**
       * Equivalent to static `createNotifyingProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @return {void}
       * @protected
       */
      _createNotifyingProperty(property) {
        this._addPropertyEffect(property, TYPES.NOTIFY, {
          fn: runNotifyEffect,
          info: {
            eventName: CaseMap.camelToDashCase(property) + '-changed',
            property: property
          }
        });
      }

      /**
       * Equivalent to static `createReflectedProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Property name
       * @return {void}
       * @protected
       */
      _createReflectedProperty(property) {
        let attr = this.constructor.attributeNameForProperty(property);
        if (attr[0] === '-') {
          console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');
        } else {
          this._addPropertyEffect(property, TYPES.REFLECT, {
            fn: runReflectEffect,
            info: {
              attrName: attr
            }
          });
        }
      }

      /**
       * Equivalent to static `createComputedProperty` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * @param {string} property Name of computed property to set
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       *   whether method names should be included as a dependency to the effect.
       * @return {void}
       * @protected
       */
      _createComputedProperty(property, expression, dynamicFn) {
        let sig = parseMethod(expression);
        if (!sig) {
          throw new Error("Malformed computed expression '" + expression + "'");
        }
        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
      }

      // -- static class methods ------------

      /**
       * Ensures an accessor exists for the specified property, and adds
       * to a list of "property effects" that will run when the accessor for
       * the specified property is set.  Effects are grouped by "type", which
       * roughly corresponds to a phase in effect processing.  The effect
       * metadata should be in the following form:
       *
       *     {
       *       fn: effectFunction, // Reference to function to call to perform effect
       *       info: { ... }       // Effect metadata passed to function
       *       trigger: {          // Optional triggering metadata; if not provided
       *         name: string      // the property is treated as a wildcard
       *         structured: boolean
       *         wildcard: boolean
       *       }
       *     }
       *
       * Effects are called from `_propertiesChanged` in the following order by
       * type:
       *
       * 1. COMPUTE
       * 2. PROPAGATE
       * 3. REFLECT
       * 4. OBSERVE
       * 5. NOTIFY
       *
       * Effect functions are called with the following signature:
       *
       *     effectFunction(inst, path, props, oldProps, info, hasPaths)
       *
       * @param {string} property Property that should trigger the effect
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object=} effect Effect metadata object
       * @return {void}
       * @protected
       */
      static addPropertyEffect(property, type, effect) {
        this.prototype._addPropertyEffect(property, type, effect);
      }

      /**
       * Creates a single-property observer for the given property.
       *
       * @param {string} property Property name
       * @param {string|function(*,*)} method Function or name of observer method to call
       * @param {boolean=} dynamicFn Whether the method name should be included as
       *   a dependency to the effect.
       * @return {void}
       * @protected
       */
      static createPropertyObserver(property, method, dynamicFn) {
        this.prototype._createPropertyObserver(property, method, dynamicFn);
      }

      /**
       * Creates a multi-property "method observer" based on the provided
       * expression, which should be a string in the form of a normal JavaScript
       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
       * should correspond to a property or path in the context of this
       * prototype (or instance), or may be a literal string or number.
       *
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating
       * @return {void}
       *   whether method names should be included as a dependency to the effect.
       * @protected
       */
      static createMethodObserver(expression, dynamicFn) {
        this.prototype._createMethodObserver(expression, dynamicFn);
      }

      /**
       * Causes the setter for the given property to dispatch `<property>-changed`
       * events to notify of changes to the property.
       *
       * @param {string} property Property name
       * @return {void}
       * @protected
       */
      static createNotifyingProperty(property) {
        this.prototype._createNotifyingProperty(property);
      }

      /**
       * Creates a read-only accessor for the given property.
       *
       * To set the property, use the protected `_setProperty` API.
       * To create a custom protected setter (e.g. `_setMyProp()` for
       * property `myProp`), pass `true` for `protectedSetter`.
       *
       * Note, if the property will have other property effects, this method
       * should be called first, before adding other effects.
       *
       * @param {string} property Property name
       * @param {boolean=} protectedSetter Creates a custom protected setter
       *   when `true`.
       * @return {void}
       * @protected
       */
      static createReadOnlyProperty(property, protectedSetter) {
        this.prototype._createReadOnlyProperty(property, protectedSetter);
      }

      /**
       * Causes the setter for the given property to reflect the property value
       * to a (dash-cased) attribute of the same name.
       *
       * @param {string} property Property name
       * @return {void}
       * @protected
       */
      static createReflectedProperty(property) {
        this.prototype._createReflectedProperty(property);
      }

      /**
       * Creates a computed property whose value is set to the result of the
       * method described by the given `expression` each time one or more
       * arguments to the method changes.  The expression should be a string
       * in the form of a normal JavaScript function signature:
       * `'methodName(arg1, [..., argn])'`
       *
       * @param {string} property Name of computed property to set
       * @param {string} expression Method expression
       * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
       *   method names should be included as a dependency to the effect.
       * @return {void}
       * @protected
       */
      static createComputedProperty(property, expression, dynamicFn) {
        this.prototype._createComputedProperty(property, expression, dynamicFn);
      }

      /**
       * Parses the provided template to ensure binding effects are created
       * for them, and then ensures property accessors are created for any
       * dependent properties in the template.  Binding effects for bound
       * templates are stored in a linked list on the instance so that
       * templates can be efficiently stamped and unstamped.
       *
       * @param {!HTMLTemplateElement} template Template containing binding
       *   bindings
       * @return {!TemplateInfo} Template metadata object
       * @protected
       */
      static bindTemplate(template) {
        return this.prototype._bindTemplate(template);
      }

      // -- binding ----------------------------------------------

      /**
       * Equivalent to static `bindTemplate` API but can be called on
       * an instance to add effects at runtime.  See that method for
       * full API docs.
       *
       * This method may be called on the prototype (for prototypical template
       * binding, to avoid creating accessors every instance) once per prototype,
       * and will be called with `runtimeBinding: true` by `_stampTemplate` to
       * create and link an instance of the template metadata associated with a
       * particular stamping.
       *
       * @param {!HTMLTemplateElement} template Template containing binding
       *   bindings
       * @param {boolean=} instanceBinding When false (default), performs
       *   "prototypical" binding of the template and overwrites any previously
       *   bound template for the class. When true (as passed from
       *   `_stampTemplate`), the template info is instanced and linked into
       *   the list of bound templates.
       * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
       *   this is an instance of the prototypical template info
       * @protected
       */
      _bindTemplate(template, instanceBinding) {
        let templateInfo = this.constructor._parseTemplate(template);
        let wasPreBound = this.__templateInfo == templateInfo;
        // Optimization: since this is called twice for proto-bound templates,
        // don't attempt to recreate accessors if this template was pre-bound
        if (!wasPreBound) {
          for (let prop in templateInfo.propertyEffects) {
            this._createPropertyAccessor(prop);
          }
        }
        if (instanceBinding) {
          // For instance-time binding, create instance of template metadata
          // and link into list of templates if necessary
          templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);
          templateInfo.wasPreBound = wasPreBound;
          if (!wasPreBound && this.__templateInfo) {
            let last = this.__templateInfoLast || this.__templateInfo;
            this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
            templateInfo.previousTemplateInfo = last;
            return templateInfo;
          }
        }
        return this.__templateInfo = templateInfo;
      }

      /**
       * Adds a property effect to the given template metadata, which is run
       * at the "propagate" stage of `_propertiesChanged` when the template
       * has been bound to the element via `_bindTemplate`.
       *
       * The `effect` object should match the format in `_addPropertyEffect`.
       *
       * @param {Object} templateInfo Template metadata to add effect to
       * @param {string} prop Property that should trigger the effect
       * @param {Object=} effect Effect metadata object
       * @return {void}
       * @protected
       */
      static _addTemplatePropertyEffect(templateInfo, prop, effect) {
        let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
        hostProps[prop] = true;
        let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
        let propEffects = effects[prop] = effects[prop] || [];
        propEffects.push(effect);
      }

      /**
       * Stamps the provided template and performs instance-time setup for
       * Polymer template features, including data bindings, declarative event
       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
       * is returned containing the stamped DOM, ready for insertion into the
       * DOM.
       *
       * This method may be called more than once; however note that due to
       * `shadycss` polyfill limitations, only styles from templates prepared
       * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
       * to the shadow root and support CSS custom properties), and note that
       * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
       * any styles required by in runtime-stamped templates must be included
       * in the main element template.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @return {!StampedTemplate} Cloned template content
       * @override
       * @protected
       */
      _stampTemplate(template) {
        // Ensures that created dom is `_enqueueClient`'d to this element so
        // that it can be flushed on next call to `_flushProperties`
        hostStack.beginHosting(this);
        let dom = super._stampTemplate(template);
        hostStack.endHosting(this);
        let templateInfo = /** @type {!TemplateInfo} */this._bindTemplate(template, true);
        // Add template-instance-specific data to instanced templateInfo
        templateInfo.nodeList = dom.nodeList;
        // Capture child nodes to allow unstamping of non-prototypical templates
        if (!templateInfo.wasPreBound) {
          let nodes = templateInfo.childNodes = [];
          for (let n = dom.firstChild; n; n = n.nextSibling) {
            nodes.push(n);
          }
        }
        dom.templateInfo = templateInfo;
        // Setup compound storage, 2-way listeners, and dataHost for bindings
        setupBindings(this, templateInfo);
        // Flush properties into template nodes if already booted
        if (this.__dataReady) {
          runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);
        }
        return dom;
      }

      /**
       * Removes and unbinds the nodes previously contained in the provided
       * DocumentFragment returned from `_stampTemplate`.
       *
       * @param {!StampedTemplate} dom DocumentFragment previously returned
       *   from `_stampTemplate` associated with the nodes to be removed
       * @return {void}
       * @protected
       */
      _removeBoundDom(dom) {
        // Unlink template info
        let templateInfo = dom.templateInfo;
        if (templateInfo.previousTemplateInfo) {
          templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;
        }
        if (templateInfo.nextTemplateInfo) {
          templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;
        }
        if (this.__templateInfoLast == templateInfo) {
          this.__templateInfoLast = templateInfo.previousTemplateInfo;
        }
        templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
        // Remove stamped nodes
        let nodes = templateInfo.childNodes;
        for (let i = 0; i < nodes.length; i++) {
          let node = nodes[i];
          node.parentNode.removeChild(node);
        }
      }

      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
       * array is added to `nodeInfo` and populated with binding metadata
       * with information capturing the binding target, and a `parts` array
       * with one or more metadata objects capturing the source(s) of the
       * binding.
       *
       * @override
       * @param {Node} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */
      static _parseTemplateNode(node, templateInfo, nodeInfo) {
        let noted = super._parseTemplateNode(node, templateInfo, nodeInfo);
        if (node.nodeType === Node.TEXT_NODE) {
          let parts = this._parseBindings(node.textContent, templateInfo);
          if (parts) {
            // Initialize the textContent with any literal parts
            // NOTE: default to a space here so the textNode remains; some browsers
            // (IE) omit an empty textNode following cloneNode/importNode.
            node.textContent = literalFromParts(parts) || ' ';
            addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
            noted = true;
          }
        }
        return noted;
      }

      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * parsing bindings from attributes.  A `bindings`
       * array is added to `nodeInfo` and populated with binding metadata
       * with information capturing the binding target, and a `parts` array
       * with one or more metadata objects capturing the source(s) of the
       * binding.
       *
       * @override
       * @param {Element} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @param {string} name Attribute name
       * @param {string} value Attribute value
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */
      static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
        let parts = this._parseBindings(value, templateInfo);
        if (parts) {
          // Attribute or property
          let origName = name;
          let kind = 'property';
          if (name[name.length - 1] == '$') {
            name = name.slice(0, -1);
            kind = 'attribute';
          }
          // Initialize attribute bindings with any literal parts
          let literal = literalFromParts(parts);
          if (literal && kind == 'attribute') {
            node.setAttribute(name, literal);
          }
          // Clear attribute before removing, since IE won't allow removing
          // `value` attribute if it previously had a value (can't
          // unconditionally set '' before removing since attributes with `$`
          // can't be set using setAttribute)
          if (node.localName === 'input' && origName === 'value') {
            node.setAttribute(origName, '');
          }
          // Remove annotation
          node.removeAttribute(origName);
          // Case hackery: attributes are lower-case, but bind targets
          // (properties) are case sensitive. Gambit is to map dash-case to
          // camel-case: `foo-bar` becomes `fooBar`.
          // Attribute bindings are excepted.
          if (kind === 'property') {
            name = Polymer.CaseMap.dashToCamelCase(name);
          }
          addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
          return true;
        } else {
          return super._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value);
        }
      }

      /**
       * Overrides default `TemplateStamp` implementation to add support for
       * binding the properties that a nested template depends on to the template
       * as `_host_<property>`.
       *
       * @override
       * @param {Node} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template node
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @protected
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */
      static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
        let noted = super._parseTemplateNestedTemplate(node, templateInfo, nodeInfo);
        // Merge host props into outer template and add bindings
        let hostProps = nodeInfo.templateInfo.hostProps;
        let mode = '{';
        for (let source in hostProps) {
          let parts = [{ mode, source, dependencies: [source] }];
          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
        }
        return noted;
      }

      /**
       * Called to parse text in a template (either attribute values or
       * textContent) into binding metadata.
       *
       * Any overrides of this method should return an array of binding part
       * metadata  representing one or more bindings found in the provided text
       * and any "literal" text in between.  Any non-literal parts will be passed
       * to `_evaluateBinding` when any dependencies change.  The only required
       * fields of each "part" in the returned array are as follows:
       *
       * - `dependencies` - Array containing trigger metadata for each property
       *   that should trigger the binding to update
       * - `literal` - String containing text if the part represents a literal;
       *   in this case no `dependencies` are needed
       *
       * Additional metadata for use by `_evaluateBinding` may be provided in
       * each part object as needed.
       *
       * The default implementation handles the following types of bindings
       * (one or more may be intermixed with literal strings):
       * - Property binding: `[[prop]]`
       * - Path binding: `[[object.prop]]`
       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
       * - Two-way property or path bindings (supports negation):
       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
       * - Inline computed method (supports negation):
       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
       *
       * @param {string} text Text to parse from attribute or textContent
       * @param {Object} templateInfo Current template metadata
       * @return {Array<!BindingPart>} Array of binding part metadata
       * @protected
       */
      static _parseBindings(text, templateInfo) {
        let parts = [];
        let lastIndex = 0;
        let m;
        // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
        // Regex matches:
        //        Iteration 1:  Iteration 2:
        // m[1]: '{{'          '[['
        // m[2]: ''            '!'
        // m[3]: 'prop'        'compute(foo,bar)'
        while ((m = bindingRegex.exec(text)) !== null) {
          // Add literal part
          if (m.index > lastIndex) {
            parts.push({ literal: text.slice(lastIndex, m.index) });
          }
          // Add binding part
          let mode = m[1][0];
          let negate = Boolean(m[2]);
          let source = m[3].trim();
          let customEvent = false,
              notifyEvent = '',
              colon = -1;
          if (mode == '{' && (colon = source.indexOf('::')) > 0) {
            notifyEvent = source.substring(colon + 2);
            source = source.substring(0, colon);
            customEvent = true;
          }
          let signature = parseMethod(source);
          let dependencies = [];
          if (signature) {
            // Inline computed function
            let { args, methodName } = signature;
            for (let i = 0; i < args.length; i++) {
              let arg = args[i];
              if (!arg.literal) {
                dependencies.push(arg);
              }
            }
            let dynamicFns = templateInfo.dynamicFns;
            if (dynamicFns && dynamicFns[methodName] || signature.static) {
              dependencies.push(methodName);
              signature.dynamicFn = true;
            }
          } else {
            // Property or path
            dependencies.push(source);
          }
          parts.push({
            source, mode, negate, customEvent, signature, dependencies,
            event: notifyEvent
          });
          lastIndex = bindingRegex.lastIndex;
        }
        // Add a final literal part
        if (lastIndex && lastIndex < text.length) {
          let literal = text.substring(lastIndex);
          if (literal) {
            parts.push({
              literal: literal
            });
          }
        }
        if (parts.length) {
          return parts;
        } else {
          return null;
        }
      }

      /**
       * Called to evaluate a previously parsed binding part based on a set of
       * one or more changed dependencies.
       *
       * @param {this} inst Element that should be used as scope for
       *   binding dependencies
       * @param {BindingPart} part Binding part metadata
       * @param {string} path Property/path that triggered this effect
       * @param {Object} props Bag of current property changes
       * @param {Object} oldProps Bag of previous values for changed properties
       * @param {boolean} hasPaths True with `props` contains one or more paths
       * @return {*} Value the binding part evaluated to
       * @protected
       */
      static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
        let value;
        if (part.signature) {
          value = runMethodEffect(inst, path, props, oldProps, part.signature);
        } else if (path != part.source) {
          value = Polymer.Path.get(inst, part.source);
        } else {
          if (hasPaths && Polymer.Path.isPath(path)) {
            value = Polymer.Path.get(inst, path);
          } else {
            value = inst.__data[path];
          }
        }
        if (part.negate) {
          value = !value;
        }
        return value;
      }

    }

    // make a typing for closure :P
    PropertyEffectsType = PropertyEffects;

    return PropertyEffects;
  });

  /**
   * Helper api for enqueuing client dom created by a host element.
   *
   * By default elements are flushed via `_flushProperties` when
   * `connectedCallback` is called. Elements attach their client dom to
   * themselves at `ready` time which results from this first flush.
   * This provides an ordering guarantee that the client dom an element
   * creates is flushed before the element itself (i.e. client `ready`
   * fires before host `ready`).
   *
   * However, if `_flushProperties` is called *before* an element is connected,
   * as for example `Templatize` does, this ordering guarantee cannot be
   * satisfied because no elements are connected. (Note: Bound elements that
   * receive data do become enqueued clients and are properly ordered but
   * unbound elements are not.)
   *
   * To maintain the desired "client before host" ordering guarantee for this
   * case we rely on the "host stack. Client nodes registers themselves with
   * the creating host element when created. This ensures that all client dom
   * is readied in the proper order, maintaining the desired guarantee.
   *
   * @private
   */
  let hostStack = {

    stack: [],

    /**
     * @param {*} inst Instance to add to hostStack
     * @return {void}
     * @this {hostStack}
     */
    registerHost(inst) {
      if (this.stack.length) {
        let host = this.stack[this.stack.length - 1];
        host._enqueueClient(inst);
      }
    },

    /**
     * @param {*} inst Instance to begin hosting
     * @return {void}
     * @this {hostStack}
     */
    beginHosting(inst) {
      this.stack.push(inst);
    },

    /**
     * @param {*} inst Instance to end hosting
     * @return {void}
     * @this {hostStack}
     */
    endHosting(inst) {
      let stackLen = this.stack.length;
      if (stackLen && this.stack[stackLen - 1] == inst) {
        this.stack.pop();
      }
    }

  };
})();

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(1);

__webpack_require__(6);

(function () {
  'use strict';

  /**
   * @summary Collapse multiple callbacks into one invocation after a timer.
   * @memberof Polymer
   */

  class Debouncer {
    constructor() {
      this._asyncModule = null;
      this._callback = null;
      this._timer = null;
    }
    /**
     * Sets the scheduler; that is, a module with the Async interface,
     * a callback and optional arguments to be passed to the run function
     * from the async module.
     *
     * @param {!AsyncInterface} asyncModule Object with Async interface.
     * @param {function()} callback Callback to run.
     * @return {void}
     */
    setConfig(asyncModule, callback) {
      this._asyncModule = asyncModule;
      this._callback = callback;
      this._timer = this._asyncModule.run(() => {
        this._timer = null;
        this._callback();
      });
    }
    /**
     * Cancels an active debouncer and returns a reference to itself.
     *
     * @return {void}
     */
    cancel() {
      if (this.isActive()) {
        this._asyncModule.cancel(this._timer);
        this._timer = null;
      }
    }
    /**
     * Flushes an active debouncer and returns a reference to itself.
     *
     * @return {void}
     */
    flush() {
      if (this.isActive()) {
        this.cancel();
        this._callback();
      }
    }
    /**
     * Returns true if the debouncer is active.
     *
     * @return {boolean} True if active.
     */
    isActive() {
      return this._timer != null;
    }
    /**
     * Creates a debouncer if no debouncer is passed as a parameter
     * or it cancels an active debouncer otherwise. The following
     * example shows how a debouncer can be called multiple times within a
     * microtask and "debounced" such that the provided callback function is
     * called once. Add this method to a custom element:
     *
     * _debounceWork() {
     *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,
     *       Polymer.Async.microTask, () => {
     *     this._doWork();
     *   });
     * }
     *
     * If the `_debounceWork` method is called multiple times within the same
     * microtask, the `_doWork` function will be called only once at the next
     * microtask checkpoint.
     *
     * Note: In testing it is often convenient to avoid asynchrony. To accomplish
     * this with a debouncer, you can use `Polymer.enqueueDebouncer` and
     * `Polymer.flush`. For example, extend the above example by adding
     * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the
     * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure
     * the debouncer has completed.
     *
     * @param {Debouncer?} debouncer Debouncer object.
     * @param {!AsyncInterface} asyncModule Object with Async interface
     * @param {function()} callback Callback to run.
     * @return {!Debouncer} Returns a debouncer object.
     */
    static debounce(debouncer, asyncModule, callback) {
      if (debouncer instanceof Debouncer) {
        debouncer.cancel();
      } else {
        debouncer = new Debouncer();
      }
      debouncer.setConfig(asyncModule, callback);
      return debouncer;
    }
  }

  Polymer.Debouncer = Debouncer;
})();

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

(function () {
  'use strict';

  let debouncerQueue = [];

  /**
   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.
   *
   * @memberof Polymer
   * @param {!Polymer.Debouncer} debouncer Debouncer to enqueue
   * @return {void}
   */
  Polymer.enqueueDebouncer = function (debouncer) {
    debouncerQueue.push(debouncer);
  };

  function flushDebouncers() {
    const didFlush = Boolean(debouncerQueue.length);
    while (debouncerQueue.length) {
      try {
        debouncerQueue.shift().flush();
      } catch (e) {
        setTimeout(() => {
          throw e;
        });
      }
    }
    return didFlush;
  }

  /**
   * Forces several classes of asynchronously queued tasks to flush:
   * - Debouncers added via `enqueueDebouncer`
   * - ShadyDOM distribution
   *
   * @memberof Polymer
   * @return {void}
   */
  Polymer.flush = function () {
    let shadyDOM, debouncers;
    do {
      shadyDOM = window.ShadyDOM && ShadyDOM.flush();
      if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
        window.ShadyCSS.ScopingShim.flush();
      }
      debouncers = flushDebouncers();
    } while (shadyDOM || debouncers);
  };
})();

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(9);

__webpack_require__(7);

(function () {
  'use strict';

  // Base class for HTMLTemplateElement extension that has property effects
  // machinery for propagating host properties to children. This is an ES5
  // class only because Babel (incorrectly) requires super() in the class
  // constructor even though no `this` is used and it returns an instance.

  let newInstance = null;
  /**
   * @constructor
   * @extends {HTMLTemplateElement}
   */
  function HTMLTemplateElementExtension() {
    return newInstance;
  }
  HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
    constructor: {
      value: HTMLTemplateElementExtension,
      writable: true
    }
  });
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   * @extends {HTMLTemplateElementExtension}
   */
  const DataTemplate = Polymer.PropertyEffects(HTMLTemplateElementExtension);
  /**
   * @constructor
   * @implements {Polymer_MutableData}
   * @extends {DataTemplate}
   */
  const MutableDataTemplate = Polymer.MutableData(DataTemplate);

  // Applies a DataTemplate subclass to a <template> instance
  function upgradeTemplate(template, constructor) {
    newInstance = template;
    Object.setPrototypeOf(template, constructor.prototype);
    new constructor();
    newInstance = null;
  }

  // Base class for TemplateInstance's
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   */
  const base = Polymer.PropertyEffects(class {});

  /**
   * @polymer
   * @customElement
   * @appliesMixin Polymer.PropertyEffects
   * @unrestricted
   */
  class TemplateInstanceBase extends base {
    constructor(props) {
      super();
      this._configureProperties(props);
      this.root = this._stampTemplate(this.__dataHost);
      // Save list of stamped children
      let children = this.children = [];
      for (let n = this.root.firstChild; n; n = n.nextSibling) {
        children.push(n);
        n.__templatizeInstance = this;
      }
      if (this.__templatizeOwner && this.__templatizeOwner.__hideTemplateChildren__) {
        this._showHideChildren(true);
      }
      // Flush props only when props are passed if instance props exist
      // or when there isn't instance props.
      let options = this.__templatizeOptions;
      if (props && options.instanceProps || !options.instanceProps) {
        this._enableProperties();
      }
    }
    /**
     * Configure the given `props` by calling `_setPendingProperty`. Also
     * sets any properties stored in `__hostProps`.
     * @private
     * @param {Object} props Object of property name-value pairs to set.
     * @return {void}
     */
    _configureProperties(props) {
      let options = this.__templatizeOptions;
      if (options.forwardHostProp) {
        for (let hprop in this.__hostProps) {
          this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
        }
      }
      // Any instance props passed in the constructor will overwrite host props;
      // normally this would be a user error but we don't specifically filter them
      for (let iprop in props) {
        this._setPendingProperty(iprop, props[iprop]);
      }
    }
    /**
     * Forwards a host property to this instance.  This method should be
     * called on instances from the `options.forwardHostProp` callback
     * to propagate changes of host properties to each instance.
     *
     * Note this method enqueues the change, which are flushed as a batch.
     *
     * @param {string} prop Property or path name
     * @param {*} value Value of the property to forward
     * @return {void}
     */
    forwardHostProp(prop, value) {
      if (this._setPendingPropertyOrPath(prop, value, false, true)) {
        this.__dataHost._enqueueClient(this);
      }
    }

    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {!Node} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {function(!Event):void} handler Listener function to add
     * @return {void}
     */
    _addEventListenerToNode(node, eventName, handler) {
      if (this._methodHost && this.__templatizeOptions.parentModel) {
        // If this instance should be considered a parent model, decorate
        // events this template instance as `model`
        this._methodHost._addEventListenerToNode(node, eventName, e => {
          e.model = this;
          handler(e);
        });
      } else {
        // Otherwise delegate to the template's host (which could be)
        // another template instance
        let templateHost = this.__dataHost.__dataHost;
        if (templateHost) {
          templateHost._addEventListenerToNode(node, eventName, handler);
        }
      }
    }
    /**
     * Shows or hides the template instance top level child elements. For
     * text nodes, `textContent` is removed while "hidden" and replaced when
     * "shown."
     * @param {boolean} hide Set to true to hide the children;
     * set to false to show them.
     * @return {void}
     * @protected
     */
    _showHideChildren(hide) {
      let c = this.children;
      for (let i = 0; i < c.length; i++) {
        let n = c[i];
        // Ignore non-changes
        if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
          if (n.nodeType === Node.TEXT_NODE) {
            if (hide) {
              n.__polymerTextContent__ = n.textContent;
              n.textContent = '';
            } else {
              n.textContent = n.__polymerTextContent__;
            }
            // remove and replace slot
          } else if (n.localName === 'slot') {
            if (hide) {
              n.__polymerReplaced__ = document.createComment('hidden-slot');
              n.parentNode.replaceChild(n.__polymerReplaced__, n);
            } else {
              const replace = n.__polymerReplaced__;
              if (replace) {
                replace.parentNode.replaceChild(n, replace);
              }
            }
          } else if (n.style) {
            if (hide) {
              n.__polymerDisplay__ = n.style.display;
              n.style.display = 'none';
            } else {
              n.style.display = n.__polymerDisplay__;
            }
          }
        }
        n.__hideTemplateChildren__ = hide;
        if (n._showHideChildren) {
          n._showHideChildren(hide);
        }
      }
    }
    /**
     * Overrides default property-effects implementation to intercept
     * textContent bindings while children are "hidden" and cache in
     * private storage for later retrieval.
     *
     * @param {!Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @return {void}
     * @protected
     */
    _setUnmanagedPropertyToNode(node, prop, value) {
      if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
        node.__polymerTextContent__ = value;
      } else {
        super._setUnmanagedPropertyToNode(node, prop, value);
      }
    }
    /**
     * Find the parent model of this template instance.  The parent model
     * is either another templatize instance that had option `parentModel: true`,
     * or else the host element.
     *
     * @return {!Polymer_PropertyEffects} The parent model of this instance
     */
    get parentModel() {
      let model = this.__parentModel;
      if (!model) {
        let options;
        model = this;
        do {
          // A template instance's `__dataHost` is a <template>
          // `model.__dataHost.__dataHost` is the template's host
          model = model.__dataHost.__dataHost;
        } while ((options = model.__templatizeOptions) && !options.parentModel);
        this.__parentModel = model;
      }
      return model;
    }

    /**
     * Stub of HTMLElement's `dispatchEvent`, so that effects that may
     * dispatch events safely no-op.
     *
     * @param {Event} event Event to dispatch
     */
    dispatchEvent(event) {// eslint-disable-line no-unused-vars
    }
  }

  /** @type {!DataTemplate} */
  TemplateInstanceBase.prototype.__dataHost;
  /** @type {!TemplatizeOptions} */
  TemplateInstanceBase.prototype.__templatizeOptions;
  /** @type {!Polymer_PropertyEffects} */
  TemplateInstanceBase.prototype._methodHost;
  /** @type {!Object} */
  TemplateInstanceBase.prototype.__templatizeOwner;
  /** @type {!Object} */
  TemplateInstanceBase.prototype.__hostProps;

  /**
   * @constructor
   * @extends {TemplateInstanceBase}
   * @implements {Polymer_MutableData}
   */
  const MutableTemplateInstanceBase = Polymer.MutableData(TemplateInstanceBase);

  function findMethodHost(template) {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    let templateHost = template.__dataHost;
    return templateHost && templateHost._methodHost || templateHost;
  }

  /* eslint-disable valid-jsdoc */
  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */
  function createTemplatizerClass(template, templateInfo, options) {
    // Anonymous class created by the templatize
    let base = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
    /**
     * @constructor
     * @extends {base}
     * @private
     */
    let klass = class extends base {};
    klass.prototype.__templatizeOptions = options;
    klass.prototype._bindTemplate(template);
    addNotifyEffects(klass, template, templateInfo, options);
    return klass;
  }

  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */
  function addPropagateEffects(template, templateInfo, options) {
    let userForwardHostProp = options.forwardHostProp;
    if (userForwardHostProp) {
      // Provide data API and property effects on memoized template class
      let klass = templateInfo.templatizeTemplateClass;
      if (!klass) {
        let base = options.mutableData ? MutableDataTemplate : DataTemplate;
        klass = templateInfo.templatizeTemplateClass = class TemplatizedTemplate extends base {};
        // Add template - >instances effects
        // and host <- template effects
        let hostProps = templateInfo.hostProps;
        for (let prop in hostProps) {
          klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, { fn: createForwardHostPropEffect(prop, userForwardHostProp) });
          klass.prototype._createNotifyingProperty('_host_' + prop);
        }
      }
      upgradeTemplate(template, klass);
      // Mix any pre-bound data into __data; no need to flush this to
      // instances since they pull from the template at instance-time
      if (template.__dataProto) {
        // Note, generally `__dataProto` could be chained, but it's guaranteed
        // to not be since this is a vanilla template we just added effects to
        Object.assign(template.__data, template.__dataProto);
      }
      // Clear any pending data for performance
      template.__dataTemp = {};
      template.__dataPending = null;
      template.__dataOld = null;
      template._enableProperties();
    }
  }
  /* eslint-enable valid-jsdoc */

  function createForwardHostPropEffect(hostProp, userForwardHostProp) {
    return function forwardHostProp(template, prop, props) {
      userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);
    };
  }

  function addNotifyEffects(klass, template, templateInfo, options) {
    let hostProps = templateInfo.hostProps || {};
    for (let iprop in options.instanceProps) {
      delete hostProps[iprop];
      let userNotifyInstanceProp = options.notifyInstanceProp;
      if (userNotifyInstanceProp) {
        klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) });
      }
    }
    if (options.forwardHostProp && template.__dataHost) {
      for (let hprop in hostProps) {
        klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, { fn: createNotifyHostPropEffect() });
      }
    }
  }

  function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
    return function notifyInstanceProp(inst, prop, props) {
      userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
    };
  }

  function createNotifyHostPropEffect() {
    return function notifyHostProp(inst, prop, props) {
      inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
    };
  }

  /**
   * Module for preparing and stamping instances of templates that utilize
   * Polymer's data-binding and declarative event listener features.
   *
   * Example:
   *
   *     // Get a template from somewhere, e.g. light DOM
   *     let template = this.querySelector('template');
   *     // Prepare the template
   *     let TemplateClass = Polymer.Templatize.templatize(template);
   *     // Instance the template with an initial data model
   *     let instance = new TemplateClass({myProp: 'initial'});
   *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
   *     this.shadowRoot.appendChild(instance.root);
   *     // Changing a property on the instance will propagate to bindings
   *     // in the template
   *     instance.myProp = 'new value';
   *
   * The `options` dictionary passed to `templatize` allows for customizing
   * features of the generated template class, including how outer-scope host
   * properties should be forwarded into template instances, how any instance
   * properties added into the template's scope should be notified out to
   * the host, and whether the instance should be decorated as a "parent model"
   * of any event handlers.
   *
   *     // Customize property forwarding and event model decoration
   *     let TemplateClass = Polymer.Templatize.templatize(template, this, {
   *       parentModel: true,
   *       forwardHostProp(property, value) {...},
   *       instanceProps: {...},
   *       notifyInstanceProp(instance, property, value) {...},
   *     });
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for preparing and stamping instances of templates
   *   utilizing Polymer templating features.
   */

  const Templatize = {

    /**
     * Returns an anonymous `Polymer.PropertyEffects` class bound to the
     * `<template>` provided.  Instancing the class will result in the
     * template being stamped into a document fragment stored as the instance's
     * `root` property, after which it can be appended to the DOM.
     *
     * Templates may utilize all Polymer data-binding features as well as
     * declarative event listeners.  Event listeners and inline computing
     * functions in the template will be called on the host of the template.
     *
     * The constructor returned takes a single argument dictionary of initial
     * property values to propagate into template bindings.  Additionally
     * host properties can be forwarded in, and instance properties can be
     * notified out by providing optional callbacks in the `options` dictionary.
     *
     * Valid configuration in `options` are as follows:
     *
     * - `forwardHostProp(property, value)`: Called when a property referenced
     *   in the template changed on the template's host. As this library does
     *   not retain references to templates instanced by the user, it is the
     *   templatize owner's responsibility to forward host property changes into
     *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
     *    method on the generated class should be called to forward host
     *   properties into the template to prevent unnecessary property-changed
     *   notifications. Any properties referenced in the template that are not
     *   defined in `instanceProps` will be notified up to the template's host
     *   automatically.
     * - `instanceProps`: Dictionary of property names that will be added
     *   to the instance by the templatize owner.  These properties shadow any
     *   host properties, and changes within the template to these properties
     *   will result in `notifyInstanceProp` being called.
     * - `mutableData`: When `true`, the generated class will skip strict
     *   dirty-checking for objects and arrays (always consider them to be
     *   "dirty").
     * - `notifyInstanceProp(instance, property, value)`: Called when
     *   an instance property changes.  Users may choose to call `notifyPath`
     *   on e.g. the owner to notify the change.
     * - `parentModel`: When `true`, events handled by declarative event listeners
     *   (`on-event="handler"`) will be decorated with a `model` property pointing
     *   to the template instance that stamped it.  It will also be returned
     *   from `instance.parentModel` in cases where template instance nesting
     *   causes an inner model to shadow an outer model.
     *
     * When `options.forwardHostProp` is declared as an option, any properties
     * referenced in the template will be automatically forwarded from the host of
     * the `<template>` to instances, with the exception of any properties listed in
     * the `options.instanceProps` object.  `instanceProps` are assumed to be
     * managed by the owner of the instances, either passed into the constructor
     * or set after the fact.  Note, any properties passed into the constructor will
     * always be set to the instance (regardless of whether they would normally
     * be forwarded from the host).
     *
     * Note that the class returned from `templatize` is generated only once
     * for a given `<template>` using `options` from the first call for that
     * template, and the cached class is returned for all subsequent calls to
     * `templatize` for that template.  As such, `options` callbacks should not
     * close over owner-specific properties since only the first `options` is
     * used; rather, callbacks are called bound to the `owner`, and so context
     * needed from the callbacks (such as references to `instances` stamped)
     * should be stored on the `owner` such that they can be retrieved via `this`.
     *
     * @memberof Polymer.Templatize
     * @param {!HTMLTemplateElement} template Template to templatize
     * @param {Polymer_PropertyEffects=} owner Owner of the template instances;
     *   any optional callbacks will be bound to this owner.
     * @param {Object=} options Options dictionary (see summary for details)
     * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
     *   provided
     * @suppress {invalidCasts}
     */
    templatize(template, owner, options) {
      options = /** @type {!TemplatizeOptions} */options || {};
      if (template.__templatizeOwner) {
        throw new Error('A <template> can only be templatized once');
      }
      template.__templatizeOwner = owner;
      const ctor = owner ? owner.constructor : TemplateInstanceBase;
      let templateInfo = ctor._parseTemplate(template);
      // Get memoized base class for the prototypical template, which
      // includes property effects for binding template & forwarding
      let baseClass = templateInfo.templatizeInstanceClass;
      if (!baseClass) {
        baseClass = createTemplatizerClass(template, templateInfo, options);
        templateInfo.templatizeInstanceClass = baseClass;
      }
      // Host property forwarding must be installed onto template instance
      addPropagateEffects(template, templateInfo, options);
      // Subclass base class and add reference for this specific template
      /** @private */
      let klass = class TemplateInstance extends baseClass {};
      klass.prototype._methodHost = findMethodHost(template);
      klass.prototype.__dataHost = template;
      klass.prototype.__templatizeOwner = owner;
      klass.prototype.__hostProps = templateInfo.hostProps;
      klass = /** @type {function(new:TemplateInstanceBase)} */klass; //eslint-disable-line no-self-assign
      return klass;
    },

    /**
     * Returns the template "model" associated with a given element, which
     * serves as the binding scope for the template instance the element is
     * contained in. A template model is an instance of
     * `TemplateInstanceBase`, and should be used to manipulate data
     * associated with this template instance.
     *
     * Example:
     *
     *   let model = modelForElement(el);
     *   if (model.index < 10) {
     *     model.set('item.checked', true);
     *   }
     *
     * @memberof Polymer.Templatize
     * @param {HTMLTemplateElement} template The model will be returned for
     *   elements stamped from this template
     * @param {Node=} node Node for which to return a template model.
     * @return {TemplateInstanceBase} Template instance representing the
     *   binding scope for the element
     */
    modelForElement(template, node) {
      let model;
      while (node) {
        // An element with a __templatizeInstance marks the top boundary
        // of a scope; walk up until we find one, and then ensure that
        // its __dataHost matches `this`, meaning this dom-repeat stamped it
        if (model = node.__templatizeInstance) {
          // Found an element stamped by another template; keep walking up
          // from its __dataHost
          if (model.__dataHost != template) {
            node = model.__dataHost;
          } else {
            return model;
          }
        } else {
          // Still in a template scope, keep going up until
          // a __templatizeInstance is found
          node = node.parentNode;
        }
      }
      return null;
    }
  };

  Polymer.Templatize = Templatize;
  Polymer.TemplateInstanceBase = TemplateInstanceBase;
})();

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(16);

__webpack_require__(24);

(function () {
  'use strict';

  /**
   * Base class that provides the core API for Polymer's meta-programming
   * features including template stamping, data-binding, attribute deserialization,
   * and property change observation.
   *
   * @customElement
   * @polymer
   * @memberof Polymer
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends HTMLElement
   * @appliesMixin Polymer.ElementMixin
   * @summary Custom element base class that provides the core API for Polymer's
   *   key meta-programming features including template stamping, data-binding,
   *   attribute deserialization, and property change observation
   */

  const Element = Polymer.ElementMixin(HTMLElement);
  /**
   * @constructor
   * @implements {Polymer_ElementMixin}
   * @extends {HTMLElement}
   */
  Polymer.Element = Element;

  // NOTE: this is here for modulizer to export `html` for the module version of this file
  Polymer.html = Polymer.html;
})();

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(15);

__webpack_require__(43);

__webpack_require__(45);

__webpack_require__(46);

__webpack_require__(47);

__webpack_require__(48);

__webpack_require__(49);

__webpack_require__(50);

__webpack_require__(53);

__webpack_require__(24);

// bc
Polymer.Base = Polymer.LegacyElementMixin(HTMLElement).prototype;

// NOTE: this is here for modulizer to export `html` for the module version of this file
Polymer.html = Polymer.html;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(30);

__webpack_require__(16);

__webpack_require__(22);

__webpack_require__(37);

__webpack_require__(1);

__webpack_require__(38);

__webpack_require__(39);

__webpack_require__(40);

__webpack_require__(41);

(function () {

  'use strict';

  let styleInterface = window.ShadyCSS;

  /**
   * Element class mixin that provides Polymer's "legacy" API intended to be
   * backward-compatible to the greatest extent possible with the API
   * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements
   * defined using the `Polymer({...})` function.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.ElementMixin
   * @appliesMixin Polymer.GestureEventListeners
   * @property isAttached {boolean} Set to `true` in this element's
   *   `connectedCallback` and `false` in `disconnectedCallback`
   * @memberof Polymer
   * @summary Element class mixin that provides Polymer's "legacy" API
   */
  Polymer.LegacyElementMixin = Polymer.dedupingMixin(base => {

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_ElementMixin}
     * @implements {Polymer_GestureEventListeners}
     * @implements {Polymer_DirMixin}
     */
    const legacyElementBase = Polymer.DirMixin(Polymer.GestureEventListeners(Polymer.ElementMixin(base)));

    /**
     * Map of simple names to touch action names
     * @dict
     */
    const DIRECTION_MAP = {
      'x': 'pan-x',
      'y': 'pan-y',
      'none': 'none',
      'all': 'auto'
    };

    /**
     * @polymer
     * @mixinClass
     * @extends {legacyElementBase}
     * @implements {Polymer_LegacyElementMixin}
     * @unrestricted
     */
    class LegacyElement extends legacyElementBase {

      constructor() {
        super();
        this.root = this;
        /** @type {boolean} */
        this.isAttached;
        /** @type {WeakMap<!Element, !Object<string, !Function>>} */
        this.__boundListeners;
        /** @type {Object<string, Function>} */
        this._debouncers;
        this.created();
        // Ensure listeners are applied immediately so that they are
        // added before declarative event listeners. This allows an element to
        // decorate itself via an event prior to any declarative listeners
        // seeing the event. Note, this ensures compatibility with 1.x ordering.
        this._applyListeners();
      }

      /**
       * Legacy callback called during the `constructor`, for overriding
       * by the user.
       * @return {void}
       */
      created() {}

      /**
       * Provides an implementation of `connectedCallback`
       * which adds Polymer legacy API's `attached` method.
       * @return {void}
       * @override
       */
      connectedCallback() {
        super.connectedCallback();
        this.isAttached = true;
        this.attached();
      }

      /**
       * Legacy callback called during `connectedCallback`, for overriding
       * by the user.
       * @return {void}
       */
      attached() {}

      /**
       * Provides an implementation of `disconnectedCallback`
       * which adds Polymer legacy API's `detached` method.
       * @return {void}
       * @override
       */
      disconnectedCallback() {
        super.disconnectedCallback();
        this.isAttached = false;
        this.detached();
      }

      /**
       * Legacy callback called during `disconnectedCallback`, for overriding
       * by the user.
       * @return {void}
       */
      detached() {}

      /**
       * Provides an override implementation of `attributeChangedCallback`
       * which adds the Polymer legacy API's `attributeChanged` method.
       * @param {string} name Name of attribute.
       * @param {?string} old Old value of attribute.
       * @param {?string} value Current value of attribute.
       * @return {void}
       * @override
       */
      attributeChangedCallback(name, old, value) {
        if (old !== value) {
          super.attributeChangedCallback(name, old, value);
          this.attributeChanged(name, old, value);
        }
      }

      /**
       * Legacy callback called during `attributeChangedChallback`, for overriding
       * by the user.
       * @param {string} name Name of attribute.
       * @param {?string} old Old value of attribute.
       * @param {?string} value Current value of attribute.
       * @return {void}
       */
      attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

      /**
       * Overrides the default `Polymer.PropertyEffects` implementation to
       * add support for class initialization via the `_registered` callback.
       * This is called only when the first instance of the element is created.
       *
       * @return {void}
       * @override
       */
      _initializeProperties() {
        let proto = Object.getPrototypeOf(this);
        if (!proto.hasOwnProperty('__hasRegisterFinished')) {
          proto.__hasRegisterFinished = true;
          this._registered();
        }
        super._initializeProperties();
      }

      /**
       * Called automatically when an element is initializing.
       * Users may override this method to perform class registration time
       * work. The implementation should ensure the work is performed
       * only once for the class.
       * @protected
       * @return {void}
       */
      _registered() {}

      /**
       * Overrides the default `Polymer.PropertyEffects` implementation to
       * add support for installing `hostAttributes` and `listeners`.
       *
       * @return {void}
       * @override
       */
      ready() {
        this._ensureAttributes();
        super.ready();
      }

      /**
       * Ensures an element has required attributes. Called when the element
       * is being readied via `ready`. Users should override to set the
       * element's required attributes. The implementation should be sure
       * to check and not override existing attributes added by
       * the user of the element. Typically, setting attributes should be left
       * to the element user and not done here; reasonable exceptions include
       * setting aria roles and focusability.
       * @protected
       * @return {void}
       */
      _ensureAttributes() {}

      /**
       * Adds element event listeners. Called when the element
       * is being readied via `ready`. Users should override to
       * add any required element event listeners.
       * In performance critical elements, the work done here should be kept
       * to a minimum since it is done before the element is rendered. In
       * these elements, consider adding listeners asynchronously so as not to
       * block render.
       * @protected
       * @return {void}
       */
      _applyListeners() {}

      /**
       * Converts a typed JavaScript value to a string.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features. To customize
       * how properties are serialized to attributes for attribute bindings and
       * `reflectToAttribute: true` properties as well as this method, override
       * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
       *
       * @param {*} value Value to deserialize
       * @return {string | undefined} Serialized value
       */
      serialize(value) {
        return this._serializeValue(value);
      }

      /**
       * Converts a string to a typed JavaScript value.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.  To customize
       * how attributes are deserialized to properties for in
       * `attributeChangedCallback`, override `_deserializeValue` method
       * provided by `Polymer.PropertyAccessors`.
       *
       * @param {string} value String to deserialize
       * @param {*} type Type to deserialize the string to
       * @return {*} Returns the deserialized value in the `type` given.
       */
      deserialize(value, type) {
        return this._deserializeValue(value, type);
      }

      /**
       * Serializes a property to its associated attribute.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect.
       * @param {*=} value Property value to reflect.
       * @return {void}
       */
      reflectPropertyToAttribute(property, attribute, value) {
        this._propertyToAttribute(property, attribute, value);
      }

      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.
       *
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       * @param {Element} node Element to set attribute to.
       * @return {void}
       */
      serializeValueToAttribute(value, attribute, node) {
        this._valueToNodeAttribute( /** @type {Element} */node || this, value, attribute);
      }

      /**
       * Copies own properties (including accessor descriptors) from a source
       * object to a target object.
       *
       * @param {Object} prototype Target object to copy properties to.
       * @param {Object} api Source object to copy properties from.
       * @return {Object} prototype object that was passed as first argument.
       */
      extend(prototype, api) {
        if (!(prototype && api)) {
          return prototype || api;
        }
        let n$ = Object.getOwnPropertyNames(api);
        for (let i = 0, n; i < n$.length && (n = n$[i]); i++) {
          let pd = Object.getOwnPropertyDescriptor(api, n);
          if (pd) {
            Object.defineProperty(prototype, n, pd);
          }
        }
        return prototype;
      }

      /**
       * Copies props from a source object to a target object.
       *
       * Note, this method uses a simple `for...in` strategy for enumerating
       * properties.  To ensure only `ownProperties` are copied from source
       * to target and that accessor implementations are copied, use `extend`.
       *
       * @param {!Object} target Target object to copy properties to.
       * @param {!Object} source Source object to copy properties from.
       * @return {!Object} Target object that was passed as first argument.
       */
      mixin(target, source) {
        for (let i in source) {
          target[i] = source[i];
        }
        return target;
      }

      /**
       * Sets the prototype of an object.
       *
       * Note this method is provided as backward-compatible legacy API
       * only.  It is not directly called by any Polymer features.
       * @param {Object} object The object on which to set the prototype.
       * @param {Object} prototype The prototype that will be set on the given
       * `object`.
       * @return {Object} Returns the given `object` with its prototype set
       * to the given `prototype` object.
       */
      chainObject(object, prototype) {
        if (object && prototype && object !== prototype) {
          object.__proto__ = prototype;
        }
        return object;
      }

      /* **** Begin Template **** */

      /**
       * Calls `importNode` on the `content` of the `template` specified and
       * returns a document fragment containing the imported content.
       *
       * @param {HTMLTemplateElement} template HTML template element to instance.
       * @return {!DocumentFragment} Document fragment containing the imported
       *   template content.
      */
      instanceTemplate(template) {
        let content = this.constructor._contentForTemplate(template);
        let dom = /** @type {!DocumentFragment} */
        document.importNode(content, true);
        return dom;
      }

      /* **** Begin Events **** */

      /**
       * Dispatches a custom event with an optional detail value.
       *
       * @param {string} type Name of event type.
       * @param {*=} detail Detail value containing event-specific
       *   payload.
       * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}
       *  options Object specifying options.  These may include:
       *  `bubbles` (boolean, defaults to `true`),
       *  `cancelable` (boolean, defaults to false), and
       *  `node` on which to fire the event (HTMLElement, defaults to `this`).
       * @return {!Event} The new event that was fired.
       */
      fire(type, detail, options) {
        options = options || {};
        detail = detail === null || detail === undefined ? {} : detail;
        let event = new Event(type, {
          bubbles: options.bubbles === undefined ? true : options.bubbles,
          cancelable: Boolean(options.cancelable),
          composed: options.composed === undefined ? true : options.composed
        });
        event.detail = detail;
        let node = options.node || this;
        node.dispatchEvent(event);
        return event;
      }

      /**
       * Convenience method to add an event listener on a given element,
       * late bound to a named method on this element.
       *
       * @param {Element} node Element to add event listener to.
       * @param {string} eventName Name of event to listen for.
       * @param {string} methodName Name of handler method on `this` to call.
       * @return {void}
       */
      listen(node, eventName, methodName) {
        node = /** @type {!Element} */node || this;
        let hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());
        let bl = hbl.get(node);
        if (!bl) {
          bl = {};
          hbl.set(node, bl);
        }
        let key = eventName + methodName;
        if (!bl[key]) {
          bl[key] = this._addMethodEventListenerToNode(node, eventName, methodName, this);
        }
      }

      /**
       * Convenience method to remove an event listener from a given element,
       * late bound to a named method on this element.
       *
       * @param {Element} node Element to remove event listener from.
       * @param {string} eventName Name of event to stop listening to.
       * @param {string} methodName Name of handler method on `this` to not call
       anymore.
       * @return {void}
       */
      unlisten(node, eventName, methodName) {
        node = /** @type {!Element} */node || this;
        let bl = this.__boundListeners && this.__boundListeners.get(node);
        let key = eventName + methodName;
        let handler = bl && bl[key];
        if (handler) {
          this._removeEventListenerFromNode(node, eventName, handler);
          bl[key] = null;
        }
      }

      /**
       * Override scrolling behavior to all direction, one direction, or none.
       *
       * Valid scroll directions:
       *   - 'all': scroll in any direction
       *   - 'x': scroll only in the 'x' direction
       *   - 'y': scroll only in the 'y' direction
       *   - 'none': disable scrolling for this node
       *
       * @param {string=} direction Direction to allow scrolling
       * Defaults to `all`.
       * @param {Element=} node Element to apply scroll direction setting.
       * Defaults to `this`.
       * @return {void}
       */
      setScrollDirection(direction, node) {
        Polymer.Gestures.setTouchAction( /** @type {Element} */node || this, DIRECTION_MAP[direction] || 'auto');
      }
      /* **** End Events **** */

      /**
       * Convenience method to run `querySelector` on this local DOM scope.
       *
       * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
       *
       * @param {string} slctr Selector to run on this local DOM scope
       * @return {Element} Element found by the selector, or null if not found.
       */
      $$(slctr) {
        return this.root.querySelector(slctr);
      }

      /**
       * Return the element whose local dom within which this element
       * is contained. This is a shorthand for
       * `this.getRootNode().host`.
       * @this {Element}
       */
      get domHost() {
        let root = this.getRootNode();
        return root instanceof DocumentFragment ? /** @type {ShadowRoot} */root.host : root;
      }

      /**
       * Force this element to distribute its children to its local dom.
       * This should not be necessary as of Polymer 2.0.2 and is provided only
       * for backwards compatibility.
       * @return {void}
       */
      distributeContent() {
        if (window.ShadyDOM && this.shadowRoot) {
          ShadyDOM.flush();
        }
      }

      /**
       * Returns a list of nodes that are the effective childNodes. The effective
       * childNodes list is the same as the element's childNodes except that
       * any `<content>` elements are replaced with the list of nodes distributed
       * to the `<content>`, the result of its `getDistributedNodes` method.
       * @return {!Array<!Node>} List of effective child nodes.
       * @suppress {invalidCasts} LegacyElementMixin must be applied to an HTMLElement
       */
      getEffectiveChildNodes() {
        const thisEl = /** @type {Element} */this;
        const domApi = /** @type {Polymer.DomApi} */Polymer.dom(thisEl);
        return domApi.getEffectiveChildNodes();
      }

      /**
       * Returns a list of nodes distributed within this element that match
       * `selector`. These can be dom children or elements distributed to
       * children that are insertion points.
       * @param {string} selector Selector to run.
       * @return {!Array<!Node>} List of distributed elements that match selector.
       * @suppress {invalidCasts} LegacyElementMixin must be applied to an HTMLElement
       */
      queryDistributedElements(selector) {
        const thisEl = /** @type {Element} */this;
        const domApi = /** @type {Polymer.DomApi} */Polymer.dom(thisEl);
        return domApi.queryDistributedElements(selector);
      }

      /**
       * Returns a list of elements that are the effective children. The effective
       * children list is the same as the element's children except that
       * any `<content>` elements are replaced with the list of elements
       * distributed to the `<content>`.
       *
       * @return {!Array<!Node>} List of effective children.
       */
      getEffectiveChildren() {
        let list = this.getEffectiveChildNodes();
        return list.filter(function ( /** @type {!Node} */n) {
          return n.nodeType === Node.ELEMENT_NODE;
        });
      }

      /**
       * Returns a string of text content that is the concatenation of the
       * text content's of the element's effective childNodes (the elements
       * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
       *
       * @return {string} List of effective children.
       */
      getEffectiveTextContent() {
        let cn = this.getEffectiveChildNodes();
        let tc = [];
        for (let i = 0, c; c = cn[i]; i++) {
          if (c.nodeType !== Node.COMMENT_NODE) {
            tc.push(c.textContent);
          }
        }
        return tc.join('');
      }

      /**
       * Returns the first effective childNode within this element that
       * match `selector`. These can be dom child nodes or elements distributed
       * to children that are insertion points.
       * @param {string} selector Selector to run.
       * @return {Node} First effective child node that matches selector.
       */
      queryEffectiveChildren(selector) {
        let e$ = this.queryDistributedElements(selector);
        return e$ && e$[0];
      }

      /**
       * Returns a list of effective childNodes within this element that
       * match `selector`. These can be dom child nodes or elements distributed
       * to children that are insertion points.
       * @param {string} selector Selector to run.
       * @return {!Array<!Node>} List of effective child nodes that match selector.
       */
      queryAllEffectiveChildren(selector) {
        return this.queryDistributedElements(selector);
      }

      /**
       * Returns a list of nodes distributed to this element's `<slot>`.
       *
       * If this element contains more than one `<slot>` in its local DOM,
       * an optional selector may be passed to choose the desired content.
       *
       * @param {string=} slctr CSS selector to choose the desired
       *   `<slot>`.  Defaults to `content`.
       * @return {!Array<!Node>} List of distributed nodes for the `<slot>`.
       */
      getContentChildNodes(slctr) {
        let content = this.root.querySelector(slctr || 'slot');
        return content ? /** @type {Polymer.DomApi} */Polymer.dom(content).getDistributedNodes() : [];
      }

      /**
       * Returns a list of element children distributed to this element's
       * `<slot>`.
       *
       * If this element contains more than one `<slot>` in its
       * local DOM, an optional selector may be passed to choose the desired
       * content.  This method differs from `getContentChildNodes` in that only
       * elements are returned.
       *
       * @param {string=} slctr CSS selector to choose the desired
       *   `<content>`.  Defaults to `content`.
       * @return {!Array<!HTMLElement>} List of distributed nodes for the
       *   `<slot>`.
       * @suppress {invalidCasts}
       */
      getContentChildren(slctr) {
        let children = /** @type {!Array<!HTMLElement>} */this.getContentChildNodes(slctr).filter(function (n) {
          return n.nodeType === Node.ELEMENT_NODE;
        });
        return children;
      }

      /**
       * Checks whether an element is in this element's light DOM tree.
       *
       * @param {?Node} node The element to be checked.
       * @return {boolean} true if node is in this element's light DOM tree.
       * @suppress {invalidCasts} LegacyElementMixin must be applied to an HTMLElement
       */
      isLightDescendant(node) {
        const thisNode = /** @type {Node} */this;
        return thisNode !== node && thisNode.contains(node) && thisNode.getRootNode() === node.getRootNode();
      }

      /**
       * Checks whether an element is in this element's local DOM tree.
       *
       * @param {!Element} node The element to be checked.
       * @return {boolean} true if node is in this element's local DOM tree.
       */
      isLocalDescendant(node) {
        return this.root === node.getRootNode();
      }

      /**
       * No-op for backwards compatibility. This should now be handled by
       * ShadyCss library.
       * @param  {*} container Unused
       * @param  {*} shouldObserve Unused
       * @return {void}
       */
      scopeSubtree(container, shouldObserve) {} // eslint-disable-line no-unused-vars


      /**
       * Returns the computed style value for the given property.
       * @param {string} property The css property name.
       * @return {string} Returns the computed css property value for the given
       * `property`.
       * @suppress {invalidCasts} LegacyElementMixin must be applied to an HTMLElement
       */
      getComputedStyleValue(property) {
        return styleInterface.getComputedStyleValue( /** @type {!Element} */this, property);
      }

      // debounce

      /**
       * Call `debounce` to collapse multiple requests for a named task into
       * one invocation which is made after the wait time has elapsed with
       * no new request.  If no wait time is given, the callback will be called
       * at microtask timing (guaranteed before paint).
       *
       *     debouncedClickAction(e) {
       *       // will not call `processClick` more than once per 100ms
       *       this.debounce('click', function() {
       *        this.processClick();
       *       } 100);
       *     }
       *
       * @param {string} jobName String to identify the debounce job.
       * @param {function():void} callback Function that is called (with `this`
       *   context) when the wait time elapses.
       * @param {number} wait Optional wait time in milliseconds (ms) after the
       *   last signal that must elapse before invoking `callback`
       * @return {!Object} Returns a debouncer object on which exists the
       * following methods: `isActive()` returns true if the debouncer is
       * active; `cancel()` cancels the debouncer if it is active;
       * `flush()` immediately invokes the debounced callback if the debouncer
       * is active.
       */
      debounce(jobName, callback, wait) {
        this._debouncers = this._debouncers || {};
        return this._debouncers[jobName] = Polymer.Debouncer.debounce(this._debouncers[jobName], wait > 0 ? Polymer.Async.timeOut.after(wait) : Polymer.Async.microTask, callback.bind(this));
      }

      /**
       * Returns whether a named debouncer is active.
       *
       * @param {string} jobName The name of the debouncer started with `debounce`
       * @return {boolean} Whether the debouncer is active (has not yet fired).
       */
      isDebouncerActive(jobName) {
        this._debouncers = this._debouncers || {};
        let debouncer = this._debouncers[jobName];
        return !!(debouncer && debouncer.isActive());
      }

      /**
       * Immediately calls the debouncer `callback` and inactivates it.
       *
       * @param {string} jobName The name of the debouncer started with `debounce`
       * @return {void}
       */
      flushDebouncer(jobName) {
        this._debouncers = this._debouncers || {};
        let debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.flush();
        }
      }

      /**
       * Cancels an active debouncer.  The `callback` will not be called.
       *
       * @param {string} jobName The name of the debouncer started with `debounce`
       * @return {void}
       */
      cancelDebouncer(jobName) {
        this._debouncers = this._debouncers || {};
        let debouncer = this._debouncers[jobName];
        if (debouncer) {
          debouncer.cancel();
        }
      }

      /**
       * Runs a callback function asynchronously.
       *
       * By default (if no waitTime is specified), async callbacks are run at
       * microtask timing, which will occur before paint.
       *
       * @param {!Function} callback The callback function to run, bound to `this`.
       * @param {number=} waitTime Time to wait before calling the
       *   `callback`.  If unspecified or 0, the callback will be run at microtask
       *   timing (before paint).
       * @return {number} Handle that may be used to cancel the async job.
       */
      async(callback, waitTime) {
        return waitTime > 0 ? Polymer.Async.timeOut.run(callback.bind(this), waitTime) : ~Polymer.Async.microTask.run(callback.bind(this));
      }

      /**
       * Cancels an async operation started with `async`.
       *
       * @param {number} handle Handle returned from original `async` call to
       *   cancel.
       * @return {void}
       */
      cancelAsync(handle) {
        handle < 0 ? Polymer.Async.microTask.cancel(~handle) : Polymer.Async.timeOut.cancel(handle);
      }

      // other

      /**
       * Convenience method for creating an element and configuring it.
       *
       * @param {string} tag HTML element tag to create.
       * @param {Object=} props Object of properties to configure on the
       *    instance.
       * @return {!Element} Newly created and configured element.
       */
      create(tag, props) {
        let elt = document.createElement(tag);
        if (props) {
          if (elt.setProperties) {
            elt.setProperties(props);
          } else {
            for (let n in props) {
              elt[n] = props[n];
            }
          }
        }
        return elt;
      }

      /**
       * Convenience method for importing an HTML document imperatively.
       *
       * This method creates a new `<link rel="import">` element with
       * the provided URL and appends it to the document to start loading.
       * In the `onload` callback, the `import` property of the `link`
       * element will contain the imported document contents.
       *
       * @param {string} href URL to document to load.
       * @param {?function(!Event):void=} onload Callback to notify when an import successfully
       *   loaded.
       * @param {?function(!ErrorEvent):void=} onerror Callback to notify when an import
       *   unsuccessfully loaded.
       * @param {boolean=} optAsync True if the import should be loaded `async`.
       *   Defaults to `false`.
       * @return {!HTMLLinkElement} The link element for the URL to be loaded.
       */
      importHref(href, onload, onerror, optAsync) {
        // eslint-disable-line no-unused-vars
        let loadFn = onload ? onload.bind(this) : null;
        let errorFn = onerror ? onerror.bind(this) : null;
        return Polymer.importHref(href, loadFn, errorFn, optAsync);
      }

      /**
       * Polyfill for Element.prototype.matches, which is sometimes still
       * prefixed.
       *
       * @param {string} selector Selector to test.
       * @param {!Element=} node Element to test the selector against.
       * @return {boolean} Whether the element matches the selector.
       */
      elementMatches(selector, node) {
        return Polymer.dom.matchesSelector( /** @type {!Element} */node || this, selector);
      }

      /**
       * Toggles an HTML attribute on or off.
       *
       * @param {string} name HTML attribute name
       * @param {boolean=} bool Boolean to force the attribute on or off.
       *    When unspecified, the state of the attribute will be reversed.
       * @param {Element=} node Node to target.  Defaults to `this`.
       * @return {void}
       */
      toggleAttribute(name, bool, node) {
        node = /** @type {Element} */node || this;
        if (arguments.length == 1) {
          bool = !node.hasAttribute(name);
        }
        if (bool) {
          node.setAttribute(name, '');
        } else {
          node.removeAttribute(name);
        }
      }

      /**
       * Toggles a CSS class on or off.
       *
       * @param {string} name CSS class name
       * @param {boolean=} bool Boolean to force the class on or off.
       *    When unspecified, the state of the class will be reversed.
       * @param {Element=} node Node to target.  Defaults to `this`.
       * @return {void}
       */
      toggleClass(name, bool, node) {
        node = /** @type {Element} */node || this;
        if (arguments.length == 1) {
          bool = !node.classList.contains(name);
        }
        if (bool) {
          node.classList.add(name);
        } else {
          node.classList.remove(name);
        }
      }

      /**
       * Cross-platform helper for setting an element's CSS `transform` property.
       *
       * @param {string} transformText Transform setting.
       * @param {Element=} node Element to apply the transform to.
       * Defaults to `this`
       * @return {void}
       */
      transform(transformText, node) {
        node = /** @type {Element} */node || this;
        node.style.webkitTransform = transformText;
        node.style.transform = transformText;
      }

      /**
       * Cross-platform helper for setting an element's CSS `translate3d`
       * property.
       *
       * @param {number} x X offset.
       * @param {number} y Y offset.
       * @param {number} z Z offset.
       * @param {Element=} node Element to apply the transform to.
       * Defaults to `this`.
       * @return {void}
       */
      translate3d(x, y, z, node) {
        node = /** @type {Element} */node || this;
        this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
      }

      /**
       * Removes an item from an array, if it exists.
       *
       * If the array is specified by path, a change notification is
       * generated, so that observers, data bindings and computed
       * properties watching that path can update.
       *
       * If the array is passed directly, **no change
       * notification is generated**.
       *
       * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
       *   (or the array itself).
       * @param {*} item Item to remove.
       * @return {Array} Array containing item removed.
       */
      arrayDelete(arrayOrPath, item) {
        let index;
        if (Array.isArray(arrayOrPath)) {
          index = arrayOrPath.indexOf(item);
          if (index >= 0) {
            return arrayOrPath.splice(index, 1);
          }
        } else {
          let arr = Polymer.Path.get(this, arrayOrPath);
          index = arr.indexOf(item);
          if (index >= 0) {
            return this.splice(arrayOrPath, index, 1);
          }
        }
        return null;
      }

      // logging

      /**
       * Facades `console.log`/`warn`/`error` as override point.
       *
       * @param {string} level One of 'log', 'warn', 'error'
       * @param {Array} args Array of strings or objects to log
       * @return {void}
       */
      _logger(level, args) {
        // accept ['foo', 'bar'] and [['foo', 'bar']]
        if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {
          args = args[0];
        }
        switch (level) {
          case 'log':
          case 'warn':
          case 'error':
            console[level](...args);
        }
      }

      /**
       * Facades `console.log` as an override point.
       *
       * @param {...*} args Array of strings or objects to log
       * @return {void}
       */
      _log(...args) {
        this._logger('log', args);
      }

      /**
       * Facades `console.warn` as an override point.
       *
       * @param {...*} args Array of strings or objects to log
       * @return {void}
       */
      _warn(...args) {
        this._logger('warn', args);
      }

      /**
       * Facades `console.error` as an override point.
       *
       * @param {...*} args Array of strings or objects to log
       * @return {void}
       */
      _error(...args) {
        this._logger('error', args);
      }

      /**
       * Formats a message using the element type an a method name.
       *
       * @param {string} methodName Method name to associate with message
       * @param {...*} args Array of strings or objects to log
       * @return {Array} Array with formatting information for `console`
       *   logging.
       */
      _logf(methodName, ...args) {
        return ['[%s::%s]', this.is, methodName, ...args];
      }

    }

    LegacyElement.prototype.is = '';

    return LegacyElement;
  });
})();

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(17);

__webpack_require__(1);

__webpack_require__(18);

__webpack_require__(5);

__webpack_require__(32);

__webpack_require__(9);

__webpack_require__(35);

(function () {
  'use strict';

  /**
   * Element class mixin that provides the core API for Polymer's meta-programming
   * features including template stamping, data-binding, attribute deserialization,
   * and property change observation.
   *
   * Subclassers may provide the following static getters to return metadata
   * used to configure Polymer's features for the class:
   *
   * - `static get is()`: When the template is provided via a `dom-module`,
   *   users should return the `dom-module` id from a static `is` getter.  If
   *   no template is needed or the template is provided directly via the
   *   `template` getter, there is no need to define `is` for the element.
   *
   * - `static get template()`: Users may provide the template directly (as
   *   opposed to via `dom-module`) by implementing a static `template` getter.
   *   The getter may return an `HTMLTemplateElement` or a string, which will
   *   automatically be parsed into a template.
   *
   * - `static get properties()`: Should return an object describing
   *   property-related metadata used by Polymer features (key: property name
   *   value: object containing property metadata). Valid keys in per-property
   *   metadata include:
   *   - `type` (String|Number|Object|Array|...): Used by
   *     `attributeChangedCallback` to determine how string-based attributes
   *     are deserialized to JavaScript property values.
   *   - `notify` (boolean): Causes a change in the property to fire a
   *     non-bubbling event called `<property>-changed`. Elements that have
   *     enabled two-way binding to the property use this event to observe changes.
   *   - `readOnly` (boolean): Creates a getter for the property, but no setter.
   *     To set a read-only property, use the private setter method
   *     `_setProperty(property, value)`.
   *   - `observer` (string): Observer method name that will be called when
   *     the property changes. The arguments of the method are
   *     `(value, previousValue)`.
   *   - `computed` (string): String describing method and dependent properties
   *     for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
   *     Computed properties are read-only by default and can only be changed
   *     via the return value of the computing method.
   *
   * - `static get observers()`: Array of strings describing multi-property
   *   observer methods and their dependent properties (e.g.
   *   `'observeABC(a, b, c)'`).
   *
   * The base class provides default implementations for the following standard
   * custom element lifecycle callbacks; users may override these, but should
   * call the super method to ensure
   * - `constructor`: Run when the element is created or upgraded
   * - `connectedCallback`: Run each time the element is connected to the
   *   document
   * - `disconnectedCallback`: Run each time the element is disconnected from
   *   the document
   * - `attributeChangedCallback`: Run each time an attribute in
   *   `observedAttributes` is set or removed (note: this element's default
   *   `observedAttributes` implementation will automatically return an array
   *   of dash-cased attributes based on `properties`)
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.PropertyEffects
   * @appliesMixin Polymer.PropertiesMixin
   * @memberof Polymer
   * @property rootPath {string} Set to the value of `Polymer.rootPath`,
   *   which defaults to the main document path
   * @property importPath {string} Set to the value of the class's static
   *   `importPath` property, which defaults to the path of this element's
   *   `dom-module` (when `is` is used), but can be overridden for other
   *   import strategies.
   * @summary Element class mixin that provides the core API for Polymer's
   * meta-programming features.
   */

  Polymer.ElementMixin = Polymer.dedupingMixin(base => {

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_PropertyEffects}
     * @implements {Polymer_PropertiesMixin}
     */
    const polymerElementBase = Polymer.PropertiesMixin(Polymer.PropertyEffects(base));

    /**
     * Returns a list of properties with default values.
     * This list is created as an optimization since it is a subset of
     * the list returned from `_properties`.
     * This list is used in `_initializeProperties` to set property defaults.
     *
     * @param {PolymerElementConstructor} constructor Element class
     * @return {PolymerElementProperties} Flattened properties for this class
     *   that have default values
     * @private
     */
    function propertyDefaults(constructor) {
      if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__propertyDefaults', constructor))) {
        constructor.__propertyDefaults = null;
        let props = constructor._properties;
        for (let p in props) {
          let info = props[p];
          if ('value' in info) {
            constructor.__propertyDefaults = constructor.__propertyDefaults || {};
            constructor.__propertyDefaults[p] = info;
          }
        }
      }
      return constructor.__propertyDefaults;
    }

    /**
     * Returns a memoized version of the the `observers` array.
     * @param {PolymerElementConstructor} constructor Element class
     * @return {Array} Array containing own observers for the given class
     * @protected
     */
    function ownObservers(constructor) {
      if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', constructor))) {
        constructor.__ownObservers = constructor.hasOwnProperty(JSCompiler_renameProperty('observers', constructor)) ?
        /** @type {PolymerElementConstructor} */constructor.observers : null;
      }
      return constructor.__ownObservers;
    }

    /**
     * Creates effects for a property.
     *
     * Note, once a property has been set to
     * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
     * these values may not be changed. For example, a subclass cannot
     * alter these settings. However, additional `observers` may be added
     * by subclasses.
     *
     * The info object should may contain property metadata as follows:
     *
     * * `type`: {function} type to which an attribute matching the property
     * is deserialized. Note the property is camel-cased from a dash-cased
     * attribute. For example, 'foo-bar' attribute is deserialized to a
     * property named 'fooBar'.
     *
     * * `readOnly`: {boolean} creates a readOnly property and
     * makes a private setter for the private of the form '_setFoo' for a
     * property 'foo',
     *
     * * `computed`: {string} creates a computed property. A computed property
     * also automatically is set to `readOnly: true`. The value is calculated
     * by running a method and arguments parsed from the given string. For
     * example 'compute(foo)' will compute a given property when the
     * 'foo' property changes by executing the 'compute' method. This method
     * must return the computed value.
     *
     * * `reflectToAttribute`: {boolean} If true, the property value is reflected
     * to an attribute of the same name. Note, the attribute is dash-cased
     * so a property named 'fooBar' is reflected as 'foo-bar'.
     *
     * * `notify`: {boolean} sends a non-bubbling notification event when
     * the property changes. For example, a property named 'foo' sends an
     * event named 'foo-changed' with `event.detail` set to the value of
     * the property.
     *
     * * observer: {string} name of a method that runs when the property
     * changes. The arguments of the method are (value, previousValue).
     *
     * Note: Users may want control over modifying property
     * effects via subclassing. For example, a user might want to make a
     * reflectToAttribute property not do so in a subclass. We've chosen to
     * disable this because it leads to additional complication.
     * For example, a readOnly effect generates a special setter. If a subclass
     * disables the effect, the setter would fail unexpectedly.
     * Based on feedback, we may want to try to make effects more malleable
     * and/or provide an advanced api for manipulating them.
     * Also consider adding warnings when an effect cannot be changed.
     *
     * @param {!PolymerElement} proto Element class prototype to add accessors
     *   and effects to
     * @param {string} name Name of the property.
     * @param {Object} info Info object from which to create property effects.
     * Supported keys:
     * @param {Object} allProps Flattened map of all properties defined in this
     *   element (including inherited properties)
     * @return {void}
     * @private
     */
    function createPropertyFromConfig(proto, name, info, allProps) {
      // computed forces readOnly...
      if (info.computed) {
        info.readOnly = true;
      }
      // Note, since all computed properties are readOnly, this prevents
      // adding additional computed property effects (which leads to a confusing
      // setup where multiple triggers for setting a property)
      // While we do have `hasComputedEffect` this is set on the property's
      // dependencies rather than itself.
      if (info.computed && !proto._hasReadOnlyEffect(name)) {
        proto._createComputedProperty(name, info.computed, allProps);
      }
      if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
        proto._createReadOnlyProperty(name, !info.computed);
      }
      if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
        proto._createReflectedProperty(name);
      }
      if (info.notify && !proto._hasNotifyEffect(name)) {
        proto._createNotifyingProperty(name);
      }
      // always add observer
      if (info.observer) {
        proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
      }
      // always create the mapping from attribute back to property for deserialization.
      proto._addPropertyToAttributeMap(name);
    }

    /**
     * Process all style elements in the element template. Styles with the
     * `include` attribute are processed such that any styles in
     * the associated "style modules" are included in the element template.
     * @param {PolymerElementConstructor} klass Element class
     * @param {!HTMLTemplateElement} template Template to process
     * @param {string} is Name of element
     * @param {string} baseURI Base URI for element
     * @private
     */
    function processElementStyles(klass, template, is, baseURI) {
      const templateStyles = template.content.querySelectorAll('style');
      const stylesWithImports = Polymer.StyleGather.stylesFromTemplate(template);
      // insert styles from <link rel="import" type="css"> at the top of the template
      const linkedStyles = Polymer.StyleGather.stylesFromModuleImports(is);
      const firstTemplateChild = template.content.firstElementChild;
      for (let idx = 0; idx < linkedStyles.length; idx++) {
        let s = linkedStyles[idx];
        s.textContent = klass._processStyleText(s.textContent, baseURI);
        template.content.insertBefore(s, firstTemplateChild);
      }
      // keep track of the last "concrete" style in the template we have encountered
      let templateStyleIndex = 0;
      // ensure all gathered styles are actually in this template.
      for (let i = 0; i < stylesWithImports.length; i++) {
        let s = stylesWithImports[i];
        let templateStyle = templateStyles[templateStyleIndex];
        // if the style is not in this template, it's been "included" and
        // we put a clone of it in the template before the style that included it
        if (templateStyle !== s) {
          s = s.cloneNode(true);
          templateStyle.parentNode.insertBefore(s, templateStyle);
        } else {
          templateStyleIndex++;
        }
        s.textContent = klass._processStyleText(s.textContent, baseURI);
      }
      if (window.ShadyCSS) {
        window.ShadyCSS.prepareTemplate(template, is);
      }
    }

    /**
     * @polymer
     * @mixinClass
     * @unrestricted
     * @implements {Polymer_ElementMixin}
     */
    class PolymerElement extends polymerElementBase {

      /**
       * Override of PropertiesMixin _finalizeClass to create observers and
       * find the template.
       * @return {void}
       * @protected
       * @override
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */
      static _finalizeClass() {
        super._finalizeClass();
        if (this.hasOwnProperty(JSCompiler_renameProperty('is', this)) && this.is) {
          Polymer.telemetry.register(this.prototype);
        }
        const observers = ownObservers(this);
        if (observers) {
          this.createObservers(observers, this._properties);
        }
        // note: create "working" template that is finalized at instance time
        let template = /** @type {PolymerElementConstructor} */this.template;
        if (template) {
          if (typeof template === 'string') {
            let t = document.createElement('template');
            t.innerHTML = template;
            template = t;
          } else {
            template = template.cloneNode(true);
          }
          this.prototype._template = template;
        }
      }

      /**
       * Override of PropertiesChanged createProperties to create accessors
       * and property effects for all of the properties.
       * @return {void}
       * @protected
       * @override
       */
      static createProperties(props) {
        for (let p in props) {
          createPropertyFromConfig(this.prototype, p, props[p], props);
        }
      }

      /**
       * Creates observers for the given `observers` array.
       * Leverages `PropertyEffects` to create observers.
       * @param {Object} observers Array of observer descriptors for
       *   this class
       * @param {Object} dynamicFns Object containing keys for any properties
       *   that are functions and should trigger the effect when the function
       *   reference is changed
       * @return {void}
       * @protected
       */
      static createObservers(observers, dynamicFns) {
        const proto = this.prototype;
        for (let i = 0; i < observers.length; i++) {
          proto._createMethodObserver(observers[i], dynamicFns);
        }
      }

      /**
       * Returns the template that will be stamped into this element's shadow root.
       *
       * If a `static get is()` getter is defined, the default implementation
       * will return the first `<template>` in a `dom-module` whose `id`
       * matches this element's `is`.
       *
       * Users may override this getter to return an arbitrary template
       * (in which case the `is` getter is unnecessary). The template returned
       * may be either an `HTMLTemplateElement` or a string that will be
       * automatically parsed into a template.
       *
       * Note that when subclassing, if the super class overrode the default
       * implementation and the subclass would like to provide an alternate
       * template via a `dom-module`, it should override this getter and
       * return `Polymer.DomModule.import(this.is, 'template')`.
       *
       * If a subclass would like to modify the super class template, it should
       * clone it rather than modify it in place.  If the getter does expensive
       * work such as cloning/modifying a template, it should memoize the
       * template for maximum performance:
       *
       *   let memoizedTemplate;
       *   class MySubClass extends MySuperClass {
       *     static get template() {
       *       if (!memoizedTemplate) {
       *         memoizedTemplate = super.template.cloneNode(true);
       *         let subContent = document.createElement('div');
       *         subContent.textContent = 'This came from MySubClass';
       *         memoizedTemplate.content.appendChild(subContent);
       *       }
       *       return memoizedTemplate;
       *     }
       *   }
       *
       * @return {HTMLTemplateElement|string} Template to be stamped
       */
      static get template() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
          this._template = Polymer.DomModule && Polymer.DomModule.import(
          /** @type {PolymerElementConstructor}*/this.is, 'template') ||
          // note: implemented so a subclass can retrieve the super
          // template; call the super impl this way so that `this` points
          // to the superclass.
          Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.template;
        }
        return this._template;
      }

      /**
       * Path matching the url from which the element was imported.
       * This path is used to resolve url's in template style cssText.
       * The `importPath` property is also set on element instances and can be
       * used to create bindings relative to the import path.
       * Defaults to the path matching the url containing a `dom-module` element
       * matching this element's static `is` property.
       * Note, this path should contain a trailing `/`.
       *
       * @return {string} The import path for this element class
       */
      static get importPath() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
          const module = Polymer.DomModule && Polymer.DomModule.import( /** @type {PolymerElementConstructor} */this.is);
          this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf( /** @type {PolymerElementConstructor}*/this.prototype).constructor.importPath;
        }
        return this._importPath;
      }

      constructor() {
        super();
        /** @type {HTMLTemplateElement} */
        this._template;
        /** @type {string} */
        this._importPath;
        /** @type {string} */
        this.rootPath;
        /** @type {string} */
        this.importPath;
        /** @type {StampedTemplate | HTMLElement | ShadowRoot} */
        this.root;
        /** @type {!Object<string, !Element>} */
        this.$;
      }

      /**
       * Overrides the default `Polymer.PropertyAccessors` to ensure class
       * metaprogramming related to property accessors and effects has
       * completed (calls `finalize`).
       *
       * It also initializes any property defaults provided via `value` in
       * `properties` metadata.
       *
       * @return {void}
       * @override
       * @suppress {invalidCasts}
       */
      _initializeProperties() {
        Polymer.telemetry.instanceCount++;
        this.constructor.finalize();
        const importPath = this.constructor.importPath;
        // note: finalize template when we have access to `localName` to
        // avoid dependence on `is` for polyfilling styling.
        this.constructor._finalizeTemplate( /** @type {!HTMLElement} */this.localName);
        super._initializeProperties();
        // set path defaults
        this.rootPath = Polymer.rootPath;
        this.importPath = importPath;
        // apply property defaults...
        let p$ = propertyDefaults(this.constructor);
        if (!p$) {
          return;
        }
        for (let p in p$) {
          let info = p$[p];
          // Don't set default value if there is already an own property, which
          // happens when a `properties` property with default but no effects had
          // a property set (e.g. bound) by its host before upgrade
          if (!this.hasOwnProperty(p)) {
            let value = typeof info.value == 'function' ? info.value.call(this) : info.value;
            // Set via `_setProperty` if there is an accessor, to enable
            // initializing readOnly property defaults
            if (this._hasAccessor(p)) {
              this._setPendingProperty(p, value, true);
            } else {
              this[p] = value;
            }
          }
        }
      }

      /**
       * Gather style text for a style element in the template.
       *
       * @param {string} cssText Text containing styling to process
       * @param {string} baseURI Base URI to rebase CSS paths against
       * @return {string} The processed CSS text
       * @protected
       */
      static _processStyleText(cssText, baseURI) {
        return Polymer.ResolveUrl.resolveCss(cssText, baseURI);
      }

      /**
      * Configures an element `proto` to function with a given `template`.
      * The element name `is` and extends `ext` must be specified for ShadyCSS
      * style scoping.
      *
      * @param {string} is Tag name (or type extension name) for this element
      * @return {void}
      * @protected
      */
      static _finalizeTemplate(is) {
        /** @const {HTMLTemplateElement} */
        const template = this.prototype._template;
        if (template && !template.__polymerFinalized) {
          template.__polymerFinalized = true;
          const importPath = this.importPath;
          const baseURI = importPath ? Polymer.ResolveUrl.resolveUrl(importPath) : '';
          // e.g. support `include="module-name"`, and ShadyCSS
          processElementStyles(this, template, is, baseURI);
          this.prototype._bindTemplate(template);
        }
      }

      /**
       * Provides a default implementation of the standard Custom Elements
       * `connectedCallback`.
       *
       * The default implementation enables the property effects system and
       * flushes any pending properties, and updates shimmed CSS properties
       * when using the ShadyCSS scoping/custom properties polyfill.
       *
       * @suppress {missingProperties, invalidCasts} Super may or may not implement the callback
       * @return {void}
       */
      connectedCallback() {
        if (window.ShadyCSS && this._template) {
          window.ShadyCSS.styleElement( /** @type {!HTMLElement} */this);
        }
        super.connectedCallback();
      }

      /**
       * Stamps the element template.
       *
       * @return {void}
       * @override
       */
      ready() {
        if (this._template) {
          this.root = this._stampTemplate(this._template);
          this.$ = this.root.$;
        }
        super.ready();
      }

      /**
       * Implements `PropertyEffects`'s `_readyClients` call. Attaches
       * element dom by calling `_attachDom` with the dom stamped from the
       * element's template via `_stampTemplate`. Note that this allows
       * client dom to be attached to the element prior to any observers
       * running.
       *
       * @return {void}
       * @override
       */
      _readyClients() {
        if (this._template) {
          this.root = this._attachDom( /** @type {StampedTemplate} */this.root);
        }
        // The super._readyClients here sets the clients initialized flag.
        // We must wait to do this until after client dom is created/attached
        // so that this flag can be checked to prevent notifications fired
        // during this process from being handled before clients are ready.
        super._readyClients();
      }

      /**
       * Attaches an element's stamped dom to itself. By default,
       * this method creates a `shadowRoot` and adds the dom to it.
       * However, this method may be overridden to allow an element
       * to put its dom in another location.
       *
       * @throws {Error}
       * @suppress {missingReturn}
       * @param {StampedTemplate} dom to attach to the element.
       * @return {ShadowRoot} node to which the dom has been attached.
       */
      _attachDom(dom) {
        if (this.attachShadow) {
          if (dom) {
            if (!this.shadowRoot) {
              this.attachShadow({ mode: 'open' });
            }
            this.shadowRoot.appendChild(dom);
            return this.shadowRoot;
          }
          return null;
        } else {
          throw new Error('ShadowDOM not available. ' +
          // TODO(sorvell): move to compile-time conditional when supported
          'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
        }
      }

      /**
       * When using the ShadyCSS scoping and custom property shim, causes all
       * shimmed styles in this element (and its subtree) to be updated
       * based on current custom property values.
       *
       * The optional parameter overrides inline custom property styles with an
       * object of properties where the keys are CSS properties, and the values
       * are strings.
       *
       * Example: `this.updateStyles({'--color': 'blue'})`
       *
       * These properties are retained unless a value of `null` is set.
       *
       * @param {Object=} properties Bag of custom property key/values to
       *   apply to this element.
       * @return {void}
       * @suppress {invalidCasts}
       */
      updateStyles(properties) {
        if (window.ShadyCSS) {
          window.ShadyCSS.styleSubtree( /** @type {!HTMLElement} */this, properties);
        }
      }

      /**
       * Rewrites a given URL relative to a base URL. The base URL defaults to
       * the original location of the document containing the `dom-module` for
       * this element. This method will return the same URL before and after
       * bundling.
       *
       * Note that this function performs no resolution for URLs that start
       * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
       * URL resolution, use `window.URL`.
       *
       * @param {string} url URL to resolve.
       * @param {string=} base Optional base URL to resolve against, defaults
       * to the element's `importPath`
       * @return {string} Rewritten URL relative to base
       */
      resolveUrl(url, base) {
        if (!base && this.importPath) {
          base = Polymer.ResolveUrl.resolveUrl(this.importPath);
        }
        return Polymer.ResolveUrl.resolveUrl(url, base);
      }

      /**
       * Overrides `PropertyAccessors` to add map of dynamic functions on
       * template info, for consumption by `PropertyEffects` template binding
       * code. This map determines which method templates should have accessors
       * created for them.
       *
       * @override
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */
      static _parseTemplateContent(template, templateInfo, nodeInfo) {
        templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;
        return super._parseTemplateContent(template, templateInfo, nodeInfo);
      }

    }

    return PolymerElement;
  });

  /**
   * Provides basic tracking of element definitions (registrations) and
   * instance counts.
   *
   * @namespace
   * @summary Provides basic tracking of element definitions (registrations) and
   * instance counts.
   */
  Polymer.telemetry = {
    /**
     * Total number of Polymer element instances created.
     * @type {number}
     */
    instanceCount: 0,
    /**
     * Array of Polymer element classes that have been finalized.
     * @type {Array<Polymer.Element>}
     */
    registrations: [],
    /**
     * @param {!PolymerElementConstructor} prototype Element prototype to log
     * @this {this}
     * @private
     */
    _regLog: function (prototype) {
      console.log('[' + prototype.is + ']: registered');
    },
    /**
     * Registers a class prototype for telemetry purposes.
     * @param {HTMLElement} prototype Element prototype to register
     * @this {this}
     * @protected
     */
    register: function (prototype) {
      this.registrations.push(prototype);
      Polymer.log && this._regLog(prototype);
    },
    /**
     * Logs all elements registered with an `is` to the console.
     * @public
     * @this {this}
     */
    dumpRegistrations: function () {
      this.registrations.forEach(this._regLog);
    }
  };

  /**
   * When using the ShadyCSS scoping and custom property shim, causes all
   * shimmed `styles` (via `custom-style`) in the document (and its subtree)
   * to be updated based on current custom property values.
   *
   * The optional parameter overrides inline custom property styles with an
   * object of properties where the keys are CSS properties, and the values
   * are strings.
   *
   * Example: `Polymer.updateStyles({'--color': 'blue'})`
   *
   * These properties are retained unless a value of `null` is set.
   *
   * @param {Object=} props Bag of custom property key/values to
   *   apply to the document.
   * @return {void}
   */
  Polymer.updateStyles = function (props) {
    if (window.ShadyCSS) {
      window.ShadyCSS.styleDocument(props);
    }
  };
})();

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(5);

/** @suppress {deprecated} */
(function () {
  'use strict';

  /**
   * Sets the global, legacy settings.
   *
   * @deprecated
   * @namespace
   * @memberof Polymer
   */

  Polymer.Settings = Polymer.Settings || {};

  Polymer.Settings.useShadow = !window.ShadyDOM;
  Polymer.Settings.useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
  Polymer.Settings.useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;

  /**
   * Globally settable property that is automatically assigned to
   * `Polymer.ElementMixin` instances, useful for binding in templates to
   * make URL's relative to an application's root.  Defaults to the main
   * document URL, but can be overridden by users.  It may be useful to set
   * `Polymer.rootPath` to provide a stable application mount path when
   * using client side routing.
   *
   * @memberof Polymer
   */
  let rootPath = Polymer.rootPath || Polymer.ResolveUrl.pathFromUrl(document.baseURI || window.location.href);

  Polymer.rootPath = rootPath;

  /**
   * Sets the global rootPath property used by `Polymer.ElementMixin` and
   * available via `Polymer.rootPath`.
   *
   * @memberof Polymer
   * @param {string} path The new root path
   * @return {void}
   */
  Polymer.setRootPath = function (path) {
    Polymer.rootPath = path;
  };

  /**
   * A global callback used to sanitize any value before inserting it into the DOM. The callback signature is:
   *
   *     Polymer = {
   *       sanitizeDOMValue: function(value, name, type, node) { ... }
   *     }
   *
   * Where:
   *
   * `value` is the value to sanitize.
   * `name` is the name of an attribute or property (for example, href).
   * `type` indicates where the value is being inserted: one of property, attribute, or text.
   * `node` is the node where the value is being inserted.
   *
   * @type {(function(*,string,string,Node):*)|undefined}
   * @memberof Polymer
   */
  let sanitizeDOMValue = Polymer.sanitizeDOMValue;

  // This is needed for tooling
  Polymer.sanitizeDOMValue = sanitizeDOMValue;

  /**
   * Sets the global sanitizeDOMValue available via `Polymer.sanitizeDOMValue`.
   *
   * @memberof Polymer
   * @param {(function(*,string,string,Node):*)|undefined} newSanitizeDOMValue the global sanitizeDOMValue callback
   * @return {void}
   */
  Polymer.setSanitizeDOMValue = function (newSanitizeDOMValue) {
    Polymer.sanitizeDOMValue = newSanitizeDOMValue;
  };

  /**
   * Globally settable property to make Polymer Gestures use passive TouchEvent listeners when recognizing gestures.
   * When set to `true`, gestures made from touch will not be able to prevent scrolling, allowing for smoother
   * scrolling performance.
   * Defaults to `false` for backwards compatibility.
   *
   * @memberof Polymer
   */
  let passiveTouchGestures = false;

  Polymer.passiveTouchGestures = passiveTouchGestures;

  /**
   * Sets `passiveTouchGestures` globally for all elements using Polymer Gestures.
   *
   * @memberof Polymer
   * @param {boolean} usePassive enable or disable passive touch gestures globally
   * @return {void}
   */
  Polymer.setPassiveTouchGestures = function (usePassive) {
    Polymer.passiveTouchGestures = usePassive;
  };
})();

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(5);

(function () {
  'use strict';

  const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
  const INCLUDE_ATTR = 'include';
  const SHADY_UNSCOPED_ATTR = 'shady-unscoped';

  function importModule(moduleId) {
    const /** Polymer.DomModule */PolymerDomModule = customElements.get('dom-module');
    if (!PolymerDomModule) {
      return null;
    }
    return PolymerDomModule.import(moduleId);
  }

  function styleForImport(importDoc) {
    // NOTE: polyfill affordance.
    // under the HTMLImports polyfill, there will be no 'body',
    // but the import pseudo-doc can be used directly.
    let container = importDoc.body ? importDoc.body : importDoc;
    const importCss = Polymer.ResolveUrl.resolveCss(container.textContent, importDoc.baseURI);
    const style = document.createElement('style');
    style.textContent = importCss;
    return style;
  }

  /** @typedef {{assetpath: string}} */
  let templateWithAssetPath; // eslint-disable-line no-unused-vars

  /**
   * Module with utilities for collection CSS text from `<templates>`, external
   * stylesheets, and `dom-module`s.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for collection CSS text from various sources.
   */
  const StyleGather = {

    /**
     * Returns a list of <style> elements in a space-separated list of `dom-module`s.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleIds List of dom-module id's within which to
     * search for css.
     * @return {!Array<!HTMLStyleElement>} Array of contained <style> elements
     * @this {StyleGather}
     */
    stylesFromModules(moduleIds) {
      const modules = moduleIds.trim().split(/\s+/);
      const styles = [];
      for (let i = 0; i < modules.length; i++) {
        styles.push(...this.stylesFromModule(modules[i]));
      }
      return styles;
    },

    /**
     * Returns a list of <style> elements in a given `dom-module`.
     * Styles in a `dom-module` can come either from `<style>`s within the
     * first `<template>`, or else from one or more
     * `<link rel="import" type="css">` links outside the template.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId dom-module id to gather styles from
     * @return {!Array<!HTMLStyleElement>} Array of contained styles.
     * @this {StyleGather}
     */
    stylesFromModule(moduleId) {
      const m = importModule(moduleId);
      if (m && m._styles === undefined) {
        const styles = [];
        // module imports: <link rel="import" type="css">
        styles.push(...this._stylesFromModuleImports(m));
        // include css from the first template in the module
        const template = m.querySelector('template');
        if (template) {
          styles.push(...this.stylesFromTemplate(template,
          /** @type {templateWithAssetPath} */m.assetpath));
        }
        m._styles = styles;
      }
      if (!m) {
        console.warn('Could not find style data in module named', moduleId);
      }
      return m ? m._styles : [];
    },

    /**
     * Returns the `<style>` elements within a given template.
     *
     * @memberof Polymer.StyleGather
     * @param {!HTMLTemplateElement} template Template to gather styles from
     * @param {string} baseURI baseURI for style content
     * @return {!Array<!HTMLStyleElement>} Array of styles
     * @this {StyleGather}
     */
    stylesFromTemplate(template, baseURI) {
      if (!template._styles) {
        const styles = [];
        // if element is a template, get content from its .content
        const e$ = template.content.querySelectorAll('style');
        for (let i = 0; i < e$.length; i++) {
          let e = e$[i];
          // support style sharing by allowing styles to "include"
          // other dom-modules that contain styling
          let include = e.getAttribute(INCLUDE_ATTR);
          if (include) {
            styles.push(...this.stylesFromModules(include));
          }
          if (baseURI) {
            e.textContent = Polymer.ResolveUrl.resolveCss(e.textContent, baseURI);
          }
          styles.push(e);
        }
        template._styles = styles;
      }
      return template._styles;
    },

    /**
     * Returns a list of <style> elements  from stylesheets loaded via `<link rel="import" type="css">` links within the specified `dom-module`.
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId Id of `dom-module` to gather CSS from
     * @return {!Array<!HTMLStyleElement>} Array of contained styles.
     * @this {StyleGather}
     */
    stylesFromModuleImports(moduleId) {
      let m = importModule(moduleId);
      return m ? this._stylesFromModuleImports(m) : [];
    },

    /**
     * @memberof Polymer.StyleGather
     * @this {StyleGather}
     * @param {!HTMLElement} module dom-module element that could contain `<link rel="import" type="css">` styles
     * @return {!Array<!HTMLStyleElement>} Array of contained styles
     */
    _stylesFromModuleImports(module) {
      const styles = [];
      const p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
      for (let i = 0; i < p$.length; i++) {
        let p = p$[i];
        if (p.import) {
          const importDoc = p.import;
          const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);
          if (unscoped && !importDoc._unscopedStyle) {
            const style = styleForImport(importDoc);
            style.setAttribute(SHADY_UNSCOPED_ATTR, '');
            importDoc._unscopedStyle = style;
          } else if (!importDoc._style) {
            importDoc._style = styleForImport(importDoc);
          }
          styles.push(unscoped ? importDoc._unscopedStyle : importDoc._style);
        }
      }
      return styles;
    },

    /**
     *
     * Returns CSS text of styles in a space-separated list of `dom-module`s.
     * Note: This method is deprecated, use `stylesFromModules` instead.
     *
     * @deprecated
     * @memberof Polymer.StyleGather
     * @param {string} moduleIds List of dom-module id's within which to
     * search for css.
     * @return {string} Concatenated CSS content from specified `dom-module`s
     * @this {StyleGather}
     */
    cssFromModules(moduleIds) {
      let modules = moduleIds.trim().split(/\s+/);
      let cssText = '';
      for (let i = 0; i < modules.length; i++) {
        cssText += this.cssFromModule(modules[i]);
      }
      return cssText;
    },

    /**
     * Returns CSS text of styles in a given `dom-module`.  CSS in a `dom-module`
     * can come either from `<style>`s within the first `<template>`, or else
     * from one or more `<link rel="import" type="css">` links outside the
     * template.
     *
     * Any `<styles>` processed are removed from their original location.
     * Note: This method is deprecated, use `styleFromModule` instead.
     *
     * @deprecated
     * @memberof Polymer.StyleGather
     * @param {string} moduleId dom-module id to gather styles from
     * @return {string} Concatenated CSS content from specified `dom-module`
     * @this {StyleGather}
     */
    cssFromModule(moduleId) {
      let m = importModule(moduleId);
      if (m && m._cssText === undefined) {
        // module imports: <link rel="import" type="css">
        let cssText = this._cssFromModuleImports(m);
        // include css from the first template in the module
        let t = m.querySelector('template');
        if (t) {
          cssText += this.cssFromTemplate(t,
          /** @type {templateWithAssetPath} */m.assetpath);
        }
        m._cssText = cssText || null;
      }
      if (!m) {
        console.warn('Could not find style data in module named', moduleId);
      }
      return m && m._cssText || '';
    },

    /**
     * Returns CSS text of `<styles>` within a given template.
     *
     * Any `<styles>` processed are removed from their original location.
     * Note: This method is deprecated, use `styleFromTemplate` instead.
     *
     * @deprecated
     * @memberof Polymer.StyleGather
     * @param {!HTMLTemplateElement} template Template to gather styles from
     * @param {string} baseURI Base URI to resolve the URL against
     * @return {string} Concatenated CSS content from specified template
     * @this {StyleGather}
     */
    cssFromTemplate(template, baseURI) {
      let cssText = '';
      const e$ = this.stylesFromTemplate(template, baseURI);
      // if element is a template, get content from its .content
      for (let i = 0; i < e$.length; i++) {
        let e = e$[i];
        if (e.parentNode) {
          e.parentNode.removeChild(e);
        }
        cssText += e.textContent;
      }
      return cssText;
    },

    /**
     * Returns CSS text from stylesheets loaded via `<link rel="import" type="css">`
     * links within the specified `dom-module`.
     *
     * Note: This method is deprecated, use `stylesFromModuleImports` instead.
     *
     * @deprecated
     *
     * @memberof Polymer.StyleGather
     * @param {string} moduleId Id of `dom-module` to gather CSS from
     * @return {string} Concatenated CSS content from links in specified `dom-module`
     * @this {StyleGather}
     */
    cssFromModuleImports(moduleId) {
      let m = importModule(moduleId);
      return m ? this._cssFromModuleImports(m) : '';
    },

    /**
     * @deprecated
     * @memberof Polymer.StyleGather
     * @this {StyleGather}
     * @param {!HTMLElement} module dom-module element that could contain `<link rel="import" type="css">` styles
     * @return {string} Concatenated CSS content from links in the dom-module
     */
    _cssFromModuleImports(module) {
      let cssText = '';
      let styles = this._stylesFromModuleImports(module);
      for (let i = 0; i < styles.length; i++) {
        cssText += styles[i].textContent;
      }
      return cssText;
    }
  };

  Polymer.StyleGather = StyleGather;
})();

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

(function () {
  'use strict';

  const caseMap = {};
  const DASH_TO_CAMEL = /-[a-z]/g;
  const CAMEL_TO_DASH = /([A-Z])/g;

  /**
   * Module with utilities for converting between "dash-case" and "camelCase"
   * identifiers.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for converting between "dash-case"
   *   and "camelCase".
   */
  const CaseMap = {

    /**
     * Converts "dash-case" identifier (e.g. `foo-bar-baz`) to "camelCase"
     * (e.g. `fooBarBaz`).
     *
     * @memberof Polymer.CaseMap
     * @param {string} dash Dash-case identifier
     * @return {string} Camel-case representation of the identifier
     */
    dashToCamelCase(dash) {
      return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, m => m[1].toUpperCase()));
    },

    /**
     * Converts "camelCase" identifier (e.g. `fooBarBaz`) to "dash-case"
     * (e.g. `foo-bar-baz`).
     *
     * @memberof Polymer.CaseMap
     * @param {string} camel Camel-case identifier
     * @return {string} Dash-case representation of the identifier
     */
    camelToDashCase(camel) {
      return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
    }

  };

  Polymer.CaseMap = CaseMap;
})();

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(1);

__webpack_require__(19);

__webpack_require__(21);

(function () {

  'use strict';

  let caseMap = Polymer.CaseMap;

  // Save map of native properties; this forms a blacklist or properties
  // that won't have their values "saved" by `saveAccessorValue`, since
  // reading from an HTMLElement accessor from the context of a prototype throws
  const nativeProperties = {};
  let proto = HTMLElement.prototype;
  while (proto) {
    let props = Object.getOwnPropertyNames(proto);
    for (let i = 0; i < props.length; i++) {
      nativeProperties[props[i]] = true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  /**
   * Used to save the value of a property that will be overridden with
   * an accessor. If the `model` is a prototype, the values will be saved
   * in `__dataProto`, and it's up to the user (or downstream mixin) to
   * decide how/when to set these values back into the accessors.
   * If `model` is already an instance (it has a `__data` property), then
   * the value will be set as a pending property, meaning the user should
   * call `_invalidateProperties` or `_flushProperties` to take effect
   *
   * @param {Object} model Prototype or instance
   * @param {string} property Name of property
   * @return {void}
   * @private
   */
  function saveAccessorValue(model, property) {
    // Don't read/store value for any native properties since they could throw
    if (!nativeProperties[property]) {
      let value = model[property];
      if (value !== undefined) {
        if (model.__data) {
          // Adding accessor to instance; update the property
          // It is the user's responsibility to call _flushProperties
          model._setPendingProperty(property, value);
        } else {
          // Adding accessor to proto; save proto's value for instance-time use
          if (!model.__dataProto) {
            model.__dataProto = {};
          } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
            model.__dataProto = Object.create(model.__dataProto);
          }
          model.__dataProto[property] = value;
        }
      }
    }
  }

  /**
   * Element class mixin that provides basic meta-programming for creating one
   * or more property accessors (getter/setter pair) that enqueue an async
   * (batched) `_propertiesChanged` callback.
   *
   * For basic usage of this mixin:
   * 
   * -   Declare attributes to observe via the standard `static get observedAttributes()`. Use
   *     `dash-case` attribute names to represent `camelCase` property names. 
   * -   Implement the `_propertiesChanged` callback on the class.
   * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to generate 
   *     property accessors for each observed attribute. This must be called before the first 
   *     instance is created, for example, by calling it before calling `customElements.define`.
   *     It can also be called lazily from the element's `constructor`, as long as it's guarded so
   *     that the call is only made once, when the first instance is created.
   * -   Call `this._enableProperties()` in the element's `connectedCallback` to enable 
   *     the accessors.
   *
   * Any `observedAttributes` will automatically be
   * deserialized via `attributeChangedCallback` and set to the associated
   * property using `dash-case`-to-`camelCase` convention.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.PropertiesChanged
   * @memberof Polymer
   * @summary Element class mixin for reacting to property changes from
   *   generated property accessors.
   */
  Polymer.PropertyAccessors = Polymer.dedupingMixin(superClass => {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_PropertiesChanged}
     * @unrestricted
     */
    const base = Polymer.PropertiesChanged(superClass);

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_PropertyAccessors}
     * @extends {base}
     * @unrestricted
     */
    class PropertyAccessors extends base {

      /**
       * Generates property accessors for all attributes in the standard
       * static `observedAttributes` array.
       *
       * Attribute names are mapped to property names using the `dash-case` to
       * `camelCase` convention
       *
       * @return {void}
       */
      static createPropertiesForAttributes() {
        let a$ = this.observedAttributes;
        for (let i = 0; i < a$.length; i++) {
          this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[i]));
        }
      }

      /**
       * Returns an attribute name that corresponds to the given property.
       * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.
       * @param {string} property Property to convert
       * @return {string} Attribute name corresponding to the given property.
       *
       * @protected
       */
      static attributeNameForProperty(property) {
        return caseMap.camelToDashCase(property);
      }

      /**
       * Overrides PropertiesChanged implementation to initialize values for
       * accessors created for values that already existed on the element
       * prototype.
       *
       * @return {void}
       * @protected
       */
      _initializeProperties() {
        if (this.__dataProto) {
          this._initializeProtoProperties(this.__dataProto);
          this.__dataProto = null;
        }
        super._initializeProperties();
      }

      /**
       * Called at instance time with bag of properties that were overwritten
       * by accessors on the prototype when accessors were created.
       *
       * The default implementation sets these properties back into the
       * setter at instance time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @return {void}
       * @protected
       */
      _initializeProtoProperties(props) {
        for (let p in props) {
          this._setProperty(p, props[p]);
        }
      }

      /**
       * Ensures the element has the given attribute. If it does not,
       * assigns the given value to the attribute.
       *
       * @suppress {invalidCasts} Closure can't figure out `this` is infact an element
       *
       * @param {string} attribute Name of attribute to ensure is set.
       * @param {string} value of the attribute.
       * @return {void}
       */
      _ensureAttribute(attribute, value) {
        const el = /** @type {!HTMLElement} */this;
        if (!el.hasAttribute(attribute)) {
          this._valueToNodeAttribute(el, value, attribute);
        }
      }

      /**
       * Overrides PropertiesChanged implemention to serialize objects as JSON.
       *
       * @param {*} value Property value to serialize.
       * @return {string | undefined} String serialized from the provided property value.
       */
      _serializeValue(value) {
        /* eslint-disable no-fallthrough */
        switch (typeof value) {
          case 'object':
            if (value instanceof Date) {
              return value.toString();
            } else if (value) {
              try {
                return JSON.stringify(value);
              } catch (x) {
                return '';
              }
            }

          default:
            return super._serializeValue(value);
        }
      }

      /**
       * Converts a string to a typed JavaScript value.
       *
       * This method is called by Polymer when reading HTML attribute values to
       * JS properties.  Users may override this method on Polymer element
       * prototypes to provide deserialization for custom `type`s.  Note,
       * the `type` argument is the value of the `type` field provided in the
       * `properties` configuration object for a given property, and is
       * by convention the constructor for the type to deserialize.
       *
       *
       * @param {?string} value Attribute value to deserialize.
       * @param {*=} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       */
      _deserializeValue(value, type) {
        /**
         * @type {*}
         */
        let outValue;
        switch (type) {
          case Object:
            try {
              outValue = JSON.parse( /** @type {string} */value);
            } catch (x) {
              // allow non-JSON literals like Strings and Numbers
              outValue = value;
            }
            break;
          case Array:
            try {
              outValue = JSON.parse( /** @type {string} */value);
            } catch (x) {
              outValue = null;
              console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);
            }
            break;
          case Date:
            outValue = isNaN(value) ? String(value) : Number(value);
            outValue = new Date(outValue);
            break;
          default:
            outValue = super._deserializeValue(value, type);
            break;
        }
        return outValue;
      }
      /* eslint-enable no-fallthrough */

      /**
       * Overrides PropertiesChanged implementation to save existing prototype
       * property value so that it can be reset.
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created
       *
       * When calling on a prototype, any overwritten values are saved in
       * `__dataProto`, and it is up to the subclasser to decide how/when
       * to set those properties back into the accessor.  When calling on an
       * instance, the overwritten value is set via `_setPendingProperty`,
       * and the user should call `_invalidateProperties` or `_flushProperties`
       * for the values to take effect.
       * @protected
       * @return {void}
       */
      _definePropertyAccessor(property, readOnly) {
        saveAccessorValue(this, property);
        super._definePropertyAccessor(property, readOnly);
      }

      /**
       * Returns true if this library created an accessor for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if an accessor was created
       */
      _hasAccessor(property) {
        return this.__dataHasAccessor && this.__dataHasAccessor[property];
      }

      /**
       * Returns true if the specified property has a pending change.
       *
       * @param {string} prop Property name
       * @return {boolean} True if property has a pending change
       * @protected
       */
      _isPropertyPending(prop) {
        return Boolean(this.__dataPending && prop in this.__dataPending);
      }

    }

    return PropertyAccessors;
  });
})();

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(1);

__webpack_require__(6);

(function () {

  'use strict';

  /** @const {!AsyncInterface} */

  const microtask = Polymer.Async.microTask;

  /**
   * Element class mixin that provides basic meta-programming for creating one
   * or more property accessors (getter/setter pair) that enqueue an async
   * (batched) `_propertiesChanged` callback.
   *
   * For basic usage of this mixin, call `MyClass.createProperties(props)`
   * once at class definition time to create property accessors for properties
   * named in props, implement `_propertiesChanged` to react as desired to
   * property changes, and implement `static get observedAttributes()` and
   * include lowercase versions of any property names that should be set from
   * attributes. Last, call `this._enableProperties()` in the element's
   * `connectedCallback` to enable the accessors.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin for reacting to property changes from
   *   generated property accessors.
   */
  Polymer.PropertiesChanged = Polymer.dedupingMixin(superClass => {

    /**
     * @polymer
     * @mixinClass
     * @extends {superClass}
     * @implements {Polymer_PropertiesChanged}
     * @unrestricted
     */
    class PropertiesChanged extends superClass {

      /**
       * Creates property accessors for the given property names.
       * @param {!Object} props Object whose keys are names of accessors.
       * @return {void}
       * @protected
       */
      static createProperties(props) {
        const proto = this.prototype;
        for (let prop in props) {
          // don't stomp an existing accessor
          if (!(prop in proto)) {
            proto._createPropertyAccessor(prop);
          }
        }
      }

      /**
       * Returns an attribute name that corresponds to the given property.
       * The attribute name is the lowercased property name. Override to
       * customize this mapping.
       * @param {string} property Property to convert
       * @return {string} Attribute name corresponding to the given property.
       *
       * @protected
       */
      static attributeNameForProperty(property) {
        return property.toLowerCase();
      }

      /**
       * Override point to provide a type to which to deserialize a value to
       * a given property.
       * @param {string} name Name of property
       *
       * @protected
       */
      static typeForProperty(name) {} //eslint-disable-line no-unused-vars

      /**
       * Creates a setter/getter pair for the named property with its own
       * local storage.  The getter returns the value in the local storage,
       * and the setter calls `_setProperty`, which updates the local storage
       * for the property and enqueues a `_propertiesChanged` callback.
       *
       * This method may be called on a prototype or an instance.  Calling
       * this method may overwrite a property value that already exists on
       * the prototype/instance by creating the accessor.
       *
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created; the
       *   protected `_setProperty` function must be used to set the property
       * @return {void}
       * @protected
       */
      _createPropertyAccessor(property, readOnly) {
        this._addPropertyToAttributeMap(property);
        if (!this.hasOwnProperty('__dataHasAccessor')) {
          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
        }
        if (!this.__dataHasAccessor[property]) {
          this.__dataHasAccessor[property] = true;
          this._definePropertyAccessor(property, readOnly);
        }
      }

      /**
       * Adds the given `property` to a map matching attribute names
       * to property names, using `attributeNameForProperty`. This map is
       * used when deserializing attribute values to properties.
       *
       * @param {string} property Name of the property
       */
      _addPropertyToAttributeMap(property) {
        if (!this.hasOwnProperty('__dataAttributes')) {
          this.__dataAttributes = Object.assign({}, this.__dataAttributes);
        }
        if (!this.__dataAttributes[property]) {
          const attr = this.constructor.attributeNameForProperty(property);
          this.__dataAttributes[attr] = property;
        }
      }

      /**
       * Defines a property accessor for the given property.
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created
       * @return {void}
       */
      _definePropertyAccessor(property, readOnly) {
        Object.defineProperty(this, property, {
          /* eslint-disable valid-jsdoc */
          /** @this {PropertiesChanged} */
          get() {
            return this.__data[property];
          },
          /** @this {PropertiesChanged} */
          set: readOnly ? function () {} : function (value) {
            this._setProperty(property, value);
          }
          /* eslint-enable */
        });
      }

      constructor() {
        super();
        this.__dataEnabled = false;
        this.__dataReady = false;
        this.__dataInvalid = false;
        this.__data = {};
        this.__dataPending = null;
        this.__dataOld = null;
        this.__dataInstanceProps = null;
        this.__serializing = false;
        this._initializeProperties();
      }

      /**
       * Lifecycle callback called when properties are enabled via
       * `_enableProperties`.
       *
       * Users may override this function to implement behavior that is
       * dependent on the element having its property data initialized, e.g.
       * from defaults (initialized from `constructor`, `_initializeProperties`),
       * `attributeChangedCallback`, or values propagated from host e.g. via
       * bindings.  `super.ready()` must be called to ensure the data system
       * becomes enabled.
       *
       * @return {void}
       * @public
       */
      ready() {
        this.__dataReady = true;
        this._flushProperties();
      }

      /**
       * Initializes the local storage for property accessors.
       *
       * Provided as an override point for performing any setup work prior
       * to initializing the property accessor system.
       *
       * @return {void}
       * @protected
       */
      _initializeProperties() {
        // Capture instance properties; these will be set into accessors
        // during first flush. Don't set them here, since we want
        // these to overwrite defaults/constructor assignments
        for (let p in this.__dataHasAccessor) {
          if (this.hasOwnProperty(p)) {
            this.__dataInstanceProps = this.__dataInstanceProps || {};
            this.__dataInstanceProps[p] = this[p];
            delete this[p];
          }
        }
      }

      /**
       * Called at ready time with bag of instance properties that overwrote
       * accessors when the element upgraded.
       *
       * The default implementation sets these properties back into the
       * setter at ready time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @return {void}
       * @protected
       */
      _initializeInstanceProperties(props) {
        Object.assign(this, props);
      }

      /**
       * Updates the local storage for a property (via `_setPendingProperty`)
       * and enqueues a `_proeprtiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @return {void}
       * @protected
       */
      _setProperty(property, value) {
        if (this._setPendingProperty(property, value)) {
          this._invalidateProperties();
        }
      }

      /**
       * Returns the value for the given property.
       * @param {string} property Name of property
       * @return {*} Value for the given property
       * @protected
       */
      _getProperty(property) {
        return this.__data[property];
      }

      /* eslint-disable no-unused-vars */
      /**
       * Updates the local storage for a property, records the previous value,
       * and adds it to the set of "pending changes" that will be passed to the
       * `_propertiesChanged` callback.  This method does not enqueue the
       * `_propertiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @param {boolean=} ext Not used here; affordance for closure
       * @return {boolean} Returns true if the property changed
       * @protected
       */
      _setPendingProperty(property, value, ext) {
        let old = this.__data[property];
        let changed = this._shouldPropertyChange(property, value, old);
        if (changed) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          // Ensure old is captured from the last turn
          if (this.__dataOld && !(property in this.__dataOld)) {
            this.__dataOld[property] = old;
          }
          this.__data[property] = value;
          this.__dataPending[property] = value;
        }
        return changed;
      }
      /* eslint-enable */

      /**
       * Marks the properties as invalid, and enqueues an async
       * `_propertiesChanged` callback.
       *
       * @return {void}
       * @protected
       */
      _invalidateProperties() {
        if (!this.__dataInvalid && this.__dataReady) {
          this.__dataInvalid = true;
          microtask.run(() => {
            if (this.__dataInvalid) {
              this.__dataInvalid = false;
              this._flushProperties();
            }
          });
        }
      }

      /**
       * Call to enable property accessor processing. Before this method is
       * called accessor values will be set but side effects are
       * queued. When called, any pending side effects occur immediately.
       * For elements, generally `connectedCallback` is a normal spot to do so.
       * It is safe to call this method multiple times as it only turns on
       * property accessors once.
       *
       * @return {void}
       * @protected
       */
      _enableProperties() {
        if (!this.__dataEnabled) {
          this.__dataEnabled = true;
          if (this.__dataInstanceProps) {
            this._initializeInstanceProperties(this.__dataInstanceProps);
            this.__dataInstanceProps = null;
          }
          this.ready();
        }
      }

      /**
       * Calls the `_propertiesChanged` callback with the current set of
       * pending changes (and old values recorded when pending changes were
       * set), and resets the pending set of changes. Generally, this method
       * should not be called in user code.
       *
       * @return {void}
       * @protected
       */
      _flushProperties() {
        if (this.__dataPending && this.__dataOld) {
          let changedProps = this.__dataPending;
          this.__dataPending = null;
          this._propertiesChanged(this.__data, changedProps, this.__dataOld);
        }
      }

      /**
       * Callback called when any properties with accessors created via
       * `_createPropertyAccessor` have been set.
       *
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {!Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {!Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {void}
       * @protected
       */
      _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars


      /**
       * Method called to determine whether a property value should be
       * considered as a change and cause the `_propertiesChanged` callback
       * to be enqueued.
       *
       * The default implementation returns `true` if a strict equality
       * check fails. The method always returns false for `NaN`.
       *
       * Override this method to e.g. provide stricter checking for
       * Objects/Arrays when using immutable patterns.
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       *   and enqueue a `_proeprtiesChanged` callback
       * @protected
       */
      _shouldPropertyChange(property, value, old) {
        return (
          // Strict equality check
          old !== value && (
          // This ensures (old==NaN, value==NaN) always returns false
          old === old || value === value)
        );
      }

      /**
       * Implements native Custom Elements `attributeChangedCallback` to
       * set an attribute value to a property via `_attributeToProperty`.
       *
       * @param {string} name Name of attribute that changed
       * @param {?string} old Old attribute value
       * @param {?string} value New attribute value
       * @return {void}
       * @suppress {missingProperties} Super may or may not implement the callback
       */
      attributeChangedCallback(name, old, value) {
        if (old !== value) {
          this._attributeToProperty(name, value);
        }
        if (super.attributeChangedCallback) {
          super.attributeChangedCallback(name, old, value);
        }
      }

      /**
       * Deserializes an attribute to its associated property.
       *
       * This method calls the `_deserializeValue` method to convert the string to
       * a typed value.
       *
       * @param {string} attribute Name of attribute to deserialize.
       * @param {?string} value of the attribute.
       * @param {*=} type type to deserialize to, defaults to the value
       * returned from `typeForProperty`
       * @return {void}
       */
      _attributeToProperty(attribute, value, type) {
        if (!this.__serializing) {
          const map = this.__dataAttributes;
          const property = map && map[attribute] || attribute;
          this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));
        }
      }

      /**
       * Serializes a property to its associated attribute.
       *
       * @suppress {invalidCasts} Closure can't figure out `this` is an element.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect to.
       * @param {*=} value Property value to refect.
       * @return {void}
       */
      _propertyToAttribute(property, attribute, value) {
        this.__serializing = true;
        value = arguments.length < 3 ? this[property] : value;
        this._valueToNodeAttribute( /** @type {!HTMLElement} */this, value, attribute || this.constructor.attributeNameForProperty(property));
        this.__serializing = false;
      }

      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * This method calls the `_serializeValue` method to convert the typed
       * value to a string.  If the `_serializeValue` method returns `undefined`,
       * the attribute will be removed (this is the default for boolean
       * type `false`).
       *
       * @param {Element} node Element to set attribute to.
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       * @return {void}
       */
      _valueToNodeAttribute(node, value, attribute) {
        const str = this._serializeValue(value);
        if (str === undefined) {
          node.removeAttribute(attribute);
        } else {
          node.setAttribute(attribute, str);
        }
      }

      /**
       * Converts a typed JavaScript value to a string.
       *
       * This method is called when setting JS property values to
       * HTML attributes.  Users may override this method to provide
       * serialization for custom types.
       *
       * @param {*} value Property value to serialize.
       * @return {string | undefined} String serialized from the provided
       * property  value.
       */
      _serializeValue(value) {
        switch (typeof value) {
          case 'boolean':
            return value ? '' : undefined;
          default:
            return value != null ? value.toString() : undefined;
        }
      }

      /**
       * Converts a string to a typed JavaScript value.
       *
       * This method is called when reading HTML attribute values to
       * JS properties.  Users may override this method to provide
       * deserialization for custom `type`s. Types for `Boolean`, `String`,
       * and `Number` convert attributes to the expected types.
       *
       * @param {?string} value Value to deserialize.
       * @param {*=} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       */
      _deserializeValue(value, type) {
        switch (type) {
          case Boolean:
            return value !== null;
          case Number:
            return Number(value);
          default:
            return value;
        }
      }

    }

    return PropertiesChanged;
  });
})();

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(1);

__webpack_require__(36);

(function () {

  'use strict';

  /**
   * @const {Polymer.Gestures}
   */

  const gestures = Polymer.Gestures;

  /**
   * Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes.
   *
   * The API is designed to be compatible with override points implemented
   * in `Polymer.TemplateStamp` such that declarative event listeners in
   * templates will support gesture events when this mixin is applied along with
   * `Polymer.TemplateStamp`.
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes
   */
  Polymer.GestureEventListeners = Polymer.dedupingMixin(superClass => {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_GestureEventListeners}
     */
    class GestureEventListeners extends superClass {

      /**
       * Add the event listener to the node if it is a gestures event.
       *
       * @param {!Node} node Node to add event listener to
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to add
       * @return {void}
       */
      _addEventListenerToNode(node, eventName, handler) {
        if (!gestures.addListener(node, eventName, handler)) {
          super._addEventListenerToNode(node, eventName, handler);
        }
      }

      /**
       * Remove the event listener to the node if it is a gestures event.
       *
       * @param {!Node} node Node to remove event listener from
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to remove
       * @return {void}
       */
      _removeEventListenerFromNode(node, eventName, handler) {
        if (!gestures.removeListener(node, eventName, handler)) {
          super._removeEventListenerFromNode(node, eventName, handler);
        }
      }

    }

    return GestureEventListeners;
  });
})();

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

(function () {

  'use strict';

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  const EDIT_LEAVE = 0;
  const EDIT_UPDATE = 1;
  const EDIT_ADD = 2;
  const EDIT_DELETE = 3;

  // Note: This function is *based* on the computation of the Levenshtein
  // "edit" distance. The one change is that "updates" are treated as two
  // edits - not one. With Array splices, an update is really a delete
  // followed by an add. By retaining this, we optimize for "keeping" the
  // maximum array items in the original array. For example:
  //
  //   'xxxx123' -> '123yyyy'
  //
  // With 1-edit updates, the shortest path would be just to update all seven
  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
  // leaves the substring '123' intact.
  function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    // "Deletion" columns
    let rowCount = oldEnd - oldStart + 1;
    let columnCount = currentEnd - currentStart + 1;
    let distances = new Array(rowCount);

    // "Addition" rows. Initialize null column.
    for (let i = 0; i < rowCount; i++) {
      distances[i] = new Array(columnCount);
      distances[i][0] = i;
    }

    // Initialize null row
    for (let j = 0; j < columnCount; j++) distances[0][j] = j;

    for (let i = 1; i < rowCount; i++) {
      for (let j = 1; j < columnCount; j++) {
        if (equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1];else {
          let north = distances[i - 1][j] + 1;
          let west = distances[i][j - 1] + 1;
          distances[i][j] = north < west ? north : west;
        }
      }
    }

    return distances;
  }

  // This starts at the final weight, and walks "backward" by finding
  // the minimum previous weight recursively until the origin of the weight
  // matrix.
  function spliceOperationsFromEditDistances(distances) {
    let i = distances.length - 1;
    let j = distances[0].length - 1;
    let current = distances[i][j];
    let edits = [];
    while (i > 0 || j > 0) {
      if (i == 0) {
        edits.push(EDIT_ADD);
        j--;
        continue;
      }
      if (j == 0) {
        edits.push(EDIT_DELETE);
        i--;
        continue;
      }
      let northWest = distances[i - 1][j - 1];
      let west = distances[i - 1][j];
      let north = distances[i][j - 1];

      let min;
      if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

      if (min == northWest) {
        if (northWest == current) {
          edits.push(EDIT_LEAVE);
        } else {
          edits.push(EDIT_UPDATE);
          current = northWest;
        }
        i--;
        j--;
      } else if (min == west) {
        edits.push(EDIT_DELETE);
        i--;
        current = west;
      } else {
        edits.push(EDIT_ADD);
        j--;
        current = north;
      }
    }

    edits.reverse();
    return edits;
  }

  /**
   * Splice Projection functions:
   *
   * A splice map is a representation of how a previous array of items
   * was transformed into a new array of items. Conceptually it is a list of
   * tuples of
   *
   *   <index, removed, addedCount>
   *
   * which are kept in ascending index order of. The tuple represents that at
   * the |index|, |removed| sequence of items were removed, and counting forward
   * from |index|, |addedCount| items were added.
   */

  /**
   * Lacking individual splice mutation information, the minimal set of
   * splices can be synthesized given the previous state and final state of an
   * array. The basic approach is to calculate the edit distance matrix and
   * choose the shortest path through it.
   *
   * Complexity: O(l * p)
   *   l: The length of the current array
   *   p: The length of the old array
   *
   * @param {!Array} current The current "changed" array for which to
   * calculate splices.
   * @param {number} currentStart Starting index in the `current` array for
   * which splices are calculated.
   * @param {number} currentEnd Ending index in the `current` array for
   * which splices are calculated.
   * @param {!Array} old The original "unchanged" array to compare `current`
   * against to determine splices.
   * @param {number} oldStart Starting index in the `old` array for
   * which splices are calculated.
   * @param {number} oldEnd Ending index in the `old` array for
   * which splices are calculated.
   * @return {!Array} Returns an array of splice record objects. Each of these
   * contains: `index` the location where the splice occurred; `removed`
   * the array of removed items from this location; `addedCount` the number
   * of items added at this location.
   */
  function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    let prefixCount = 0;
    let suffixCount = 0;
    let splice;

    let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);

    if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);

    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;

    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

    if (currentStart == currentEnd) {
      splice = newSplice(currentStart, [], 0);
      while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);

      return [splice];
    } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

    let ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

    splice = undefined;
    let splices = [];
    let index = currentStart;
    let oldIndex = oldStart;
    for (let i = 0; i < ops.length; i++) {
      switch (ops[i]) {
        case EDIT_LEAVE:
          if (splice) {
            splices.push(splice);
            splice = undefined;
          }

          index++;
          oldIndex++;
          break;
        case EDIT_UPDATE:
          if (!splice) splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
        case EDIT_ADD:
          if (!splice) splice = newSplice(index, [], 0);

          splice.addedCount++;
          index++;
          break;
        case EDIT_DELETE:
          if (!splice) splice = newSplice(index, [], 0);

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
      }
    }

    if (splice) {
      splices.push(splice);
    }
    return splices;
  }

  function sharedPrefix(current, old, searchLength) {
    for (let i = 0; i < searchLength; i++) if (!equals(current[i], old[i])) return i;
    return searchLength;
  }

  function sharedSuffix(current, old, searchLength) {
    let index1 = current.length;
    let index2 = old.length;
    let count = 0;
    while (count < searchLength && equals(current[--index1], old[--index2])) count++;

    return count;
  }

  function calculateSplices(current, previous) {
    return calcSplices(current, 0, current.length, previous, 0, previous.length);
  }

  function equals(currentValue, previousValue) {
    return currentValue === previousValue;
  }

  /**
   * @namespace
   * @memberof Polymer
   * @summary Module that provides utilities for diffing arrays.
   */
  Polymer.ArraySplice = {
    /**
     * Returns an array of splice records indicating the minimum edits required
     * to transform the `previous` array into the `current` array.
     *
     * Splice records are ordered by index and contain the following fields:
     * - `index`: index where edit started
     * - `removed`: array of removed items from this index
     * - `addedCount`: number of items added at this index
     *
     * This function is based on the Levenshtein "minimum edit distance"
     * algorithm. Note that updates are treated as removal followed by addition.
     *
     * The worst-case time complexity of this algorithm is `O(l * p)`
     *   l: The length of the current array
     *   p: The length of the previous array
     *
     * However, the worst-case complexity is reduced by an `O(n)` optimization
     * to detect any shared prefix & suffix between the two arrays and only
     * perform the more expensive minimum edit distance calculation over the
     * non-shared portions of the arrays.
     *
     * @function
     * @memberof Polymer.ArraySplice
     * @param {!Array} current The "changed" array for which splices will be
     * calculated.
     * @param {!Array} previous The "unchanged" original array to compare
     * `current` against to determine the splices.
     * @return {!Array} Returns an array of splice record objects. Each of these
     * contains: `index` the location where the splice occurred; `removed`
     * the array of removed items from this location; `addedCount` the number
     * of items added at this location.
     */
    calculateSplices
  };
})();

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

(function () {
  'use strict';

  /**
   * Class representing a static string value which can be used to filter
   * strings by asseting that they have been created via this class. The
   * `value` property returns the string passed to the constructor.
   */

  class LiteralString {
    constructor(string) {
      /** @type {string} */
      this.value = string.toString();
    }
    /**
     * @return {string} LiteralString string value
     */
    toString() {
      return this.value;
    }
  }

  /**
   * @param {*} value Object to stringify into HTML
   * @return {string} HTML stringified form of `obj`
   */
  function literalValue(value) {
    if (value instanceof LiteralString) {
      return (/** @type {!LiteralString} */value.value
      );
    } else {
      throw new Error(`non-literal value passed to Polymer.htmlLiteral: ${value}`);
    }
  }

  /**
   * @param {*} value Object to stringify into HTML
   * @return {string} HTML stringified form of `obj`
   */
  function htmlValue(value) {
    if (value instanceof HTMLTemplateElement) {
      return (/** @type {!HTMLTemplateElement } */value.innerHTML
      );
    } else if (value instanceof LiteralString) {
      return literalValue(value);
    } else {
      throw new Error(`non-template value passed to Polymer.html: ${value}`);
    }
  }

  /**
   * A template literal tag that creates an HTML <template> element from the
   * contents of the string.
   *
   * This allows you to write a Polymer Template in JavaScript.
   *
   * Templates can be composed by interpolating `HTMLTemplateElement`s in
   * expressions in the JavaScript template literal. The nested template's
   * `innerHTML` is included in the containing template.  The only other
   * values allowed in expressions are those returned from `Polymer.htmlLiteral`
   * which ensures only literal values from JS source ever reach the HTML, to
   * guard against XSS risks.
   *
   * All other values are disallowed in expressions to help prevent XSS
   * attacks; however, `Polymer.htmlLiteral` can be used to compose static
   * string values into templates. This is useful to compose strings into
   * places that do not accept html, like the css text of a `style`
   * element.
   *
   * Example:
   *
   *   static get template() {
   *     return Polymer.html`
   *       <style>:host{ content:"..." }</style>
   *       <div class="shadowed">${this.partialTemplate}</div>
   *       ${super.template}
   *     `;
   *   }
   *   static get partialTemplate() { return Polymer.html`<span>Partial!</span>`; }
   *
   * @memberof Polymer
   * @param {!ITemplateArray} strings Constant parts of tagged template literal
   * @param {...*} values Variable parts of tagged template literal
   * @return {!HTMLTemplateElement} Constructed HTMLTemplateElement
   */
  Polymer.html = function html(strings, ...values) {
    const template = /** @type {!HTMLTemplateElement} */document.createElement('template');
    template.innerHTML = values.reduce((acc, v, idx) => acc + htmlValue(v) + strings[idx + 1], strings[0]);
    return template;
  };

  /**
   * An html literal tag that can be used with `Polymer.html` to compose.
   * a literal string.
   *
   * Example:
   *
   *   static get template() {
   *     return Polymer.html`
   *       <style>
   *         :host { display: block; }
   *         ${styleTemplate}
   *       </style>
   *       <div class="shadowed">${staticValue}</div>
   *       ${super.template}
   *     `;
   *   }
   *   static get styleTemplate() { return Polymer.htmlLiteral`.shadowed { background: gray; }`; }
   *
   * @memberof Polymer
   * @param {!ITemplateArray} strings Constant parts of tagged template literal
   * @param {...*} values Variable parts of tagged template literal
   * @return {!LiteralString} Constructed literal string
   */
  Polymer.htmlLiteral = function (strings, ...values) {
    return new LiteralString(values.reduce((acc, v, idx) => acc + literalValue(v) + strings[idx + 1], strings[0]));
  };
})();

/***/ }),
/* 25 */
/***/ (function(module, exports) {

/* eslint-env browser */

class RegisterHtmlTemplate {
  /**
   * Create a `<template>` element to hold `<dom-module>` content.
   * This bit of code will execute in the context of the main document,
   * calling `importNode` on the `<template>`, which in turn triggers
   * the lifecycle of the `<dom-module>` and allows it to insert its
   * content into Polymer's global module map. When a Polymer element
   * boots up it will fetch its template from this module map.
   * https://github.com/Polymer/polymer/blob/master/lib/mixins/element-mixin.html#L501-L538
   * @param {string} val A `<dom-module>` as an HTML string
   */
  static register(val) {
    let content;
    const template = document.createElement('template');
    template.innerHTML = val;
    if (template.content) {
      content = template.content; // eslint-disable-line prefer-destructuring
    } else {
      content = document.createDocumentFragment();
      while (template.firstChild) {
        content.appendChild(template.firstChild);
      }
    }
    document.importNode(content, true);
  }
  /**
   * Content that will be injected into the main document. This is primarily
   * for things like `<iron-iconset>` and `<custom-style>` which do not have
   * templates but rely on HTML Imports ability to apply content to the main
   * document.
   * @param {string} val An HTML string
   */
  static toBody(val) {
    const trimmedVal = val.trim();
    if (trimmedVal) {
      const div = document.createElement('div');
      div.innerHTML = trimmedVal;
      if (div.firstChild) {
        if (document.body) {
          document.body.insertBefore(div.firstChild, document.body.firstChild);
        } else {
          document.addEventListener('DOMContentLoaded', () => {
            document.body.insertBefore(div.firstChild, document.body.firstChild);
          });
        }
      }
    }
  }
}

module.exports = RegisterHtmlTemplate;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if (( false ? 'undefined' : _typeof2(exports)) === 'object' && ( false ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory(__webpack_require__(4));else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports["ClapprMarkersPlugin"] = factory(require("Clappr"));else root["ClapprMarkersPlugin"] = factory(root["Clappr"]);
})(undefined, function (__WEBPACK_EXTERNAL_MODULE_1__) {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};

			/******/ // The require function
			/******/function __webpack_require__(moduleId) {

				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;

				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };

				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

				/******/ // Flag the module as loaded
				/******/module.loaded = true;

				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}

			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;

			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;

			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";

			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			Object.defineProperty(exports, "__esModule", { value: true });var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}();var _clappr = __webpack_require__(1);__webpack_require__(27);var _marker = __webpack_require__(4);var _marker2 = _interopRequireDefault(_marker);var _standardMarker = __webpack_require__(24);var _standardMarker2 = _interopRequireDefault(_standardMarker);var _cropMarker = __webpack_require__(22);var _cropMarker2 = _interopRequireDefault(_cropMarker);var _imageMarker = __webpack_require__(23);var _imageMarker2 = _interopRequireDefault(_imageMarker);function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			}var MarkersPlugin = function (_UICorePlugin) {
				_inherits(MarkersPlugin, _UICorePlugin);_createClass(MarkersPlugin, [{ key: 'name', get: function get() {
						return 'markers-plugin';
					} }, { key: 'attributes', get: function get() {
						return { 'class': this.name };
					} }], [{ key: 'Marker', get: function get() {
						return _marker2.default;
					} }, { key: 'StandardMarker', get: function get() {
						return _standardMarker2.default;
					} }, { key: 'CropMarker', get: function get() {
						return _cropMarker2.default;
					} }, { key: 'ImageMarker', get: function get() {
						return _imageMarker2.default;
					} // backwards compatibility
				}, { key: 'default', get: function get() {
						return MarkersPlugin;
					} }]);function MarkersPlugin(core) {
					_classCallCheck(this, MarkersPlugin);var _this = _possibleConstructorReturn(this, (MarkersPlugin.__proto__ || Object.getPrototypeOf(MarkersPlugin)).call(this, core));_this._markers = [];_this._duration = null;_this._createInitialMarkers();return _this;
				}_createClass(MarkersPlugin, [{ key: 'bindEvents', value: function bindEvents() {
						this.listenTo(this.core.mediaControl, _clappr.Events.MEDIACONTROL_RENDERED, this._onMediaControlRendered);this.listenTo(this.core.mediaControl, _clappr.Events.MEDIACONTROL_CONTAINERCHANGED, this._onMediaControlContainerChanged);
					} /*
       * Add a new marker.
       */ }, { key: 'addMarker', value: function addMarker(marker) {
						var internalMarker = this._buildInternalMarker(marker);this._markers.push(internalMarker);this._createMarkerEl(internalMarker);this._renderMarkers();
					} /*
       * Remove a marker which has previously been added.
       * Returns true if the marker was removed, false if it didn't exist.
       */ }, { key: 'removeMarker', value: function removeMarker(marker) {
						debugger;var internalMarker = null;var index = 0;this._markers.some(function (a) {
							if (a.source === marker) {
								internalMarker = a;return true;
							}index++;return false;
						});if (!internalMarker) {
							return false;
						}this._removeInternalMarker(index);return true;
					} }, { key: '_removeInternalMarker', value: function _removeInternalMarker(index) {
						var internalMarker = this._markers[index];internalMarker.$marker.remove();internalMarker.emitter.off("timeChanged", internalMarker.timeChangedHandler);if (internalMarker.$tooltipContainer) {
							internalMarker.$tooltipContainer.remove();
						}if (internalMarker.tooltipChangedHandler) {
							internalMarker.emitter.off("tooltipChanged", internalMarker.tooltipChangedHandler);
						}internalMarker.onDestroy();this._markers.splice(index, 1);
					} /*
       * Clear all existing markers
       */ }, { key: 'clearMarkers', value: function clearMarkers() {
						if (!this._markers) {
							return;
						}for (var i = this._markers.length - 1; i >= 0; i--) {
							this._removeInternalMarker(i);
						}
					} /*
       * Get all markers
       */ }, { key: 'getAll', value: function getAll() {
						return this._markers.map(function (internalMarker) {
							return internalMarker.source;
						});
					} /*
       * Get marker by index. Can be used with removeMarker() to remove a marker by index.
       */ }, { key: 'getByIndex', value: function getByIndex(index) {
						if (index >= this._markers.length || index < 0) {
							return null;
						}return this._markers[index].source;
					} }, { key: '_bindContainerEvents', value: function _bindContainerEvents() {
						if (this._oldContainer) {
							this.stopListening(this._oldContainer, _clappr.Events.CONTAINER_TIMEUPDATE, this._onTimeUpdate);this.stopListening(this._oldContainer, _clappr.Events.CONTAINER_MEDIACONTROL_SHOW, this._onMediaControlShow);
						}this._oldContainer = this.core.mediaControl.container;this.listenTo(this.core.mediaControl.container, _clappr.Events.CONTAINER_TIMEUPDATE, this._onTimeUpdate);this.listenTo(this.core.mediaControl.container, _clappr.Events.CONTAINER_MEDIACONTROL_SHOW, this._onMediaControlShow);
					} }, { key: '_getOptions', value: function _getOptions() {
						if (!("markersPlugin" in this.core.options)) {
							throw "'markersPlugin' property missing from options object.";
						}return this.core.options.markersPlugin;
					} // build a marker object for internal use from the provided Marker
				}, { key: '_buildInternalMarker', value: function _buildInternalMarker(marker) {
						var $tooltip = marker.getTooltipEl();if ($tooltip) {
							console.log('there is a tooltip');$tooltip = (0, _clappr.$)($tooltip);
						}marker.videoDuration = this._duration;marker.core = this.core;console.log(marker.videoDuration);return { source: marker, emitter: marker.getEmitter(), $marker: marker.getMarkerEl(), markerLeft: null, $tooltip: $tooltip, $tooltipContainer: null, tooltipContainerLeft: null, tooltipContainerBottom: null, tooltipChangedHandler: null, time: marker.getTime(), duration: marker.getDuration ? marker.getDuration() : undefined, timeChangedHandler: null, onDestroy: marker.onDestroy };
					} }, { key: '_createInitialMarkers', value: function _createInitialMarkers() {
						var _this2 = this;var markers = this._getOptions().markers;if (!markers) {
							return;
						}this._markers = [];markers.forEach(function (a) {
							_this2._markers.push(_this2._buildInternalMarker(a));
						}); // append the marker elements to the dom
						this._markers.forEach(function (marker) {
							_this2._createMarkerEl(marker);
						});this._renderMarkers();
					} }, { key: '_createMarkerEl', value: function _createMarkerEl(marker) {
						var _this3 = this; // marker
						var $marker = marker.$marker;marker.timeChangedHandler = function () {
							// fired from marker if it's time changes
							_this3._updateMarkerTime(marker);
						};marker.emitter.on("timeChanged", marker.timeChangedHandler);$marker.click(function (e) {
							// when marker clicked seek to the exact time represented by the marker
							_this3.core.mediaControl.container.seek(marker.time);e.preventDefault();e.stopImmediatePropagation();
						});this._$markers.appendChild($marker); // tooltip
						var $tooltip = marker.$tooltip;if ($tooltip) {
							console.log('there is a tooltip'); // there is a tooltip
							var $tooltipContainer = (0, _clappr.$)("<div />").addClass("tooltip-container");marker.$tooltipContainer = $tooltipContainer;$tooltipContainer.append($tooltip);this._$tooltips.append($tooltipContainer);marker.tooltipChangedHandler = function () {
								// fired from marker if it's tooltip contents changes
								_this3._updateTooltipPosition(marker);
							};marker.emitter.on("tooltipChanged", marker.tooltipChangedHandler);this._updateTooltipPosition(marker);
						}
					} }, { key: '_updateMarkerTime', value: function _updateMarkerTime(marker) {
						marker.time = marker.source.getTime();this._renderMarkers();
					} // calculates and sets the position of the tooltip
				}, { key: '_updateTooltipPosition', value: function _updateTooltipPosition(marker) {
						if (!this._mediaControlContainerLoaded || !this._duration) {
							// renderMarkers() will be called when it has loaded, which will call this
							return;
						}var $tooltipContainer = marker.$tooltipContainer;if (!$tooltipContainer) {
							// no tooltip
							return;
						}var bottomMargin = this._getOptions().tooltipBottomMargin || 17;var width = $tooltipContainer.width();var seekBarWidth = this._$tooltips.width();var leftPos = seekBarWidth * (marker.time / this._duration) - width / 2;leftPos = Math.max(0, Math.min(leftPos, seekBarWidth - width));if (bottomMargin !== marker.tooltipContainerBottom || leftPos !== marker.tooltipContainerLeft) {
							$tooltipContainer.css({ bottom: bottomMargin + "px", left: leftPos + "px" });marker.tooltipContainerBottom = bottomMargin;marker.tooltipContainerLeft = leftPos;
						}
					} }, { key: '_onMediaControlRendered', value: function _onMediaControlRendered() {
						this._appendElToMediaControl();
					} }, { key: '_updateDuration', value: function _updateDuration() {
						var _this4 = this;this._duration = this.core.mediaControl.container.getDuration() || null;this.getAll().forEach(function (marker) {
							marker.videoDuration = _this4._duration;
						});
					} }, { key: '_onMediaControlContainerChanged', value: function _onMediaControlContainerChanged() {
						this._bindContainerEvents();this._mediaControlContainerLoaded = true;this._updateDuration();this._renderMarkers();
					} }, { key: '_onTimeUpdate', value: function _onTimeUpdate() {
						// need to render on time update because if duration is increasing
						// markers will need to be repositioned
						this._updateDuration();this._renderMarkers();
					} }, { key: '_onMediaControlShow', value: function _onMediaControlShow() {
						this._renderMarkers();
					} }, { key: '_renderMarkers', value: function _renderMarkers() {
						var _this5 = this;if (!this._mediaControlContainerLoaded || !this._duration) {
							// this will be called again once loaded, or there is a duration > 0
							return;
						}this._markers.forEach(function (marker) {
							marker.source.render();_this5._updateTooltipPosition(marker);
						});
					} }, { key: '_appendElToMediaControl', value: function _appendElToMediaControl() {
						this.core.mediaControl.$el.find(".bar-container").first().append(this.el);
					} }, { key: 'render', value: function render() {
						this._$markers = document.createElement('div');this._$markers.classList.add("markers-plugin-markers");this._$tooltips = document.createElement('div');this._$tooltips.classList.add("markers-plugin-tooltips");this.el.appendChild(this._$markers);this.el.appendChild(this._$tooltips);this._appendElToMediaControl();return this;
					} }, { key: 'destroy', value: function destroy() {
						// remove any listeners and call onDestroy()
						this._markers.forEach(function (marker) {
							if (marker.tooltipChangedHandler) {
								marker.emitter.off("timeChanged", marker.timeChangedHandler);marker.emitter.off("tooltipChanged", marker.tooltipChangedHandler);
							}marker.onDestroy();
						});
					} }]);return MarkersPlugin;
			}(_clappr.UICorePlugin);exports.default = MarkersPlugin;module.exports = exports['default'];

			/***/
		},
		/* 1 */
		/***/function (module, exports) {

			module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

			/***/
		},
		/* 2 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			var _undefined = __webpack_require__(7)(); // Support ES3 engines
			module.exports = function (val) {
				return val !== _undefined && val !== null;
			};

			/***/
		},
		/* 3 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			Object.defineProperty(exports, "__esModule", { value: true });var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}();var _clappr = __webpack_require__(1);var _marker = __webpack_require__(4);var _marker2 = _interopRequireDefault(_marker);function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			}var BaseMarker = function (_Marker) {
				_inherits(BaseMarker, _Marker);function BaseMarker(time) {
					_classCallCheck(this, BaseMarker);var _this = _possibleConstructorReturn(this, (BaseMarker.__proto__ || Object.getPrototypeOf(BaseMarker)).call(this));_this._time = time;_this._$marker = _this._buildMarkerEl();_this._$tooltip = null;return _this;
				} /*
      * Should return the time (in seconds) that this marker represents.
      */_createClass(BaseMarker, [{ key: 'getTime', value: function getTime() {
						return this._time;
					} /*
       * Set a new time for this marker.
       */ }, { key: 'setTime', value: function setTime(time) {
						this._time = time;this.notifyTimeChanged();
					} /*
       * Should return the dom element which should represent the marker.
       * It will be inserted onto the seek bar and kept at the correct location.
       */ }, { key: 'getMarkerEl', value: function getMarkerEl() {
						return this._$marker;
					} /*
       * Should return the dom element which is the tool tip,
       * or null if there is no tool tip for this marker.
       *
       * The tooltip will placed above the marker element, inside a container,
       * and this containers position will be managed for you.
       */ }, { key: 'getTooltipEl', value: function getTooltipEl() {
						return this._$tooltip;
					} }, { key: '_buildMarkerEl', value: function _buildMarkerEl() {
						var $marker = (0, _clappr.$)('<div />').addClass('standard-marker');$marker.append((0, _clappr.$)('<div />').addClass('standard-marker-inner'));return $marker;
					} /*
       * Set the tooltip element for this marker.
       *
       * The tooltip will placed above the marker element, inside a container,
       * and this containers position will be managed for you.
       */ }, { key: '_setTooltipEl', value: function _setTooltipEl($el) {
						if (this._$tooltip) {
							throw new Error("Tooltip can only be set once.");
						}this._$tooltip = $el;this._addListenersForTooltip();
					} }, { key: '_addListenersForTooltip', value: function _addListenersForTooltip() {
						var _this2 = this;if (!this._$tooltip) {
							return;
						}var $marker = this._$marker;var hovering = false;$marker.bind('mouseover', function () {
							if (hovering) {
								return;
							}hovering = true;_this2._$tooltip.attr('data-show', '1');_this2.notifyTooltipChanged();
						});$marker.bind('mouseout', function () {
							if (!hovering) {
								return;
							}hovering = false;_this2._$tooltip.attr('data-show', '0');
						});
					} }]);return BaseMarker;
			}(_marker2.default);exports.default = BaseMarker;module.exports = exports['default'];

			/***/
		},
		/* 4 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			Object.defineProperty(exports, "__esModule", { value: true });var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}();var _eventEmitter = __webpack_require__(21);var _eventEmitter2 = _interopRequireDefault(_eventEmitter);function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			} /*
     * This represents and Marker and should be extended.
     */var Marker = function () {
				function Marker() {
					_classCallCheck(this, Marker);this._emitter = new _eventEmitter2.default({});this.initAttributes();
				} /*
      * Get the event emitter.
      * Used by the plugin and notifyTooltipChanged() method
      */_createClass(Marker, [{ key: "getEmitter", value: function getEmitter() {
						return this._emitter;
					} /*
       * Call this to notify the plugin that the time of the marker
       * has changed so that it's position can be recalculated and changed
       * if necessary.
       */ }, { key: "notifyTimeChanged", value: function notifyTimeChanged() {
						this._emitter.emit("timeChanged");
					} /*
       * Call this to notify the plugin that the contents of the tooltip
       * has changed so that it's position will be recalculated and changed
       * if necessary.
       */ }, { key: "notifyTooltipChanged", value: function notifyTooltipChanged() {
						this._emitter.emit("tooltipChanged");
					} /*
       * Should return the time (in seconds) that this marker represents.
       */ }, { key: "getTime", value: function getTime() {
						throw "Not implemented!";
					} /*
       * Should return the dom element which should represent the marker.
       * It will be inserted onto the seek bar and kept at the correct location.
       */ }, { key: "getMarkerEl", value: function getMarkerEl() {
						throw "Not implemented!";
					} /*
       * Should return the dom element which is the tool tip,
       * or null if there is no tool tip for this marker.
       *
       * The tooltip will placed above the marker element, inside a container,
       * and this containers position will be managed for you.
       */ }, { key: "getTooltipEl", value: function getTooltipEl() {
						throw "Not implemented!";
					} /*
       * Called when the marker is removed.
       */ }, { key: "onDestroy", value: function onDestroy() {// default to doing nothing
					} }, { key: "initAttributes", value: function initAttributes() {
						this.videoDuration = 0;
					} }]);return Marker;
			}();exports.default = Marker;module.exports = exports["default"];

			/***/
		},
		/* 5 */
		/***/function (module, exports) {

			"use strict"; /*
                 MIT License http://www.opensource.org/licenses/mit-license.php
                 Author Tobias Koppers @sokra
                 */ // css base code, injected by the css-loader

			module.exports = function () {
				var list = []; // return the list of modules as css string
				list.toString = function toString() {
					var result = [];for (var i = 0; i < this.length; i++) {
						var item = this[i];if (item[2]) {
							result.push("@media " + item[2] + "{" + item[1] + "}");
						} else {
							result.push(item[1]);
						}
					}return result.join("");
				}; // import a list of modules into the list
				list.i = function (modules, mediaQuery) {
					if (typeof modules === "string") modules = [[null, modules, ""]];var alreadyImportedModules = {};for (var i = 0; i < this.length; i++) {
						var id = this[i][0];if (typeof id === "number") alreadyImportedModules[id] = true;
					}for (i = 0; i < modules.length; i++) {
						var item = modules[i]; // skip already imported module
						// this implementation is not 100% perfect for weird media query combinations
						//  when a module is imported multiple times with different media queries.
						//  I hope this will never occur (Hey this way we have smaller bundles)
						if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
							if (mediaQuery && !item[2]) {
								item[2] = mediaQuery;
							} else if (mediaQuery) {
								item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
							}list.push(item);
						}
					}
				};return list;
			};

			/***/
		},
		/* 6 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			var assign = __webpack_require__(8),
			    normalizeOpts = __webpack_require__(15),
			    isCallable = __webpack_require__(11),
			    contains = __webpack_require__(18),
			    d;d = module.exports = function (dscr, value /*, options*/) {
				var c, e, w, options, desc;if (arguments.length < 2 || typeof dscr !== 'string') {
					options = value;value = dscr;dscr = null;
				} else {
					options = arguments[2];
				}if (dscr == null) {
					c = w = true;e = false;
				} else {
					c = contains.call(dscr, 'c');e = contains.call(dscr, 'e');w = contains.call(dscr, 'w');
				}desc = { value: value, configurable: c, enumerable: e, writable: w };return !options ? desc : assign(normalizeOpts(options), desc);
			};d.gs = function (dscr, get, set /*, options*/) {
				var c, e, options, desc;if (typeof dscr !== 'string') {
					options = set;set = get;get = dscr;dscr = null;
				} else {
					options = arguments[3];
				}if (get == null) {
					get = undefined;
				} else if (!isCallable(get)) {
					options = get;get = set = undefined;
				} else if (set == null) {
					set = undefined;
				} else if (!isCallable(set)) {
					options = set;set = undefined;
				}if (dscr == null) {
					c = true;e = false;
				} else {
					c = contains.call(dscr, 'c');e = contains.call(dscr, 'e');
				}desc = { get: get, set: set, configurable: c, enumerable: e };return !options ? desc : assign(normalizeOpts(options), desc);
			};

			/***/
		},
		/* 7 */
		/***/function (module, exports) {

			"use strict"; // eslint-disable-next-line no-empty-function

			module.exports = function () {};

			/***/
		},
		/* 8 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			module.exports = __webpack_require__(9)() ? Object.assign : __webpack_require__(10);

			/***/
		},
		/* 9 */
		/***/function (module, exports) {

			"use strict";
			module.exports = function () {
				var assign = Object.assign,
				    obj;if (typeof assign !== "function") return false;obj = { foo: "raz" };assign(obj, { bar: "dwa" }, { trzy: "trzy" });return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
			};

			/***/
		},
		/* 10 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			var keys = __webpack_require__(12),
			    value = __webpack_require__(17),
			    max = Math.max;module.exports = function (dest, src /*, srcn*/) {
				var error,
				    i,
				    length = max(arguments.length, 2),
				    assign;dest = Object(value(dest));assign = function assign(key) {
					try {
						dest[key] = src[key];
					} catch (e) {
						if (!error) error = e;
					}
				};for (i = 1; i < length; ++i) {
					src = arguments[i];keys(src).forEach(assign);
				}if (error !== undefined) throw error;return dest;
			};

			/***/
		},
		/* 11 */
		/***/function (module, exports) {

			// Deprecated
			"use strict";
			module.exports = function (obj) {
				return typeof obj === "function";
			};

			/***/
		},
		/* 12 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			module.exports = __webpack_require__(13)() ? Object.keys : __webpack_require__(14);

			/***/
		},
		/* 13 */
		/***/function (module, exports) {

			"use strict";
			module.exports = function () {
				try {
					Object.keys("primitive");return true;
				} catch (e) {
					return false;
				}
			};

			/***/
		},
		/* 14 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			var isValue = __webpack_require__(2);var keys = Object.keys;module.exports = function (object) {
				return keys(isValue(object) ? Object(object) : object);
			};

			/***/
		},
		/* 15 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			var isValue = __webpack_require__(2);var forEach = Array.prototype.forEach,
			    create = Object.create;var process = function process(src, obj) {
				var key;for (key in src) {
					obj[key] = src[key];
				}
			}; // eslint-disable-next-line no-unused-vars
			module.exports = function (opts1 /*, options*/) {
				var result = create(null);forEach.call(arguments, function (options) {
					if (!isValue(options)) return;process(Object(options), result);
				});return result;
			};

			/***/
		},
		/* 16 */
		/***/function (module, exports) {

			"use strict";
			module.exports = function (fn) {
				if (typeof fn !== "function") throw new TypeError(fn + " is not a function");return fn;
			};

			/***/
		},
		/* 17 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			var isValue = __webpack_require__(2);module.exports = function (value) {
				if (!isValue(value)) throw new TypeError("Cannot use null or undefined");return value;
			};

			/***/
		},
		/* 18 */
		/***/function (module, exports, __webpack_require__) {

			"use strict";
			module.exports = __webpack_require__(19)() ? String.prototype.contains : __webpack_require__(20);

			/***/
		},
		/* 19 */
		/***/function (module, exports) {

			"use strict";
			var str = "razdwatrzy";module.exports = function () {
				if (typeof str.contains !== "function") return false;return str.contains("dwa") === true && str.contains("foo") === false;
			};

			/***/
		},
		/* 20 */
		/***/function (module, exports) {

			"use strict";
			var indexOf = String.prototype.indexOf;module.exports = function (searchString /*, position*/) {
				return indexOf.call(this, searchString, arguments[1]) > -1;
			};

			/***/
		},
		/* 21 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
				return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
			} : function (obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
			};var d = __webpack_require__(6),
			    callable = __webpack_require__(16),
			    apply = Function.prototype.apply,
			    call = Function.prototype.call,
			    create = Object.create,
			    defineProperty = Object.defineProperty,
			    defineProperties = Object.defineProperties,
			    hasOwnProperty = Object.prototype.hasOwnProperty,
			    descriptor = { configurable: true, enumerable: false, writable: true },
			    on,
			    _once2,
			    off,
			    emit,
			    methods,
			    descriptors,
			    base;on = function on(type, listener) {
				var data;callable(listener);if (!hasOwnProperty.call(this, '__ee__')) {
					data = descriptor.value = create(null);defineProperty(this, '__ee__', descriptor);descriptor.value = null;
				} else {
					data = this.__ee__;
				}if (!data[type]) data[type] = listener;else if (_typeof(data[type]) === 'object') data[type].push(listener);else data[type] = [data[type], listener];return this;
			};_once2 = function once(type, listener) {
				var _once, self;callable(listener);self = this;on.call(this, type, _once = function once() {
					off.call(self, type, _once);apply.call(listener, this, arguments);
				});_once.__eeOnceListener__ = listener;return this;
			};off = function off(type, listener) {
				var data, listeners, candidate, i;callable(listener);if (!hasOwnProperty.call(this, '__ee__')) return this;data = this.__ee__;if (!data[type]) return this;listeners = data[type];if ((typeof listeners === 'undefined' ? 'undefined' : _typeof(listeners)) === 'object') {
					for (i = 0; candidate = listeners[i]; ++i) {
						if (candidate === listener || candidate.__eeOnceListener__ === listener) {
							if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];else listeners.splice(i, 1);
						}
					}
				} else {
					if (listeners === listener || listeners.__eeOnceListener__ === listener) {
						delete data[type];
					}
				}return this;
			};emit = function emit(type) {
				var i, l, listener, listeners, args;if (!hasOwnProperty.call(this, '__ee__')) return;listeners = this.__ee__[type];if (!listeners) return;if ((typeof listeners === 'undefined' ? 'undefined' : _typeof(listeners)) === 'object') {
					l = arguments.length;args = new Array(l - 1);for (i = 1; i < l; ++i) {
						args[i - 1] = arguments[i];
					}listeners = listeners.slice();for (i = 0; listener = listeners[i]; ++i) {
						apply.call(listener, this, args);
					}
				} else {
					switch (arguments.length) {case 1:
							call.call(listeners, this);break;case 2:
							call.call(listeners, this, arguments[1]);break;case 3:
							call.call(listeners, this, arguments[1], arguments[2]);break;default:
							l = arguments.length;args = new Array(l - 1);for (i = 1; i < l; ++i) {
								args[i - 1] = arguments[i];
							}apply.call(listeners, this, args);}
				}
			};methods = { on: on, once: _once2, off: off, emit: emit };descriptors = { on: d(on), once: d(_once2), off: d(off), emit: d(emit) };base = defineProperties({}, descriptors);module.exports = exports = function exports(o) {
				return o == null ? create(base) : defineProperties(Object(o), descriptors);
			};exports.methods = methods;

			/***/
		},
		/* 22 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			Object.defineProperty(exports, "__esModule", { value: true });var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}();var _clappr = __webpack_require__(1);var _baseMarker = __webpack_require__(3);var _baseMarker2 = _interopRequireDefault(_baseMarker);function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			} /*
     * An implementation of an image Marker, which can show an image.
     */var CropMarker = function (_BaseMarker) {
				_inherits(CropMarker, _BaseMarker); /*
                                        * time: the time in seconds that this marker represents
                                        * tooltipImage: the image to be shown (optional)
                                        * width: width for the image (Default: 200px)
                                        * height: height for the image (Default: auto)
                                        */function CropMarker(time, duration) {
					_classCallCheck(this, CropMarker);var _this = _possibleConstructorReturn(this, (CropMarker.__proto__ || Object.getPrototypeOf(CropMarker)).call(this, time));_this._duration = duration || 5;_this.core = undefined;return _this;
				} /*
      * Returns the duration (in seconds) that this marker represents.
      */_createClass(CropMarker, [{ key: 'getDuration', value: function getDuration() {
						var duration = this._updateDurationValueFromCss();return duration;
					} }, { key: '_updateDurationValueFromCss', value: function _updateDurationValueFromCss() {
						var duration = this.videoDuration / 100 * parseFloat(this.getMarkerEl().style.width);if (isNaN(duration)) {
							duration = this._duration;
						} else {
							this._duration = duration;
						}return duration;
					} /*
       * Set the duration (in seconds) that this marker should represents.
       */ }, { key: 'setDuration', value: function setDuration(duration) {
						var fitToChunk = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // TODO manager 0
						if (this._duration !== duration) {
							this._renderDuration(duration);this._duration = duration;
						}
					} }, { key: '_renderDuration', value: function _renderDuration(duration) {
						var percentage = Math.min(Math.max(this._time / this.videoDuration * 100, 0), 100);var percentageWidth = Math.min(Math.max(duration / this.videoDuration * 100, 0), 100 - percentage);this.getMarkerEl().style.width = percentageWidth + "%"; //console.log("Width:" + percentageWidth + "%")
					} }, { key: '_renderTime', value: function _renderTime(time) {
						var percentage = Math.min(Math.max(time / this.videoDuration * 100, 0), 100);this.getMarkerEl().style.left = percentage + "%"; //console.log("Left:" + percentage + "%")
					} }, { key: 'render', value: function render() {
						//console.log('render')
						this._renderDuration(this._duration);this._renderTime(this._time);
					} /*
       * Should return the time (in seconds) that this marker represents.
       */ }, { key: 'getTime', value: function getTime() {
						var time = this._updateTimeFromCss();return time;
					} }, { key: '_updateTimeFromCss', value: function _updateTimeFromCss() {
						var time = this.videoDuration / 100 * parseFloat(this.getMarkerEl().style.left);if (isNaN(time)) {
							time = this._time;
						} else {
							this._time = time;
						}return time;
					} /*
       * Set the time (in seconds) that this marker represents.
       */ }, { key: 'setTime', value: function setTime(time) {
						if (this._time !== time) {
							this._renderTime(time);this._time = time;
						}
					} }, { key: '_buildMarkerEl', value: function _buildMarkerEl() {
						var _this2 = this;if (typeof jQuery !== 'undefined') {
							var $marker = (0, _clappr.$)('<div />').addClass('crop-marker');$marker.append((0, _clappr.$)('<div id="wgrip"/>').addClass('crop-marker-handle').addClass('ui-resizable-handle').addClass('ui-resizable-w').addClass('left'));$marker.append((0, _clappr.$)('<div id="egrip"/>').addClass('crop-marker-handle').addClass('ui-resizable-handle').addClass('ui-resizable-e').addClass('right'));jQuery($marker[0]).resizable({ handles: { 'w': '#wgrip', 'e': '#egrip' }, resize: function resize(event, ui) {
									ui.originalElement.css({ 'left': '' + 1.0 * ui.position.left / ui.originalElement.parents('.bar-container').width() * 100.0 + '%', 'width': '' + 1.0 * ui.size.width / ui.originalElement.parents('.bar-container').width() * 100.0 + '%' });_this2._updateDurationValueFromCss();_this2._updateTimeFromCss();
								}, maxHeight: 20, minHeight: 20 });return $marker[0];
						}
					} }, { key: 'getHlsFragments', value: function getHlsFragments() {
						var updateToFit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;try {
							var playback = this.core.getCurrentPlayback();if (playback.name === 'hls') {
								var videoHlsLevels = playback._hls.levels;
							} else {
								throw new Error('this video does not contains fragments');
							}var fragments = videoHlsLevels[0].details.fragments;var startTime = this.getTime();var endTime = this.getDuration() + startTime;var coversFragments = fragments.filter(function (frag) {
								var midTs = frag.start + frag.duration / 2;return startTime < midTs && endTime > midTs;
							});if (updateToFit) {
								startTime = coversFragments[0].start;this.setTime(startTime);var lastFrag = coversFragments[coversFragments.length - 1];this.setDuration(lastFrag.endDTS - startTime);
							}return coversFragments.map(function (frag) {
								return frag.relurl;
							});
						} catch (e) {
							if (this._fitToChunk) {
								console.error('error in getting HLS chunk');console.error(e.message);
							} else {//ignor error
							}return [];
						}
					} }]);return CropMarker;
			}(_baseMarker2.default);exports.default = CropMarker;module.exports = exports['default'];

			/***/
		},
		/* 23 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			Object.defineProperty(exports, "__esModule", { value: true });var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}();var _clappr = __webpack_require__(1);var _baseMarker = __webpack_require__(3);var _baseMarker2 = _interopRequireDefault(_baseMarker);function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			} /*
     * An implementation of an image Marker, which can show an image.
     */var ImageMarker = function (_BaseMarker) {
				_inherits(ImageMarker, _BaseMarker); /*
                                         * time: the time in seconds that this marker represents
                                         * tooltipImage: the image to be shown (optional)
                                         * width: width for the image (Default: 200px)
                                         * height: height for the image (Default: auto)
                                         */function ImageMarker(time, tooltipImage, width, height) {
					_classCallCheck(this, ImageMarker);var _this = _possibleConstructorReturn(this, (ImageMarker.__proto__ || Object.getPrototypeOf(ImageMarker)).call(this, time));_this._tooltipImage = tooltipImage || null;_this._width = width || 200;_this._height = height || 'auto';_this._tooltipImage && _this._setTooltipEl(_this._buildTooltipEl());return _this;
				}_createClass(ImageMarker, [{ key: '_buildTooltipEl', value: function _buildTooltipEl() {
						if (!this._tooltipImage) {
							return null;
						}var $img = (0, _clappr.$)('<img />').attr('src', this._tooltipImage).css({ width: this._width, height: this._height });$img.one('load', this.notifyTooltipChanged.bind(this));return (0, _clappr.$)('<div />').addClass('image-tooltip').append($img);
					} }]);return ImageMarker;
			}(_baseMarker2.default);exports.default = ImageMarker;module.exports = exports['default'];

			/***/
		},
		/* 24 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';
			Object.defineProperty(exports, "__esModule", { value: true });var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}();var _clappr = __webpack_require__(1);var _baseMarker = __webpack_require__(3);var _baseMarker2 = _interopRequireDefault(_baseMarker);function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}function _possibleConstructorReturn(self, call) {
				if (!self) {
					throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
			}function _inherits(subClass, superClass) {
				if (typeof superClass !== "function" && superClass !== null) {
					throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
				}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
			} /*
     * An implementation of a basic Marker, which can have a tooltip containing text.
     */var StandardMarker = function (_BaseMarker) {
				_inherits(StandardMarker, _BaseMarker); /*
                                            * time: the time in seconds that this marker represents
                                            * tooltipText: the text to be shown on the tooltip (optional)
                                            */function StandardMarker(time, tooltipText) {
					_classCallCheck(this, StandardMarker);var _this = _possibleConstructorReturn(this, (StandardMarker.__proto__ || Object.getPrototypeOf(StandardMarker)).call(this, time));_this._tooltipText = tooltipText || null;_this._tooltipText && _this._setTooltipEl(_this._buildTooltipEl());return _this;
				}_createClass(StandardMarker, [{ key: '_buildTooltipEl', value: function _buildTooltipEl() {
						return (0, _clappr.$)('<div />').addClass('standard-tooltip').text(this._tooltipText);
					} }]);return StandardMarker;
			}(_baseMarker2.default);exports.default = StandardMarker;module.exports = exports['default'];

			/***/
		},
		/* 25 */
		/***/function (module, exports, __webpack_require__) {

			exports = module.exports = __webpack_require__(5)();
			// imports


			// module
			exports.push([module.id, ".markers-plugin {\n  pointer-events: none; }\n  .markers-plugin .markers-plugin-markers {\n    overflow: hidden;\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0; }\n    .markers-plugin .markers-plugin-markers > * {\n      pointer-events: auto; }\n    .markers-plugin .markers-plugin-markers .standard-marker {\n      position: absolute;\n      -webkit-transform: translateX(-50%);\n      -moz-transform: translateX(-50%);\n      -ms-transform: translateX(-50%);\n      -o-transform: translateX(-50%);\n      transform: translateX(-50%);\n      top: 2px;\n      left: 0;\n      width: 20px;\n      height: 20px; }\n      .markers-plugin .markers-plugin-markers .standard-marker .standard-marker-inner {\n        position: absolute;\n        left: 7.5px;\n        top: 7.5px;\n        width: 5px;\n        height: 5px;\n        border-radius: 2.5px;\n        box-shadow: 0 0 0 3px rgba(200, 200, 200, 0.2);\n        background-color: #c8c8c8; }\n      .markers-plugin .markers-plugin-markers .standard-marker:hover {\n        cursor: pointer; }\n        .markers-plugin .markers-plugin-markers .standard-marker:hover .standard-marker-inner {\n          left: 6px;\n          top: 6px;\n          width: 8px;\n          height: 8px;\n          border-radius: 4px;\n          box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.2);\n          background-color: white; }\n    .markers-plugin .markers-plugin-markers .crop-marker {\n      position: absolute;\n      top: 2px;\n      height: 20px;\n      background-color: #c8c8c8; }\n      .markers-plugin .markers-plugin-markers .crop-marker .crop-marker-handle {\n        background-color: #c8a000;\n        width: 4px;\n        height: 20px;\n        position: absolute;\n        top: 0; }\n      .markers-plugin .markers-plugin-markers .crop-marker .left {\n        left: 0; }\n      .markers-plugin .markers-plugin-markers .crop-marker .right {\n        right: 0; }\n  .markers-plugin .markers-plugin-tooltips {\n    position: relative;\n    height: 0; }\n    .markers-plugin .markers-plugin-tooltips .tooltip-container {\n      position: absolute;\n      white-space: nowrap;\n      line-height: normal; }\n      .markers-plugin .markers-plugin-tooltips .tooltip-container > * {\n        pointer-events: auto; }\n      .markers-plugin .markers-plugin-tooltips .tooltip-container .standard-tooltip, .markers-plugin .markers-plugin-tooltips .tooltip-container .image-tooltip {\n        display: none;\n        background-color: rgba(2, 2, 2, 0.5);\n        color: white;\n        font-size: 10px;\n        padding: 4px 7px;\n        line-height: normal; }\n        .markers-plugin .markers-plugin-tooltips .tooltip-container .standard-tooltip[data-show=\"1\"], .markers-plugin .markers-plugin-tooltips .tooltip-container .image-tooltip[data-show=\"1\"] {\n          display: inline-block; }\n", ""]);

			// exports


			/***/
		},
		/* 26 */
		/***/function (module, exports, __webpack_require__) {

			/*
   	MIT License http://www.opensource.org/licenses/mit-license.php
   	Author Tobias Koppers @sokra
   */
			var stylesInDom = {},
			    memoize = function memoize(fn) {
				var memo;
				return function () {
					if (typeof memo === "undefined") memo = fn.apply(this, arguments);
					return memo;
				};
			},
			    isOldIE = memoize(function () {
				return (/msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase())
				);
			}),
			    getHeadElement = memoize(function () {
				return document.head || document.getElementsByTagName("head")[0];
			}),
			    singletonElement = null,
			    singletonCounter = 0,
			    styleElementsInsertedAtTop = [];

			module.exports = function (list, options) {
				if (false) {
					if ((typeof document === 'undefined' ? 'undefined' : _typeof2(document)) !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
				}

				options = options || {};
				// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
				// tags it will allow on a page
				if (typeof options.singleton === "undefined") options.singleton = isOldIE();

				// By default, add <style> tags to the bottom of <head>.
				if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

				var styles = listToStyles(list);
				addStylesToDom(styles, options);

				return function update(newList) {
					var mayRemove = [];
					for (var i = 0; i < styles.length; i++) {
						var item = styles[i];
						var domStyle = stylesInDom[item.id];
						domStyle.refs--;
						mayRemove.push(domStyle);
					}
					if (newList) {
						var newStyles = listToStyles(newList);
						addStylesToDom(newStyles, options);
					}
					for (var i = 0; i < mayRemove.length; i++) {
						var domStyle = mayRemove[i];
						if (domStyle.refs === 0) {
							for (var j = 0; j < domStyle.parts.length; j++) {
								domStyle.parts[j]();
							}delete stylesInDom[domStyle.id];
						}
					}
				};
			};

			function addStylesToDom(styles, options) {
				for (var i = 0; i < styles.length; i++) {
					var item = styles[i];
					var domStyle = stylesInDom[item.id];
					if (domStyle) {
						domStyle.refs++;
						for (var j = 0; j < domStyle.parts.length; j++) {
							domStyle.parts[j](item.parts[j]);
						}
						for (; j < item.parts.length; j++) {
							domStyle.parts.push(addStyle(item.parts[j], options));
						}
					} else {
						var parts = [];
						for (var j = 0; j < item.parts.length; j++) {
							parts.push(addStyle(item.parts[j], options));
						}
						stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts };
					}
				}
			}

			function listToStyles(list) {
				var styles = [];
				var newStyles = {};
				for (var i = 0; i < list.length; i++) {
					var item = list[i];
					var id = item[0];
					var css = item[1];
					var media = item[2];
					var sourceMap = item[3];
					var part = { css: css, media: media, sourceMap: sourceMap };
					if (!newStyles[id]) styles.push(newStyles[id] = { id: id, parts: [part] });else newStyles[id].parts.push(part);
				}
				return styles;
			}

			function insertStyleElement(options, styleElement) {
				var head = getHeadElement();
				var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
				if (options.insertAt === "top") {
					if (!lastStyleElementInsertedAtTop) {
						head.insertBefore(styleElement, head.firstChild);
					} else if (lastStyleElementInsertedAtTop.nextSibling) {
						head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
					} else {
						head.appendChild(styleElement);
					}
					styleElementsInsertedAtTop.push(styleElement);
				} else if (options.insertAt === "bottom") {
					head.appendChild(styleElement);
				} else {
					throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
				}
			}

			function removeStyleElement(styleElement) {
				styleElement.parentNode.removeChild(styleElement);
				var idx = styleElementsInsertedAtTop.indexOf(styleElement);
				if (idx >= 0) {
					styleElementsInsertedAtTop.splice(idx, 1);
				}
			}

			function createStyleElement(options) {
				var styleElement = document.createElement("style");
				styleElement.type = "text/css";
				insertStyleElement(options, styleElement);
				return styleElement;
			}

			function createLinkElement(options) {
				var linkElement = document.createElement("link");
				linkElement.rel = "stylesheet";
				insertStyleElement(options, linkElement);
				return linkElement;
			}

			function addStyle(obj, options) {
				var styleElement, update, remove;

				if (options.singleton) {
					var styleIndex = singletonCounter++;
					styleElement = singletonElement || (singletonElement = createStyleElement(options));
					update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
					remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
				} else if (obj.sourceMap && typeof URL === "function" && typeof URL.createObjectURL === "function" && typeof URL.revokeObjectURL === "function" && typeof Blob === "function" && typeof btoa === "function") {
					styleElement = createLinkElement(options);
					update = updateLink.bind(null, styleElement);
					remove = function remove() {
						removeStyleElement(styleElement);
						if (styleElement.href) URL.revokeObjectURL(styleElement.href);
					};
				} else {
					styleElement = createStyleElement(options);
					update = applyToTag.bind(null, styleElement);
					remove = function remove() {
						removeStyleElement(styleElement);
					};
				}

				update(obj);

				return function updateStyle(newObj) {
					if (newObj) {
						if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) return;
						update(obj = newObj);
					} else {
						remove();
					}
				};
			}

			var replaceText = function () {
				var textStore = [];

				return function (index, replacement) {
					textStore[index] = replacement;
					return textStore.filter(Boolean).join('\n');
				};
			}();

			function applyToSingletonTag(styleElement, index, remove, obj) {
				var css = remove ? "" : obj.css;

				if (styleElement.styleSheet) {
					styleElement.styleSheet.cssText = replaceText(index, css);
				} else {
					var cssNode = document.createTextNode(css);
					var childNodes = styleElement.childNodes;
					if (childNodes[index]) styleElement.removeChild(childNodes[index]);
					if (childNodes.length) {
						styleElement.insertBefore(cssNode, childNodes[index]);
					} else {
						styleElement.appendChild(cssNode);
					}
				}
			}

			function applyToTag(styleElement, obj) {
				var css = obj.css;
				var media = obj.media;

				if (media) {
					styleElement.setAttribute("media", media);
				}

				if (styleElement.styleSheet) {
					styleElement.styleSheet.cssText = css;
				} else {
					while (styleElement.firstChild) {
						styleElement.removeChild(styleElement.firstChild);
					}
					styleElement.appendChild(document.createTextNode(css));
				}
			}

			function updateLink(linkElement, obj) {
				var css = obj.css;
				var sourceMap = obj.sourceMap;

				if (sourceMap) {
					// http://stackoverflow.com/a/26603875
					css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
				}

				var blob = new Blob([css], { type: "text/css" });

				var oldSrc = linkElement.href;

				linkElement.href = URL.createObjectURL(blob);

				if (oldSrc) URL.revokeObjectURL(oldSrc);
			}

			/***/
		},
		/* 27 */
		/***/function (module, exports, __webpack_require__) {

			// style-loader: Adds some css to the DOM by adding a <style> tag

			// load the styles
			var content = __webpack_require__(25);
			if (typeof content === 'string') content = [[module.id, content, '']];
			// add the styles to the DOM
			var update = __webpack_require__(26)(content, {});
			if (content.locals) module.exports = content.locals;
			// Hot Module Replacement
			if (false) {
				// When the styles change, update the <style> tags
				if (!content.locals) {
					module.hot.accept("!!../node_modules/css-loader/index.js!../node_modules/sass-loader/index.js?includePaths[]=/Users/hubert/Workspace/temp/clappr-markers-plugin/node_modules/compass-mixins/lib!./style.sass", function () {
						var newContent = require("!!../node_modules/css-loader/index.js!../node_modules/sass-loader/index.js?includePaths[]=/Users/hubert/Workspace/temp/clappr-markers-plugin/node_modules/compass-mixins/lib!./style.sass");
						if (typeof newContent === 'string') newContent = [[module.id, newContent, '']];
						update(newContent);
					});
				}
				// When the module is disposed, remove the <style> tags
				module.hot.dispose(function () {
					update();
				});
			}

			/***/
		}]
		/******/)
	);
});
;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(63)(module)))

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return OzonePreviewSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OzoneMediaUrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ozone_api_item__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ozone_config__ = __webpack_require__(3);
/// <amd-module name="ozone-media-url"/>
/**
 * Created by hubert on 21/06/17.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = this && this.__metadata || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



let OzonePreviewSize = class OzonePreviewSize {};
OzonePreviewSize.Small = 250;
OzonePreviewSize.Medium = 500;
OzonePreviewSize.Large = 1500;
OzonePreviewSize = __decorate([Object(__WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript__["jsElement"])()], OzonePreviewSize);

/**
 * JavaScript class to convert media ID to URL
 */
let OzoneMediaUrl = class OzoneMediaUrl {
    constructor(id, config) {
        this.id = id;
        this.config = config;
    }
    _getOzoneApi() {
        if (!this.ozoneApi) {
            this.ozoneApi = new __WEBPACK_IMPORTED_MODULE_1_ozone_api_item__["a" /* OzoneApiItem */]();
        }
        return this.ozoneApi;
    }
    getNumericId() {
        return parseInt('0x' + this.id.split('-')[4]);
    }
    _buildBaseUrl(action) {
        return `${this.config.host}${this.config.view}/${action.join('/')}`;
    }
    getPreviewUrlJpg(size) {
        const preview = this.config.format.type.jpg.replace('{SIZE}', size.toString());
        return this._buildBaseUrl([this.getNumericId(), preview]);
    }
    getOriginalFormat() {
        return this._buildBaseUrl([this.getNumericId(), this.config.format.type.original]);
    }
    getPreviewUrlPng(size) {
        const preview = this.config.format.type.png.replace('{SIZE}', size.toString());
        return this._buildBaseUrl([this.getNumericId(), preview]);
    }
    getPreviewUrl(size) {
        return __awaiter(this, void 0, void 0, function* () {
            //TODO default is png
            return this.getPreviewUrlJpg(size);
        });
    }
    getVideoUrl() {
        return __awaiter(this, void 0, void 0, function* () {
            const formatName = yield this.getPreferedVideoFormat();
            if (formatName) {
                return this._buildBaseUrl([this.getNumericId(), formatName, 'index.m3u8']);
            } else {
                throw new Error('Video Format is undefined');
            }
        });
    }
    getVideoUrlMp4() {
        return this._buildBaseUrl([this.getNumericId(), this.config.format.type.mp4]);
    }
    _fileTypeRequest(filetypeIdentifier) {
        const url = `${this.config.host}${this.config.endPoints.fileType}/identifier/${filetypeIdentifier}`;
        return new Promise((resolve, reject) => {
            const xmlhttp = new XMLHttpRequest();
            xmlhttp.responseType = 'json';
            xmlhttp.open("GET", url, true);
            xmlhttp.onload = function () {
                resolve(xmlhttp.response);
            };
            xmlhttp.onerror = function () {
                reject(xmlhttp.statusText);
            };
            xmlhttp.send();
        });
    }
    _getVideoFileType() {
        const videoFormat = this.config.format.priority.video;
        const promises = videoFormat.map(format => {
            const filetypeIdentifier = this.config.format.type[format];
            return this._fileTypeRequest(filetypeIdentifier).catch(() => {
                console.log(format, 'not found');
            });
        });
        return Promise.all(promises);
    }
    getPreferedVideoFormat() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._referedVideoFormat) {
                return this._referedVideoFormat;
            }
            const ozoneApi = this._getOzoneApi();
            const video = yield ozoneApi.on('video').getOne(this.id);
            var avaliableRessourceId = [];
            if (video.file) avaliableRessourceId.push(video.file);
            if (video.derivedFiles) avaliableRessourceId = avaliableRessourceId.concat(video.derivedFiles);
            const avaliableRessource = yield ozoneApi.on('file').bulkGet(avaliableRessourceId);
            const videoFileTypes = yield this._getVideoFileType();
            for (let format of this.config.format.priority.video) {
                const ressourceToUse = avaliableRessource.find(ressource => {
                    const fileType = videoFileTypes.find(videoFileType => {
                        if (videoFileType && videoFileType.id) return videoFileType.id == ressource.fileType;
                        return false;
                    });
                    const filetypeIdentifier = this.config.format.type[format];
                    if (!fileType) return false;
                    return fileType.identifier === filetypeIdentifier;
                });
                if (ressourceToUse) {
                    const fileTypeToUse = videoFileTypes.find(videoFileType => {
                        return videoFileType.id == ressourceToUse.fileType;
                    });
                    if (fileTypeToUse && fileTypeToUse.identifier) {
                        this._referedVideoFormat = fileTypeToUse.identifier;
                        return this._referedVideoFormat;
                    }
                }
            }
            //if no result found
            throw new Error('no video file found');
        });
    }
};
OzoneMediaUrl = __decorate([Object(__WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript__["jsElement"])(), __metadata("design:paramtypes", [String, Object])], OzoneMediaUrl);


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ozone_video_player_ts__ = __webpack_require__(29);
/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, "OzoneVideoPlayer", function() { return __WEBPACK_IMPORTED_MODULE_0__ozone_video_player_ts__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__demo_demo_app_ts__ = __webpack_require__(73);
/* empty harmony namespace reexport */



/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OzoneVideoPlayer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_polymer_polymer_html__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_polymer_polymer_html___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_polymer_polymer_html__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ozone_video_player_html__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ozone_video_player_html___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__ozone_video_player_html__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ozone_config__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_taktik_polymer_typescript__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_taktik_polymer_typescript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_taktik_polymer_typescript__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_Clappr__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_Clappr___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_Clappr__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_clappr_markers_plugin__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_clappr_markers_plugin___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_clappr_markers_plugin__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Clappr_Subtitle__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__clappr_marker__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_ozone_media_url__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ozone_api_mediaplay__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__MediaControl__ = __webpack_require__(72);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};











/**
 * `<ozone-video-player>`
 *
 * Customisable Ozone video player. Package in a webComponents and written in typeScript
 *
 *
 * ### Styling
 *
 * The following custom css mixin properties are available for styling:
 *
 * Custom property | Description | Default
 * ----------------|-------------|----------
 * `--marker-bar-background` | Background color of the marker's bar | `rgba(29,38,43,0.52)`
 * `--resizer-color` | Background color of the resizer | `rgba(29,38,43,0.9)`
 * `--resizer-handle-color` | Background color of the resizer's handle | `rgba(255,255,255,0.2)`
 * `--marker-bar` | Mixin applied to the marker's bar| {}
 * `--resizer` | Mixin applied to the marker's bar| {}
 * `--moving-tooltip-background-color` | Background color of the moving tooltip | `rgba(29,38,43,0.9)`
 * `--moving-tooltip-text-color` | Text color of the moving tooltip | `white`
 * `--moving-tooltip-mixin` | Mixin applied to the marker's bar| {}
 * `--subtiltes-color` | Color of the subtitles | `#fffb00`
 * `--subtitles-font-size` | Font size of the subtiltes | `16px`
 * `--subtitles-weight` | Font weight of the subtitles | `bold`
 * `--subtitles-font-family` | Font family of the subtitles | `'Roboto'`
 * `--subtitles` | Mixin applied to the subtitles and the subtitles' container | {}
 */
let OzoneVideoPlayer = class OzoneVideoPlayer extends Polymer.Element {
    /**
     * `<ozone-video-player>`
     *
     * Customisable Ozone video player. Package in a webComponents and written in typeScript
     *
     *
     * ### Styling
     *
     * The following custom css mixin properties are available for styling:
     *
     * Custom property | Description | Default
     * ----------------|-------------|----------
     * `--marker-bar-background` | Background color of the marker's bar | `rgba(29,38,43,0.52)`
     * `--resizer-color` | Background color of the resizer | `rgba(29,38,43,0.9)`
     * `--resizer-handle-color` | Background color of the resizer's handle | `rgba(255,255,255,0.2)`
     * `--marker-bar` | Mixin applied to the marker's bar| {}
     * `--resizer` | Mixin applied to the marker's bar| {}
     * `--moving-tooltip-background-color` | Background color of the moving tooltip | `rgba(29,38,43,0.9)`
     * `--moving-tooltip-text-color` | Text color of the moving tooltip | `white`
     * `--moving-tooltip-mixin` | Mixin applied to the marker's bar| {}
     * `--subtiltes-color` | Color of the subtitles | `#fffb00`
     * `--subtitles-font-size` | Font size of the subtiltes | `16px`
     * `--subtitles-weight` | Font weight of the subtitles | `bold`
     * `--subtitles-font-family` | Font family of the subtitles | `'Roboto'`
     * `--subtitles` | Mixin applied to the subtitles and the subtitles' container | {}
     */
    constructor() {
        super(...arguments);
        /**
         * hide element and pause the player.
         */
        this.hidden = false;
        /**
         * Array of video markers
         */
        this.markers = [];
        /**
         * List of subtitles languages avaliable
         */
        this.subtitlesAvailable = [];
        /**
         * default parameters apply to Clapper Player
         */
        this.defaultClapprParameters = {
            plugins: {
                core: [__WEBPACK_IMPORTED_MODULE_5_clappr_markers_plugin__, __WEBPACK_IMPORTED_MODULE_6__Clappr_Subtitle__["a" /* ClapprSubtitle */]],
            },
            markersPlugin: {
                markers: [],
            },
            subtitle: {
                auto: true,
                backgroundColor: 'transparent',
                fontWeight: 'normal',
                fontSize: '14px',
                color: 'yellow',
                textShadow: '1px 1px #000'
            },
            mediacontrol: { external: __WEBPACK_IMPORTED_MODULE_10__MediaControl__["a" /* WCMediaControl */] },
        };
        this.OzoneMediaUrl = __WEBPACK_IMPORTED_MODULE_8_ozone_media_url__["a" /* OzoneMediaUrl */]; //Exposed for testing purpose
        this._subtitles = new Map();
    }
    get markerFactory() {
        if (!this._markerFactory)
            this._markerFactory = new __WEBPACK_IMPORTED_MODULE_7__clappr_marker__["a" /* ClapprMarkerFactory */](this);
        return this._markerFactory;
    }
    static get observers() {
        return ['markersChange(markers.*)'];
    }
    markersChange() {
    }
    subtitleSelectedChange(subtitle) {
        return __awaiter(this, void 0, void 0, function* () {
            if (subtitle && this.player && this.video) {
                const config = yield (__WEBPACK_IMPORTED_MODULE_2_ozone_config__["a" /* OzoneConfig */].get());
                const mediaUrl = new this.OzoneMediaUrl(this.video.subtitles[subtitle], config);
                if (this.player.options.subtitle) {
                    const plugin = this.player.getPlugin('subtitle-plugin');
                    plugin.options.src = mediaUrl.getOriginalFormat();
                    plugin.initSubtitle();
                }
            }
        });
    }
    addConfigSubtitle(video, config) {
        if (this.subtitleSelected && this._subtitles.has(this.subtitleSelected)) {
            const mediaUrl = new this.OzoneMediaUrl(video.subtitles[this.subtitleSelected], config);
            this.defaultClapprParameters.subtitle.src = mediaUrl.getOriginalFormat();
        }
        else {
            this.defaultClapprParameters.subtitle.src = null;
        }
        return this.defaultClapprParameters;
    }
    _updateSubtitlesAvailable(video) {
        if (video.subtitles) {
            for (let s in video.subtitles) {
                this._subtitles.set(s, video.subtitles[s]);
                this.push('subtitlesAvailable', s);
            }
        }
        else {
            this._subtitles.clear();
            this.set('subtitlesAvailable', []);
        }
    }
    /**
     * Load video from Ozone.
     * @param {Video} data
     * @return {Promise<void>}
     */
    loadOzoneVideo(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (data) {
                this.video = data;
            }
        });
    }
    _loadOzoneVideo(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield (__WEBPACK_IMPORTED_MODULE_2_ozone_config__["a" /* OzoneConfig */].get());
            if (data) {
                this.video = data;
                this._updateSubtitlesAvailable(data);
                const mediaUrl = new this.OzoneMediaUrl(data.id, config);
                const url = yield mediaUrl.getVideoUrl();
                const previewImage = mediaUrl.getPreviewUrlJpg(__WEBPACK_IMPORTED_MODULE_8_ozone_media_url__["b" /* OzonePreviewSize */].Small);
                const clapprConfig = this.addConfigSubtitle(data, config);
                const param = Object.assign({
                    source: url,
                    poster: previewImage,
                }, clapprConfig);
                param.subtitle.list = this._subtitles;
                this.createPlayer(param);
                this.intervalReporter = window.setInterval(() => {
                    this.reportUsage();
                }, __WEBPACK_IMPORTED_MODULE_9__ozone_api_mediaplay__["a" /* ReportInterval_ms */]);
            }
        });
    }
    /**
     * Load a video from an url.
     * @param {string} url
     * @return {Promise<void>}
     */
    loadVideoUrl(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const param = Object.assign({
                source: url,
            }, this.defaultClapprParameters);
            this.createPlayer(param);
        });
    }
    set intervalReporter(interval) {
        if (this._intervalReporter) {
            clearInterval(this._intervalReporter);
        }
        this._intervalReporter = interval;
    }
    get intervalReporter() {
        return this._intervalReporter;
    }
    reportUsage() {
        if (this.video && this.player && this.player.isPlaying())
            __WEBPACK_IMPORTED_MODULE_9__ozone_api_mediaplay__["b" /* ozoneApiMediaplay */].reportMediaUsage(this.video);
    }
    createPlayer(param) {
        this.destroy();
        this.player = new __WEBPACK_IMPORTED_MODULE_4_Clappr__["Player"](param);
        var playerElement = document.createElement('div');
        if (this.$)
            this.$.player.appendChild(playerElement);
        this.player.attachTo(playerElement);
        this.player.on(__WEBPACK_IMPORTED_MODULE_4_Clappr__["Events"].PLAYER_PLAY, () => {
            this.reportUsage();
        });
    }
    visibilityChange() {
        if (this.hidden && this.player) {
            this.player.pause();
        }
    }
    videoUrlChange(url) {
        if (url) {
            this.loadVideoUrl(url);
        }
    }
    videoChange(video) {
        if (video) {
            this._loadOzoneVideo(video);
        }
    }
    destroy() {
        this.set('markers', []);
        if (this.player) {
            this.player.destroy();
        }
        this.intervalReporter = undefined;
    }
    buildMarker(marker, index) {
        return this.markerFactory.createMarker(marker, index);
    }
    addMarker(videoMarker) {
        if (this.player) {
            this.push('markers', videoMarker);
            const aMarker = this.buildMarker(videoMarker, this.markers.length - 1);
            const markersPlugin = this.player.getPlugin('markers-plugin');
            markersPlugin.addMarker(aMarker);
            if (this.$)
                this.$.player.getElementsByClassName("media-control-layer")[0].classList.add("edit-mode");
        }
    }
    ;
    removeMarker(id) {
        if (this.player) {
            const markersPlugin = this.player.getPlugin('markers-plugin');
            const marker = markersPlugin.getByIndex(id);
            markersPlugin.removeMarker(marker);
            this.splice('markers', id, 1);
        }
    }
    ;
    clearMarkers() {
        if (this.player) {
            const markersPlugin = this.player.getPlugin('markers-plugin');
            markersPlugin.clearMarkers();
            this.set('markers', []);
            if (this.$)
                this.$.player.getElementsByClassName("media-control-layer")[0].classList.remove("edit-mode");
        }
    }
    ;
    getSelectedChunks(updateToFitHlsChunk = false) {
        if (this.player) {
            const markersPlugin = this.player.getPlugin('markers-plugin');
            return markersPlugin.getAll()
                .map((marker, index) => {
                const markerC = marker;
                const selectedChunks = markerC.getHlsFragments(updateToFitHlsChunk);
                if (updateToFitHlsChunk) {
                    this.set(`markers.${index}.duration`, markerC.getDuration());
                    this.set(`markers.${index}.time`, markerC.getTime());
                }
                return selectedChunks;
            });
        }
        return null;
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_3_taktik_polymer_typescript__["property"])({ type: Object }),
    __metadata("design:type", Object)
], OzoneVideoPlayer.prototype, "player", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_3_taktik_polymer_typescript__["property"])({ type: String, observer: 'videoUrlChange' }),
    __metadata("design:type", String)
], OzoneVideoPlayer.prototype, "videoUrl", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_3_taktik_polymer_typescript__["property"])({ type: Object, observer: 'videoChange' }),
    __metadata("design:type", Object)
], OzoneVideoPlayer.prototype, "video", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_3_taktik_polymer_typescript__["property"])({ type: Boolean, observer: 'visibilityChange' }),
    __metadata("design:type", Boolean)
], OzoneVideoPlayer.prototype, "hidden", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_3_taktik_polymer_typescript__["property"])({ type: Array, notify: true }),
    __metadata("design:type", Array)
], OzoneVideoPlayer.prototype, "markers", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_3_taktik_polymer_typescript__["property"])({ type: Array, notify: true, }),
    __metadata("design:type", Array)
], OzoneVideoPlayer.prototype, "subtitlesAvailable", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_3_taktik_polymer_typescript__["property"])({ type: String, observer: 'subtitleSelectedChange' }),
    __metadata("design:type", String)
], OzoneVideoPlayer.prototype, "subtitleSelected", void 0);
OzoneVideoPlayer = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_3_taktik_polymer_typescript__["customElement"])('ozone-video-player')
], OzoneVideoPlayer);



/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(31);

/***/ }),
/* 31 */
/***/ (function(module, exports) {

(function () {
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';
  var k = {};function n() {
    this.end = this.start = 0;this.rules = this.parent = this.previous = null;this.cssText = this.parsedCssText = "";this.atRule = !1;this.type = 0;this.parsedSelector = this.selector = this.keyframesName = "";
  }
  function p(a) {
    a = a.replace(aa, "").replace(ba, "");var c = q,
        b = a,
        d = new n();d.start = 0;d.end = b.length;for (var e = d, f = 0, h = b.length; f < h; f++) if ("{" === b[f]) {
      e.rules || (e.rules = []);var g = e,
          m = g.rules[g.rules.length - 1] || null;e = new n();e.start = f + 1;e.parent = g;e.previous = m;g.rules.push(e);
    } else "}" === b[f] && (e.end = f + 1, e = e.parent || d);return c(d, a);
  }
  function q(a, c) {
    var b = c.substring(a.start, a.end - 1);a.parsedCssText = a.cssText = b.trim();a.parent && (b = c.substring(a.previous ? a.previous.end : a.parent.start, a.start - 1), b = ca(b), b = b.replace(r, " "), b = b.substring(b.lastIndexOf(";") + 1), b = a.parsedSelector = a.selector = b.trim(), a.atRule = 0 === b.indexOf("@"), a.atRule ? 0 === b.indexOf("@media") ? a.type = t : b.match(da) && (a.type = u, a.keyframesName = a.selector.split(r).pop()) : a.type = 0 === b.indexOf("--") ? v : x);if (b = a.rules) for (var d = 0, e = b.length, f; d < e && (f = b[d]); d++) q(f, c);return a;
  }
  function ca(a) {
    return a.replace(/\\([0-9a-f]{1,6})\s/gi, function (a, b) {
      a = b;for (b = 6 - a.length; b--;) a = "0" + a;return "\\" + a;
    });
  }
  function y(a, c, b) {
    b = void 0 === b ? "" : b;var d = "";if (a.cssText || a.rules) {
      var e = a.rules,
          f;if (f = e) f = e[0], f = !(f && f.selector && 0 === f.selector.indexOf("--"));if (f) {
        f = 0;for (var h = e.length, g; f < h && (g = e[f]); f++) d = y(g, c, d);
      } else c ? c = a.cssText : (c = a.cssText, c = c.replace(ea, "").replace(fa, ""), c = c.replace(ha, "").replace(ia, "")), (d = c.trim()) && (d = "  " + d + "\n");
    }d && (a.selector && (b += a.selector + " {\n"), b += d, a.selector && (b += "}\n\n"));return b;
  }
  var x = 1,
      u = 7,
      t = 4,
      v = 1E3,
      aa = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
      ba = /@import[^;]*;/gim,
      ea = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
      fa = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
      ha = /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
      ia = /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
      da = /^@[^\s]*keyframes/,
      r = /\s+/g;var ja = Promise.resolve();function ka(a) {
    if (a = k[a]) a._applyShimCurrentVersion = a._applyShimCurrentVersion || 0, a._applyShimValidatingVersion = a._applyShimValidatingVersion || 0, a._applyShimNextVersion = (a._applyShimNextVersion || 0) + 1;
  }function z(a) {
    return a._applyShimCurrentVersion === a._applyShimNextVersion;
  }function la(a) {
    a._applyShimValidatingVersion = a._applyShimNextVersion;a.b || (a.b = !0, ja.then(function () {
      a._applyShimCurrentVersion = a._applyShimNextVersion;a.b = !1;
    }));
  };var A = !(window.ShadyDOM && window.ShadyDOM.inUse),
      B;function C(a) {
    B = a && a.shimcssproperties ? !1 : A || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? B = window.ShadyCSS.nativeCss : window.ShadyCSS ? (C(window.ShadyCSS), window.ShadyCSS = void 0) : C(window.WebComponents && window.WebComponents.flags);var D = B;var F = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi,
      G = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
      ma = /@media\s(.*)/;var H = new Set();function I(a) {
    if (!a) return "";"string" === typeof a && (a = p(a));return y(a, D);
  }function J(a) {
    !a.__cssRules && a.textContent && (a.__cssRules = p(a.textContent));return a.__cssRules || null;
  }function K(a, c, b, d) {
    if (a) {
      var e = !1,
          f = a.type;if (d && f === t) {
        var h = a.selector.match(ma);h && (window.matchMedia(h[1]).matches || (e = !0));
      }f === x ? c(a) : b && f === u ? b(a) : f === v && (e = !0);if ((a = a.rules) && !e) {
        e = 0;f = a.length;for (var g; e < f && (g = a[e]); e++) K(g, c, b, d);
      }
    }
  }
  function L(a, c) {
    var b = a.indexOf("var(");if (-1 === b) return c(a, "", "", "");a: {
      var d = 0;var e = b + 3;for (var f = a.length; e < f; e++) if ("(" === a[e]) d++;else if (")" === a[e] && 0 === --d) break a;e = -1;
    }d = a.substring(b + 4, e);b = a.substring(0, b);a = L(a.substring(e + 1), c);e = d.indexOf(",");return -1 === e ? c(b, d.trim(), "", a) : c(b, d.substring(0, e).trim(), d.substring(e + 1).trim(), a);
  };var na = /;\s*/m,
      oa = /^\s*(initial)|(inherit)\s*$/;function M() {
    this.a = {};
  }M.prototype.set = function (a, c) {
    a = a.trim();this.a[a] = { h: c, i: {} };
  };M.prototype.get = function (a) {
    a = a.trim();return this.a[a] || null;
  };var N = null;function O() {
    this.b = this.c = null;this.a = new M();
  }O.prototype.o = function (a) {
    a = G.test(a) || F.test(a);G.lastIndex = 0;F.lastIndex = 0;return a;
  };
  O.prototype.m = function (a, c) {
    if (void 0 === a.a) {
      var b = [];for (var d = a.content.querySelectorAll("style"), e = 0; e < d.length; e++) {
        var f = d[e];if (f.hasAttribute("shady-unscoped")) {
          if (!A) {
            var h = f.textContent;H.has(h) || (H.add(h), h = f.cloneNode(!0), document.head.appendChild(h));f.parentNode.removeChild(f);
          }
        } else b.push(f.textContent), f.parentNode.removeChild(f);
      }(b = b.join("").trim()) ? (d = document.createElement("style"), d.textContent = b, a.content.insertBefore(d, a.content.firstChild), b = d) : b = null;a.a = b;
    }return (a = a.a) ? this.j(a, c) : null;
  };O.prototype.j = function (a, c) {
    c = void 0 === c ? "" : c;var b = J(a);this.l(b, c);a.textContent = I(b);return b;
  };O.prototype.f = function (a) {
    var c = this,
        b = J(a);K(b, function (a) {
      ":root" === a.selector && (a.selector = "html");c.g(a);
    });a.textContent = I(b);return b;
  };O.prototype.l = function (a, c) {
    var b = this;this.c = c;K(a, function (a) {
      b.g(a);
    });this.c = null;
  };O.prototype.g = function (a) {
    a.cssText = pa(this, a.parsedCssText);":root" === a.selector && (a.selector = ":host > *");
  };
  function pa(a, c) {
    c = c.replace(F, function (b, c, e, f) {
      return qa(a, b, c, e, f);
    });return P(a, c);
  }function P(a, c) {
    for (var b; b = G.exec(c);) {
      var d = b[0],
          e = b[1];b = b.index;var f = c.slice(0, b + d.indexOf("@apply"));c = c.slice(b + d.length);var h = Q(a, f);d = void 0;var g = a;e = e.replace(na, "");var m = [];var l = g.a.get(e);l || (g.a.set(e, {}), l = g.a.get(e));if (l) for (d in g.c && (l.i[g.c] = !0), l.h) g = h && h[d], l = [d, ": var(", e, "_-_", d], g && l.push(",", g), l.push(")"), m.push(l.join(""));d = m.join("; ");c = "" + f + d + c;G.lastIndex = b + d.length;
    }return c;
  }
  function Q(a, c) {
    c = c.split(";");for (var b, d, e = {}, f = 0, h; f < c.length; f++) if (b = c[f]) if (h = b.split(":"), 1 < h.length) {
      b = h[0].trim();var g = a;d = b;h = h.slice(1).join(":");var m = oa.exec(h);m && (m[1] ? (g.b || (g.b = document.createElement("meta"), g.b.setAttribute("apply-shim-measure", ""), g.b.style.all = "initial", document.head.appendChild(g.b)), d = window.getComputedStyle(g.b).getPropertyValue(d)) : d = "apply-shim-inherit", h = d);d = h;e[b] = d;
    }return e;
  }function ra(a, c) {
    if (N) for (var b in c.i) b !== a.c && N(b);
  }
  function qa(a, c, b, d, e) {
    d && L(d, function (c, b) {
      b && a.a.get(b) && (e = "@apply " + b + ";");
    });if (!e) return c;var f = P(a, e),
        h = c.slice(0, c.indexOf("--")),
        g = f = Q(a, f),
        m = a.a.get(b),
        l = m && m.h;l ? g = Object.assign(Object.create(l), f) : a.a.set(b, g);var Y = [],
        w,
        Z = !1;for (w in g) {
      var E = f[w];void 0 === E && (E = "initial");!l || w in l || (Z = !0);Y.push("" + b + "_-_" + w + ": " + E);
    }Z && ra(a, m);m && (m.h = g);d && (h = c + ";" + h);return "" + h + Y.join("; ") + ";";
  }O.prototype.detectMixin = O.prototype.o;O.prototype.transformStyle = O.prototype.j;
  O.prototype.transformCustomStyle = O.prototype.f;O.prototype.transformRules = O.prototype.l;O.prototype.transformRule = O.prototype.g;O.prototype.transformTemplate = O.prototype.m;O.prototype._separator = "_-_";Object.defineProperty(O.prototype, "invalidCallback", { get: function () {
      return N;
    }, set: function (a) {
      N = a;
    } });var R = null,
      sa = window.HTMLImports && window.HTMLImports.whenReady || null,
      S;function ta(a) {
    requestAnimationFrame(function () {
      sa ? sa(a) : (R || (R = new Promise(function (a) {
        S = a;
      }), "complete" === document.readyState ? S() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && S();
      })), R.then(function () {
        a && a();
      }));
    });
  };var T = new O();function U() {
    var a = this;this.a = null;ta(function () {
      V(a);
    });T.invalidCallback = ka;
  }function V(a) {
    a.a || (a.a = window.ShadyCSS.CustomStyleInterface, a.a && (a.a.transformCallback = function (a) {
      T.f(a);
    }, a.a.validateCallback = function () {
      requestAnimationFrame(function () {
        a.a.enqueued && W(a);
      });
    }));
  }U.prototype.prepareTemplate = function (a, c) {
    V(this);k[c] = a;c = T.m(a, c);a._styleAst = c;
  };
  function W(a) {
    V(a);if (a.a) {
      var c = a.a.processStyles();if (a.a.enqueued) {
        for (var b = 0; b < c.length; b++) {
          var d = a.a.getStyleForCustomStyle(c[b]);d && T.f(d);
        }a.a.enqueued = !1;
      }
    }
  }U.prototype.styleSubtree = function (a, c) {
    V(this);if (c) for (var b in c) null === b ? a.style.removeProperty(b) : a.style.setProperty(b, c[b]);if (a.shadowRoot) for (this.styleElement(a), a = a.shadowRoot.children || a.shadowRoot.childNodes, c = 0; c < a.length; c++) this.styleSubtree(a[c]);else for (a = a.children || a.childNodes, c = 0; c < a.length; c++) this.styleSubtree(a[c]);
  };
  U.prototype.styleElement = function (a) {
    V(this);var c = a.localName,
        b;c ? -1 < c.indexOf("-") ? b = c : b = a.getAttribute && a.getAttribute("is") || "" : b = a.is;if ((c = k[b]) && !z(c)) {
      if (z(c) || c._applyShimValidatingVersion !== c._applyShimNextVersion) this.prepareTemplate(c, b), la(c);if (a = a.shadowRoot) if (a = a.querySelector("style")) a.__cssRules = c._styleAst, a.textContent = I(c._styleAst);
    }
  };U.prototype.styleDocument = function (a) {
    V(this);this.styleSubtree(document.body, a);
  };
  if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
    var X = new U(),
        ua = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;window.ShadyCSS = { prepareTemplate: function (a, c) {
        W(X);X.prepareTemplate(a, c);
      }, styleSubtree: function (a, c) {
        W(X);X.styleSubtree(a, c);
      }, styleElement: function (a) {
        W(X);X.styleElement(a);
      }, styleDocument: function (a) {
        W(X);X.styleDocument(a);
      }, getComputedStyleValue: function (a, c) {
        return (a = window.getComputedStyle(a).getPropertyValue(c)) ? a.trim() : "";
      }, nativeCss: D, nativeShadow: A };ua && (window.ShadyCSS.CustomStyleInterface = ua);
  }window.ShadyCSS.ApplyShim = T;
}).call(this);

//# sourceMappingURL=apply-shim.min.js.map

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(5);

(function () {
  'use strict';

  let modules = {};
  let lcModules = {};
  function findModule(id) {
    return modules[id] || lcModules[id.toLowerCase()];
  }

  function styleOutsideTemplateCheck(inst) {
    if (inst.querySelector('style')) {
      console.warn('dom-module %s has style outside template', inst.id);
    }
  }

  /**
   * The `dom-module` element registers the dom it contains to the name given
   * by the module's id attribute. It provides a unified database of dom
   * accessible via its static `import` API.
   *
   * A key use case of `dom-module` is for providing custom element `<template>`s
   * via HTML imports that are parsed by the native HTML parser, that can be
   * relocated during a bundling pass and still looked up by `id`.
   *
   * Example:
   *
   *     <dom-module id="foo">
   *       <img src="stuff.png">
   *     </dom-module>
   *
   * Then in code in some other location that cannot access the dom-module above
   *
   *     let img = customElements.get('dom-module').import('foo', 'img');
   *
   * @customElement
   * @extends HTMLElement
   * @memberof Polymer
   * @summary Custom element that provides a registry of relocatable DOM content
   *   by `id` that is agnostic to bundling.
   * @unrestricted
   */
  class DomModule extends HTMLElement {

    static get observedAttributes() {
      return ['id'];
    }

    /**
     * Retrieves the element specified by the css `selector` in the module
     * registered by `id`. For example, this.import('foo', 'img');
     * @param {string} id The id of the dom-module in which to search.
     * @param {string=} selector The css selector by which to find the element.
     * @return {Element} Returns the element which matches `selector` in the
     * module registered at the specified `id`.
     */
    static import(id, selector) {
      if (id) {
        let m = findModule(id);
        if (m && selector) {
          return m.querySelector(selector);
        }
        return m;
      }
      return null;
    }

    /**
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @return {void}
     */
    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        this.register();
      }
    }

    /**
     * The absolute URL of the original location of this `dom-module`.
     *
     * This value will differ from this element's `ownerDocument` in the
     * following ways:
     * - Takes into account any `assetpath` attribute added during bundling
     *   to indicate the original location relative to the bundled location
     * - Uses the HTMLImports polyfill's `importForElement` API to ensure
     *   the path is relative to the import document's location since
     *   `ownerDocument` is not currently polyfilled
     */
    get assetpath() {
      // Don't override existing assetpath.
      if (!this.__assetpath) {
        // note: assetpath set via an attribute must be relative to this
        // element's location; accomodate polyfilled HTMLImports
        const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
        const url = Polymer.ResolveUrl.resolveUrl(this.getAttribute('assetpath') || '', owner.baseURI);
        this.__assetpath = Polymer.ResolveUrl.pathFromUrl(url);
      }
      return this.__assetpath;
    }

    /**
     * Registers the dom-module at a given id. This method should only be called
     * when a dom-module is imperatively created. For
     * example, `document.createElement('dom-module').register('foo')`.
     * @param {string=} id The id at which to register the dom-module.
     * @return {void}
     */
    register(id) {
      id = id || this.id;
      if (id) {
        this.id = id;
        // store id separate from lowercased id so that
        // in all cases mixedCase id will stored distinctly
        // and lowercase version is a fallback
        modules[id] = this;
        lcModules[id.toLowerCase()] = this;
        styleOutsideTemplateCheck(this);
      }
    }
  }

  DomModule.prototype['modules'] = modules;

  customElements.define('dom-module', DomModule);

  // export
  Polymer.DomModule = DomModule;
})();

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

(function () {
  'use strict';

  /**
   * Module with utilities for manipulating structured data path strings.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module with utilities for manipulating structured data path strings.
   */

  const Path = {

    /**
     * Returns true if the given string is a structured data path (has dots).
     *
     * Example:
     *
     * ```
     * Polymer.Path.isPath('foo.bar.baz') // true
     * Polymer.Path.isPath('foo')         // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} path Path string
     * @return {boolean} True if the string contained one or more dots
     */
    isPath: function (path) {
      return path.indexOf('.') >= 0;
    },

    /**
     * Returns the root property name for the given path.
     *
     * Example:
     *
     * ```
     * Polymer.Path.root('foo.bar.baz') // 'foo'
     * Polymer.Path.root('foo')         // 'foo'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} path Path string
     * @return {string} Root property name
     */
    root: function (path) {
      let dotIndex = path.indexOf('.');
      if (dotIndex === -1) {
        return path;
      }
      return path.slice(0, dotIndex);
    },

    /**
     * Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
     * Returns true if the given path is an ancestor of the base path.
     *
     * Example:
     *
     * ```
     * Polymer.Path.isAncestor('foo.bar', 'foo')         // true
     * Polymer.Path.isAncestor('foo.bar', 'foo.bar')     // false
     * Polymer.Path.isAncestor('foo.bar', 'foo.bar.baz') // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Path string to test against.
     * @param {string} path Path string to test.
     * @return {boolean} True if `path` is an ancestor of `base`.
     */
    isAncestor: function (base, path) {
      //     base.startsWith(path + '.');
      return base.indexOf(path + '.') === 0;
    },

    /**
     * Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
     *
     * Example:
     *
     * ```
     * Polymer.Path.isDescendant('foo.bar', 'foo.bar.baz') // true
     * Polymer.Path.isDescendant('foo.bar', 'foo.bar')     // false
     * Polymer.Path.isDescendant('foo.bar', 'foo')         // false
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Path string to test against.
     * @param {string} path Path string to test.
     * @return {boolean} True if `path` is a descendant of `base`.
     */
    isDescendant: function (base, path) {
      //     path.startsWith(base + '.');
      return path.indexOf(base + '.') === 0;
    },

    /**
     * Replaces a previous base path with a new base path, preserving the
     * remainder of the path.
     *
     * User must ensure `path` has a prefix of `base`.
     *
     * Example:
     *
     * ```
     * Polymer.Path.translate('foo.bar', 'zot', 'foo.bar.baz') // 'zot.baz'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string} base Current base string to remove
     * @param {string} newBase New base string to replace with
     * @param {string} path Path to translate
     * @return {string} Translated string
     */
    translate: function (base, newBase, path) {
      return newBase + path.slice(base.length);
    },

    /**
     * @param {string} base Path string to test against
     * @param {string} path Path string to test
     * @return {boolean} True if `path` is equal to `base`
     * @this {Path}
     */
    matches: function (base, path) {
      return base === path || this.isAncestor(base, path) || this.isDescendant(base, path);
    },

    /**
     * Converts array-based paths to flattened path.  String-based paths
     * are returned as-is.
     *
     * Example:
     *
     * ```
     * Polymer.Path.normalize(['foo.bar', 0, 'baz'])  // 'foo.bar.0.baz'
     * Polymer.Path.normalize('foo.bar.0.baz')        // 'foo.bar.0.baz'
     * ```
     *
     * @memberof Polymer.Path
     * @param {string | !Array<string|number>} path Input path
     * @return {string} Flattened path
     */
    normalize: function (path) {
      if (Array.isArray(path)) {
        let parts = [];
        for (let i = 0; i < path.length; i++) {
          let args = path[i].toString().split('.');
          for (let j = 0; j < args.length; j++) {
            parts.push(args[j]);
          }
        }
        return parts.join('.');
      } else {
        return path;
      }
    },

    /**
     * Splits a path into an array of property names. Accepts either arrays
     * of path parts or strings.
     *
     * Example:
     *
     * ```
     * Polymer.Path.split(['foo.bar', 0, 'baz'])  // ['foo', 'bar', '0', 'baz']
     * Polymer.Path.split('foo.bar.0.baz')        // ['foo', 'bar', '0', 'baz']
     * ```
     *
     * @memberof Polymer.Path
     * @param {string | !Array<string|number>} path Input path
     * @return {!Array<string>} Array of path parts
     * @this {Path}
     * @suppress {checkTypes}
     */
    split: function (path) {
      if (Array.isArray(path)) {
        return this.normalize(path).split('.');
      }
      return path.toString().split('.');
    },

    /**
     * Reads a value from a path.  If any sub-property in the path is `undefined`,
     * this method returns `undefined` (will never throw.
     *
     * @memberof Polymer.Path
     * @param {Object} root Object from which to dereference path from
     * @param {string | !Array<string|number>} path Path to read
     * @param {Object=} info If an object is provided to `info`, the normalized
     *  (flattened) path will be set to `info.path`.
     * @return {*} Value at path, or `undefined` if the path could not be
     *  fully dereferenced.
     * @this {Path}
     */
    get: function (root, path, info) {
      let prop = root;
      let parts = this.split(path);
      // Loop over path parts[0..n-1] and dereference
      for (let i = 0; i < parts.length; i++) {
        if (!prop) {
          return;
        }
        let part = parts[i];
        prop = prop[part];
      }
      if (info) {
        info.path = parts.join('.');
      }
      return prop;
    },

    /**
     * Sets a value to a path.  If any sub-property in the path is `undefined`,
     * this method will no-op.
     *
     * @memberof Polymer.Path
     * @param {Object} root Object from which to dereference path from
     * @param {string | !Array<string|number>} path Path to set
     * @param {*} value Value to set to path
     * @return {string | undefined} The normalized version of the input path
     * @this {Path}
     */
    set: function (root, path, value) {
      let prop = root;
      let parts = this.split(path);
      let last = parts[parts.length - 1];
      if (parts.length > 1) {
        // Loop over path parts[0..n-2] and dereference
        for (let i = 0; i < parts.length - 1; i++) {
          let part = parts[i];
          prop = prop[part];
          if (!prop) {
            return;
          }
        }
        // Set value to object at end of path
        prop[last] = value;
      } else {
        // Simple property set
        prop[path] = value;
      }
      return parts.join('.');
    }

  };

  /**
   * Returns true if the given string is a structured data path (has dots).
   *
   * This function is deprecated.  Use `Polymer.Path.isPath` instead.
   *
   * Example:
   *
   * ```
   * Polymer.Path.isDeep('foo.bar.baz') // true
   * Polymer.Path.isDeep('foo')         // false
   * ```
   *
   * @deprecated
   * @memberof Polymer.Path
   * @param {string} path Path string
   * @return {boolean} True if the string contained one or more dots
   */
  Path.isDeep = Path.isPath;

  Polymer.Path = Path;
})();

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(1);

(function () {

  'use strict';

  // 1.x backwards-compatible auto-wrapper for template type extensions
  // This is a clear layering violation and gives favored-nation status to
  // dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
  // a.) to ease 1.x backwards-compatibility due to loss of `is`, and
  // b.) to maintain if/repeat capability in parser-constrained elements
  //     (e.g. table, select) in lieu of native CE type extensions without
  //     massive new invention in this space (e.g. directive system)

  const templateExtensions = {
    'dom-if': true,
    'dom-repeat': true
  };
  function wrapTemplateExtension(node) {
    let is = node.getAttribute('is');
    if (is && templateExtensions[is]) {
      let t = node;
      t.removeAttribute('is');
      node = t.ownerDocument.createElement(is);
      t.parentNode.replaceChild(node, t);
      node.appendChild(t);
      while (t.attributes.length) {
        node.setAttribute(t.attributes[0].name, t.attributes[0].value);
        t.removeAttribute(t.attributes[0].name);
      }
    }
    return node;
  }

  function findTemplateNode(root, nodeInfo) {
    // recursively ascend tree until we hit root
    let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
    // unwind the stack, returning the indexed node at each level
    if (parent) {
      // note: marginally faster than indexing via childNodes
      // (http://jsperf.com/childnodes-lookup)
      for (let n = parent.firstChild, i = 0; n; n = n.nextSibling) {
        if (nodeInfo.parentIndex === i++) {
          return n;
        }
      }
    } else {
      return root;
    }
  }

  // construct `$` map (from id annotations)
  function applyIdToMap(inst, map, node, nodeInfo) {
    if (nodeInfo.id) {
      map[nodeInfo.id] = node;
    }
  }

  // install event listeners (from event annotations)
  function applyEventListener(inst, node, nodeInfo) {
    if (nodeInfo.events && nodeInfo.events.length) {
      for (let j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
        inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
      }
    }
  }

  // push configuration references at configure time
  function applyTemplateContent(inst, node, nodeInfo) {
    if (nodeInfo.templateInfo) {
      node._templateInfo = nodeInfo.templateInfo;
    }
  }

  function createNodeEventHandler(context, eventName, methodName) {
    // Instances can optionally have a _methodHost which allows redirecting where
    // to find methods. Currently used by `templatize`.
    context = context._methodHost || context;
    let handler = function (e) {
      if (context[methodName]) {
        context[methodName](e, e.detail);
      } else {
        console.warn('listener method `' + methodName + '` not defined');
      }
    };
    return handler;
  }

  /**
   * Element mixin that provides basic template parsing and stamping, including
   * the following template-related features for stamped templates:
   *
   * - Declarative event listeners (`on-eventname="listener"`)
   * - Map of node id's to stamped node instances (`this.$.id`)
   * - Nested template content caching/removal and re-installation (performance
   *   optimization)
   *
   * @mixinFunction
   * @polymer
   * @memberof Polymer
   * @summary Element class mixin that provides basic template parsing and stamping
   */
  Polymer.TemplateStamp = Polymer.dedupingMixin(superClass => {

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_TemplateStamp}
     */
    class TemplateStamp extends superClass {

      /**
       * Scans a template to produce template metadata.
       *
       * Template-specific metadata are stored in the object returned, and node-
       * specific metadata are stored in objects in its flattened `nodeInfoList`
       * array.  Only nodes in the template that were parsed as nodes of
       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
       * contains an `index` (`childNodes` index in parent) and optionally
       * `parent`, which points to node info of its parent (including its index).
       *
       * The template metadata object returned from this method has the following
       * structure (many fields optional):
       *
       * ```js
       *   {
       *     // Flattened list of node metadata (for nodes that generated metadata)
       *     nodeInfoList: [
       *       {
       *         // `id` attribute for any nodes with id's for generating `$` map
       *         id: {string},
       *         // `on-event="handler"` metadata
       *         events: [
       *           {
       *             name: {string},   // event name
       *             value: {string},  // handler method name
       *           }, ...
       *         ],
       *         // Notes when the template contained a `<slot>` for shady DOM
       *         // optimization purposes
       *         hasInsertionPoint: {boolean},
       *         // For nested `<template>`` nodes, nested template metadata
       *         templateInfo: {object}, // nested template metadata
       *         // Metadata to allow efficient retrieval of instanced node
       *         // corresponding to this metadata
       *         parentInfo: {number},   // reference to parent nodeInfo>
       *         parentIndex: {number},  // index in parent's `childNodes` collection
       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
       *       },
       *       ...
       *     ],
       *     // When true, the template had the `strip-whitespace` attribute
       *     // or was nested in a template with that setting
       *     stripWhitespace: {boolean},
       *     // For nested templates, nested template content is moved into
       *     // a document fragment stored here; this is an optimization to
       *     // avoid the cost of nested template cloning
       *     content: {DocumentFragment}
       *   }
       * ```
       *
       * This method kicks off a recursive treewalk as follows:
       *
       * ```
       *    _parseTemplate <---------------------+
       *      _parseTemplateContent              |
       *        _parseTemplateNode  <------------|--+
       *          _parseTemplateNestedTemplate --+  |
       *          _parseTemplateChildNodes ---------+
       *          _parseTemplateNodeAttributes
       *            _parseTemplateNodeAttribute
       *
       * ```
       *
       * These methods may be overridden to add custom metadata about templates
       * to either `templateInfo` or `nodeInfo`.
       *
       * Note that this method may be destructive to the template, in that
       * e.g. event annotations may be removed after being noted in the
       * template metadata.
       *
       * @param {!HTMLTemplateElement} template Template to parse
       * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
       *   template, for parsing nested templates
       * @return {!TemplateInfo} Parsed template metadata
       */
      static _parseTemplate(template, outerTemplateInfo) {
        // since a template may be re-used, memo-ize metadata
        if (!template._templateInfo) {
          let templateInfo = template._templateInfo = {};
          templateInfo.nodeInfoList = [];
          templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');
          this._parseTemplateContent(template, templateInfo, { parent: null });
        }
        return template._templateInfo;
      }

      static _parseTemplateContent(template, templateInfo, nodeInfo) {
        return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
      }

      /**
       * Parses template node and adds template and node metadata based on
       * the current node, and its `childNodes` and `attributes`.
       *
       * This method may be overridden to add custom node or template specific
       * metadata based on this node.
       *
       * @param {Node} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */
      static _parseTemplateNode(node, templateInfo, nodeInfo) {
        let noted;
        let element = /** @type {Element} */node;
        if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
          noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
        } else if (element.localName === 'slot') {
          // For ShadyDom optimization, indicating there is an insertion point
          templateInfo.hasInsertionPoint = true;
        }
        if (element.firstChild) {
          noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
        }
        if (element.hasAttributes && element.hasAttributes()) {
          noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
        }
        return noted;
      }

      /**
       * Parses template child nodes for the given root node.
       *
       * This method also wraps whitelisted legacy template extensions
       * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
       * wrappers, collapses text nodes, and strips whitespace from the template
       * if the `templateInfo.stripWhitespace` setting was provided.
       *
       * @param {Node} root Root node whose `childNodes` will be parsed
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {void}
       */
      static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
        if (root.localName === 'script' || root.localName === 'style') {
          return;
        }
        for (let node = root.firstChild, parentIndex = 0, next; node; node = next) {
          // Wrap templates
          if (node.localName == 'template') {
            node = wrapTemplateExtension(node);
          }
          // collapse adjacent textNodes: fixes an IE issue that can cause
          // text nodes to be inexplicably split =(
          // note that root.normalize() should work but does not so we do this
          // manually.
          next = node.nextSibling;
          if (node.nodeType === Node.TEXT_NODE) {
            let /** Node */n = next;
            while (n && n.nodeType === Node.TEXT_NODE) {
              node.textContent += n.textContent;
              next = n.nextSibling;
              root.removeChild(n);
              n = next;
            }
            // optionally strip whitespace
            if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
              root.removeChild(node);
              continue;
            }
          }
          let childInfo = { parentIndex, parentInfo: nodeInfo };
          if (this._parseTemplateNode(node, templateInfo, childInfo)) {
            childInfo.infoIndex = templateInfo.nodeInfoList.push( /** @type {!NodeInfo} */childInfo) - 1;
          }
          // Increment if not removed
          if (node.parentNode) {
            parentIndex++;
          }
        }
      }

      /**
       * Parses template content for the given nested `<template>`.
       *
       * Nested template info is stored as `templateInfo` in the current node's
       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
       * It will then be the responsibility of the host to set it back to the
       * template and for users stamping nested templates to use the
       * `_contentForTemplate` method to retrieve the content for this template
       * (an optimization to avoid the cost of cloning nested template content).
       *
       * @param {HTMLTemplateElement} node Node to parse (a <template>)
       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
       *   that includes the template `node`
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */
      static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
        let templateInfo = this._parseTemplate(node, outerTemplateInfo);
        let content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();
        content.appendChild(node.content);
        nodeInfo.templateInfo = templateInfo;
        return true;
      }

      /**
       * Parses template node attributes and adds node metadata to `nodeInfo`
       * for nodes of interest.
       *
       * @param {Element} node Node to parse
       * @param {TemplateInfo} templateInfo Template metadata for current template
       * @param {NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */
      static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
        // Make copy of original attribute list, since the order may change
        // as attributes are added and removed
        let noted = false;
        let attrs = Array.from(node.attributes);
        for (let i = attrs.length - 1, a; a = attrs[i]; i--) {
          noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
        }
        return noted;
      }

      /**
       * Parses a single template node attribute and adds node metadata to
       * `nodeInfo` for attributes of interest.
       *
       * This implementation adds metadata for `on-event="handler"` attributes
       * and `id` attributes.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @param {string} name Attribute name
       * @param {string} value Attribute value
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       */
      static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
        // events (on-*)
        if (name.slice(0, 3) === 'on-') {
          node.removeAttribute(name);
          nodeInfo.events = nodeInfo.events || [];
          nodeInfo.events.push({
            name: name.slice(3),
            value
          });
          return true;
        }
        // static id
        else if (name === 'id') {
            nodeInfo.id = value;
            return true;
          }
        return false;
      }

      /**
       * Returns the `content` document fragment for a given template.
       *
       * For nested templates, Polymer performs an optimization to cache nested
       * template content to avoid the cost of cloning deeply nested templates.
       * This method retrieves the cached content for a given template.
       *
       * @param {HTMLTemplateElement} template Template to retrieve `content` for
       * @return {DocumentFragment} Content fragment
       */
      static _contentForTemplate(template) {
        let templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;
        return templateInfo && templateInfo.content || template.content;
      }

      /**
       * Clones the provided template content and returns a document fragment
       * containing the cloned dom.
       *
       * The template is parsed (once and memoized) using this library's
       * template parsing features, and provides the following value-added
       * features:
       * * Adds declarative event listeners for `on-event="handler"` attributes
       * * Generates an "id map" for all nodes with id's under `$` on returned
       *   document fragment
       * * Passes template info including `content` back to templates as
       *   `_templateInfo` (a performance optimization to avoid deep template
       *   cloning)
       *
       * Note that the memoized template parsing process is destructive to the
       * template: attributes for bindings and declarative event listeners are
       * removed after being noted in notes, and any nested `<template>.content`
       * is removed and stored in notes as well.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @return {!StampedTemplate} Cloned template content
       */
      _stampTemplate(template) {
        // Polyfill support: bootstrap the template if it has not already been
        if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
          HTMLTemplateElement.decorate(template);
        }
        let templateInfo = this.constructor._parseTemplate(template);
        let nodeInfo = templateInfo.nodeInfoList;
        let content = templateInfo.content || template.content;
        let dom = /** @type {DocumentFragment} */document.importNode(content, true);
        // NOTE: ShadyDom optimization indicating there is an insertion point
        dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
        let nodes = dom.nodeList = new Array(nodeInfo.length);
        dom.$ = {};
        for (let i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
          let node = nodes[i] = findTemplateNode(dom, info);
          applyIdToMap(this, dom.$, node, info);
          applyTemplateContent(this, node, info);
          applyEventListener(this, node, info);
        }
        dom = /** @type {!StampedTemplate} */dom; // eslint-disable-line no-self-assign
        return dom;
      }

      /**
       * Adds an event listener by method name for the event provided.
       *
       * This method generates a handler function that looks up the method
       * name at handling time.
       *
       * @param {!Node} node Node to add listener on
       * @param {string} eventName Name of event
       * @param {string} methodName Name of method
       * @param {*=} context Context the method will be called on (defaults
       *   to `node`)
       * @return {Function} Generated handler function
       */
      _addMethodEventListenerToNode(node, eventName, methodName, context) {
        context = context || node;
        let handler = createNodeEventHandler(context, eventName, methodName);
        this._addEventListenerToNode(node, eventName, handler);
        return handler;
      }

      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {!Node} node Node to add event listener to
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to add
       * @return {void}
       */
      _addEventListenerToNode(node, eventName, handler) {
        node.addEventListener(eventName, handler);
      }

      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {Node} node Node to remove event listener from
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to remove
       * @return {void}
       */
      _removeEventListenerFromNode(node, eventName, handler) {
        node.removeEventListener(eventName, handler);
      }

    }

    return TemplateStamp;
  });
})();

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(1);

__webpack_require__(21);

(function () {
  'use strict';

  /**
   * Creates a copy of `props` with each property normalized such that
   * upgraded it is an object with at least a type property { type: Type}.
   *
   * @param {Object} props Properties to normalize
   * @return {Object} Copy of input `props` with normalized properties that
   * are in the form {type: Type}
   * @private
   */

  function normalizeProperties(props) {
    const output = {};
    for (let p in props) {
      const o = props[p];
      output[p] = typeof o === 'function' ? { type: o } : o;
    }
    return output;
  }

  /**
   * Mixin that provides a minimal starting point to using the PropertiesChanged
   * mixin by providing a mechanism to declare properties in a static
   * getter (e.g. static get properties() { return { foo: String } }). Changes
   * are reported via the `_propertiesChanged` method.
   *
   * This mixin provides no specific support for rendering. Users are expected
   * to create a ShadowRoot and put content into it and update it in whatever
   * way makes sense. This can be done in reaction to properties changing by
   * implementing `_propertiesChanged`.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.PropertiesChanged
   * @memberof Polymer
   * @summary Mixin that provides a minimal starting point for using
   * the PropertiesChanged mixin by providing a declarative `properties` object.
   */
  Polymer.PropertiesMixin = Polymer.dedupingMixin(superClass => {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_PropertiesChanged}
     */
    const base = Polymer.PropertiesChanged(superClass);

    /**
     * Returns the super class constructor for the given class, if it is an
     * instance of the PropertiesMixin.
     *
     * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor
     * @return {PropertiesMixinConstructor} Super class constructor
     */
    function superPropertiesClass(constructor) {
      const superCtor = Object.getPrototypeOf(constructor);

      // Note, the `PropertiesMixin` class below only refers to the class
      // generated by this call to the mixin; the instanceof test only works
      // because the mixin is deduped and guaranteed only to apply once, hence
      // all constructors in a proto chain will see the same `PropertiesMixin`
      return superCtor.prototype instanceof PropertiesMixin ?
      /** @type {PropertiesMixinConstructor} */superCtor : null;
    }

    /**
     * Returns a memoized version of the `properties` object for the
     * given class. Properties not in object format are converted to at
     * least {type}.
     *
     * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor
     * @return {Object} Memoized properties object
     */
    function ownProperties(constructor) {
      if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {
        let props = null;

        if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor)) && constructor.properties) {
          props = normalizeProperties(constructor.properties);
        }

        constructor.__ownProperties = props;
      }
      return constructor.__ownProperties;
    }

    /**
     * @polymer
     * @mixinClass
     * @extends {base}
     * @implements {Polymer_PropertiesMixin}
     * @unrestricted
     */
    class PropertiesMixin extends base {

      /**
       * Implements standard custom elements getter to observes the attributes
       * listed in `properties`.
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */
      static get observedAttributes() {
        const props = this._properties;
        return props ? Object.keys(props).map(p => this.attributeNameForProperty(p)) : [];
      }

      /**
       * Finalizes an element definition, including ensuring any super classes
       * are also finalized. This includes ensuring property
       * accessors exist on the element prototype. This method calls
       * `_finalizeClass` to finalize each constructor in the prototype chain.
       * @return {void}
       */
      static finalize() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {
          const superCtor = superPropertiesClass( /** @type {PropertiesMixinConstructor} */this);
          if (superCtor) {
            superCtor.finalize();
          }
          this.__finalized = true;
          this._finalizeClass();
        }
      }

      /**
       * Finalize an element class. This includes ensuring property
       * accessors exist on the element prototype. This method is called by
       * `finalize` and finalizes the class constructor.
       *
       * @protected
       */
      static _finalizeClass() {
        const props = ownProperties( /** @type {PropertiesMixinConstructor} */this);
        if (props) {
          this.createProperties(props);
        }
      }

      /**
       * Returns a memoized version of all properties, including those inherited
       * from super classes. Properties not in object format are converted to
       * at least {type}.
       *
       * @return {Object} Object containing properties for this class
       * @protected
       */
      static get _properties() {
        if (!this.hasOwnProperty(JSCompiler_renameProperty('__properties', this))) {
          const superCtor = superPropertiesClass( /** @type {PropertiesMixinConstructor} */this);
          this.__properties = Object.assign({}, superCtor && superCtor._properties, ownProperties( /** @type {PropertiesMixinConstructor} */this));
        }
        return this.__properties;
      }

      /**
       * Overrides `PropertiesChanged` method to return type specified in the
       * static `properties` object for the given property.
       * @param {string} name Name of property
       * @return {*} Type to which to deserialize attribute
       *
       * @protected
       */
      static typeForProperty(name) {
        const info = this._properties[name];
        return info && info.type;
      }

      /**
       * Overrides `PropertiesChanged` method and adds a call to
       * `finalize` which lazily configures the element's property accessors.
       * @override
       * @return {void}
       */
      _initializeProperties() {
        this.constructor.finalize();
        super._initializeProperties();
      }

      /**
       * Called when the element is added to a document.
       * Calls `_enableProperties` to turn on property system from
       * `PropertiesChanged`.
       * @suppress {missingProperties} Super may or may not implement the callback
       * @return {void}
       */
      connectedCallback() {
        if (super.connectedCallback) {
          super.connectedCallback();
        }
        this._enableProperties();
      }

      /**
       * Called when the element is removed from a document
       * @suppress {missingProperties} Super may or may not implement the callback
       * @return {void}
       */
      disconnectedCallback() {
        if (super.disconnectedCallback) {
          super.disconnectedCallback();
        }
      }

    }

    return PropertiesMixin;
  });
})();

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(6);

__webpack_require__(10);

(function () {

  'use strict';

  // detect native touch action support

  let HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
  let GESTURE_KEY = '__polymerGestures';
  let HANDLED_OBJ = '__polymerGesturesHandled';
  let TOUCH_ACTION = '__polymerGesturesTouchAction';
  // radius for tap and track
  let TAP_DISTANCE = 25;
  let TRACK_DISTANCE = 5;
  // number of last N track positions to keep
  let TRACK_LENGTH = 2;

  // Disabling "mouse" handlers for 2500ms is enough
  let MOUSE_TIMEOUT = 2500;
  let MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
  // an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
  let MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
  let MOUSE_HAS_BUTTONS = function () {
    try {
      return new MouseEvent('test', { buttons: 1 }).buttons === 1;
    } catch (e) {
      return false;
    }
  }();

  /**
   * @param {string} name Possible mouse event name
   * @return {boolean} true if mouse event, false if not
   */
  function isMouseEvent(name) {
    return MOUSE_EVENTS.indexOf(name) > -1;
  }

  /* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
  // check for passive event listeners
  let SUPPORTS_PASSIVE = false;
  (function () {
    try {
      let opts = Object.defineProperty({}, 'passive', { get() {
          SUPPORTS_PASSIVE = true;
        } });
      window.addEventListener('test', null, opts);
      window.removeEventListener('test', null, opts);
    } catch (e) {}
  })();

  /**
   * Generate settings for event listeners, dependant on `Polymer.passiveTouchGestures`
   *
   * @param {string} eventName Event name to determine if `{passive}` option is needed
   * @return {{passive: boolean} | undefined} Options to use for addEventListener and removeEventListener
   */
  function PASSIVE_TOUCH(eventName) {
    if (isMouseEvent(eventName) || eventName === 'touchend') {
      return;
    }
    if (HAS_NATIVE_TA && SUPPORTS_PASSIVE && Polymer.passiveTouchGestures) {
      return { passive: true };
    } else {
      return;
    }
  }

  // Check for touch-only devices
  let IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

  let GestureRecognizer = function () {}; // eslint-disable-line no-unused-vars
  /** @type {function(): void} */
  GestureRecognizer.prototype.reset;
  /** @type {function(MouseEvent): void | undefined} */
  GestureRecognizer.prototype.mousedown;
  /** @type {(function(MouseEvent): void | undefined)} */
  GestureRecognizer.prototype.mousemove;
  /** @type {(function(MouseEvent): void | undefined)} */
  GestureRecognizer.prototype.mouseup;
  /** @type {(function(TouchEvent): void | undefined)} */
  GestureRecognizer.prototype.touchstart;
  /** @type {(function(TouchEvent): void | undefined)} */
  GestureRecognizer.prototype.touchmove;
  /** @type {(function(TouchEvent): void | undefined)} */
  GestureRecognizer.prototype.touchend;
  /** @type {(function(MouseEvent): void | undefined)} */
  GestureRecognizer.prototype.click;

  // touch will make synthetic mouse events
  // `preventDefault` on touchend will cancel them,
  // but this breaks `<input>` focus and link clicks
  // disable mouse handlers for MOUSE_TIMEOUT ms after
  // a touchend to ignore synthetic mouse events
  let mouseCanceller = function (mouseEvent) {
    // Check for sourceCapabilities, used to distinguish synthetic events
    // if mouseEvent did not come from a device that fires touch events,
    // it was made by a real mouse and should be counted
    // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
    let sc = mouseEvent.sourceCapabilities;
    if (sc && !sc.firesTouchEvents) {
      return;
    }
    // skip synthetic mouse events
    mouseEvent[HANDLED_OBJ] = { skip: true };
    // disable "ghost clicks"
    if (mouseEvent.type === 'click') {
      let path = mouseEvent.composedPath && mouseEvent.composedPath();
      if (path) {
        for (let i = 0; i < path.length; i++) {
          if (path[i] === POINTERSTATE.mouse.target) {
            return;
          }
        }
      }
      mouseEvent.preventDefault();
      mouseEvent.stopPropagation();
    }
  };

  /**
   * @param {boolean=} setup True to add, false to remove.
   * @return {void}
   */
  function setupTeardownMouseCanceller(setup) {
    let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
    for (let i = 0, en; i < events.length; i++) {
      en = events[i];
      if (setup) {
        document.addEventListener(en, mouseCanceller, true);
      } else {
        document.removeEventListener(en, mouseCanceller, true);
      }
    }
  }

  function ignoreMouse(e) {
    if (!POINTERSTATE.mouse.mouseIgnoreJob) {
      setupTeardownMouseCanceller(true);
    }
    let unset = function () {
      setupTeardownMouseCanceller();
      POINTERSTATE.mouse.target = null;
      POINTERSTATE.mouse.mouseIgnoreJob = null;
    };
    POINTERSTATE.mouse.target = e.composedPath()[0];
    POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debouncer.debounce(POINTERSTATE.mouse.mouseIgnoreJob, Polymer.Async.timeOut.after(MOUSE_TIMEOUT), unset);
  }

  /**
   * @param {MouseEvent} ev event to test for left mouse button down
   * @return {boolean} has left mouse button down
   */
  function hasLeftMouseButton(ev) {
    let type = ev.type;
    // exit early if the event is not a mouse event
    if (!isMouseEvent(type)) {
      return false;
    }
    // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
    // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
    if (type === 'mousemove') {
      // allow undefined for testing events
      let buttons = ev.buttons === undefined ? 1 : ev.buttons;
      if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
        buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
      }
      // buttons is a bitmask, check that the left button bit is set (1)
      return Boolean(buttons & 1);
    } else {
      // allow undefined for testing events
      let button = ev.button === undefined ? 0 : ev.button;
      // ev.button is 0 in mousedown/mouseup/click for left button activation
      return button === 0;
    }
  }

  function isSyntheticClick(ev) {
    if (ev.type === 'click') {
      // ev.detail is 0 for HTMLElement.click in most browsers
      if (ev.detail === 0) {
        return true;
      }
      // in the worst case, check that the x/y position of the click is within
      // the bounding box of the target of the event
      // Thanks IE 10 >:(
      let t = Gestures._findOriginalTarget(ev);
      // make sure the target of the event is an element so we can use getBoundingClientRect,
      // if not, just assume it is a synthetic click
      if (!t.nodeType || /** @type {Element} */t.nodeType !== Node.ELEMENT_NODE) {
        return true;
      }
      let bcr = /** @type {Element} */t.getBoundingClientRect();
      // use page x/y to account for scrolling
      let x = ev.pageX,
          y = ev.pageY;
      // ev is a synthetic click if the position is outside the bounding box of the target
      return !(x >= bcr.left && x <= bcr.right && y >= bcr.top && y <= bcr.bottom);
    }
    return false;
  }

  let POINTERSTATE = {
    mouse: {
      target: null,
      mouseIgnoreJob: null
    },
    touch: {
      x: 0,
      y: 0,
      id: -1,
      scrollDecided: false
    }
  };

  function firstTouchAction(ev) {
    let ta = 'auto';
    let path = ev.composedPath && ev.composedPath();
    if (path) {
      for (let i = 0, n; i < path.length; i++) {
        n = path[i];
        if (n[TOUCH_ACTION]) {
          ta = n[TOUCH_ACTION];
          break;
        }
      }
    }
    return ta;
  }

  function trackDocument(stateObj, movefn, upfn) {
    stateObj.movefn = movefn;
    stateObj.upfn = upfn;
    document.addEventListener('mousemove', movefn);
    document.addEventListener('mouseup', upfn);
  }

  function untrackDocument(stateObj) {
    document.removeEventListener('mousemove', stateObj.movefn);
    document.removeEventListener('mouseup', stateObj.upfn);
    stateObj.movefn = null;
    stateObj.upfn = null;
  }

  // use a document-wide touchend listener to start the ghost-click prevention mechanism
  // Use passive event listeners, if supported, to not affect scrolling performance
  document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? { passive: true } : false);

  /**
   * Module for adding listeners to a node for the following normalized
   * cross-platform "gesture" events:
   * - `down` - mouse or touch went down
   * - `up` - mouse or touch went up
   * - `tap` - mouse click or finger tap
   * - `track` - mouse drag or touch move
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for adding cross-platform gesture event listeners.
   */
  const Gestures = {
    gestures: {},
    recognizers: [],

    /**
     * Finds the element rendered on the screen at the provided coordinates.
     *
     * Similar to `document.elementFromPoint`, but pierces through
     * shadow roots.
     *
     * @memberof Polymer.Gestures
     * @param {number} x Horizontal pixel coordinate
     * @param {number} y Vertical pixel coordinate
     * @return {Element} Returns the deepest shadowRoot inclusive element
     * found at the screen position given.
     */
    deepTargetFind: function (x, y) {
      let node = document.elementFromPoint(x, y);
      let next = node;
      // this code path is only taken when native ShadowDOM is used
      // if there is a shadowroot, it may have a node at x/y
      // if there is not a shadowroot, exit the loop
      while (next && next.shadowRoot && !window.ShadyDOM) {
        // if there is a node at x/y in the shadowroot, look deeper
        let oldNext = next;
        next = next.shadowRoot.elementFromPoint(x, y);
        // on Safari, elementFromPoint may return the shadowRoot host
        if (oldNext === next) {
          break;
        }
        if (next) {
          node = next;
        }
      }
      return node;
    },
    /**
     * a cheaper check than ev.composedPath()[0];
     *
     * @private
     * @param {Event} ev Event.
     * @return {EventTarget} Returns the event target.
     */
    _findOriginalTarget: function (ev) {
      // shadowdom
      if (ev.composedPath) {
        const targets = /** @type {!Array<!EventTarget>} */ev.composedPath();
        // It shouldn't be, but sometimes targets is empty (window on Safari).
        return targets.length > 0 ? targets[0] : ev.target;
      }
      // shadydom
      return ev.target;
    },

    /**
     * @private
     * @param {Event} ev Event.
     * @return {void}
     */
    _handleNative: function (ev) {
      let handled;
      let type = ev.type;
      let node = ev.currentTarget;
      let gobj = node[GESTURE_KEY];
      if (!gobj) {
        return;
      }
      let gs = gobj[type];
      if (!gs) {
        return;
      }
      if (!ev[HANDLED_OBJ]) {
        ev[HANDLED_OBJ] = {};
        if (type.slice(0, 5) === 'touch') {
          ev = /** @type {TouchEvent} */ev; // eslint-disable-line no-self-assign
          let t = ev.changedTouches[0];
          if (type === 'touchstart') {
            // only handle the first finger
            if (ev.touches.length === 1) {
              POINTERSTATE.touch.id = t.identifier;
            }
          }
          if (POINTERSTATE.touch.id !== t.identifier) {
            return;
          }
          if (!HAS_NATIVE_TA) {
            if (type === 'touchstart' || type === 'touchmove') {
              Gestures._handleTouchAction(ev);
            }
          }
        }
      }
      handled = ev[HANDLED_OBJ];
      // used to ignore synthetic mouse events
      if (handled.skip) {
        return;
      }
      // reset recognizer state
      for (let i = 0, r; i < Gestures.recognizers.length; i++) {
        r = Gestures.recognizers[i];
        if (gs[r.name] && !handled[r.name]) {
          if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
            r.reset();
          }
        }
      }
      // enforce gesture recognizer order
      for (let i = 0, r; i < Gestures.recognizers.length; i++) {
        r = Gestures.recognizers[i];
        if (gs[r.name] && !handled[r.name]) {
          handled[r.name] = true;
          r[type](ev);
        }
      }
    },

    /**
     * @private
     * @param {TouchEvent} ev Event.
     * @return {void}
     */
    _handleTouchAction: function (ev) {
      let t = ev.changedTouches[0];
      let type = ev.type;
      if (type === 'touchstart') {
        POINTERSTATE.touch.x = t.clientX;
        POINTERSTATE.touch.y = t.clientY;
        POINTERSTATE.touch.scrollDecided = false;
      } else if (type === 'touchmove') {
        if (POINTERSTATE.touch.scrollDecided) {
          return;
        }
        POINTERSTATE.touch.scrollDecided = true;
        let ta = firstTouchAction(ev);
        let prevent = false;
        let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
        let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
        if (!ev.cancelable) {
          // scrolling is happening
        } else if (ta === 'none') {
          prevent = true;
        } else if (ta === 'pan-x') {
          prevent = dy > dx;
        } else if (ta === 'pan-y') {
          prevent = dx > dy;
        }
        if (prevent) {
          ev.preventDefault();
        } else {
          Gestures.prevent('track');
        }
      }
    },

    /**
     * Adds an event listener to a node for the given gesture type.
     *
     * @memberof Polymer.Gestures
     * @param {!Node} node Node to add listener on
     * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
     * @param {!function(!Event):void} handler Event listener function to call
     * @return {boolean} Returns true if a gesture event listener was added.
     * @this {Gestures}
     */
    addListener: function (node, evType, handler) {
      if (this.gestures[evType]) {
        this._add(node, evType, handler);
        return true;
      }
      return false;
    },

    /**
     * Removes an event listener from a node for the given gesture type.
     *
     * @memberof Polymer.Gestures
     * @param {!Node} node Node to remove listener from
     * @param {string} evType Gesture type: `down`, `up`, `track`, or `tap`
     * @param {!function(!Event):void} handler Event listener function previously passed to
     *  `addListener`.
     * @return {boolean} Returns true if a gesture event listener was removed.
     * @this {Gestures}
     */
    removeListener: function (node, evType, handler) {
      if (this.gestures[evType]) {
        this._remove(node, evType, handler);
        return true;
      }
      return false;
    },

    /**
     * automate the event listeners for the native events
     *
     * @private
     * @param {!HTMLElement} node Node on which to add the event.
     * @param {string} evType Event type to add.
     * @param {function(!Event)} handler Event handler function.
     * @return {void}
     * @this {Gestures}
     */
    _add: function (node, evType, handler) {
      let recognizer = this.gestures[evType];
      let deps = recognizer.deps;
      let name = recognizer.name;
      let gobj = node[GESTURE_KEY];
      if (!gobj) {
        node[GESTURE_KEY] = gobj = {};
      }
      for (let i = 0, dep, gd; i < deps.length; i++) {
        dep = deps[i];
        // don't add mouse handlers on iOS because they cause gray selection overlays
        if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== 'click') {
          continue;
        }
        gd = gobj[dep];
        if (!gd) {
          gobj[dep] = gd = { _count: 0 };
        }
        if (gd._count === 0) {
          node.addEventListener(dep, this._handleNative, PASSIVE_TOUCH(dep));
        }
        gd[name] = (gd[name] || 0) + 1;
        gd._count = (gd._count || 0) + 1;
      }
      node.addEventListener(evType, handler);
      if (recognizer.touchAction) {
        this.setTouchAction(node, recognizer.touchAction);
      }
    },

    /**
     * automate event listener removal for native events
     *
     * @private
     * @param {!HTMLElement} node Node on which to remove the event.
     * @param {string} evType Event type to remove.
     * @param {function(Event?)} handler Event handler function.
     * @return {void}
     * @this {Gestures}
     */
    _remove: function (node, evType, handler) {
      let recognizer = this.gestures[evType];
      let deps = recognizer.deps;
      let name = recognizer.name;
      let gobj = node[GESTURE_KEY];
      if (gobj) {
        for (let i = 0, dep, gd; i < deps.length; i++) {
          dep = deps[i];
          gd = gobj[dep];
          if (gd && gd[name]) {
            gd[name] = (gd[name] || 1) - 1;
            gd._count = (gd._count || 1) - 1;
            if (gd._count === 0) {
              node.removeEventListener(dep, this._handleNative, PASSIVE_TOUCH(dep));
            }
          }
        }
      }
      node.removeEventListener(evType, handler);
    },

    /**
     * Registers a new gesture event recognizer for adding new custom
     * gesture event types.
     *
     * @memberof Polymer.Gestures
     * @param {!GestureRecognizer} recog Gesture recognizer descriptor
     * @return {void}
     * @this {Gestures}
     */
    register: function (recog) {
      this.recognizers.push(recog);
      for (let i = 0; i < recog.emits.length; i++) {
        this.gestures[recog.emits[i]] = recog;
      }
    },

    /**
     * @private
     * @param {string} evName Event name.
     * @return {Object} Returns the gesture for the given event name.
     * @this {Gestures}
     */
    _findRecognizerByEvent: function (evName) {
      for (let i = 0, r; i < this.recognizers.length; i++) {
        r = this.recognizers[i];
        for (let j = 0, n; j < r.emits.length; j++) {
          n = r.emits[j];
          if (n === evName) {
            return r;
          }
        }
      }
      return null;
    },

    /**
     * Sets scrolling direction on node.
     *
     * This value is checked on first move, thus it should be called prior to
     * adding event listeners.
     *
     * @memberof Polymer.Gestures
     * @param {!Element} node Node to set touch action setting on
     * @param {string} value Touch action value
     * @return {void}
     */
    setTouchAction: function (node, value) {
      if (HAS_NATIVE_TA) {
        // NOTE: add touchAction async so that events can be added in
        // custom element constructors. Otherwise we run afoul of custom
        // elements restriction against settings attributes (style) in the
        // constructor.
        Polymer.Async.microTask.run(() => {
          node.style.touchAction = value;
        });
      }
      node[TOUCH_ACTION] = value;
    },

    /**
     * Dispatches an event on the `target` element of `type` with the given
     * `detail`.
     * @private
     * @param {!EventTarget} target The element on which to fire an event.
     * @param {string} type The type of event to fire.
     * @param {!Object=} detail The detail object to populate on the event.
     * @return {void}
     */
    _fire: function (target, type, detail) {
      let ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
      ev.detail = detail;
      target.dispatchEvent(ev);
      // forward `preventDefault` in a clean way
      if (ev.defaultPrevented) {
        let preventer = detail.preventer || detail.sourceEvent;
        if (preventer && preventer.preventDefault) {
          preventer.preventDefault();
        }
      }
    },

    /**
     * Prevents the dispatch and default action of the given event name.
     *
     * @memberof Polymer.Gestures
     * @param {string} evName Event name.
     * @return {void}
     * @this {Gestures}
     */
    prevent: function (evName) {
      let recognizer = this._findRecognizerByEvent(evName);
      if (recognizer.info) {
        recognizer.info.prevent = true;
      }
    },

    /**
     * Reset the 2500ms timeout on processing mouse input after detecting touch input.
     *
     * Touch inputs create synthesized mouse inputs anywhere from 0 to 2000ms after the touch.
     * This method should only be called during testing with simulated touch inputs.
     * Calling this method in production may cause duplicate taps or other Gestures.
     *
     * @memberof Polymer.Gestures
     * @return {void}
     */
    resetMouseCanceller: function () {
      if (POINTERSTATE.mouse.mouseIgnoreJob) {
        POINTERSTATE.mouse.mouseIgnoreJob.flush();
      }
    }
  };

  /* eslint-disable valid-jsdoc */

  Gestures.register({
    name: 'downup',
    deps: ['mousedown', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['down', 'up'],

    info: {
      movefn: null,
      upfn: null
    },

    /**
     * @this {GestureRecognizer}
     * @return {void}
     */
    reset: function () {
      untrackDocument(this.info);
    },

    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     * @return {void}
     */
    mousedown: function (e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      let t = Gestures._findOriginalTarget(e);
      let self = this;
      let movefn = function movefn(e) {
        if (!hasLeftMouseButton(e)) {
          self._fire('up', t, e);
          untrackDocument(self.info);
        }
      };
      let upfn = function upfn(e) {
        if (hasLeftMouseButton(e)) {
          self._fire('up', t, e);
        }
        untrackDocument(self.info);
      };
      trackDocument(this.info, movefn, upfn);
      this._fire('down', t, e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchstart: function (e) {
      this._fire('down', Gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchend: function (e) {
      this._fire('up', Gestures._findOriginalTarget(e), e.changedTouches[0], e);
    },
    /**
     * @param {string} type
     * @param {!EventTarget} target
     * @param {Event} event
     * @param {Function} preventer
     * @return {void}
     */
    _fire: function (type, target, event, preventer) {
      Gestures._fire(target, type, {
        x: event.clientX,
        y: event.clientY,
        sourceEvent: event,
        preventer: preventer,
        prevent: function (e) {
          return Gestures.prevent(e);
        }
      });
    }
  });

  Gestures.register({
    name: 'track',
    touchAction: 'none',
    deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['mouseup', 'touchend']
    },
    emits: ['track'],

    info: {
      x: 0,
      y: 0,
      state: 'start',
      started: false,
      moves: [],
      /** @this {GestureRecognizer} */
      addMove: function (move) {
        if (this.moves.length > TRACK_LENGTH) {
          this.moves.shift();
        }
        this.moves.push(move);
      },
      movefn: null,
      upfn: null,
      prevent: false
    },

    /**
     * @this {GestureRecognizer}
     * @return {void}
     */
    reset: function () {
      this.info.state = 'start';
      this.info.started = false;
      this.info.moves = [];
      this.info.x = 0;
      this.info.y = 0;
      this.info.prevent = false;
      untrackDocument(this.info);
    },

    /**
     * @this {GestureRecognizer}
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     */
    hasMovedEnough: function (x, y) {
      if (this.info.prevent) {
        return false;
      }
      if (this.info.started) {
        return true;
      }
      let dx = Math.abs(this.info.x - x);
      let dy = Math.abs(this.info.y - y);
      return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     * @return {void}
     */
    mousedown: function (e) {
      if (!hasLeftMouseButton(e)) {
        return;
      }
      let t = Gestures._findOriginalTarget(e);
      let self = this;
      let movefn = function movefn(e) {
        let x = e.clientX,
            y = e.clientY;
        if (self.hasMovedEnough(x, y)) {
          // first move is 'start', subsequent moves are 'move', mouseup is 'end'
          self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
          if (self.info.state === 'start') {
            // if and only if tracking, always prevent tap
            Gestures.prevent('tap');
          }
          self.info.addMove({ x: x, y: y });
          if (!hasLeftMouseButton(e)) {
            // always _fire "end"
            self.info.state = 'end';
            untrackDocument(self.info);
          }
          self._fire(t, e);
          self.info.started = true;
        }
      };
      let upfn = function upfn(e) {
        if (self.info.started) {
          movefn(e);
        }

        // remove the temporary listeners
        untrackDocument(self.info);
      };
      // add temporary document listeners as mouse retargets
      trackDocument(this.info, movefn, upfn);
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchstart: function (e) {
      let ct = e.changedTouches[0];
      this.info.x = ct.clientX;
      this.info.y = ct.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchmove: function (e) {
      let t = Gestures._findOriginalTarget(e);
      let ct = e.changedTouches[0];
      let x = ct.clientX,
          y = ct.clientY;
      if (this.hasMovedEnough(x, y)) {
        if (this.info.state === 'start') {
          // if and only if tracking, always prevent tap
          Gestures.prevent('tap');
        }
        this.info.addMove({ x: x, y: y });
        this._fire(t, ct);
        this.info.state = 'track';
        this.info.started = true;
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchend: function (e) {
      let t = Gestures._findOriginalTarget(e);
      let ct = e.changedTouches[0];
      // only trackend if track was started and not aborted
      if (this.info.started) {
        // reset started state on up
        this.info.state = 'end';
        this.info.addMove({ x: ct.clientX, y: ct.clientY });
        this._fire(t, ct, e);
      }
    },

    /**
     * @this {GestureRecognizer}
     * @param {!EventTarget} target
     * @param {Touch} touch
     * @return {void}
     */
    _fire: function (target, touch) {
      let secondlast = this.info.moves[this.info.moves.length - 2];
      let lastmove = this.info.moves[this.info.moves.length - 1];
      let dx = lastmove.x - this.info.x;
      let dy = lastmove.y - this.info.y;
      let ddx,
          ddy = 0;
      if (secondlast) {
        ddx = lastmove.x - secondlast.x;
        ddy = lastmove.y - secondlast.y;
      }
      Gestures._fire(target, 'track', {
        state: this.info.state,
        x: touch.clientX,
        y: touch.clientY,
        dx: dx,
        dy: dy,
        ddx: ddx,
        ddy: ddy,
        sourceEvent: touch,
        hover: function () {
          return Gestures.deepTargetFind(touch.clientX, touch.clientY);
        }
      });
    }

  });

  Gestures.register({
    name: 'tap',
    deps: ['mousedown', 'click', 'touchstart', 'touchend'],
    flow: {
      start: ['mousedown', 'touchstart'],
      end: ['click', 'touchend']
    },
    emits: ['tap'],
    info: {
      x: NaN,
      y: NaN,
      prevent: false
    },
    /**
     * @this {GestureRecognizer}
     * @return {void}
     */
    reset: function () {
      this.info.x = NaN;
      this.info.y = NaN;
      this.info.prevent = false;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     * @return {void}
     */
    save: function (e) {
      this.info.x = e.clientX;
      this.info.y = e.clientY;
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     * @return {void}
     */
    mousedown: function (e) {
      if (hasLeftMouseButton(e)) {
        this.save(e);
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {MouseEvent} e
     * @return {void}
     */
    click: function (e) {
      if (hasLeftMouseButton(e)) {
        this.forward(e);
      }
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchstart: function (e) {
      this.save(e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {TouchEvent} e
     * @return {void}
     */
    touchend: function (e) {
      this.forward(e.changedTouches[0], e);
    },
    /**
     * @this {GestureRecognizer}
     * @param {Event | Touch} e
     * @param {Event=} preventer
     * @return {void}
     */
    forward: function (e, preventer) {
      let dx = Math.abs(e.clientX - this.info.x);
      let dy = Math.abs(e.clientY - this.info.y);
      // find original target from `preventer` for TouchEvents, or `e` for MouseEvents
      let t = Gestures._findOriginalTarget( /** @type {Event} */preventer || e);
      if (!t) {
        return;
      }
      // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
      if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {
        // prevent taps from being generated if an event has canceled them
        if (!this.info.prevent) {
          Gestures._fire(t, 'tap', {
            x: e.clientX,
            y: e.clientY,
            sourceEvent: e,
            preventer: preventer
          });
        }
      }
    }
  });

  /* eslint-enable valid-jsdoc */

  /** @deprecated */
  Gestures.findOriginalTarget = Gestures._findOriginalTarget;

  /** @deprecated */
  Gestures.add = Gestures.addListener;

  /** @deprecated */
  Gestures.remove = Gestures.removeListener;

  Polymer.Gestures = Gestures;
})();

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(20);

(function () {
  'use strict';

  const HOST_DIR = /:host\(:dir\((ltr|rtl)\)\)/g;
  const HOST_DIR_REPLACMENT = ':host([dir="$1"])';

  const EL_DIR = /([\s\w-#\.\[\]\*]*):dir\((ltr|rtl)\)/g;
  const EL_DIR_REPLACMENT = ':host([dir="$2"]) $1';

  /**
   * @type {!Array<!Polymer_DirMixin>}
   */
  const DIR_INSTANCES = [];

  /** @type {MutationObserver} */
  let observer = null;

  let DOCUMENT_DIR = '';

  function getRTL() {
    DOCUMENT_DIR = document.documentElement.getAttribute('dir');
  }

  /**
   * @param {!Polymer_DirMixin} instance Instance to set RTL status on
   */
  function setRTL(instance) {
    if (!instance.__autoDirOptOut) {
      const el = /** @type {!HTMLElement} */instance;
      el.setAttribute('dir', DOCUMENT_DIR);
    }
  }

  function updateDirection() {
    getRTL();
    DOCUMENT_DIR = document.documentElement.getAttribute('dir');
    for (let i = 0; i < DIR_INSTANCES.length; i++) {
      setRTL(DIR_INSTANCES[i]);
    }
  }

  function takeRecords() {
    if (observer && observer.takeRecords().length) {
      updateDirection();
    }
  }

  /**
   * Element class mixin that allows elements to use the `:dir` CSS Selector to have
   * text direction specific styling.
   *
   * With this mixin, any stylesheet provided in the template will transform `:dir` into
   * `:host([dir])` and sync direction with the page via the element's `dir` attribute.
   *
   * Elements can opt out of the global page text direction by setting the `dir` attribute
   * directly in `ready()` or in HTML.
   *
   * Caveats:
   * - Applications must set `<html dir="ltr">` or `<html dir="rtl">` to sync direction
   * - Automatic left-to-right or right-to-left styling is sync'd with the `<html>` element only.
   * - Changing `dir` at runtime is supported.
   * - Opting out of the global direction styling is permanent
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin Polymer.PropertyAccessors
   * @memberof Polymer
   */
  Polymer.DirMixin = Polymer.dedupingMixin(base => {

    if (!observer) {
      getRTL();
      observer = new MutationObserver(updateDirection);
      observer.observe(document.documentElement, { attributes: true, attributeFilter: ['dir'] });
    }

    /**
     * @constructor
     * @extends {base}
     * @implements {Polymer_PropertyAccessors}
     */
    const elementBase = Polymer.PropertyAccessors(base);

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_DirMixin}
     */
    class Dir extends elementBase {

      /**
       * @override
       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
       */
      static _processStyleText(cssText, baseURI) {
        cssText = super._processStyleText(cssText, baseURI);
        cssText = this._replaceDirInCssText(cssText);
        return cssText;
      }

      /**
       * Replace `:dir` in the given CSS text
       *
       * @param {string} text CSS text to replace DIR
       * @return {string} Modified CSS
       */
      static _replaceDirInCssText(text) {
        let replacedText = text;
        replacedText = replacedText.replace(HOST_DIR, HOST_DIR_REPLACMENT);
        replacedText = replacedText.replace(EL_DIR, EL_DIR_REPLACMENT);
        if (text !== replacedText) {
          this.__activateDir = true;
        }
        return replacedText;
      }

      constructor() {
        super();
        /** @type {boolean} */
        this.__autoDirOptOut = false;
      }

      /**
       * @suppress {invalidCasts} Closure doesn't understand that `this` is an HTMLElement
       * @return {void}
       */
      ready() {
        super.ready();
        this.__autoDirOptOut = /** @type {!HTMLElement} */this.hasAttribute('dir');
      }

      /**
       * @suppress {missingProperties} If it exists on elementBase, it can be super'd
       * @return {void}
       */
      connectedCallback() {
        if (elementBase.prototype.connectedCallback) {
          super.connectedCallback();
        }
        if (this.constructor.__activateDir) {
          takeRecords();
          DIR_INSTANCES.push(this);
          setRTL(this);
        }
      }

      /**
       * @suppress {missingProperties} If it exists on elementBase, it can be super'd
       * @return {void}
       */
      disconnectedCallback() {
        if (elementBase.prototype.disconnectedCallback) {
          super.disconnectedCallback();
        }
        if (this.constructor.__activateDir) {
          const idx = DIR_INSTANCES.indexOf(this);
          if (idx > -1) {
            DIR_INSTANCES.splice(idx, 1);
          }
        }
      }
    }

    Dir.__activateDir = false;

    return Dir;
  });
})();

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

(function () {

  'use strict';

  // run a callback when HTMLImports are ready or immediately if
  // this api is not available.

  function whenImportsReady(cb) {
    if (window.HTMLImports) {
      HTMLImports.whenReady(cb);
    } else {
      cb();
    }
  }

  /**
   * Convenience method for importing an HTML document imperatively.
   *
   * This method creates a new `<link rel="import">` element with
   * the provided URL and appends it to the document to start loading.
   * In the `onload` callback, the `import` property of the `link`
   * element will contain the imported document contents.
   *
   * @memberof Polymer
   * @param {string} href URL to document to load.
   * @param {?function(!Event):void=} onload Callback to notify when an import successfully
   *   loaded.
   * @param {?function(!ErrorEvent):void=} onerror Callback to notify when an import
   *   unsuccessfully loaded.
   * @param {boolean=} optAsync True if the import should be loaded `async`.
   *   Defaults to `false`.
   * @return {!HTMLLinkElement} The link element for the URL to be loaded.
   */
  Polymer.importHref = function (href, onload, onerror, optAsync) {
    let link = /** @type {HTMLLinkElement} */
    document.head.querySelector('link[href="' + href + '"][import-href]');
    if (!link) {
      link = /** @type {HTMLLinkElement} */document.createElement('link');
      link.rel = 'import';
      link.href = href;
      link.setAttribute('import-href', '');
    }
    // always ensure link has `async` attribute if user specified one,
    // even if it was previously not async. This is considered less confusing.
    if (optAsync) {
      link.setAttribute('async', '');
    }
    // NOTE: the link may now be in 3 states: (1) pending insertion,
    // (2) inflight, (3) already loaded. In each case, we need to add
    // event listeners to process callbacks.
    let cleanup = function () {
      link.removeEventListener('load', loadListener);
      link.removeEventListener('error', errorListener);
    };
    let loadListener = function (event) {
      cleanup();
      // In case of a successful load, cache the load event on the link so
      // that it can be used to short-circuit this method in the future when
      // it is called with the same href param.
      link.__dynamicImportLoaded = true;
      if (onload) {
        whenImportsReady(() => {
          onload(event);
        });
      }
    };
    let errorListener = function (event) {
      cleanup();
      // In case of an error, remove the link from the document so that it
      // will be automatically created again the next time `importHref` is
      // called.
      if (link.parentNode) {
        link.parentNode.removeChild(link);
      }
      if (onerror) {
        whenImportsReady(() => {
          onerror(event);
        });
      }
    };
    link.addEventListener('load', loadListener);
    link.addEventListener('error', errorListener);
    if (link.parentNode == null) {
      document.head.appendChild(link);
      // if the link already loaded, dispatch a fake load event
      // so that listeners are called and get a proper event argument.
    } else if (link.__dynamicImportLoaded) {
      link.dispatchEvent(new Event('load'));
    }
    return link;
  };
})();

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

(function () {

  'use strict';

  let scheduled = false;
  let beforeRenderQueue = [];
  let afterRenderQueue = [];

  function schedule() {
    scheduled = true;
    // before next render
    requestAnimationFrame(function () {
      scheduled = false;
      flushQueue(beforeRenderQueue);
      // after the render
      setTimeout(function () {
        runQueue(afterRenderQueue);
      });
    });
  }

  function flushQueue(queue) {
    while (queue.length) {
      callMethod(queue.shift());
    }
  }

  function runQueue(queue) {
    for (let i = 0, l = queue.length; i < l; i++) {
      callMethod(queue.shift());
    }
  }

  function callMethod(info) {
    const context = info[0];
    const callback = info[1];
    const args = info[2];
    try {
      callback.apply(context, args);
    } catch (e) {
      setTimeout(() => {
        throw e;
      });
    }
  }

  function flush() {
    while (beforeRenderQueue.length || afterRenderQueue.length) {
      flushQueue(beforeRenderQueue);
      flushQueue(afterRenderQueue);
    }
    scheduled = false;
  }

  /**
   * Module for scheduling flushable pre-render and post-render tasks.
   *
   * @namespace
   * @memberof Polymer
   * @summary Module for scheduling flushable pre-render and post-render tasks.
   */
  Polymer.RenderStatus = {

    /**
     * Enqueues a callback which will be run before the next render, at
     * `requestAnimationFrame` timing.
     *
     * This method is useful for enqueuing work that requires DOM measurement,
     * since measurement may not be reliable in custom element callbacks before
     * the first render, as well as for batching measurement tasks in general.
     *
     * Tasks in this queue may be flushed by calling `Polymer.RenderStatus.flush()`.
     *
     * @memberof Polymer.RenderStatus
     * @param {*} context Context object the callback function will be bound to
     * @param {function(...*):void} callback Callback function
     * @param {!Array=} args An array of arguments to call the callback function with
     * @return {void}
     */
    beforeNextRender: function (context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      beforeRenderQueue.push([context, callback, args]);
    },

    /**
     * Enqueues a callback which will be run after the next render, equivalent
     * to one task (`setTimeout`) after the next `requestAnimationFrame`.
     *
     * This method is useful for tuning the first-render performance of an
     * element or application by deferring non-critical work until after the
     * first paint.  Typical non-render-critical work may include adding UI
     * event listeners and aria attributes.
     *
     * @memberof Polymer.RenderStatus
     * @param {*} context Context object the callback function will be bound to
     * @param {function(...*):void} callback Callback function
     * @param {!Array=} args An array of arguments to call the callback function with
     * @return {void}
     */
    afterNextRender: function (context, callback, args) {
      if (!scheduled) {
        schedule();
      }
      afterRenderQueue.push([context, callback, args]);
    },

    /**
     * Flushes all `beforeNextRender` tasks, followed by all `afterNextRender`
     * tasks.
     *
     * @memberof Polymer.RenderStatus
     * @return {void}
     */
    flush: flush

  };
})();

/***/ }),
/* 40 */
/***/ (function(module, exports) {



(function () {
  'use strict';

  // unresolved

  function resolve() {
    document.body.removeAttribute('unresolved');
  }

  if (window.WebComponents) {
    window.addEventListener('WebComponentsReady', resolve);
  } else {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      resolve();
    } else {
      window.addEventListener('DOMContentLoaded', resolve);
    }
  }
})();

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(17);

__webpack_require__(42);

__webpack_require__(11);

(function () {
  'use strict';

  const p = Element.prototype;
  /**
   * @const {function(this:Node, string): boolean}
   */
  const normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

  /**
   * Cross-platform `element.matches` shim.
   *
   * @function matchesSelector
   * @memberof Polymer.dom
   * @param {!Node} node Node to check selector against
   * @param {string} selector Selector to match
   * @return {boolean} True if node matched selector
   */
  const matchesSelector = function (node, selector) {
    return normalizedMatchesSelector.call(node, selector);
  };

  /**
   * Node API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is a `Node`.
   *
   * @memberof Polymer
   */
  class DomApi {

    /**
     * @param {Node} node Node for which to create a Polymer.dom helper object.
     */
    constructor(node) {
      this.node = node;
    }

    /**
     * Returns an instance of `Polymer.FlattenedNodesObserver` that
     * listens for node changes on this element.
     *
     * @param {function(!Element, { target: !Element, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Called when direct or distributed children
     *   of this element changes
     * @return {!Polymer.FlattenedNodesObserver} Observer instance
     */
    observeNodes(callback) {
      return new Polymer.FlattenedNodesObserver(this.node, callback);
    }

    /**
     * Disconnects an observer previously created via `observeNodes`
     *
     * @param {!Polymer.FlattenedNodesObserver} observerHandle Observer instance
     *   to disconnect.
     * @return {void}
     */
    unobserveNodes(observerHandle) {
      observerHandle.disconnect();
    }

    /**
     * Provided as a backwards-compatible API only.  This method does nothing.
     * @return {void}
     */
    notifyObserver() {}

    /**
     * Returns true if the provided node is contained with this element's
     * light-DOM children or shadow root, including any nested shadow roots
     * of children therein.
     *
     * @param {Node} node Node to test
     * @return {boolean} Returns true if the given `node` is contained within
     *   this element's light or shadow DOM.
     */
    deepContains(node) {
      if (this.node.contains(node)) {
        return true;
      }
      let n = node;
      let doc = node.ownerDocument;
      // walk from node to `this` or `document`
      while (n && n !== doc && n !== this.node) {
        // use logical parentnode, or native ShadowRoot host
        n = n.parentNode || n.host;
      }
      return n === this.node;
    }

    /**
     * Returns the root node of this node.  Equivalent to `getRoodNode()`.
     *
     * @return {Node} Top most element in the dom tree in which the node
     * exists. If the node is connected to a document this is either a
     * shadowRoot or the document; otherwise, it may be the node
     * itself or a node or document fragment containing it.
     */
    getOwnerRoot() {
      return this.node.getRootNode();
    }

    /**
     * For slot elements, returns the nodes assigned to the slot; otherwise
     * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
     *
     * @return {!Array<!Node>} Array of assigned nodes
     */
    getDistributedNodes() {
      return this.node.localName === 'slot' ? this.node.assignedNodes({ flatten: true }) : [];
    }

    /**
     * Returns an array of all slots this element was distributed to.
     *
     * @return {!Array<!HTMLSlotElement>} Description
     */
    getDestinationInsertionPoints() {
      let ip$ = [];
      let n = this.node.assignedSlot;
      while (n) {
        ip$.push(n);
        n = n.assignedSlot;
      }
      return ip$;
    }

    /**
     * Calls `importNode` on the `ownerDocument` for this node.
     *
     * @param {!Node} node Node to import
     * @param {boolean} deep True if the node should be cloned deeply during
     *   import
     * @return {Node} Clone of given node imported to this owner document
     */
    importNode(node, deep) {
      let doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
      return doc.importNode(node, deep);
    }

    /**
     * @return {!Array<!Node>} Returns a flattened list of all child nodes and
     * nodes assigned to child slots.
     */
    getEffectiveChildNodes() {
      return Polymer.FlattenedNodesObserver.getFlattenedNodes(this.node);
    }

    /**
     * Returns a filtered list of flattened child elements for this element based
     * on the given selector.
     *
     * @param {string} selector Selector to filter nodes against
     * @return {!Array<!HTMLElement>} List of flattened child elements
     */
    queryDistributedElements(selector) {
      let c$ = this.getEffectiveChildNodes();
      let list = [];
      for (let i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
        if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
          list.push(c);
        }
      }
      return list;
    }

    /**
     * For shadow roots, returns the currently focused element within this
     * shadow root.
     *
     * @return {Node|undefined} Currently focused element
     */
    get activeElement() {
      let node = this.node;
      return node._activeElement !== undefined ? node._activeElement : node.activeElement;
    }
  }

  function forwardMethods(proto, methods) {
    for (let i = 0; i < methods.length; i++) {
      let method = methods[i];
      /* eslint-disable valid-jsdoc */
      proto[method] = /** @this {DomApi} */function () {
        return this.node[method].apply(this.node, arguments);
      };
      /* eslint-enable */
    }
  }

  function forwardReadOnlyProperties(proto, properties) {
    for (let i = 0; i < properties.length; i++) {
      let name = properties[i];
      Object.defineProperty(proto, name, {
        get: function () {
          const domApi = /** @type {DomApi} */this;
          return domApi.node[name];
        },
        configurable: true
      });
    }
  }

  function forwardProperties(proto, properties) {
    for (let i = 0; i < properties.length; i++) {
      let name = properties[i];
      Object.defineProperty(proto, name, {
        get: function () {
          const domApi = /** @type {DomApi} */this;
          return domApi.node[name];
        },
        set: function (value) {
          /** @type {DomApi} */this.node[name] = value;
        },
        configurable: true
      });
    }
  }

  forwardMethods(DomApi.prototype, ['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector', 'querySelectorAll']);

  forwardReadOnlyProperties(DomApi.prototype, ['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling', 'childNodes', 'children', 'classList']);

  forwardProperties(DomApi.prototype, ['textContent', 'innerHTML']);

  /**
   * Event API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is an `Event`.
   */
  class EventApi {
    constructor(event) {
      this.event = event;
    }

    /**
     * Returns the first node on the `composedPath` of this event.
     *
     * @return {!EventTarget} The node this event was dispatched to
     */
    get rootTarget() {
      return this.event.composedPath()[0];
    }

    /**
     * Returns the local (re-targeted) target for this event.
     *
     * @return {!EventTarget} The local (re-targeted) target for this event.
     */
    get localTarget() {
      return this.event.target;
    }

    /**
     * Returns the `composedPath` for this event.
     * @return {!Array<EventTarget>} The nodes this event propagated through
     */
    get path() {
      return this.event.composedPath();
    }
  }

  Polymer.DomApi = DomApi;

  /**
   * @function
   * @param {boolean=} deep
   * @return {!Node}
   */
  Polymer.DomApi.prototype.cloneNode;
  /**
   * @function
   * @param {!Node} node
   * @return {!Node}
   */
  Polymer.DomApi.prototype.appendChild;
  /**
   * @function
   * @param {!Node} newChild
   * @param {Node} refChild
   * @return {!Node}
   */
  Polymer.DomApi.prototype.insertBefore;
  /**
   * @function
   * @param {!Node} node
   * @return {!Node}
   */
  Polymer.DomApi.prototype.removeChild;
  /**
   * @function
   * @param {!Node} oldChild
   * @param {!Node} newChild
   * @return {!Node}
   */
  Polymer.DomApi.prototype.replaceChild;
  /**
   * @function
   * @param {string} name
   * @param {string} value
   * @return {void}
   */
  Polymer.DomApi.prototype.setAttribute;
  /**
   * @function
   * @param {string} name
   * @return {void}
   */
  Polymer.DomApi.prototype.removeAttribute;
  /**
   * @function
   * @param {string} selector
   * @return {?Element}
   */
  Polymer.DomApi.prototype.querySelector;
  /**
   * @function
   * @param {string} selector
   * @return {!NodeList<!Element>}
   */
  Polymer.DomApi.prototype.querySelectorAll;

  /**
   * Legacy DOM and Event manipulation API wrapper factory used to abstract
   * differences between native Shadow DOM and "Shady DOM" when polyfilling on
   * older browsers.
   *
   * Note that in Polymer 2.x use of `Polymer.dom` is no longer required and
   * in the majority of cases simply facades directly to the standard native
   * API.
   *
   * @namespace
   * @summary Legacy DOM and Event manipulation API wrapper factory used to
   * abstract differences between native Shadow DOM and "Shady DOM."
   * @memberof Polymer
   * @param {(Node|Event)=} obj Node or event to operate on
   * @return {!DomApi|!EventApi} Wrapper providing either node API or event API
   */
  Polymer.dom = function (obj) {
    obj = obj || document;
    if (!obj.__domApi) {
      let helper;
      if (obj instanceof Event) {
        helper = new EventApi(obj);
      } else {
        helper = new DomApi(obj);
      }
      obj.__domApi = helper;
    }
    return obj.__domApi;
  };

  Polymer.dom.matchesSelector = matchesSelector;

  /**
   * Forces several classes of asynchronously queued tasks to flush:
   * - Debouncers added via `Polymer.enqueueDebouncer`
   * - ShadyDOM distribution
   *
   * This method facades to `Polymer.flush`.
   *
   * @memberof Polymer.dom
   */
  Polymer.dom.flush = Polymer.flush;

  /**
   * Adds a `Polymer.Debouncer` to a list of globally flushable tasks.
   *
   * This method facades to `Polymer.enqueueDebouncer`.
   *
   * @memberof Polymer.dom
   * @param {Polymer.Debouncer} debouncer Debouncer to enqueue
   */
  Polymer.dom.addDebouncer = Polymer.enqueueDebouncer;
})();

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(23);

__webpack_require__(6);

(function () {
  'use strict';

  /**
   * Returns true if `node` is a slot element
   * @param {Node} node Node to test.
   * @return {boolean} Returns true if the given `node` is a slot
   * @private
   */

  function isSlot(node) {
    return node.localName === 'slot';
  }

  /**
   * Class that listens for changes (additions or removals) to
   * "flattened nodes" on a given `node`. The list of flattened nodes consists
   * of a node's children and, for any children that are `<slot>` elements,
   * the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * The provided `callback` is called whenever any change to this list
   * of flattened nodes occurs, where an addition or removal of a node is
   * considered a change. The `callback` is called with one argument, an object
   * containing an array of any `addedNodes` and `removedNodes`.
   *
   * Note: the callback is called asynchronous to any changes
   * at a microtask checkpoint. This is because observation is performed using
   * `MutationObserver` and the `<slot>` element's `slotchange` event which
   * are asynchronous.
   *
   * An example:
   * ```js
   * class TestSelfObserve extends Polymer.Element {
   *   static get is() { return 'test-self-observe';}
   *   connectedCallback() {
   *     super.connectedCallback();
   *     this._observer = new Polymer.FlattenedNodesObserver(this, (info) => {
   *       this.info = info;
   *     });
   *   }
   *   disconnectedCallback() {
   *     super.disconnectedCallback();
   *     this._observer.disconnect();
   *   }
   * }
   * customElements.define(TestSelfObserve.is, TestSelfObserve);
   * ```
   *
   * @memberof Polymer
   * @summary Class that listens for changes (additions or removals) to
   * "flattened nodes" on a given `node`.
   */
  class FlattenedNodesObserver {

    /**
     * Returns the list of flattened nodes for the given `node`.
     * This list consists of a node's children and, for any children
     * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
     * For example, if the observed node has children `<a></a><slot></slot><b></b>`
     * and the `<slot>` has one `<div>` assigned to it, then the flattened
     * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
     * `<slot>` elements assigned to it, these are flattened as well.
     *
     * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.
     * @return {Array} The list of flattened nodes for the given `node`.
    */
    static getFlattenedNodes(node) {
      if (isSlot(node)) {
        node = /** @type {HTMLSlotElement} */node; // eslint-disable-line no-self-assign
        return node.assignedNodes({ flatten: true });
      } else {
        return Array.from(node.childNodes).map(node => {
          if (isSlot(node)) {
            node = /** @type {HTMLSlotElement} */node; // eslint-disable-line no-self-assign
            return node.assignedNodes({ flatten: true });
          } else {
            return [node];
          }
        }).reduce((a, b) => a.concat(b), []);
      }
    }

    /**
     * @param {Element} target Node on which to listen for changes.
     * @param {?function(!Element, { target: !Element, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Function called when there are additions
     * or removals from the target's list of flattened nodes.
    */
    constructor(target, callback) {
      /**
       * @type {MutationObserver}
       * @private
       */
      this._shadyChildrenObserver = null;
      /**
       * @type {MutationObserver}
       * @private
       */
      this._nativeChildrenObserver = null;
      this._connected = false;
      /**
       * @type {Element}
       * @private
       */
      this._target = target;
      this.callback = callback;
      this._effectiveNodes = [];
      this._observer = null;
      this._scheduled = false;
      /**
       * @type {function()}
       * @private
       */
      this._boundSchedule = () => {
        this._schedule();
      };
      this.connect();
      this._schedule();
    }

    /**
     * Activates an observer. This method is automatically called when
     * a `FlattenedNodesObserver` is created. It should only be called to
     * re-activate an observer that has been deactivated via the `disconnect` method.
     *
     * @return {void}
     */
    connect() {
      if (isSlot(this._target)) {
        this._listenSlots([this._target]);
      } else if (this._target.children) {
        this._listenSlots(this._target.children);
        if (window.ShadyDOM) {
          this._shadyChildrenObserver = ShadyDOM.observeChildren(this._target, mutations => {
            this._processMutations(mutations);
          });
        } else {
          this._nativeChildrenObserver = new MutationObserver(mutations => {
            this._processMutations(mutations);
          });
          this._nativeChildrenObserver.observe(this._target, { childList: true });
        }
      }
      this._connected = true;
    }

    /**
     * Deactivates the flattened nodes observer. After calling this method
     * the observer callback will not be called when changes to flattened nodes
     * occur. The `connect` method may be subsequently called to reactivate
     * the observer.
     *
     * @return {void}
     */
    disconnect() {
      if (isSlot(this._target)) {
        this._unlistenSlots([this._target]);
      } else if (this._target.children) {
        this._unlistenSlots(this._target.children);
        if (window.ShadyDOM && this._shadyChildrenObserver) {
          ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
          this._shadyChildrenObserver = null;
        } else if (this._nativeChildrenObserver) {
          this._nativeChildrenObserver.disconnect();
          this._nativeChildrenObserver = null;
        }
      }
      this._connected = false;
    }

    /**
     * @return {void}
     * @private
     */
    _schedule() {
      if (!this._scheduled) {
        this._scheduled = true;
        Polymer.Async.microTask.run(() => this.flush());
      }
    }

    /**
     * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
     * @return {void}
     * @private
     */
    _processMutations(mutations) {
      this._processSlotMutations(mutations);
      this.flush();
    }

    /**
     * @param {Array<MutationRecord>} mutations Mutations signaled by the mutation observer
     * @return {void}
     * @private
     */
    _processSlotMutations(mutations) {
      if (mutations) {
        for (let i = 0; i < mutations.length; i++) {
          let mutation = mutations[i];
          if (mutation.addedNodes) {
            this._listenSlots(mutation.addedNodes);
          }
          if (mutation.removedNodes) {
            this._unlistenSlots(mutation.removedNodes);
          }
        }
      }
    }

    /**
     * Flushes the observer causing any pending changes to be immediately
     * delivered the observer callback. By default these changes are delivered
     * asynchronously at the next microtask checkpoint.
     *
     * @return {boolean} Returns true if any pending changes caused the observer
     * callback to run.
     */
    flush() {
      if (!this._connected) {
        return false;
      }
      if (window.ShadyDOM) {
        ShadyDOM.flush();
      }
      if (this._nativeChildrenObserver) {
        this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
      } else if (this._shadyChildrenObserver) {
        this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
      }
      this._scheduled = false;
      let info = {
        target: this._target,
        addedNodes: [],
        removedNodes: []
      };
      let newNodes = this.constructor.getFlattenedNodes(this._target);
      let splices = Polymer.ArraySplice.calculateSplices(newNodes, this._effectiveNodes);
      // process removals
      for (let i = 0, s; i < splices.length && (s = splices[i]); i++) {
        for (let j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
          info.removedNodes.push(n);
        }
      }
      // process adds
      for (let i = 0, s; i < splices.length && (s = splices[i]); i++) {
        for (let j = s.index; j < s.index + s.addedCount; j++) {
          info.addedNodes.push(newNodes[j]);
        }
      }
      // update cache
      this._effectiveNodes = newNodes;
      let didFlush = false;
      if (info.addedNodes.length || info.removedNodes.length) {
        didFlush = true;
        this.callback.call(this._target, info);
      }
      return didFlush;
    }

    /**
     * @param {!Array<Element|Node>|!NodeList<Node>} nodeList Nodes that could change
     * @return {void}
     * @private
     */
    _listenSlots(nodeList) {
      for (let i = 0; i < nodeList.length; i++) {
        let n = nodeList[i];
        if (isSlot(n)) {
          n.addEventListener('slotchange', this._boundSchedule);
        }
      }
    }

    /**
     * @param {!Array<Element|Node>|!NodeList<Node>} nodeList Nodes that could change
     * @return {void}
     * @private
     */
    _unlistenSlots(nodeList) {
      for (let i = 0; i < nodeList.length; i++) {
        let n = nodeList[i];
        if (isSlot(n)) {
          n.removeEventListener('slotchange', this._boundSchedule);
        }
      }
    }

  }

  Polymer.FlattenedNodesObserver = FlattenedNodesObserver;
})();

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(44);

(function () {
  'use strict';

  /**
   * Legacy class factory and registration helper for defining Polymer
   * elements.
   *
   * This method is equivalent to
   * `customElements.define(info.is, Polymer.Class(info));`
   *
   * See `Polymer.Class` for details on valid legacy metadata format for `info`.
   *
   * @global
   * @override
   * @function Polymer
   * @param {!PolymerInit} info Object containing Polymer metadata and functions
   *   to become class methods.
   * @return {function(new: HTMLElement)} Generated class
   * @suppress {duplicate, invalidCasts, checkTypes}
   */

  window.Polymer._polymerFn = function (info) {
    // if input is a `class` (aka a function with a prototype), use the prototype
    // remember that the `constructor` will never be called
    let klass;
    if (typeof info === 'function') {
      klass = info;
    } else {
      klass = Polymer.Class(info);
    }
    customElements.define(klass.is, /** @type {!HTMLElement} */klass);
    return klass;
  };
})();

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(15);

(function () {

  'use strict';

  let metaProps = {
    attached: true,
    detached: true,
    ready: true,
    created: true,
    beforeRegister: true,
    registered: true,
    attributeChanged: true,
    // meta objects
    behaviors: true
  };

  /**
   * Applies a "legacy" behavior or array of behaviors to the provided class.
   *
   * Note: this method will automatically also apply the `Polymer.LegacyElementMixin`
   * to ensure that any legacy behaviors can rely on legacy Polymer API on
   * the underlying element.
   *
   * @template T
   * @param {!Object|!Array<!Object>} behaviors Behavior object or array of behaviors.
   * @param {function(new:T)} klass Element class.
   * @return {function(new:T)} Returns a new Element class extended by the
   * passed in `behaviors` and also by `Polymer.LegacyElementMixin`.
   * @memberof Polymer
   * @suppress {invalidCasts, checkTypes}
   */
  function mixinBehaviors(behaviors, klass) {
    if (!behaviors) {
      klass = /** @type {HTMLElement} */klass; // eslint-disable-line no-self-assign
      return klass;
    }
    // NOTE: ensure the behavior is extending a class with
    // legacy element api. This is necessary since behaviors expect to be able
    // to access 1.x legacy api.
    klass = Polymer.LegacyElementMixin(klass);
    if (!Array.isArray(behaviors)) {
      behaviors = [behaviors];
    }
    let superBehaviors = klass.prototype.behaviors;
    // get flattened, deduped list of behaviors *not* already on super class
    behaviors = flattenBehaviors(behaviors, null, superBehaviors);
    // mixin new behaviors
    klass = _mixinBehaviors(behaviors, klass);
    if (superBehaviors) {
      behaviors = superBehaviors.concat(behaviors);
    }
    // Set behaviors on prototype for BC...
    klass.prototype.behaviors = behaviors;
    return klass;
  }

  // NOTE:
  // 1.x
  // Behaviors were mixed in *in reverse order* and de-duped on the fly.
  // The rule was that behavior properties were copied onto the element
  // prototype if and only if the property did not already exist.
  // Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
  // (1), B, (2), A, (3) C. This means prototype properties win over
  // B properties win over A win over C. This mirrors what would happen
  // with inheritance if element extended B extended A extended C.
  //
  // Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
  // `behaviors` array was [C, A, B].
  // Behavior lifecycle methods were called in behavior array order
  // followed by the element, e.g. (1) C.created, (2) A.created,
  // (3) B.created, (4) element.created. There was no support for
  // super, and "super-behavior" methods were callable only by name).
  //
  // 2.x
  // Behaviors are made into proper mixins which live in the
  // element's prototype chain. Behaviors are placed in the element prototype
  // eldest to youngest and de-duped youngest to oldest:
  // So, first [A, B, C, A, B] becomes [C, A, B] then,
  // the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
  // (3) class(A), (4) class(B), (5) class(Polymer({...})).
  // Result:
  // This means element properties win over B properties win over A win
  // over C. (same as 1.x)
  // If lifecycle is called (super then me), order is
  // (1) C.created, (2) A.created, (3) B.created, (4) element.created
  // (again same as 1.x)
  function _mixinBehaviors(behaviors, klass) {
    for (let i = 0; i < behaviors.length; i++) {
      let b = behaviors[i];
      if (b) {
        klass = Array.isArray(b) ? _mixinBehaviors(b, klass) : GenerateClassFromInfo(b, klass);
      }
    }
    return klass;
  }

  /**
   * @param {Array} behaviors List of behaviors to flatten.
   * @param {Array=} list Target list to flatten behaviors into.
   * @param {Array=} exclude List of behaviors to exclude from the list.
   * @return {!Array} Returns the list of flattened behaviors.
   */
  function flattenBehaviors(behaviors, list, exclude) {
    list = list || [];
    for (let i = behaviors.length - 1; i >= 0; i--) {
      let b = behaviors[i];
      if (b) {
        if (Array.isArray(b)) {
          flattenBehaviors(b, list);
        } else {
          // dedup
          if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
            list.unshift(b);
          }
        }
      } else {
        console.warn('behavior is null, check for missing or 404 import');
      }
    }
    return list;
  }

  /**
   * @param {!PolymerInit} info Polymer info object
   * @param {function(new:HTMLElement)} Base base class to extend with info object
   * @return {function(new:HTMLElement)} Generated class
   * @suppress {checkTypes}
   * @private
   */
  function GenerateClassFromInfo(info, Base) {

    class PolymerGenerated extends Base {

      static get properties() {
        return info.properties;
      }

      static get observers() {
        return info.observers;
      }

      /**
       * @return {HTMLTemplateElement} template for this class
       */
      static get template() {
        // get template first from any imperative set in `info._template`
        return info._template ||
        // next look in dom-module associated with this element's is.
        Polymer.DomModule && Polymer.DomModule.import(this.is, 'template') ||
        // next look for superclass template (note: use superclass symbol
        // to ensure correct `this.is`)
        Base.template ||
        // finally fall back to `_template` in element's prototype.
        this.prototype._template || null;
      }

      /**
       * @return {void}
       */
      created() {
        super.created();
        if (info.created) {
          info.created.call(this);
        }
      }

      /**
       * @return {void}
       */
      _registered() {
        super._registered();
        /* NOTE: `beforeRegister` is called here for bc, but the behavior
         is different than in 1.x. In 1.0, the method was called *after*
         mixing prototypes together but *before* processing of meta-objects.
         However, dynamic effects can still be set here and can be done either
         in `beforeRegister` or `registered`. It is no longer possible to set
         `is` in `beforeRegister` as you could in 1.x.
        */
        if (info.beforeRegister) {
          info.beforeRegister.call(Object.getPrototypeOf(this));
        }
        if (info.registered) {
          info.registered.call(Object.getPrototypeOf(this));
        }
      }

      /**
       * @return {void}
       */
      _applyListeners() {
        super._applyListeners();
        if (info.listeners) {
          for (let l in info.listeners) {
            this._addMethodEventListenerToNode(this, l, info.listeners[l]);
          }
        }
      }

      // note: exception to "super then me" rule;
      // do work before calling super so that super attributes
      // only apply if not already set.
      /**
       * @return {void}
       */
      _ensureAttributes() {
        if (info.hostAttributes) {
          for (let a in info.hostAttributes) {
            this._ensureAttribute(a, info.hostAttributes[a]);
          }
        }
        super._ensureAttributes();
      }

      /**
       * @return {void}
       */
      ready() {
        super.ready();
        if (info.ready) {
          info.ready.call(this);
        }
      }

      /**
       * @return {void}
       */
      attached() {
        super.attached();
        if (info.attached) {
          info.attached.call(this);
        }
      }

      /**
       * @return {void}
       */
      detached() {
        super.detached();
        if (info.detached) {
          info.detached.call(this);
        }
      }

      /**
       * Implements native Custom Elements `attributeChangedCallback` to
       * set an attribute value to a property via `_attributeToProperty`.
       *
       * @param {string} name Name of attribute that changed
       * @param {?string} old Old attribute value
       * @param {?string} value New attribute value
       * @return {void}
       */
      attributeChanged(name, old, value) {
        super.attributeChanged(name, old, value);
        if (info.attributeChanged) {
          info.attributeChanged.call(this, name, old, value);
        }
      }
    }

    PolymerGenerated.generatedFrom = info;

    for (let p in info) {
      // NOTE: cannot copy `metaProps` methods onto prototype at least because
      // `super.ready` must be called and is not included in the user fn.
      if (!(p in metaProps)) {
        let pd = Object.getOwnPropertyDescriptor(info, p);
        if (pd) {
          Object.defineProperty(PolymerGenerated.prototype, p, pd);
        }
      }
    }

    return PolymerGenerated;
  }

  /**
   * Generates a class that extends `Polymer.LegacyElement` based on the
   * provided info object.  Metadata objects on the `info` object
   * (`properties`, `observers`, `listeners`, `behaviors`, `is`) are used
   * for Polymer's meta-programming systems, and any functions are copied
   * to the generated class.
   *
   * Valid "metadata" values are as follows:
   *
   * `is`: String providing the tag name to register the element under. In
   * addition, if a `dom-module` with the same id exists, the first template
   * in that `dom-module` will be stamped into the shadow root of this element,
   * with support for declarative event listeners (`on-...`), Polymer data
   * bindings (`[[...]]` and `{{...}}`), and id-based node finding into
   * `this.$`.
   *
   * `properties`: Object describing property-related metadata used by Polymer
   * features (key: property names, value: object containing property metadata).
   * Valid keys in per-property metadata include:
   * - `type` (String|Number|Object|Array|...): Used by
   *   `attributeChangedCallback` to determine how string-based attributes
   *   are deserialized to JavaScript property values.
   * - `notify` (boolean): Causes a change in the property to fire a
   *   non-bubbling event called `<property>-changed`. Elements that have
   *   enabled two-way binding to the property use this event to observe changes.
   * - `readOnly` (boolean): Creates a getter for the property, but no setter.
   *   To set a read-only property, use the private setter method
   *   `_setProperty(property, value)`.
   * - `observer` (string): Observer method name that will be called when
   *   the property changes. The arguments of the method are
   *   `(value, previousValue)`.
   * - `computed` (string): String describing method and dependent properties
   *   for computing the value of this property (e.g. `'computeFoo(bar, zot)'`).
   *   Computed properties are read-only by default and can only be changed
   *   via the return value of the computing method.
   *
   * `observers`: Array of strings describing multi-property observer methods
   *  and their dependent properties (e.g. `'observeABC(a, b, c)'`).
   *
   * `listeners`: Object describing event listeners to be added to each
   *  instance of this element (key: event name, value: method name).
   *
   * `behaviors`: Array of additional `info` objects containing metadata
   * and callbacks in the same format as the `info` object here which are
   * merged into this element.
   *
   * `hostAttributes`: Object listing attributes to be applied to the host
   *  once created (key: attribute name, value: attribute value).  Values
   *  are serialized based on the type of the value.  Host attributes should
   *  generally be limited to attributes such as `tabIndex` and `aria-...`.
   *  Attributes in `hostAttributes` are only applied if a user-supplied
   *  attribute is not already present (attributes in markup override
   *  `hostAttributes`).
   *
   * In addition, the following Polymer-specific callbacks may be provided:
   * - `registered`: called after first instance of this element,
   * - `created`: called during `constructor`
   * - `attached`: called during `connectedCallback`
   * - `detached`: called during `disconnectedCallback`
   * - `ready`: called before first `attached`, after all properties of
   *   this element have been propagated to its template and all observers
   *   have run
   *
   * @param {!PolymerInit} info Object containing Polymer metadata and functions
   *   to become class methods.
   * @return {function(new:HTMLElement)} Generated class
   * @memberof Polymer
   */
  Polymer.Class = function (info) {
    if (!info) {
      console.warn('Polymer.Class requires `info` argument');
    }
    let klass = GenerateClassFromInfo(info, info.behaviors ?
    // note: mixinBehaviors ensures `LegacyElementMixin`.
    mixinBehaviors(info.behaviors, HTMLElement) : Polymer.LegacyElementMixin(HTMLElement));
    // decorate klass with registration info
    klass.is = info.is;
    return klass;
  };

  Polymer.mixinBehaviors = mixinBehaviors;
})();

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(12);

(function () {
  'use strict';

  let TemplateInstanceBase = Polymer.TemplateInstanceBase; // eslint-disable-line

  /**
   * @typedef {{
   *   _templatizerTemplate: HTMLTemplateElement,
   *   _parentModel: boolean,
   *   _instanceProps: Object,
   *   _forwardHostPropV2: Function,
   *   _notifyInstancePropV2: Function,
   *   ctor: TemplateInstanceBase
   * }}
   */
  let TemplatizerUser; // eslint-disable-line

  /**
   * The `Polymer.Templatizer` behavior adds methods to generate instances of
   * templates that are each managed by an anonymous `Polymer.PropertyEffects`
   * instance where data-bindings in the stamped template content are bound to
   * accessors on itself.
   *
   * This behavior is provided in Polymer 2.x as a hybrid-element convenience
   * only.  For non-hybrid usage, the `Polymer.Templatize` library
   * should be used instead.
   *
   * Example:
   *
   *     // Get a template from somewhere, e.g. light DOM
   *     let template = this.querySelector('template');
   *     // Prepare the template
   *     this.templatize(template);
   *     // Instance the template with an initial data model
   *     let instance = this.stamp({myProp: 'initial'});
   *     // Insert the instance's DOM somewhere, e.g. light DOM
   *     Polymer.dom(this).appendChild(instance.root);
   *     // Changing a property on the instance will propagate to bindings
   *     // in the template
   *     instance.myProp = 'new value';
   *
   * Users of `Templatizer` may need to implement the following abstract
   * API's to determine how properties and paths from the host should be
   * forwarded into to instances:
   *
   *     _forwardHostPropV2: function(prop, value)
   *
   * Likewise, users may implement these additional abstract API's to determine
   * how instance-specific properties that change on the instance should be
   * forwarded out to the host, if necessary.
   *
   *     _notifyInstancePropV2: function(inst, prop, value)
   *
   * In order to determine which properties are instance-specific and require
   * custom notification via `_notifyInstanceProp`, define an `_instanceProps`
   * object containing keys for each instance prop, for example:
   *
   *     _instanceProps: {
   *       item: true,
   *       index: true
   *     }
   *
   * Any properties used in the template that are not defined in _instanceProp
   * will be forwarded out to the Templatize `owner` automatically.
   *
   * Users may also implement the following abstract function to show or
   * hide any DOM generated using `stamp`:
   *
   *     _showHideChildren: function(shouldHide)
   *
   * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior
   * as the implementations will need to differ from the callbacks required
   * by the 1.x Templatizer API due to changes in the `TemplateInstance` API
   * between versions 1.x and 2.x.
   *
   * @polymerBehavior
   */
  Polymer.Templatizer = {

    /**
     * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
     * for the provided template.  This method should be called once per
     * template to prepare an element for stamping the template, followed
     * by `stamp` to create new instances of the template.
     *
     * @param {!HTMLTemplateElement} template Template to prepare
     * @param {boolean=} mutableData When `true`, the generated class will skip
     *   strict dirty-checking for objects and arrays (always consider them to
     *   be "dirty"). Defaults to false.
     * @return {void}
     * @this {TemplatizerUser}
     */
    templatize(template, mutableData) {
      this._templatizerTemplate = template;
      this.ctor = Polymer.Templatize.templatize(template, this, {
        mutableData: Boolean(mutableData),
        parentModel: this._parentModel,
        instanceProps: this._instanceProps,
        forwardHostProp: this._forwardHostPropV2,
        notifyInstanceProp: this._notifyInstancePropV2
      });
    },

    /**
     * Creates an instance of the template prepared by `templatize`.  The object
     * returned is an instance of the anonymous class generated by `templatize`
     * whose `root` property is a document fragment containing newly cloned
     * template content, and which has property accessors corresponding to
     * properties referenced in template bindings.
     *
     * @param {Object=} model Object containing initial property values to
     *   populate into the template bindings.
     * @return {TemplateInstanceBase} Returns the created instance of
     * the template prepared by `templatize`.
     * @this {TemplatizerUser}
     */
    stamp(model) {
      return new this.ctor(model);
    },

    /**
     * Returns the template "model" (`TemplateInstance`) associated with
     * a given element, which serves as the binding scope for the template
     * instance the element is contained in.  A template model should be used
     * to manipulate data associated with this template instance.
     *
     * @param {HTMLElement} el Element for which to return a template model.
     * @return {TemplateInstanceBase} Model representing the binding scope for
     *   the element.
     * @this {TemplatizerUser}
     */
    modelForElement(el) {
      return Polymer.Templatize.modelForElement(this._templatizerTemplate, el);
    }
  };
})();

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(0);

__webpack_require__(9);

__webpack_require__(7);

__webpack_require__(22);

(function () {
  'use strict';

  /**
   * @constructor
   * @extends {HTMLElement}
   * @implements {Polymer_PropertyEffects}
   * @implements {Polymer_OptionalMutableData}
   * @implements {Polymer_GestureEventListeners}
   */

  const domBindBase = Polymer.GestureEventListeners(Polymer.OptionalMutableData(Polymer.PropertyEffects(HTMLElement)));

  /**
   * Custom element to allow using Polymer's template features (data binding,
   * declarative event listeners, etc.) in the main document without defining
   * a new custom element.
   *
   * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
   * element, which will immediately stamp the wrapped template into the main
   * document and bind elements to the `dom-bind` element itself as the
   * binding scope.
   *
   * @polymer
   * @customElement
   * @appliesMixin Polymer.PropertyEffects
   * @appliesMixin Polymer.OptionalMutableData
   * @appliesMixin Polymer.GestureEventListeners
   * @extends {domBindBase}
   * @memberof Polymer
   * @summary Custom element to allow using Polymer's template features (data
   *   binding, declarative event listeners, etc.) in the main document.
   */
  class DomBind extends domBindBase {

    static get observedAttributes() {
      return ['mutable-data'];
    }

    constructor() {
      super();
      this.root = null;
      this.$ = null;
      this.__children = null;
    }

    /** @return {void} */
    attributeChangedCallback() {
      // assumes only one observed attribute
      this.mutableData = true;
    }

    /** @return {void} */
    connectedCallback() {
      this.style.display = 'none';
      this.render();
    }

    /** @return {void} */
    disconnectedCallback() {
      this.__removeChildren();
    }

    __insertChildren() {
      this.parentNode.insertBefore(this.root, this);
    }

    __removeChildren() {
      if (this.__children) {
        for (let i = 0; i < this.__children.length; i++) {
          this.root.appendChild(this.__children[i]);
        }
      }
    }

    /**
     * Forces the element to render its content. This is typically only
     * necessary to call if HTMLImports with the async attribute are used.
     * @return {void}
     */
    render() {
      let template;
      if (!this.__children) {
        template = /** @type {HTMLTemplateElement} */template || this.querySelector('template');
        if (!template) {
          // Wait until childList changes and template should be there by then
          let observer = new MutationObserver(() => {
            template = /** @type {HTMLTemplateElement} */this.querySelector('template');
            if (template) {
              observer.disconnect();
              this.render();
            } else {
              throw new Error('dom-bind requires a <template> child');
            }
          });
          observer.observe(this, { childList: true });
          return;
        }
        this.root = this._stampTemplate(template);
        this.$ = this.root.$;
        this.__children = [];
        for (let n = this.root.firstChild; n; n = n.nextSibling) {
          this.__children[this.__children.length] = n;
        }
        this._enableProperties();
      }
      this.__insertChildren();
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
    }

  }

  customElements.define('dom-bind', DomBind);

  Polymer.DomBind = DomBind;
})();

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(13);

__webpack_require__(12);

__webpack_require__(10);

__webpack_require__(11);

__webpack_require__(7);

(function () {
  'use strict';

  let TemplateInstanceBase = Polymer.TemplateInstanceBase; // eslint-disable-line

  /**
   * @constructor
   * @implements {Polymer_OptionalMutableData}
   * @extends {Polymer.Element}
   */
  const domRepeatBase = Polymer.OptionalMutableData(Polymer.Element);

  /**
   * The `<dom-repeat>` element will automatically stamp and binds one instance
   * of template content to each object in a user-provided array.
   * `dom-repeat` accepts an `items` property, and one instance of the template
   * is stamped for each item into the DOM at the location of the `dom-repeat`
   * element.  The `item` property will be set on each instance's binding
   * scope, thus templates should bind to sub-properties of `item`.
   *
   * Example:
   *
   * ```html
   * <dom-module id="employee-list">
   *
   *   <template>
   *
   *     <div> Employee list: </div>
   *     <dom-repeat items="{{employees}}">
   *       <template>
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *       </template>
   *     </dom-repeat>
   *
   *   </template>
   *
   *   <script>
   *     class EmployeeList extends Polymer.Element {
   *       static get is() { return 'employee-list'; }
   *       static get properties() {
   *         return {
   *           employees: {
   *             value() {
   *               return [
   *                 {first: 'Bob', last: 'Smith'},
   *                 {first: 'Sally', last: 'Johnson'},
   *                 ...
   *               ];
   *             }
   *           }
   *         };
   *       }
   *     }
   *   < /script>
   *
   * </dom-module>
   * ```
   *
   * Notifications for changes to items sub-properties will be forwarded to template
   * instances, which will update via the normal structured data notification system.
   *
   * Mutations to the `items` array itself should be made using the Array
   * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,
   * `unshift`), and template instances will be kept in sync with the data in the
   * array.
   *
   * Events caught by event handlers within the `dom-repeat` template will be
   * decorated with a `model` property, which represents the binding scope for
   * each template instance.  The model is an instance of Polymer.Base, and should
   * be used to manipulate data on the instance, for example
   * `event.model.set('item.checked', true);`.
   *
   * Alternatively, the model for a template instance for an element stamped by
   * a `dom-repeat` can be obtained using the `modelForElement` API on the
   * `dom-repeat` that stamped it, for example
   * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
   * This may be useful for manipulating instance data of event targets obtained
   * by event handlers on parents of the `dom-repeat` (event delegation).
   *
   * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
   * `filter` and/or `sort` property.  This may be a string that names a function on
   * the host, or a function may be assigned to the property directly.  The functions
   * should implemented following the standard `Array` filter/sort API.
   *
   * In order to re-run the filter or sort functions based on changes to sub-fields
   * of `items`, the `observe` property may be set as a space-separated list of
   * `item` sub-fields that should cause a re-filter/sort when modified.  If
   * the filter or sort function depends on properties not contained in `items`,
   * the user should observe changes to those properties and call `render` to update
   * the view based on the dependency change.
   *
   * For example, for an `dom-repeat` with a filter of the following:
   *
   * ```js
   * isEngineer(item) {
   *   return item.type == 'engineer' || item.manager.type == 'engineer';
   * }
   * ```
   *
   * Then the `observe` property should be configured as follows:
   *
   * ```html
   * <dom-repeat items="{{employees}}" filter="isEngineer" observe="type manager.type">
   * ```
   *
   * @customElement
   * @polymer
   * @memberof Polymer
   * @extends {domRepeatBase}
   * @appliesMixin Polymer.OptionalMutableData
   * @summary Custom element for stamping instance of a template bound to
   *   items in an array.
   */
  class DomRepeat extends domRepeatBase {

    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    static get is() {
      return 'dom-repeat';
    }

    static get template() {
      return null;
    }

    static get properties() {

      /**
       * Fired whenever DOM is added or removed by this template (by
       * default, rendering occurs lazily).  To force immediate rendering, call
       * `render`.
       *
       * @event dom-change
       */
      return {

        /**
         * An array containing items determining how many instances of the template
         * to stamp and that that each template instance should bind to.
         */
        items: {
          type: Array
        },

        /**
         * The name of the variable to add to the binding scope for the array
         * element associated with a given template instance.
         */
        as: {
          type: String,
          value: 'item'
        },

        /**
         * The name of the variable to add to the binding scope with the index
         * of the instance in the sorted and filtered list of rendered items.
         * Note, for the index in the `this.items` array, use the value of the
         * `itemsIndexAs` property.
         */
        indexAs: {
          type: String,
          value: 'index'
        },

        /**
         * The name of the variable to add to the binding scope with the index
         * of the instance in the `this.items` array. Note, for the index of
         * this instance in the sorted and filtered list of rendered items,
         * use the value of the `indexAs` property.
         */
        itemsIndexAs: {
          type: String,
          value: 'itemsIndex'
        },

        /**
         * A function that should determine the sort order of the items.  This
         * property should either be provided as a string, indicating a method
         * name on the element's host, or else be an actual function.  The
         * function should match the sort function passed to `Array.sort`.
         * Using a sort function has no effect on the underlying `items` array.
         */
        sort: {
          type: Function,
          observer: '__sortChanged'
        },

        /**
         * A function that can be used to filter items out of the view.  This
         * property should either be provided as a string, indicating a method
         * name on the element's host, or else be an actual function.  The
         * function should match the sort function passed to `Array.filter`.
         * Using a filter function has no effect on the underlying `items` array.
         */
        filter: {
          type: Function,
          observer: '__filterChanged'
        },

        /**
         * When using a `filter` or `sort` function, the `observe` property
         * should be set to a space-separated list of the names of item
         * sub-fields that should trigger a re-sort or re-filter when changed.
         * These should generally be fields of `item` that the sort or filter
         * function depends on.
         */
        observe: {
          type: String,
          observer: '__observeChanged'
        },

        /**
         * When using a `filter` or `sort` function, the `delay` property
         * determines a debounce time in ms after a change to observed item
         * properties that must pass before the filter or sort is re-run.
         * This is useful in rate-limiting shuffling of the view when
         * item changes may be frequent.
         */
        delay: Number,

        /**
         * Count of currently rendered items after `filter` (if any) has been applied.
         * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
         * set of template instances is rendered.
         *
         */
        renderedItemCount: {
          type: Number,
          notify: true,
          readOnly: true
        },

        /**
         * Defines an initial count of template instances to render after setting
         * the `items` array, before the next paint, and puts the `dom-repeat`
         * into "chunking mode".  The remaining items will be created and rendered
         * incrementally at each animation frame therof until all instances have
         * been rendered.
         */
        initialCount: {
          type: Number,
          observer: '__initializeChunking'
        },

        /**
         * When `initialCount` is used, this property defines a frame rate (in
         * fps) to target by throttling the number of instances rendered each
         * frame to not exceed the budget for the target frame rate.  The
         * framerate is effectively the number of `requestAnimationFrame`s that
         * it tries to allow to actually fire in a given second. It does this
         * by measuring the time between `rAF`s and continuously adjusting the
         * number of items created each `rAF` to maintain the target framerate.
         * Setting this to a higher number allows lower latency and higher
         * throughput for event handlers and other tasks, but results in a
         * longer time for the remaining items to complete rendering.
         */
        targetFramerate: {
          type: Number,
          value: 20
        },

        _targetFrameTime: {
          type: Number,
          computed: '__computeFrameTime(targetFramerate)'
        }

      };
    }

    static get observers() {
      return ['__itemsChanged(items.*)'];
    }

    constructor() {
      super();
      this.__instances = [];
      this.__limit = Infinity;
      this.__pool = [];
      this.__renderDebouncer = null;
      this.__itemsIdxToInstIdx = {};
      this.__chunkCount = null;
      this.__lastChunkTime = null;
      this.__sortFn = null;
      this.__filterFn = null;
      this.__observePaths = null;
      this.__ctor = null;
      this.__isDetached = true;
      this.template = null;
    }

    /**
     * @return {void}
     */
    disconnectedCallback() {
      super.disconnectedCallback();
      this.__isDetached = true;
      for (let i = 0; i < this.__instances.length; i++) {
        this.__detachInstance(i);
      }
    }

    /**
     * @return {void}
     */
    connectedCallback() {
      super.connectedCallback();
      this.style.display = 'none';
      // only perform attachment if the element was previously detached.
      if (this.__isDetached) {
        this.__isDetached = false;
        let parent = this.parentNode;
        for (let i = 0; i < this.__instances.length; i++) {
          this.__attachInstance(i, parent);
        }
      }
    }

    __ensureTemplatized() {
      // Templatizing (generating the instance constructor) needs to wait
      // until ready, since won't have its template content handed back to
      // it until then
      if (!this.__ctor) {
        let template = this.template = this.querySelector('template');
        if (!template) {
          // // Wait until childList changes and template should be there by then
          let observer = new MutationObserver(() => {
            if (this.querySelector('template')) {
              observer.disconnect();
              this.__render();
            } else {
              throw new Error('dom-repeat requires a <template> child');
            }
          });
          observer.observe(this, { childList: true });
          return false;
        }
        // Template instance props that should be excluded from forwarding
        let instanceProps = {};
        instanceProps[this.as] = true;
        instanceProps[this.indexAs] = true;
        instanceProps[this.itemsIndexAs] = true;
        this.__ctor = Polymer.Templatize.templatize(template, this, {
          mutableData: this.mutableData,
          parentModel: true,
          instanceProps: instanceProps,
          /**
           * @this {this}
           * @param {string} prop Property to set
           * @param {*} value Value to set property to
           */
          forwardHostProp: function (prop, value) {
            let i$ = this.__instances;
            for (let i = 0, inst; i < i$.length && (inst = i$[i]); i++) {
              inst.forwardHostProp(prop, value);
            }
          },
          /**
           * @this {this}
           * @param {Object} inst Instance to notify
           * @param {string} prop Property to notify
           * @param {*} value Value to notify
           */
          notifyInstanceProp: function (inst, prop, value) {
            if (Polymer.Path.matches(this.as, prop)) {
              let idx = inst[this.itemsIndexAs];
              if (prop == this.as) {
                this.items[idx] = value;
              }
              let path = Polymer.Path.translate(this.as, 'items.' + idx, prop);
              this.notifyPath(path, value);
            }
          }
        });
      }
      return true;
    }

    __getMethodHost() {
      // Technically this should be the owner of the outermost template.
      // In shadow dom, this is always getRootNode().host, but we can
      // approximate this via cooperation with our dataHost always setting
      // `_methodHost` as long as there were bindings (or id's) on this
      // instance causing it to get a dataHost.
      return this.__dataHost._methodHost || this.__dataHost;
    }

    __functionFromPropertyValue(functionOrMethodName) {
      if (typeof functionOrMethodName === 'string') {
        let methodName = functionOrMethodName;
        let obj = this.__getMethodHost();
        return function () {
          return obj[methodName].apply(obj, arguments);
        };
      }

      return functionOrMethodName;
    }

    __sortChanged(sort) {
      this.__sortFn = this.__functionFromPropertyValue(sort);
      if (this.items) {
        this.__debounceRender(this.__render);
      }
    }

    __filterChanged(filter) {
      this.__filterFn = this.__functionFromPropertyValue(filter);
      if (this.items) {
        this.__debounceRender(this.__render);
      }
    }

    __computeFrameTime(rate) {
      return Math.ceil(1000 / rate);
    }

    __initializeChunking() {
      if (this.initialCount) {
        this.__limit = this.initialCount;
        this.__chunkCount = this.initialCount;
        this.__lastChunkTime = performance.now();
      }
    }

    __tryRenderChunk() {
      // Debounced so that multiple calls through `_render` between animation
      // frames only queue one new rAF (e.g. array mutation & chunked render)
      if (this.items && this.__limit < this.items.length) {
        this.__debounceRender(this.__requestRenderChunk);
      }
    }

    __requestRenderChunk() {
      requestAnimationFrame(() => this.__renderChunk());
    }

    __renderChunk() {
      // Simple auto chunkSize throttling algorithm based on feedback loop:
      // measure actual time between frames and scale chunk count by ratio
      // of target/actual frame time
      let currChunkTime = performance.now();
      let ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
      this.__limit += this.__chunkCount;
      this.__lastChunkTime = currChunkTime;
      this.__debounceRender(this.__render);
    }

    __observeChanged() {
      this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
    }

    __itemsChanged(change) {
      if (this.items && !Array.isArray(this.items)) {
        console.warn('dom-repeat expected array for `items`, found', this.items);
      }
      // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
      // path to that instance synchronously (returns false for non-item paths)
      if (!this.__handleItemPath(change.path, change.value)) {
        // Otherwise, the array was reset ('items') or spliced ('items.splices'),
        // so queue a full refresh
        this.__initializeChunking();
        this.__debounceRender(this.__render);
      }
    }

    __handleObservedPaths(path) {
      // Handle cases where path changes should cause a re-sort/filter
      if (this.__sortFn || this.__filterFn) {
        if (!path) {
          // Always re-render if the item itself changed
          this.__debounceRender(this.__render, this.delay);
        } else if (this.__observePaths) {
          // Otherwise, re-render if the path changed matches an observed path
          let paths = this.__observePaths;
          for (let i = 0; i < paths.length; i++) {
            if (path.indexOf(paths[i]) === 0) {
              this.__debounceRender(this.__render, this.delay);
            }
          }
        }
      }
    }

    /**
     * @param {function(this:DomRepeat)} fn Function to debounce.
     * @param {number=} delay Delay in ms to debounce by.
     */
    __debounceRender(fn, delay = 0) {
      this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, delay > 0 ? Polymer.Async.timeOut.after(delay) : Polymer.Async.microTask, fn.bind(this));
      Polymer.enqueueDebouncer(this.__renderDebouncer);
    }

    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     * @return {void}
     */
    render() {
      // Queue this repeater, then flush all in order
      this.__debounceRender(this.__render);
      Polymer.flush();
    }

    __render() {
      if (!this.__ensureTemplatized()) {
        // No template found yet
        return;
      }
      this.__applyFullRefresh();
      // Reset the pool
      // TODO(kschaaf): Reuse pool across turns and nested templates
      // Now that objects/arrays are re-evaluated when set, we can safely
      // reuse pooled instances across turns, however we still need to decide
      // semantics regarding how long to hold, how many to hold, etc.
      this.__pool.length = 0;
      // Set rendered item count
      this._setRenderedItemCount(this.__instances.length);
      // Notify users
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
      // Check to see if we need to render more items
      this.__tryRenderChunk();
    }

    __applyFullRefresh() {
      let items = this.items || [];
      let isntIdxToItemsIdx = new Array(items.length);
      for (let i = 0; i < items.length; i++) {
        isntIdxToItemsIdx[i] = i;
      }
      // Apply user filter
      if (this.__filterFn) {
        isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) => this.__filterFn(items[i], idx, array));
      }
      // Apply user sort
      if (this.__sortFn) {
        isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));
      }
      // items->inst map kept for item path forwarding
      const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
      let instIdx = 0;
      // Generate instances and assign items
      const limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
      for (; instIdx < limit; instIdx++) {
        let inst = this.__instances[instIdx];
        let itemIdx = isntIdxToItemsIdx[instIdx];
        let item = items[itemIdx];
        itemsIdxToInstIdx[itemIdx] = instIdx;
        if (inst) {
          inst._setPendingProperty(this.as, item);
          inst._setPendingProperty(this.indexAs, instIdx);
          inst._setPendingProperty(this.itemsIndexAs, itemIdx);
          inst._flushProperties();
        } else {
          this.__insertInstance(item, instIdx, itemIdx);
        }
      }
      // Remove any extra instances from previous state
      for (let i = this.__instances.length - 1; i >= instIdx; i--) {
        this.__detachAndRemoveInstance(i);
      }
    }

    __detachInstance(idx) {
      let inst = this.__instances[idx];
      for (let i = 0; i < inst.children.length; i++) {
        let el = inst.children[i];
        inst.root.appendChild(el);
      }
      return inst;
    }

    __attachInstance(idx, parent) {
      let inst = this.__instances[idx];
      parent.insertBefore(inst.root, this);
    }

    __detachAndRemoveInstance(idx) {
      let inst = this.__detachInstance(idx);
      if (inst) {
        this.__pool.push(inst);
      }
      this.__instances.splice(idx, 1);
    }

    __stampInstance(item, instIdx, itemIdx) {
      let model = {};
      model[this.as] = item;
      model[this.indexAs] = instIdx;
      model[this.itemsIndexAs] = itemIdx;
      return new this.__ctor(model);
    }

    __insertInstance(item, instIdx, itemIdx) {
      let inst = this.__pool.pop();
      if (inst) {
        // TODO(kschaaf): If the pool is shared across turns, hostProps
        // need to be re-set to reused instances in addition to item
        inst._setPendingProperty(this.as, item);
        inst._setPendingProperty(this.indexAs, instIdx);
        inst._setPendingProperty(this.itemsIndexAs, itemIdx);
        inst._flushProperties();
      } else {
        inst = this.__stampInstance(item, instIdx, itemIdx);
      }
      let beforeRow = this.__instances[instIdx + 1];
      let beforeNode = beforeRow ? beforeRow.children[0] : this;
      this.parentNode.insertBefore(inst.root, beforeNode);
      this.__instances[instIdx] = inst;
      return inst;
    }

    // Implements extension point from Templatize mixin
    /**
     * Shows or hides the template instance top level child elements. For
     * text nodes, `textContent` is removed while "hidden" and replaced when
     * "shown."
     * @param {boolean} hidden Set to true to hide the children;
     * set to false to show them.
     * @return {void}
     * @protected
     */
    _showHideChildren(hidden) {
      for (let i = 0; i < this.__instances.length; i++) {
        this.__instances[i]._showHideChildren(hidden);
      }
    }

    // Called as a side effect of a host items.<key>.<path> path change,
    // responsible for notifying item.<path> changes to inst for key
    __handleItemPath(path, value) {
      let itemsPath = path.slice(6); // 'items.'.length == 6
      let dot = itemsPath.indexOf('.');
      let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
      // If path was index into array...
      if (itemsIdx == parseInt(itemsIdx, 10)) {
        let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);
        // If the path is observed, it will trigger a full refresh
        this.__handleObservedPaths(itemSubPath);
        // Note, even if a rull refresh is triggered, always do the path
        // notification because unless mutableData is used for dom-repeat
        // and all elements in the instance subtree, a full refresh may
        // not trigger the proper update.
        let instIdx = this.__itemsIdxToInstIdx[itemsIdx];
        let inst = this.__instances[instIdx];
        if (inst) {
          let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
          // This is effectively `notifyPath`, but avoids some of the overhead
          // of the public API
          inst._setPendingPropertyOrPath(itemPath, value, false, true);
          inst._flushProperties();
        }
        return true;
      }
    }

    /**
     * Returns the item associated with a given element stamped by
     * this `dom-repeat`.
     *
     * Note, to modify sub-properties of the item,
     * `modelForElement(el).set('item.<sub-prop>', value)`
     * should be used.
     *
     * @param {!HTMLElement} el Element for which to return the item.
     * @return {*} Item associated with the element.
     */
    itemForElement(el) {
      let instance = this.modelForElement(el);
      return instance && instance[this.as];
    }

    /**
     * Returns the inst index for a given element stamped by this `dom-repeat`.
     * If `sort` is provided, the index will reflect the sorted order (rather
     * than the original array order).
     *
     * @param {!HTMLElement} el Element for which to return the index.
     * @return {?number} Row index associated with the element (note this may
     *   not correspond to the array index if a user `sort` is applied).
     */
    indexForElement(el) {
      let instance = this.modelForElement(el);
      return instance && instance[this.indexAs];
    }

    /**
     * Returns the template "model" associated with a given element, which
     * serves as the binding scope for the template instance the element is
     * contained in. A template model is an instance of `Polymer.Base`, and
     * should be used to manipulate data associated with this template instance.
     *
     * Example:
     *
     *   let model = modelForElement(el);
     *   if (model.index < 10) {
     *     model.set('item.checked', true);
     *   }
     *
     * @param {!HTMLElement} el Element for which to return a template model.
     * @return {TemplateInstanceBase} Model representing the binding scope for
     *   the element.
     */
    modelForElement(el) {
      return Polymer.Templatize.modelForElement(this.template, el);
    }

  }

  customElements.define(DomRepeat.is, DomRepeat);

  Polymer.DomRepeat = DomRepeat;
})();

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(13);

__webpack_require__(12);

__webpack_require__(10);

__webpack_require__(11);

(function () {
  'use strict';

  /**
   * The `<dom-if>` element will stamp a light-dom `<template>` child when
   * the `if` property becomes truthy, and the template can use Polymer
   * data-binding and declarative event features when used in the context of
   * a Polymer element's template.
   *
   * When `if` becomes falsy, the stamped content is hidden but not
   * removed from dom. When `if` subsequently becomes truthy again, the content
   * is simply re-shown. This approach is used due to its favorable performance
   * characteristics: the expense of creating template content is paid only
   * once and lazily.
   *
   * Set the `restamp` property to true to force the stamped content to be
   * created / destroyed when the `if` condition changes.
   *
   * @customElement
   * @polymer
   * @extends Polymer.Element
   * @memberof Polymer
   * @summary Custom element that conditionally stamps and hides or removes
   *   template content based on a boolean flag.
   */

  class DomIf extends Polymer.Element {

    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    static get is() {
      return 'dom-if';
    }

    static get template() {
      return null;
    }

    static get properties() {

      return {

        /**
         * Fired whenever DOM is added or removed/hidden by this template (by
         * default, rendering occurs lazily).  To force immediate rendering, call
         * `render`.
         *
         * @event dom-change
         */

        /**
         * A boolean indicating whether this template should stamp.
         */
        if: {
          type: Boolean,
          observer: '__debounceRender'
        },

        /**
         * When true, elements will be removed from DOM and discarded when `if`
         * becomes false and re-created and added back to the DOM when `if`
         * becomes true.  By default, stamped elements will be hidden but left
         * in the DOM when `if` becomes false, which is generally results
         * in better performance.
         */
        restamp: {
          type: Boolean,
          observer: '__debounceRender'
        }

      };
    }

    constructor() {
      super();
      this.__renderDebouncer = null;
      this.__invalidProps = null;
      this.__instance = null;
      this._lastIf = false;
      this.__ctor = null;
    }

    __debounceRender() {
      // Render is async for 2 reasons:
      // 1. To eliminate dom creation trashing if user code thrashes `if` in the
      //    same turn. This was more common in 1.x where a compound computed
      //    property could result in the result changing multiple times, but is
      //    mitigated to a large extent by batched property processing in 2.x.
      // 2. To avoid double object propagation when a bag including values bound
      //    to the `if` property as well as one or more hostProps could enqueue
      //    the <dom-if> to flush before the <template>'s host property
      //    forwarding. In that scenario creating an instance would result in
      //    the host props being set once, and then the enqueued changes on the
      //    template would set properties a second time, potentially causing an
      //    object to be set to an instance more than once.  Creating the
      //    instance async from flushing data ensures this doesn't happen. If
      //    we wanted a sync option in the future, simply having <dom-if> flush
      //    (or clear) its template's pending host properties before creating
      //    the instance would also avoid the problem.
      this.__renderDebouncer = Polymer.Debouncer.debounce(this.__renderDebouncer, Polymer.Async.microTask, () => this.__render());
      Polymer.enqueueDebouncer(this.__renderDebouncer);
    }

    /**
     * @return {void}
     */
    disconnectedCallback() {
      super.disconnectedCallback();
      if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !this.parentNode.host) {
        this.__teardownInstance();
      }
    }

    /**
     * @return {void}
     */
    connectedCallback() {
      super.connectedCallback();
      this.style.display = 'none';
      if (this.if) {
        this.__debounceRender();
      }
    }

    /**
     * Forces the element to render its content. Normally rendering is
     * asynchronous to a provoking change. This is done for efficiency so
     * that multiple changes trigger only a single render. The render method
     * should be called if, for example, template rendering is required to
     * validate application state.
     * @return {void}
     */
    render() {
      Polymer.flush();
    }

    __render() {
      if (this.if) {
        if (!this.__ensureInstance()) {
          // No template found yet
          return;
        }
        this._showHideChildren();
      } else if (this.restamp) {
        this.__teardownInstance();
      }
      if (!this.restamp && this.__instance) {
        this._showHideChildren();
      }
      if (this.if != this._lastIf) {
        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
        this._lastIf = this.if;
      }
    }

    __ensureInstance() {
      let parentNode = this.parentNode;
      // Guard against element being detached while render was queued
      if (parentNode) {
        if (!this.__ctor) {
          let template = this.querySelector('template');
          if (!template) {
            // Wait until childList changes and template should be there by then
            let observer = new MutationObserver(() => {
              if (this.querySelector('template')) {
                observer.disconnect();
                this.__render();
              } else {
                throw new Error('dom-if requires a <template> child');
              }
            });
            observer.observe(this, { childList: true });
            return false;
          }
          this.__ctor = Polymer.Templatize.templatize(template, this, {
            // dom-if templatizer instances require `mutable: true`, as
            // `__syncHostProperties` relies on that behavior to sync objects
            mutableData: true,
            /**
             * @param {string} prop Property to forward
             * @param {*} value Value of property
             * @this {this}
             */
            forwardHostProp: function (prop, value) {
              if (this.__instance) {
                if (this.if) {
                  this.__instance.forwardHostProp(prop, value);
                } else {
                  // If we have an instance but are squelching host property
                  // forwarding due to if being false, note the invalidated
                  // properties so `__syncHostProperties` can sync them the next
                  // time `if` becomes true
                  this.__invalidProps = this.__invalidProps || Object.create(null);
                  this.__invalidProps[Polymer.Path.root(prop)] = true;
                }
              }
            }
          });
        }
        if (!this.__instance) {
          this.__instance = new this.__ctor();
          parentNode.insertBefore(this.__instance.root, this);
        } else {
          this.__syncHostProperties();
          let c$ = this.__instance.children;
          if (c$ && c$.length) {
            // Detect case where dom-if was re-attached in new position
            let lastChild = this.previousSibling;
            if (lastChild !== c$[c$.length - 1]) {
              for (let i = 0, n; i < c$.length && (n = c$[i]); i++) {
                parentNode.insertBefore(n, this);
              }
            }
          }
        }
      }
      return true;
    }

    __syncHostProperties() {
      let props = this.__invalidProps;
      if (props) {
        for (let prop in props) {
          this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
        }
        this.__invalidProps = null;
        this.__instance._flushProperties();
      }
    }

    __teardownInstance() {
      if (this.__instance) {
        let c$ = this.__instance.children;
        if (c$ && c$.length) {
          // use first child parent, for case when dom-if may have been detached
          let parent = c$[0].parentNode;
          for (let i = 0, n; i < c$.length && (n = c$[i]); i++) {
            parent.removeChild(n);
          }
        }
        this.__instance = null;
        this.__invalidProps = null;
      }
    }

    /**
     * Shows or hides the template instance top level child elements. For
     * text nodes, `textContent` is removed while "hidden" and replaced when
     * "shown."
     * @return {void}
     * @protected
     */
    _showHideChildren() {
      let hidden = this.__hideTemplateChildren__ || !this.if;
      if (this.__instance) {
        this.__instance._showHideChildren(hidden);
      }
    }

  }

  customElements.define(DomIf.is, DomIf);

  Polymer.DomIf = DomIf;
})();

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(13);

__webpack_require__(1);

__webpack_require__(23);

(function () {
  'use strict';

  /**
   * Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array such that path changes to the
   * master array (at the host) element or elsewhere via data-binding) are
   * correctly propagated to items in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * @polymer
   * @mixinFunction
   * @appliesMixin Polymer.ElementMixin
   * @memberof Polymer
   * @summary Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array
   */

  let ArraySelectorMixin = Polymer.dedupingMixin(superClass => {

    /**
     * @constructor
     * @extends {superClass}
     * @implements {Polymer_ElementMixin}
     */
    let elementBase = Polymer.ElementMixin(superClass);

    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_ArraySelectorMixin}
     * @unrestricted
     */
    class ArraySelectorMixin extends elementBase {

      static get properties() {

        return {

          /**
           * An array containing items from which selection will be made.
           */
          items: {
            type: Array
          },

          /**
           * When `true`, multiple items may be selected at once (in this case,
           * `selected` is an array of currently selected items).  When `false`,
           * only one item may be selected at a time.
           */
          multi: {
            type: Boolean,
            value: false
          },

          /**
           * When `multi` is true, this is an array that contains any selected.
           * When `multi` is false, this is the currently selected item, or `null`
           * if no item is selected.
           * @type {?(Object|Array<!Object>)}
           */
          selected: {
            type: Object,
            notify: true
          },

          /**
           * When `multi` is false, this is the currently selected item, or `null`
           * if no item is selected.
           * @type {?Object}
           */
          selectedItem: {
            type: Object,
            notify: true
          },

          /**
           * When `true`, calling `select` on an item that is already selected
           * will deselect the item.
           */
          toggle: {
            type: Boolean,
            value: false
          }

        };
      }

      static get observers() {
        return ['__updateSelection(multi, items.*)'];
      }

      constructor() {
        super();
        this.__lastItems = null;
        this.__lastMulti = null;
        this.__selectedMap = null;
      }

      __updateSelection(multi, itemsInfo) {
        let path = itemsInfo.path;
        if (path == 'items') {
          // Case 1 - items array changed, so diff against previous array and
          // deselect any removed items and adjust selected indices
          let newItems = itemsInfo.base || [];
          let lastItems = this.__lastItems;
          let lastMulti = this.__lastMulti;
          if (multi !== lastMulti) {
            this.clearSelection();
          }
          if (lastItems) {
            let splices = Polymer.ArraySplice.calculateSplices(newItems, lastItems);
            this.__applySplices(splices);
          }
          this.__lastItems = newItems;
          this.__lastMulti = multi;
        } else if (itemsInfo.path == 'items.splices') {
          // Case 2 - got specific splice information describing the array mutation:
          // deselect any removed items and adjust selected indices
          this.__applySplices(itemsInfo.value.indexSplices);
        } else {
          // Case 3 - an array element was changed, so deselect the previous
          // item for that index if it was previously selected
          let part = path.slice('items.'.length);
          let idx = parseInt(part, 10);
          if (part.indexOf('.') < 0 && part == idx) {
            this.__deselectChangedIdx(idx);
          }
        }
      }

      __applySplices(splices) {
        let selected = this.__selectedMap;
        // Adjust selected indices and mark removals
        for (let i = 0; i < splices.length; i++) {
          let s = splices[i];
          selected.forEach((idx, item) => {
            if (idx < s.index) {
              // no change
            } else if (idx >= s.index + s.removed.length) {
              // adjust index
              selected.set(item, idx + s.addedCount - s.removed.length);
            } else {
              // remove index
              selected.set(item, -1);
            }
          });
          for (let j = 0; j < s.addedCount; j++) {
            let idx = s.index + j;
            if (selected.has(this.items[idx])) {
              selected.set(this.items[idx], idx);
            }
          }
        }
        // Update linked paths
        this.__updateLinks();
        // Remove selected items that were removed from the items array
        let sidx = 0;
        selected.forEach((idx, item) => {
          if (idx < 0) {
            if (this.multi) {
              this.splice('selected', sidx, 1);
            } else {
              this.selected = this.selectedItem = null;
            }
            selected.delete(item);
          } else {
            sidx++;
          }
        });
      }

      __updateLinks() {
        this.__dataLinkedPaths = {};
        if (this.multi) {
          let sidx = 0;
          this.__selectedMap.forEach(idx => {
            if (idx >= 0) {
              this.linkPaths('items.' + idx, 'selected.' + sidx++);
            }
          });
        } else {
          this.__selectedMap.forEach(idx => {
            this.linkPaths('selected', 'items.' + idx);
            this.linkPaths('selectedItem', 'items.' + idx);
          });
        }
      }

      /**
       * Clears the selection state.
       * @return {void}
       */
      clearSelection() {
        // Unbind previous selection
        this.__dataLinkedPaths = {};
        // The selected map stores 3 pieces of information:
        // key: items array object
        // value: items array index
        // order: selected array index
        this.__selectedMap = new Map();
        // Initialize selection
        this.selected = this.multi ? [] : null;
        this.selectedItem = null;
      }

      /**
       * Returns whether the item is currently selected.
       *
       * @param {*} item Item from `items` array to test
       * @return {boolean} Whether the item is selected
       */
      isSelected(item) {
        return this.__selectedMap.has(item);
      }

      /**
       * Returns whether the item is currently selected.
       *
       * @param {number} idx Index from `items` array to test
       * @return {boolean} Whether the item is selected
       */
      isIndexSelected(idx) {
        return this.isSelected(this.items[idx]);
      }

      __deselectChangedIdx(idx) {
        let sidx = this.__selectedIndexForItemIndex(idx);
        if (sidx >= 0) {
          let i = 0;
          this.__selectedMap.forEach((idx, item) => {
            if (sidx == i++) {
              this.deselect(item);
            }
          });
        }
      }

      __selectedIndexForItemIndex(idx) {
        let selected = this.__dataLinkedPaths['items.' + idx];
        if (selected) {
          return parseInt(selected.slice('selected.'.length), 10);
        }
      }

      /**
       * Deselects the given item if it is already selected.
       *
       * @param {*} item Item from `items` array to deselect
       * @return {void}
       */
      deselect(item) {
        let idx = this.__selectedMap.get(item);
        if (idx >= 0) {
          this.__selectedMap.delete(item);
          let sidx;
          if (this.multi) {
            sidx = this.__selectedIndexForItemIndex(idx);
          }
          this.__updateLinks();
          if (this.multi) {
            this.splice('selected', sidx, 1);
          } else {
            this.selected = this.selectedItem = null;
          }
        }
      }

      /**
       * Deselects the given index if it is already selected.
       *
       * @param {number} idx Index from `items` array to deselect
       * @return {void}
       */
      deselectIndex(idx) {
        this.deselect(this.items[idx]);
      }

      /**
       * Selects the given item.  When `toggle` is true, this will automatically
       * deselect the item if already selected.
       *
       * @param {*} item Item from `items` array to select
       * @return {void}
       */
      select(item) {
        this.selectIndex(this.items.indexOf(item));
      }

      /**
       * Selects the given index.  When `toggle` is true, this will automatically
       * deselect the item if already selected.
       *
       * @param {number} idx Index from `items` array to select
       * @return {void}
       */
      selectIndex(idx) {
        let item = this.items[idx];
        if (!this.isSelected(item)) {
          if (!this.multi) {
            this.__selectedMap.clear();
          }
          this.__selectedMap.set(item, idx);
          this.__updateLinks();
          if (this.multi) {
            this.push('selected', item);
          } else {
            this.selected = this.selectedItem = item;
          }
        } else if (this.toggle) {
          this.deselectIndex(idx);
        }
      }

    }

    return ArraySelectorMixin;
  });

  // export mixin
  Polymer.ArraySelectorMixin = ArraySelectorMixin;

  /**
   * @constructor
   * @extends {Polymer.Element}
   * @implements {Polymer_ArraySelectorMixin}
   */
  let baseArraySelector = ArraySelectorMixin(Polymer.Element);

  /**
   * Element implementing the `Polymer.ArraySelector` mixin, which records
   * dynamic associations between item paths in a master `items` array and a
   * `selected` array such that path changes to the master array (at the host)
   * element or elsewhere via data-binding) are correctly propagated to items
   * in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * Example:
   *
   * ```html
   * <dom-module id="employee-list">
   *
   *   <template>
   *
   *     <div> Employee list: </div>
   *     <dom-repeat id="employeeList" items="{{employees}}">
   *       <template>
   *         <div>First name: <span>{{item.first}}</span></div>
   *           <div>Last name: <span>{{item.last}}</span></div>
   *           <button on-click="toggleSelection">Select</button>
   *       </template>
   *     </dom-repeat>
   *
   *     <array-selector id="selector" items="{{employees}}" selected="{{selected}}" multi toggle></array-selector>
   *
   *     <div> Selected employees: </div>
   *     <dom-repeat items="{{selected}}">
   *       <template>
   *         <div>First name: <span>{{item.first}}</span></div>
   *         <div>Last name: <span>{{item.last}}</span></div>
   *       </template>
   *     </dom-repeat>
   *
   *   </template>
   *
   * </dom-module>
   * ```
   *
   * ```js
   *class EmployeeList extends Polymer.Element {
   *  static get is() { return 'employee-list'; }
   *  static get properties() {
   *    return {
   *      employees: {
   *        value() {
   *          return [
   *            {first: 'Bob', last: 'Smith'},
   *            {first: 'Sally', last: 'Johnson'},
   *            ...
   *          ];
   *        }
   *      }
   *    };
   *  }
   *  toggleSelection(e) {
   *    let item = this.$.employeeList.itemForElement(e.target);
   *    this.$.selector.select(item);
   *  }
   *}
   * ```
   *
   * @polymer
   * @customElement
   * @extends {baseArraySelector}
   * @appliesMixin Polymer.ArraySelectorMixin
   * @memberof Polymer
   * @summary Custom element that links paths between an input `items` array and
   *   an output `selected` item or array based on calls to its selection API.
   */
  class ArraySelector extends baseArraySelector {
    // Not needed to find template; can be removed once the analyzer
    // can find the tag name from customElements.define call
    static get is() {
      return 'array-selector';
    }
  }
  customElements.define(ArraySelector.is, ArraySelector);
  Polymer.ArraySelector = ArraySelector;
})();

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(51);

__webpack_require__(18);

(function () {
  'use strict';

  const attr = 'include';

  const CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

  /**
   * Custom element for defining styles in the main document that can take
   * advantage of [shady DOM](https://github.com/webcomponents/shadycss) shims
   * for style encapsulation, custom properties, and custom mixins.
   *
   * - Document styles defined in a `<custom-style>` are shimmed to ensure they
   *   do not leak into local DOM when running on browsers without native
   *   Shadow DOM.
   * - Custom properties can be defined in a `<custom-style>`. Use the `html` selector
   *   to define custom properties that apply to all custom elements.
   * - Custom mixins can be defined in a `<custom-style>`, if you import the optional
   *   [apply shim](https://github.com/webcomponents/shadycss#about-applyshim)
   *   (`shadycss/apply-shim.html`).
   *
   * To use:
   *
   * - Import `custom-style.html`.
   * - Place a `<custom-style>` element in the main document, wrapping an inline `<style>` tag that
   *   contains the CSS rules you want to shim.
   *
   * For example:
   *
   * ```
   * <!-- import apply shim--only required if using mixins -->
   * <link rel="import href="bower_components/shadycss/apply-shim.html">
   * <!-- import custom-style element -->
   * <link rel="import" href="bower_components/polymer/lib/elements/custom-style.html">
   * ...
   * <custom-style>
   *   <style>
   *     html {
   *       --custom-color: blue;
   *       --custom-mixin: {
   *         font-weight: bold;
   *         color: red;
   *       };
   *     }
   *   </style>
   * </custom-style>
   * ```
   *
   * @customElement
   * @extends HTMLElement
   * @memberof Polymer
   * @summary Custom element for defining styles in the main document that can
   *   take advantage of Polymer's style scoping and custom properties shims.
   */
  class CustomStyle extends HTMLElement {
    constructor() {
      super();
      this._style = null;
      CustomStyleInterface.addCustomStyle(this);
    }
    /**
     * Returns the light-DOM `<style>` child this element wraps.  Upon first
     * call any style modules referenced via the `include` attribute will be
     * concatenated to this element's `<style>`.
     *
     * @return {HTMLStyleElement} This element's light-DOM `<style>`
     */
    getStyle() {
      if (this._style) {
        return this._style;
      }
      const style = /** @type {HTMLStyleElement} */this.querySelector('style');
      if (!style) {
        return null;
      }
      this._style = style;
      const include = style.getAttribute(attr);
      if (include) {
        style.removeAttribute(attr);
        style.textContent = Polymer.StyleGather.cssFromModules(include) + style.textContent;
      }
      /*
      HTML Imports styling the main document are deprecated in Chrome
      https://crbug.com/523952
       If this element is not in the main document, then it must be in an HTML Import document.
      In that case, move the custom style to the main document.
       The ordering of `<custom-style>` should stay the same as when loaded by HTML Imports, but there may be odd
      cases of ordering w.r.t the main document styles.
      */
      if (this.ownerDocument !== window.document) {
        window.document.head.appendChild(this);
      }
      return this._style;
    }
  }

  window.customElements.define('custom-style', CustomStyle);
  Polymer.CustomStyle = CustomStyle;
})();

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(52);

/***/ }),
/* 52 */
/***/ (function(module, exports) {

(function () {
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';
  var c = !(window.ShadyDOM && window.ShadyDOM.inUse),
      f;function g(a) {
    f = a && a.shimcssproperties ? !1 : c || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? f = window.ShadyCSS.nativeCss : window.ShadyCSS ? (g(window.ShadyCSS), window.ShadyCSS = void 0) : g(window.WebComponents && window.WebComponents.flags);var h = f;function k(a, b) {
    for (var d in b) null === d ? a.style.removeProperty(d) : a.style.setProperty(d, b[d]);
  };var l = null,
      m = window.HTMLImports && window.HTMLImports.whenReady || null,
      n;function p() {
    var a = q;requestAnimationFrame(function () {
      m ? m(a) : (l || (l = new Promise(function (a) {
        n = a;
      }), "complete" === document.readyState ? n() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && n();
      })), l.then(function () {
        a && a();
      }));
    });
  };var r = null,
      q = null;function t() {
    this.customStyles = [];this.enqueued = !1;
  }function u(a) {
    !a.enqueued && q && (a.enqueued = !0, p());
  }t.prototype.c = function (a) {
    a.__seenByShadyCSS || (a.__seenByShadyCSS = !0, this.customStyles.push(a), u(this));
  };t.prototype.b = function (a) {
    if (a.__shadyCSSCachedStyle) return a.__shadyCSSCachedStyle;var b;a.getStyle ? b = a.getStyle() : b = a;return b;
  };
  t.prototype.a = function () {
    for (var a = this.customStyles, b = 0; b < a.length; b++) {
      var d = a[b];if (!d.__shadyCSSCachedStyle) {
        var e = this.b(d);e && (e = e.__appliedElement || e, r && r(e), d.__shadyCSSCachedStyle = e);
      }
    }return a;
  };t.prototype.addCustomStyle = t.prototype.c;t.prototype.getStyleForCustomStyle = t.prototype.b;t.prototype.processStyles = t.prototype.a;
  Object.defineProperties(t.prototype, { transformCallback: { get: function () {
        return r;
      }, set: function (a) {
        r = a;
      } }, validateCallback: { get: function () {
        return q;
      }, set: function (a) {
        var b = !1;q || (b = !0);q = a;b && u(this);
      } } });var v = new t();window.ShadyCSS || (window.ShadyCSS = { prepareTemplate: function () {}, styleSubtree: function (a, b) {
      v.a();k(a, b);
    }, styleElement: function () {
      v.a();
    }, styleDocument: function (a) {
      v.a();k(document.body, a);
    }, getComputedStyleValue: function (a, b) {
      return (a = window.getComputedStyle(a).getPropertyValue(b)) ? a.trim() : "";
    }, nativeCss: h, nativeShadow: c });window.ShadyCSS.CustomStyleInterface = v;
}).call(this);

//# sourceMappingURL=custom-style-interface.min.js.map

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {


__webpack_require__(7);

(function () {
  'use strict';

  let mutablePropertyChange;
  /** @suppress {missingProperties} */
  (() => {
    mutablePropertyChange = Polymer.MutableData._mutablePropertyChange;
  })();

  /**
   * Legacy element behavior to skip strict dirty-checking for objects and arrays,
   * (always consider them to be "dirty") for use on legacy API Polymer elements.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will cause Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   * Specifically, any elements in the binding tree between the source of a
   * mutation and the consumption of it must apply this behavior or enable the
   * `Polymer.OptionalMutableDataBehavior`.
   *
   * In order to make the dirty check strategy configurable, see
   * `Polymer.OptionalMutableDataBehavior`.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse as opposed to using strict dirty checking with immutable
   * patterns or Polymer's path notification API.
   *
   * @polymerBehavior
   * @memberof Polymer
   * @summary Behavior to skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.MutableDataBehavior = {

    /**
     * Overrides `Polymer.PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }
  };

  /**
   * Legacy element behavior to add the optional ability to skip strict
   * dirty-checking for objects and arrays (always consider them to be
   * "dirty") by setting a `mutable-data` attribute on an element instance.
   *
   * By default, `Polymer.PropertyEffects` performs strict dirty checking on
   * objects, which means that any deep modifications to an object or array will
   * not be propagated unless "immutable" data patterns are used (i.e. all object
   * references from the root to the mutation were changed).
   *
   * Polymer also provides a proprietary data mutation and path notification API
   * (e.g. `notifyPath`, `set`, and array mutation API's) that allow efficient
   * mutation and notification of deep changes in an object graph to all elements
   * bound to the same object graph.
   *
   * In cases where neither immutable patterns nor the data mutation API can be
   * used, applying this mixin will allow Polymer to skip dirty checking for
   * objects and arrays (always consider them to be "dirty").  This allows a
   * user to make a deep modification to a bound object graph, and then either
   * simply re-set the object (e.g. `this.items = this.items`) or call `notifyPath`
   * (e.g. `this.notifyPath('items')`) to update the tree.  Note that all
   * elements that wish to be updated based on deep mutations must apply this
   * mixin or otherwise skip strict dirty checking for objects/arrays.
   * Specifically, any elements in the binding tree between the source of a
   * mutation and the consumption of it must enable this behavior or apply the
   * `Polymer.OptionalMutableDataBehavior`.
   *
   * While this behavior adds the ability to forgo Object/Array dirty checking,
   * the `mutableData` flag defaults to false and must be set on the instance.
   *
   * Note, the performance characteristics of propagating large object graphs
   * will be worse by relying on `mutableData: true` as opposed to using
   * strict dirty checking with immutable patterns or Polymer's path notification
   * API.
   *
   * @polymerBehavior
   * @memberof Polymer
   * @summary Behavior to optionally skip strict dirty-checking for objects and
   *   arrays
   */
  Polymer.OptionalMutableDataBehavior = {

    properties: {
      /**
       * Instance-level flag for configuring the dirty-checking strategy
       * for this element.  When true, Objects and Arrays will skip dirty
       * checking, otherwise strict equality checking will be used.
       */
      mutableData: Boolean
    },

    /**
     * Overrides `Polymer.PropertyEffects` to skip strict equality checking
     * for Objects and Arrays.
     *
     * Pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @this {this}
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
  };
})();

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {


const RegisterHtmlTemplate = __webpack_require__(25);

RegisterHtmlTemplate.register("<dom-module id=ozone-video-player> <template> <style>.element{position:absolute;overflow:hidden;background:var(--marker-bar-background,rgba(29,38,43,.52));min-height:10px;max-height:10px;width:20%;top:4px;transform-origin:center center;min-width:10px;@apply --marker-bar;}.resizer{width:5px;height:100%;position:absolute;bottom:0;cursor:ew-resize;background:var(--resizer-color,rgba(29,38,43,.9));@apply --resizer;}.resizer::after{content:'';position:absolute;left:50%;top:50%;display:block;width:1px;height:80%;transform:translate(-50%,-50%);background:var(--resizer-handle-color,rgba(255,255,255,.2))}.moving-tooltip::before{content:attr(data-attr);display:block;width:60px;height:16px;background:var(--moving-tooltip-background-color,rgba(29,38,43,.9));position:fixed;bottom:60px;transform:translateX(-50%);color:var(--moving-tooltip-text-color,#fff);font-size:12px;text-align:center;line-height:10px;padding-top:6px;border-radius:2px;@apply --moving-tooltip-mixin;}.edit-mode>.media-control-center-panel>.bar-container>.bar-background{height:10px!important;top:4px!important;background:#95a5a6!important}.bar-fill-1{background:#bdc3c7!important}.bar-fill-2{background:#50e3c2!important}.edit-mode>.media-control-center-panel>.bar-container>.bar-scrubber>.bar-scrubber-icon{left:8px!important;top:1px!important;width:12px!important;height:12px!important}.subtitles{display:block;position:absolute;left:50%;bottom:0!important;background-color:transparent;transform:translateX(-50%);box-sizing:border-box;padding:7px;opacity:1;pointer-events:none;max-width:95%;white-space:normal;z-index:1;letter-spacing:1px;text-shadow:0 1px 0 rgba(0,0,0,.2),0 1px 8px rgba(0,0,0,.6);font-family:var(--subtitles-font-family, 'Roboto'),sans-serif!important;color:var(--subtiltes-color,#fffb00);font-size:var(--subtitles-font-size,16px)!important;font-weight:var(--subtitles-weight,bold)!important;@apply --subtitles;}.media-control-subtitles-menu{background:rgba(29,38,43,.7);width:200px;display:block;position:absolute;bottom:46px;right:50px;border-radius:3px;color:#fff;padding:16px!important;opacity:0}.media-control-subtitles-menu-element{color:#fff;font-size:14px!important;text-align:left;font-family:Roboto,sans-serif;height:26px;display:flex!important;flex-direction:row;align-items:center;justify-content:space-between}.media-control-subtitles-menu-element:hover{font-weight:700;background:rgba(255,255,255,.15)}.media-control-subtitles-menu-element.selected{font-weight:700}.media-control-subtitles-menu-element.selected::after{content:'';height:26px;display:block;width:26px;position:relative;right:0;top:0;background:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMTFweCIgaGVpZ2h0PSI5cHgiIHZpZXdCb3g9IjAgMCAxMSA5IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCA0Ni4yICg0NDQ5NikgLSBodHRwOi8vd3d3LmJvaGVtaWFuY29kaW5nLmNvbS9za2V0Y2ggLS0+CiAgICA8dGl0bGU+Y2hlY2sgLSBtYXRlcmlhbDwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZvbnQtc2l6ZT0iMTQiIGZvbnQtZmFtaWx5PSJtYXRlcmlhbCIgZm9udC13ZWlnaHQ9Im5vcm1hbCI+CiAgICAgICAgPGcgaWQ9IkFydGJvYXJkIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTI0LjAwMDAwMCwgLTIzMC4wMDAwMDApIiBmaWxsPSIjNTBFM0MyIj4KICAgICAgICAgICAgPGcgaWQ9Ikdyb3VwIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MDguMDAwMDAwLCAyMjIuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8dGV4dCBpZD0iY2hlY2stLS1tYXRlcmlhbCI+CiAgICAgICAgICAgICAgICAgICAgPHRzcGFuIHg9IjExNCIgeT0iMTciPu6ihjwvdHNwYW4+CiAgICAgICAgICAgICAgICA8L3RleHQ+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==);background-position:center;background-repeat:no-repeat}.bar-hover{opacity:0!important}</style> <div id=player></div> </template> </dom-module>");

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        } else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous) previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate ? function () {
                return MakeDictionary(Object.create(null));
            } : supportsProto ? function () {
                return MakeDictionary({ __proto__: null });
            } : function () {
                return MakeDictionary({});
            },
            has: downLevel ? function (map, key) {
                return hasOwn.call(map, key);
            } : function (map, key) {
                return key in map;
            },
            get: downLevel ? function (map, key) {
                return hasOwn.call(map, key) ? map[key] : undefined;
            } : function (map, key) {
                return map[key];
            }
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators)) throw new TypeError();
                if (!IsObject(target)) throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes)) throw new TypeError();
                if (IsNull(attributes)) attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            } else {
                if (!IsArray(decorators)) throw new TypeError();
                if (!IsConstructor(target)) throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target)) throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey)) throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target)) throw new TypeError();
            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target)) throw new TypeError();
            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target)) throw new TypeError();
            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target)) throw new TypeError();
            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target)) throw new TypeError();
            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target)) throw new TypeError();
            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target)) throw new TypeError();
            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target)) throw new TypeError();
            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/false);
            if (IsUndefined(metadataMap)) return false;
            if (!metadataMap.delete(metadataKey)) return false;
            if (metadataMap.size > 0) return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0) return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated)) throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated)) throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create) return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create) return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn) return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent)) return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/false);
            if (IsUndefined(metadataMap)) return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent)) return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/false);
            if (IsUndefined(metadataMap)) return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null) return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0) return ownKeys;
            if (ownKeys.length <= 0) return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/false);
            if (IsUndefined(metadataMap)) return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                } catch (e) {
                    try {
                        IteratorClose(iterator);
                    } finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null) return 1 /* Null */;
            switch (typeof x) {
                case "undefined":
                    return 0 /* Undefined */;
                case "boolean":
                    return 2 /* Boolean */;
                case "string":
                    return 3 /* String */;
                case "symbol":
                    return 4 /* Symbol */;
                case "number":
                    return 5 /* Number */;
                case "object":
                    return x === null ? 1 /* Null */ : 6 /* Object */;
                default:
                    return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */:
                    return input;
                case 1 /* Null */:
                    return input;
                case 2 /* Boolean */:
                    return input;
                case 3 /* String */:
                    return input;
                case 4 /* Symbol */:
                    return input;
                case 5 /* Number */:
                    return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result)) throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result)) return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result)) return result;
                }
            } else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result)) return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result)) return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key)) return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */:
                    return true;
                case 4 /* Symbol */:
                    return true;
                default:
                    return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null) return undefined;
            if (!IsCallable(func)) throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method)) throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator)) throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f) f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype) return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype) return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype) return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function") return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O) return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () {
                    return this;
                };
                MapIterator.prototype[iteratorSymbol] = function () {
                    return this;
                };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        } else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }();
            return function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () {
                        return this._keys.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) {
                    return this._find(key, /*insert*/false) >= 0;
                };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () {
                    return new MapIterator(this._keys, this._values, getKey);
                };
                Map.prototype.values = function () {
                    return new MapIterator(this._keys, this._values, getValue);
                };
                Map.prototype.entries = function () {
                    return new MapIterator(this._keys, this._values, getEntry);
                };
                Map.prototype["@@iterator"] = function () {
                    return this.entries();
                };
                Map.prototype[iteratorSymbol] = function () {
                    return this.entries();
                };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }();
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () {
                        return this._map.size;
                    },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) {
                    return this._map.has(value);
                };
                Set.prototype.add = function (value) {
                    return this._map.set(value, value), this;
                };
                Set.prototype.delete = function (value) {
                    return this._map.delete(value);
                };
                Set.prototype.clear = function () {
                    this._map.clear();
                };
                Set.prototype.keys = function () {
                    return this._map.keys();
                };
                Set.prototype.values = function () {
                    return this._map.values();
                };
                Set.prototype.entries = function () {
                    return this._map.entries();
                };
                Set.prototype["@@iterator"] = function () {
                    return this.keys();
                };
                Set.prototype[iteratorSymbol] = function () {
                    return this.keys();
                };
                return Set;
            }();
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }();
            function CreateUniqueKey() {
                var key;
                do key = "@@WeakMap@@" + CreateUUID(); while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create) return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i) buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined") return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined") return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122  4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8) result += "-";
                    if (byte < 16) result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));
//# sourceMappingURL=Reflect.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(56), __webpack_require__(57)))

/***/ }),
/* 56 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 57 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Custom Elements v1
 *
 * Based on https://www.w3.org/TR/2016/WD-custom-elements-20160830/
 */

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Created by hubert on 8/06/17.
 */

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function () {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function () {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_Clappr__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_Clappr___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_Clappr__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ozone_media_url__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ozone_config__ = __webpack_require__(3);
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/*!
 *
 *  ClapprSubtitle
 *  Copyright 2016 JMV Technology. All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use (this as any) file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License
 */



var BLOCK_REGEX = /[0-9]+(?:\r\n|\r|\n)([0-9]{2}:[0-9]{2}:[0-9]{2}(?:,|\.)[0-9]{3}) --> ([0-9]{2}:[0-9]{2}:[0-9]{2}(?:,|\.)[0-9]{3})(?:\r\n|\r|\n)((?:.*(?:\r\n|\r|\n))*?)(?:\r\n|\r|\n)/g;
class ClapprSubtitle extends __WEBPACK_IMPORTED_MODULE_0_Clappr__["UICorePlugin"] {
    /**
     * @constructor
     */
    constructor(core) {
        super(core);
        this.subtitles = [];
        this.element = null;
        this._active = false;
        this._menuOpen = false;
        this.subtitles = [];
        // initialize subtitle on DOM
        this.initializeElement();
        // check options
        if (!this._options.subtitle)
            return;
        var options = this._options.subtitle;
        // override src and style
        // if 'options' is object
        if (typeof (options) === "object") {
            if ('src' in options) {
                if (typeof (options.src) == 'string') {
                    this.options.src = options.src;
                }
                else {
                    return;
                }
            }
            if ('auto' in options) {
                this.options.auto = options.auto === true;
                if (this.options.auto) {
                    //this.active = true;
                }
            }
            if ('backgroundColor' in options)
                this.options.backgroundColor = options.backgroundColor;
            if ('color' in options) {
                this.options.color = options.color;
            }
            if ('fontSize' in options)
                this.options.fontSize = options.fontSize;
            if ('fontWeight' in options)
                this.options.fontWeight = options.fontWeight;
            if ('textShadow' in options)
                this.options.textShadow = options.textShadow;
            // override src if 'options' is string
        }
        else if (typeof (options) === "string") {
            this.options.src = options;
            this.options.auto = true;
        }
        else {
            return;
        }
        // initialize subtitle on DOM
        this.initializeElement();
        this.initSubtitle();
    }
    get name() { return 'subtitle-plugin'; }
    initSubtitle() {
        this.addMenuToMediaControl();
        // fetch subtitles
        this.fetchSubtitle(this.onSubtitlesFetched.bind(this));
    }
    isThereSubtitle() {
        if (this.options.subtitle && this.options.subtitle.list) {
            return this.options.subtitle.list.size > 0;
        }
        else {
            return false;
        }
    }
    get active() {
        return this._active;
    }
    set active(active) {
        var menuContainer = this.core
            .mediaControl
            .$el
            .children('.media-control-layer')
            .children('.media-control-right-panel')
            .children('.media-control-subtitle-toggler');
        menuContainer[0].style.opacity = active ? '1' : 0.5;
        if (!active)
            this.hideElement();
        this._active = active;
    }
    /**
     * Add event listeners
     */
    bindEvents() {
        this.listenTo(this.core, __WEBPACK_IMPORTED_MODULE_0_Clappr__["Events"].CORE_CONTAINERS_CREATED, this.containersCreated);
        this.listenTo(this.core.mediaControl, __WEBPACK_IMPORTED_MODULE_0_Clappr__["Events"].MEDIACONTROL_RENDERED, this.addButtonToMediaControl);
        this.listenTo(this.core.mediaControl, __WEBPACK_IMPORTED_MODULE_0_Clappr__["Events"].MEDIACONTROL_SHOW, this.onMediaControlShow);
        this.listenTo(this.core.mediaControl, __WEBPACK_IMPORTED_MODULE_0_Clappr__["Events"].MEDIACONTROL_HIDE, this.onMediaControlHide);
        this.listenTo(this.core.mediaControl, __WEBPACK_IMPORTED_MODULE_0_Clappr__["Events"].MEDIACONTROL_CONTAINERCHANGED, this.onContainerChanged);
        this.listenTo(this.core.mediaControl, __WEBPACK_IMPORTED_MODULE_0_Clappr__["Events"].MEDIACONTROL_RENDERED, () => { this.initSubtitle(); });
    }
    /**
     * Add event listeners after containers were created
     */
    containersCreated() {
        // append element to container
        this.core.containers[0].$el.append(this.element);
        // run
        this.listenTo(this.core.containers[0].playback, __WEBPACK_IMPORTED_MODULE_0_Clappr__["Events"].PLAYBACK_TIMEUPDATE, this.run);
    }
    /**
     * On container changed
     */
    onContainerChanged() {
        // container changed is fired right off the bat
        // so we should bail if subtitles aren't yet loaded
        if (this.subtitles.length === 0)
            return;
        // kill the current element
        this.element.parentNode.removeChild(this.element);
        // clear subtitles
        this.subtitle = [];
        // initialize stuff again
        this.initialize();
        // trigger containers created
        this.containersCreated();
    }
    /**
     * Subtitles fetched
     */
    onSubtitlesFetched(data) {
        // parse subtitle
        this.parseSubtitle(data);
    }
    /**
     * AJAX request to the subtitles source
     * @param {function} callback
     */
    fetchSubtitle(cb) {
        if (typeof (this.options.src) == 'string') {
            var r = new XMLHttpRequest();
            r.open("GET", this.options.src, true);
            r.onreadystatechange = function () {
                // nothing happens if request
                // fails or is not ready
                if (r.readyState != 4 || r.status != 200)
                    return;
                // callback
                if (cb)
                    cb(r.responseText);
            };
            r.send();
        }
        else {
        }
    }
    /**
     * Parse subtitle
     * @param {string} data
     */
    parseSubtitle(datas) {
        // clear existing subtitles if any
        this.subtitles = [];
        // Get blocks and loop through them
        let blocks = datas.match(BLOCK_REGEX);
        for (var i = 0; i < blocks.length; i++) {
            var startTime = null;
            var endTime = null;
            var text = "";
            // Break the block in lines
            var block = blocks[i];
            var lines = block.split(/(?:\r\n|\r|\n)/);
            // The second line is the time line.
            // We parse the start and end time.
            var time = lines[1].split(' --> ');
            var startTime = this.humanDurationToSeconds(time[0].trim());
            var endTime = this.humanDurationToSeconds(time[1].trim());
            // As for the rest of the lines, we loop through
            // them and append the to the text,
            for (var j = 2; j < lines.length; j++) {
                var line = lines[j].trim();
                if (text.length > 0) {
                    text += "<br />";
                }
                text += line;
            }
            // Then we push it to the subtitles
            this.subtitles.push({
                startTime: startTime,
                endTime: endTime,
                text: text
            });
        }
    }
    /**
     * Converts human duration time (00:00:00) to seconds
     * @param {string} human time
     * @return {float}
     */
    humanDurationToSeconds(duration) {
        duration = duration.split(":");
        var hours = duration[0], minutes = duration[1], seconds = duration[2].replace(",", ".");
        var result = 0.00;
        result += parseFloat(hours) * 60 * 60;
        result += parseFloat(minutes) * 60;
        result += parseFloat(seconds);
        return result;
    }
    /**
     * Initializes the subtitle on the dom
     */
    initializeElement() {
        var el = document.createElement('div');
        el.classList.add('subtitles');
        this.element = el;
    }
    /**
     * Add button to media control
     */
    addButtonToMediaControl() {
        if (this.isThereSubtitle()) {
            var bar = this.core
                .mediaControl
                .$el
                .children('.media-control-layer')
                .children('.media-control-right-panel');
            // create icon
            var button = document.createElement('button');
            button.classList.add('media-control-button');
            button.classList.add('media-control-icon');
            button.classList.add('media-control-subtitle-toggler');
            button.innerHTML = this.getMediaControlButtonSVG();
            // create icon
            var menuContainer = document.createElement('div');
            menuContainer.classList.add('media-control-menu');
            // if active, glow
            if (this.active)
                button.style.opacity = '1';
            // append to bar
            bar.append(button);
            // add listener
            button.onclick = (e) => this.onMediaControlButtonClick(e);
        }
    }
    /**
     * Button SGV
     * @return {string}
     */
    getMediaControlButtonSVG() {
        return '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 1000 1000" enable-background="new 0 0 1000 1000" xml:space="preserve" style="pointer-events: none">' +
            '<metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>' +
            '<g><path d="M893.4,599V500H401.1V599H893.4z M893.4,794.5v-98.9H695.5v98.9H893.4z M598.9,794.5v-98.9H106.6v98.9H598.9z M106.6,500V599h197.8V500H106.6z M893.4,106.7c26.1,0,48.7,10,67.9,29.9s28.8,42.9,28.8,69v588.9c0,26.1-9.6,49.1-28.8,69c-19.2,19.9-41.8,29.9-67.9,29.9H106.6c-26.1,0-48.7-10-67.9-29.9c-19.2-19.9-28.8-42.9-28.8-69V205.5c0-26.1,9.6-49.1,28.8-69s41.8-29.9,67.9-29.9H893.4z"/></g>' +
            '</svg>';
    }
    /**
     * on button click
     */
    onMediaControlButtonClick(mouseEvent) {
        console.log('onMediaControlButtonClick');
        // toggle menuOpen on/off
        this.menuOpen = !this.menuOpen;
    }
    set menuOpen(val) {
        let subtitlesMenu = this.core
            .mediaControl
            .$el
            .children('.media-control-layer')
            .children('.media-control-right-panel')
            .children('.media-control-subtitles-menu');
        this._menuOpen = val;
        subtitlesMenu.css('opacity', val ? '1' : '0');
    }
    get menuOpen() {
        return this._menuOpen;
    }
    getSubtile(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield (__WEBPACK_IMPORTED_MODULE_2_ozone_config__["a" /* OzoneConfig */].get());
            const mediaUrl = new __WEBPACK_IMPORTED_MODULE_1_ozone_media_url__["a" /* OzoneMediaUrl */](id, config);
            this.options.src = mediaUrl.getOriginalFormat();
            this.fetchSubtitle(this.onSubtitlesFetched.bind(this));
        });
    }
    /**
     * Add subtitles menu to media control
     */
    addMenuToMediaControl() {
        var bar = this.core
            .mediaControl
            .$el
            .children('.media-control-layer')
            .children('.media-control-right-panel');
        // create icon
        var menuContainer = document.createElement('div');
        menuContainer.classList.add('media-control-subtitles-menu');
        if (this.options.subtitle.list) {
            this.options.subtitle.list.forEach((id, name) => {
                let subtitleElement = document.createElement('div');
                subtitleElement.classList.add('media-control-subtitles-menu-element');
                subtitleElement.classList.add(name);
                subtitleElement.textContent = name;
                console.log('add ', name);
                menuContainer.appendChild(subtitleElement);
                subtitleElement.onclick = (mouseEvent) => {
                    this.selectSubtitleTrack(name, id);
                    menuContainer.style.opacity = '0';
                    this.menuOpen = false;
                };
            });
        }
        // append to bar
        if (menuContainer.hasChildNodes())
            bar.append(menuContainer);
    }
    selectSubtitleTrack(name, id) {
        this.getSubtile(id);
        const subtitleList = this.core
            .mediaControl
            .$el
            .children('.media-control-layer')
            .children('.media-control-right-panel')
            .children('.media-control-subtitles-menu')
            .children('.media-control-subtitles-menu-element');
        if (subtitleList) {
            subtitleList.forEach((menuElement) => {
                if (menuElement.classList.contains(name)) {
                    this.active = menuElement.classList.toggle('selected');
                }
                else {
                    menuElement.classList.remove('selected');
                }
            });
        }
    }
    /**
     * Hides the subtitle element
     */
    hideElement() {
        this.element.style.opacity = '0';
    }
    /**
     * Shows the subtitle element with text
     * @param {string} text
     */
    showElement(text) {
        if (!this.active)
            return;
        this.element.innerHTML = text;
        this.element.style.opacity = '1';
    }
    /**
     * Subtitle element moves up
     * to give space to the controls
     */
    onMediaControlShow() {
        if (this.element)
            this.element.style.bottom = '100px';
    }
    /**
     * Subtitle element moves down
     * when controls hide
     */
    onMediaControlHide() {
        if (this.element)
            this.element.style.bottom = '50px';
    }
    /**
     * Show subtitles as media is playing
     */
    run(time) {
        var subtitle = this.subtitles.find(function (subtitle) {
            return time.current >= subtitle.startTime && time.current <= subtitle.endTime;
        });
        if (subtitle) {
            this.showElement(subtitle.text);
        }
        else {
            this.hideElement();
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ClapprSubtitle;

;
//  export const ClapprSubtitle = Clappr.CorePlugin.extend(ClapprSubtitleObject);


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OzoneApiItem; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ozone_config__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ozone_api_request__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ozone_search_helper__ = __webpack_require__(66);
/**
 * Created by hubert on 8/06/17.
 */
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




/**
 * `ozone-api-item` is low level es6 module to ozone api.
 * It provide CRUD operation and search in a given collection.
 *
 * * Example
 * ```javaScript
 * const ozoneApiSearch = new OzoneApiItem(); // return instance of OzoneApiItem located in the dom
 * const result = ozoneApiSearch.on('item').getOne('an-id');
 * ```
 *
 */
let OzoneApiItem = class OzoneApiItem {
    /**
     * `ozone-api-item` is low level es6 module to ozone api.
     * It provide CRUD operation and search in a given collection.
     *
     * * Example
     * ```javaScript
     * const ozoneApiSearch = new OzoneApiItem(); // return instance of OzoneApiItem located in the dom
     * const result = ozoneApiSearch.on('item').getOne('an-id');
     * ```
     *
     */
    constructor() {
        /**
         * type of the ozone collection.
         * Default value is 'item'
         */
        this.collection = 'item';
        this._readItemResponse = res => res.response;
        this._readBulkItemResponse = res => {
            return res.response;
        };
    }
    /**
     * set collection and return this to be chain by a query.
     * @param {string} collection
     * @return {OzoneApiItem} this
     */
    on(collection) {
        this.setCollection(collection);
        return this;
    }
    /**
     * Set ozone collection to query
     * @param {string} collection
     */
    setCollection(collection) {
        this.collection = collection;
    }
    /**
     * Create or update a collection item.
     * @param data Item item to create.
     * @return {Promise<Item>}
     */
    create(data) {
        return this.update(data);
    }
    /**
     * Create or update a collection item.
     * @param data Item item to update.
     * @return {Promise<Item>}
     */
    update(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield this._buildUrl('');
            return this._postRequest(url, data, this._readItemResponse);
        });
    }
    /**
     * get one collection item by uuid.
     * @param id
     * @return {Promise<Item | null>}
     */
    getOne(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield this._buildUrl(id);
            return this._getRequest(url).then(response => {
                if (response == '') {
                    return null;
                } else {
                    return response;
                }
            });
        });
    }
    /**
     * delete one collection item by uuid.
     * @param id
     * @return {Promise<any>}
     */
    deleteOne(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield this._buildUrl(id);
            return this._deleteRequest(url);
        });
    }
    /**
     * get collection items from a list of id.
     * @param ids {Array<uuid>} array of id to get
     * @return {Promise<Iterator<Item>>} promise resole with an iterator of collection item
     */
    bulkGet(ids) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield this._buildUrl('bulkGet');
            return this._postRequest(url, ids, this._readBulkItemResponse);
        });
    }
    /**
     * delete items from a list of id.
     * @param ids
     * @return {Promise<Array<uuid>>} promise resole with an array of deleted id
     */
    bulkDelete(ids) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield this._buildUrl('bulkDelete');
            return this._postRequest(url, ids, this._readItemResponse);
        });
    }
    /**
     * save an array of items
     * @param items
     * @return {Promise<Iterator<Item>>} promise resole with an iterator of collection item
     */
    bulkSave(items) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield this._buildUrl('bulkSave');
            return this._postRequest(url, items, this._readBulkItemResponse);
        });
    }
    /**
     * Submit ozone search query
     */
    search(search) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield this._buildUrl('search');
            return new __WEBPACK_IMPORTED_MODULE_3_ozone_search_helper__["a" /* SearchGenerator */](url, search);
        });
    }
    _postRequest(url, body, responseFilter) {
        const ozoneAccess = new __WEBPACK_IMPORTED_MODULE_1_ozone_api_request__["a" /* OzoneAPIRequest */]();
        ozoneAccess.url = url;
        ozoneAccess.method = 'POST';
        ozoneAccess.body = JSON.stringify(body);
        return ozoneAccess.sendRequest().then(responseFilter.bind(this));
    }
    _getRequest(url) {
        const ozoneAccess = new __WEBPACK_IMPORTED_MODULE_1_ozone_api_request__["a" /* OzoneAPIRequest */]();
        ozoneAccess.url = url;
        ozoneAccess.method = 'GET';
        return ozoneAccess.sendRequest().then(res => res.response);
    }
    _deleteRequest(url) {
        const ozoneAccess = new __WEBPACK_IMPORTED_MODULE_1_ozone_api_request__["a" /* OzoneAPIRequest */]();
        ozoneAccess.url = url;
        ozoneAccess.method = 'DELETE';
        return ozoneAccess.sendRequest().then(res => res.response);
    }
    _buildUrl(action, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield __WEBPACK_IMPORTED_MODULE_0_ozone_config__["a" /* OzoneConfig */].get();
            const ozoneEndPoint = config.endPoints[this.collection];
            const serviceUrl = config.host + ozoneEndPoint;
            return `${serviceUrl}/${action}`;
        });
    }
};
OzoneApiItem = __decorate([Object(__WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript__["jsElement"])()], OzoneApiItem);


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SearchQuery */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SearchGenerator; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ozone_api_request__ = __webpack_require__(8);
/// <amd-module name="ozone-search-helper"/>
var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = this && this.__metadata || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Created by hubert on 8/06/17.
 */


/**
 * Class helper to create searchQuery.
 * * Example:
 * ```javaScript
 *   let searchQuery = new SearchQuery();
 *   searchQuery.quicksearch('');
 *   const searchGenerator = ozoneItemApi.search(searchQuery);
 *
 * ```
 */
let SearchQuery = class SearchQuery {
    /**
     * Class helper to create searchQuery.
     * * Example:
     * ```javaScript
     *   let searchQuery = new SearchQuery();
     *   searchQuery.quicksearch('');
     *   const searchGenerator = ozoneItemApi.search(searchQuery);
     *
     * ```
     */
    constructor() {
        this._searchRequest = {
            size: 10
        };
    }
    get searchQuery() {
        return JSON.stringify(this._searchRequest);
    }
    get size() {
        return this._searchRequest.size || 0;
    }
    set size(size) {
        this._searchRequest.size = size;
    }
    get offset() {
        return this._searchRequest.offset || 0;
    }
    set offset(size) {
        this._searchRequest.offset = size;
    }
    /**
     *
     * @param searchString
     */
    quicksearch(searchString) {
        let searchParam = {};
        searchParam.size = this.size;
        searchParam.query = {
            "$type": "QueryStringQuery",
            "field": "_quicksearch",
            "queryString": `${searchString}*`
        };
        this._searchRequest = searchParam;
    }
    suggestion(searchString, lastTerm) {
        let searchParam = {};
        if (lastTerm) {
            searchParam.aggregations = [{
                "$type": "TermsAggregation",
                name: "suggest",
                field: "_quicksearch",
                order: "COUNT_DESC",
                size: this.size,
                includePattern: `${lastTerm}.*`
            }];
        }
        searchParam.query = {
            $type: "QueryStringQuery",
            field: "_quicksearch",
            queryString: `${searchString}*`
        };
        this._searchRequest = searchParam;
    }
    custom(searchParam) {
        this._searchRequest = searchParam;
    }
};
SearchQuery = __decorate([Object(__WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript__["jsElement"])()], SearchQuery);

/**
 * Class helper to iterate on search result.
 * * Example:
 * ```javaScript
 *   let searchQuery = new SearchQuery();
 *   searchQuery.quicksearch('');
 *   const searchGenerator = ozoneItemApi.search(searchQuery);
 *   searchGenerator.next().then((searchResult)=>{
 *               searchResult.results.forEach((item)=>{
 *                   this.push('items', item);
 *               })
 *           });
 * ```
 */
let SearchGenerator = class SearchGenerator {
    constructor(url, searchParam) {
        this.total = NaN;
        this.offset = 0;
        this.done = false;
        this.searchParam = searchParam;
        this.url = url;
    }
    /**
     * load next array of results
     * @return {Promise<SearchResult>}
     */
    next() {
        this.searchParam.offset = this.offset;
        return this._postRequest(this.url, this.searchParam.searchQuery, this._readSearchResponse);
    }
    _postRequest(url, body, responseFilter) {
        const ozoneAccess = new __WEBPACK_IMPORTED_MODULE_1_ozone_api_request__["a" /* OzoneAPIRequest */]();
        ozoneAccess.url = url;
        ozoneAccess.method = 'POST';
        ozoneAccess.body = body;
        return ozoneAccess.sendRequest().then(responseFilter.bind(this));
    }
    _readSearchResponse(res) {
        this.total = Number(res.response.total);
        this.offset += Number(res.response.size);
        this.done = this.offset < this.total;
        let results = res.response.results || [];
        return {
            results,
            total: this.total
        };
    }
};
SearchGenerator = __decorate([Object(__WEBPACK_IMPORTED_MODULE_0_taktik_polymer_typescript__["jsElement"])(), __metadata("design:paramtypes", [String, SearchQuery])], SearchGenerator);


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_clappr_markers_plugin__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_clappr_markers_plugin___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_clappr_markers_plugin__);

class ClapprMarkerFactory {
    constructor(parent) {
        this.parent = parent;
    }
    computeMove(element, e) {
        const parentElement = element.parentElement;
        const movePc = (e.movementX / parentElement.clientWidth) * 100;
        return movePc;
    }
    createMarker(marker, index) {
        const myClapprMarkersPlugin = __WEBPACK_IMPORTED_MODULE_0_clappr_markers_plugin__;
        var aMarker = new myClapprMarkersPlugin.CropMarker(marker.time, marker.duration);
        const element = document.createElement('div');
        element.className = 'element';
        var resizer = document.createElement('div');
        resizer.className = 'resizer';
        resizer.style.right = '0';
        element.appendChild(resizer);
        resizer.addEventListener('mousedown', (e) => {
            initResize(e);
        }, false);
        var resizerL = document.createElement('div');
        resizerL.className = 'resizer';
        resizerL.id = 'resizerL';
        element.appendChild(resizerL);
        resizerL.addEventListener('mousedown', (e) => {
            initResizeLeft(e);
        }, false);
        element.addEventListener('mousedown', (e) => {
            initTranslate(e);
        }, false);
        const updateMarker = () => {
            this.parent.set(`markers.${index}.duration`, aMarker.getDuration());
            this.parent.set(`markers.${index}.time`, aMarker.getTime());
        };
        const self = this;
        function initResize(e) {
            e.stopPropagation();
            window.addEventListener('mousemove', Resize, false);
            window.addEventListener('mouseup', stopResize, false);
        }
        function Resize(e) {
            e.stopPropagation();
            const markerTime = aMarker.getDuration() + aMarker.getTime();
            resizer.classList.add('moving-tooltip');
            resizer.setAttribute('data-attr', '' + secondsToHms(markerTime));
            const movePc = self.computeMove(element, e);
            element.style.width = parseFloat(element.style.width || '') + movePc + '%';
            updateMarker();
            aMarker.core.mediaControl
                .setTime(aMarker.getDuration() + aMarker.getTime());
        }
        function stopResize(e) {
            e.stopPropagation();
            resizer.classList.remove('moving-tooltip');
            window.removeEventListener('mousemove', Resize, false);
            window.removeEventListener('mouseup', stopResize, false);
        }
        function initResizeLeft(e) {
            e.stopPropagation();
            window.addEventListener('mousemove', ResizeLeft, false);
            window.addEventListener('mouseup', stopResizeLeft, false);
        }
        function ResizeLeft(e) {
            e.stopPropagation();
            let left = parseFloat(element.style.left || '');
            if (isNaN(left)) {
                left = 0;
            }
            const movePc = self.computeMove(element, e);
            resizerL.classList.add('moving-tooltip');
            resizerL.setAttribute('data-attr', '' + secondsToHms(aMarker.getTime()));
            element.style.left = left + movePc + '%';
            element.style.width = parseFloat(element.style.width || '') - movePc + '%';
            updateMarker();
            aMarker.core.mediaControl
                .setTime(aMarker.getTime());
        }
        function stopResizeLeft(e) {
            e.stopPropagation();
            resizerL.classList.remove('moving-tooltip');
            window.removeEventListener('mousemove', ResizeLeft, false);
            window.removeEventListener('mouseup', stopResizeLeft, false);
        }
        function initTranslate(e) {
            e.stopPropagation();
            window.addEventListener('mousemove', transtlate, false);
            window.addEventListener('mouseup', stopTranstlate, false);
        }
        function transtlate(e) {
            e.stopPropagation();
            let left = parseFloat(element.style.left || '');
            if (isNaN(left)) {
                left = 0;
            }
            const movePc = self.computeMove(element, e);
            element.style.left = left + movePc + '%';
            updateMarker();
            const parentElement = element.parentElement;
            const markerLeft = (element.offsetLeft / parentElement.clientWidth) * 100;
            const shiftPc = (e.offsetX / parentElement.clientWidth) * 100;
            aMarker.core.mediaControl
                .setTime(aMarker.getDuration() / 2 + aMarker.getTime());
        }
        function stopTranstlate(e) {
            e.stopPropagation();
            window.removeEventListener('mousemove', transtlate, false);
            window.removeEventListener('mouseup', stopTranstlate, false);
        }
        function secondsToHms(d) {
            d = Number(d);
            const h = Math.floor(d / 3600);
            const m = Math.floor(d % 3600 / 60);
            const s = Math.floor(d % 3600 % 60);
            let hours = ('0' + h).slice(-2) + ":";
            let minutes = ('0' + m).slice(-2) + ":";
            if (h <= 1) {
                hours = "";
            }
            return hours + minutes + ('0' + s).slice(-2);
        }
        aMarker._$marker = element;
        return aMarker;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ClapprMarkerFactory;



/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ozone_api_request__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ozone_config__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_uuid_v4__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_uuid_v4___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_uuid_v4__);
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const ReportInterval_ms = 60 * 1000;
/* harmony export (immutable) */ __webpack_exports__["a"] = ReportInterval_ms;

const visitorId = __WEBPACK_IMPORTED_MODULE_2_uuid_v4__();
class OzoneApiMediaplay {
    constructor() {
        this.recordUsage = true;
    }
    static sendStatistic(stat) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield __WEBPACK_IMPORTED_MODULE_1_ozone_config__["a" /* OzoneConfig */].get();
            const request = new __WEBPACK_IMPORTED_MODULE_0_ozone_api_request__["a" /* OzoneAPIRequest */]();
            request.url = `${config.host}${config.endPoints.mediaplay}/send`;
            request.method = 'POST';
            request.body = JSON.stringify(stat);
            request.sendRequest();
        });
    }
    reportMediaUsage(media) {
        if (this.recordUsage && media.id) {
            const report = {
                media: media.id,
                user: visitorId,
                userAgent: navigator.userAgent,
                description: media.title,
            };
            OzoneApiMediaplay.sendStatistic(report);
        }
    }
}
/* unused harmony export OzoneApiMediaplay */

const ozoneApiMediaplay = new OzoneApiMediaplay();
/* harmony export (immutable) */ __webpack_exports__["b"] = ozoneApiMediaplay;



/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(70);
var bytesToUuid = __webpack_require__(71);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

/***/ }),
/* 70 */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && msCrypto.getRandomValues.bind(msCrypto);
if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

/***/ }),
/* 71 */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_Clappr__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_Clappr___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_Clappr__);

class WCMediaControl extends __WEBPACK_IMPORTED_MODULE_0_Clappr__["MediaControl"] {
    constructor() {
        super(...arguments);
        this._muted = false;
        /***  End audio control  ***/
    }
    get events() {
        return {
            'click [data-play]': 'play',
            'click [data-pause]': 'pause',
            'click [data-playpause]': 'togglePlayPause',
            'click [data-stop]': 'stop',
            'click [data-playstop]': 'togglePlayStop',
            'click [data-fullscreen]': 'toggleFullscreen',
            'click .bar-container[data-volume]': 'onVolumeClick',
            'click .drawer-icon[data-volume]': 'toggleMute',
            'mouseenter .drawer-container[data-volume]': 'showVolumeBar',
            'mouseleave .drawer-container[data-volume]': 'hideVolumeBar',
            'mousedown .bar-container[data-volume]': 'startVolumeDrag',
            'mousemove .bar-container[data-volume]': 'mousemoveOnVolumeBar',
            'mousedown .bar-container[data-seekbar]': 'startSeekDrag',
            'mouseenter .media-control-layer[data-controls]': 'setUserKeepVisible',
            'mouseleave .media-control-layer[data-controls]': 'resetUserKeepVisible'
        };
    }
    /***  Start seek control  ***/
    seek(event) {
        event.stopPropagation();
        const target = event.target;
        if (target.classList.contains('bar-scrubber')
            || target.classList.contains('bar-scrubber-icon')) {
        }
        else {
            if (!this.settings.seekEnabled)
                return;
            const offsetX = event.offsetX;
            let pos = offsetX / this.$seekBarContainer[0].clientWidth * 100;
            pos = Math.min(100, Math.max(pos, 0));
            this.setPosition(pos);
        }
        return false;
    }
    mousemoveOnSeekBar(event) { }
    mouseleaveOnSeekBar(event) { }
    stopDragHandler() { }
    updateDragHandler() { }
    startSeekDrag(event) {
        super.startSeekDrag(event);
        const parentElement = this.$seekBarContainer[0];
        window.addEventListener('mousemove', updateSeek, false);
        window.addEventListener('mouseup', stopDragSeek, false);
        const self = this;
        this.seek(event);
        function updateSeek(e) {
            if (self.userKeepVisible) {
                const target = event.target;
                e.preventDefault();
                e.stopPropagation();
                const movePc = (e.movementX / parentElement.clientWidth) * 100;
                const posPc = parseFloat(self.$seekBarScrubber[0].style.left);
                let pos = posPc + movePc;
                self.setPosition(pos);
            }
        }
        function stopDragSeek(e) {
            e.preventDefault();
            e.stopPropagation();
            self.$el.removeClass('dragging');
            self.$seekBarLoaded.removeClass('media-control-notransition');
            self.$seekBarPosition.removeClass('media-control-notransition');
            self.$seekBarScrubber.removeClass('media-control-notransition dragging');
            self.draggingSeekBar = false;
            self.draggingVolumeBar = false;
            window.removeEventListener('mousemove', updateSeek, false);
            window.removeEventListener('mouseup', stopDragSeek, false);
        }
    }
    setPosition(pos) {
        pos = Math.min(99, Math.max(pos, 0));
        this.container.seekPercentage(pos);
        this.setSeekPercentage(pos);
    }
    setTime(timeSec) {
        let pos = (timeSec / this.container.getDuration()) * 100;
        this.setPosition(pos);
    }
    /***  Start seek control  ***/
    show(event) {
        if (this.disabled) {
            return;
        }
        const timeout = 2000;
        if (!event ||
            (event.clientX !== this.lastMouseX && event.clientY !== this.lastMouseY)
            || navigator.userAgent.match(/firefox/i)) {
            clearTimeout(this.hideId);
            this.$el.show();
            this.trigger(__WEBPACK_IMPORTED_MODULE_0_Clappr__["Events"].MEDIACONTROL_SHOW, this.name);
            this.$el.removeClass('media-control-hide');
            this.hideId = window.setTimeout(() => this.hide(), timeout);
            if (event) {
                this.lastMouseX = event.clientX;
                this.lastMouseY = event.clientY;
            }
        }
    }
    stopDrag(event) {
        //super.stopDrag(event)
    }
    hide(delay = 0) {
        if (!this.isVisible()) {
            return;
        }
        const timeout = delay || 2000;
        clearTimeout(this.hideId);
        if (!this.disabled && this.options.hideMediaControl === false) {
            return;
        }
        if (!this.container.isPlaying()) {
            return;
        }
        if (!this.disabled && (delay || this.userKeepVisible || this.keepVisible || this.draggingSeekBar || this.draggingVolumeBar)) {
            this.hideId = window.setTimeout(() => this.hide(), timeout);
        }
        else {
            this.trigger(__WEBPACK_IMPORTED_MODULE_0_Clappr__["Events"].MEDIACONTROL_HIDE, this.name);
            this.$el.addClass('media-control-hide');
            this.hideVolumeBar(0);
        }
    }
    /***  Start audio control  ***/
    updateDrag(event) {
    }
    getVolumeFromUIEvent(event) {
        const volumeBar = this.$volumeBarContainer.children('.segmented-bar-element');
        return (volumeBar.indexOf(event.target) + 1) * volumeBar.size();
    }
    get savedVolume() {
        if (!this._savedVolume) {
            this._savedVolume = this.container.volume;
        }
        return this._savedVolume;
    }
    set savedVolume(savedVolume) {
        this._savedVolume = savedVolume;
    }
    get muted() {
        return this._muted;
    }
    set muted(muted) {
        this._muted = muted;
    }
    toggleMute() {
        this.muted = !this.muted;
        this.setVolume(this.muted ? 0 : this.savedVolume);
    }
    onVolumeClick(event) {
        this.muted = false;
        this.savedVolume = this.getVolumeFromUIEvent(event);
        this.setVolume(this.savedVolume);
    }
    mousemoveOnVolumeBar(event) { }
    startVolumeDrag(event) {
        window.addEventListener('mousemove', updateVolume, false);
        window.addEventListener('mouseup', stopDragVolume, false);
        const self = this;
        this.onVolumeClick(event);
        function updateVolume(e) {
            const parentElement = self.$volumeBarContainer[0];
            const movePc = (e.movementX / parentElement.clientWidth) * 100;
            self.savedVolume = self.savedVolume + movePc;
            self.setVolume(self.savedVolume);
        }
        function stopDragVolume(e) {
            window.removeEventListener('mousemove', updateVolume, false);
            window.removeEventListener('mouseup', stopDragVolume, false);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = WCMediaControl;



/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_polymer_polymer_html__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_polymer_polymer_html___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_polymer_polymer_html__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__demo_app_html__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__demo_app_html___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__demo_app_html__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let demoApp = class demoApp extends Polymer.Element {
    constructor() {
        super(...arguments);
        this.videoUrl = "test/data/3/org.taktik.filetype.video.hls/index.m3u8";
        this.display = false;
    }
    ready() {
        super.ready();
        if (!this.$)
            throw new Error();
        this.$.addMarker.addEventListener('click', e => this._addMarker());
        this.$.clear.addEventListener('click', e => this._clearMarkers());
        this.$.loadUrl.addEventListener('click', e => this._loadUrl());
        this.$.loadOzoneSub.addEventListener('click', e => this._loadOzoneVideo());
    }
    _addMarker() {
        if (!this.$)
            throw new Error();
        this.$.mediaPlayer.addMarker({ duration: 10, time: 10 });
    }
    _clearMarkers() {
        if (!this.$)
            throw new Error();
        this.$.mediaPlayer.clearMarkers();
    }
    _loadUrl() {
        if (!this.$)
            throw new Error();
        this.$.mediaPlayer.loadVideoUrl(this.videoUrl);
    }
    _loadOzoneVideo() {
        if (!this.$)
            throw new Error();
        this.$.mediaPlayer.loadOzoneVideo({
            id: '00000000-0000-0000-0000-000000000003',
            type: 'video',
            subtitles: { "English": "00000000-0000-0000-0000-000000000002", "Polish": "00000000-0000-0000-0000-000000000001" },
        });
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript__["property"])(),
    __metadata("design:type", String)
], demoApp.prototype, "videoUrl", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript__["property"])(),
    __metadata("design:type", Boolean)
], demoApp.prototype, "display", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript__["property"])(),
    __metadata("design:type", String)
], demoApp.prototype, "subtitleSelect", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript__["property"])(),
    __metadata("design:type", Array)
], demoApp.prototype, "markers", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript__["property"])(),
    __metadata("design:type", Array)
], demoApp.prototype, "subtitles", void 0);
demoApp = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_2_taktik_polymer_typescript__["customElement"])('demo-app')
], demoApp);


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {


const RegisterHtmlTemplate = __webpack_require__(25);

RegisterHtmlTemplate.register("<dom-module id=demo-app> <template> <style>ozone-video-player{--marker-bar-background:#2f5fc4;--resizer-color:#2c3e50;--resizer-handle-color:#ecf0f1;--moving-tooltip-background-color:#2c3e50;--moving-tooltip-text-color:#ecf0f1}:host{min-height:100%;width:100%;margin:0;display:block}.container{width:640px;height:600px;margin:3em auto;padding:1em;background:#fefffe;border-radius:2px;box-shadow:0 2px 4px 0 rgba(0,0,0,.14),0 4px 5px 0 rgba(0,0,0,.12),0 1px 10px 0 rgba(0,0,0,.2)}h4{margin-bottom:8px;margin-left:.29em;font-family:Roboto,sans-serif}button{background:#2c2958;color:#fff;position:relative;box-sizing:border-box;min-width:5.14em;margin:0 .29em;-webkit-tap-highlight-color:transparent;-webkit-tap-highlight-color:transparent;font:inherit;text-transform:uppercase;outline-width:0;border-radius:3px;-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;user-select:none;cursor:pointer;z-index:0;padding:.7em 1em;font-size:13px;font-family:Roboto,sans-serif;box-shadow:0 0 0 0 transparent;border:0}.secondary{color:#585185;background:0 0;border:0;text-shadow:none}button:hover{transition:box-shadow .1s cubic-bezier(.4,0,.2,1);top:-1px;box-shadow:0 0 2px 0 rgba(0,0,0,.14),0 2px 2px 0 rgba(0,0,0,.12),0 1px 3px 0 rgba(0,0,0,.2)}button:focus{animation:ripple .2s cubic-bezier(.4,0,.2,1)}.deactivated{background:#d8d8d8;cursor:not-allowed}.dactivate:hover,.deactivated:focus{box-shadow:none}@keyframes ripple{0%{box-shadow:inset 0 0 0 0 rgba(88,81,133,.2)}100%{box-shadow:inset 0 0 0 60px rgba(88,81,133,.2)}}</style> <div class=container> <ozone-video-player id=mediaPlayer video-url=[[videoUrl]] hidden=[[!display]] markers={{markers}} subtitles-available={{subtitles}} subtitle-selected={{subtitleSelect}}>NO editor</ozone-video-player> <h4>Edit video</h4> <button id=addMarker>Add marker</button> <button id=clear class=secondary>clear all markers</button> <p>[[markersJson]]</p> <h4>Load video</h4> <button id=loadUrl class=deactivated> load a video from url</button> <button id=loadOzoneSub class=secondary> load a video with subtitle</button> </div> </template> </dom-module>");

/***/ })
/******/ ]);